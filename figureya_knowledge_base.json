[
  {
    "id": "main_FigureYa279panGeneGSEA_FigureYa279panGeneGSEA",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa279panGeneGSEA_FigureYa279panGeneGSEA.txt",
    "content": "FigureYa279panGeneGSEA\nFigureYa279panGeneGSEA\nAuthor(s)\n: Xiaofan Lu; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-05-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nDemand description\n想把FigureYa253panGSEA中的单基因多通路的泛癌富集分析改成”多基因，单通路的泛癌富集分析”，即把下图中的Y轴变成了基因，X轴还是癌种。\nI want to modify the pan-cancer enrichment analysis in\nFigureYa253panGSEA from “single-gene multi-pathway” to “multi-gene\nsingle-pathway” analysis. That is, changing the Y-axis in the figure to\nshow genes while keeping the X-axis as cancer types.\n出自：\nhttps://www.cell.com/iscience/fulltext/S2589-0042(20)30489-2?_returnURL=https%3A%2F%2Flinkinghub.elsevier.com%2Fretrieve%2Fpii%2FS2589004220304892%3Fshowall%3Dtrue\n图3. 铁死亡与信号通路及免疫表型的关系。 (A和B)\n高FPI与低FPI肿瘤组织间代谢通路(A)和癌症信号(B)的富集分析。NES表示GSEA算法中的标准化富集分数。\nSource:\nhttps://www.cell.com/iscience/fulltext/S2589-0042(20)30489-2?_returnURL=https%3A%2F%2Flinkinghub.elsevier.com%2Fretrieve%2Fpii%2FS2589004220304892%3Fshowall%3Dtrue\nFigure 3. Relationships between Ferroptosis and Signaling Pathways\nand Immunophenotypes. (A and B) Enrichment analysis for metabolism\npathway (A) and cancer signaling (B) between high- and low-FPI tumor\ntissues. NES is the normalized enrichment score in the GSEA\nalgorithm.\n应用场景\nApplication scenarios\n基于特定基因两组数据，对每个肿瘤进行单基因集富集分析(GSEA)，展示某特定通路的富集情况。\nBased on two groups of specific gene data, single gene set enrichment\nanalysis (GSEA) was performed for each tumor to demonstrate the\nenrichment of a particular pathway.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(clusterProfiler)\nlibrary(limma)\nlibrary(ggplot2)\nlibrary(data.table)\nlibrary(ggpubr)\nlibrary(SimDesign)\nsource(\"twoclasslimma.R\")\n\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n输入文件\nInput Files\nmerged_sample_quality_annotations.tsv，样本分组信息。下载自\nhttp://api.gdc.cancer.gov/data/1a7d7be8-675d-4e60-a105-19d4121bdebf\n。\nEBPlusPlusAdjustPANCAN_IlluminaHiSeq_RNASeqV2.geneExp.tsv，表达矩阵，第一列是基因，之后是其在每个样本中的表达量。下载自\nhttp://api.gdc.cancer.gov/data/3586c0da-64d0-4b74-a449-5ff4d9136611\n。\nmerged_sample_quality_annotations.tsv, sample grouping information.\nDownloaded from\nhttp://api.gdc.cancer.gov/data/1a7d7be8-675d-4e60-a105-19d4121bdebf\n.\nEBPlusPlusAdjustPANCAN_IlluminaHiSeq_RNASeqV2.geneExp.tsv, expression\nmatrix where the first column lists genes, followed by their expression\nlevels in each sample. Downloaded from\nhttp://api.gdc.cancer.gov/data/3586c0da-64d0-4b74-a449-5ff4d9136611\n.\n# 生成文件夹来保存中间结果\n# Create directory to store intermediate results\nres.path <- file.path(\"Results\")\nif (!file.exists(res.path)) { dir.create(res.path) }\n\n# 设置颜色\n# Define color palette\ndarkblue <- \"#303B7F\"\ndarkred <- \"#D51113\"\nyellow <- \"#EECA1F\"\n\n# 获取感兴趣的肿瘤类型（有正常和肿瘤样本）\n# Select tumor types of interest (with both normal and tumor samples)\ntumors <- c(\"BLCA\",\"BRCA\",\"CESC\",\"CHOL\",\"COAD\",\n            \"ESCA\",\"GBM\",\"HNSC\",\"KICH\",\"KIRC\",\n            \"KIRP\",\"LIHC\",\"LUAD\",\"LUSC\",\"PAAD\",\n            \"PRAD\",\"READ\",\"STAD\",\"THCA\",\"UCEC\")\n\n# 从原文中获取感兴趣的基因集 (TTC35/EMC2) \n# Extract gene set of interest (TTC35/EMC2) from original publication\ngenelist <- c(\"CDKN1A\",\"HSPA5\",\"TTC35\",\"SLC7A11\",\"NFE2L2\",\"MT1G\",\"HSPB1\",\"GPX4\",\"FANCD2\",\"CISD1\",\"FDFT1\",\"SLC1A5\",\"SAT1\",\n         \"TFRC\",\"RPL8\",\"NCOA4\",\"LPCAT3\",\"GLS2\",\"DPP4\",\"CS\",\"CARS\",\"ATP5G3\",\"ALOX15\",\"ACSL4\")\n\n# 读取肿瘤注释文件\n# Load tumor annotation file\nrawAnno <- read.delim(\"merged_sample_quality_annotations.tsv\",sep = \"\\t\",row.names = NULL,check.names = F,stringsAsFactors = F,header = T)\n# 数据来自：http://api.gdc.cancer.gov/data/1a7d7be8-675d-4e60-a105-19d4121bdebf\n# Data source: http://api.gdc.cancer.gov/data/1a7d7be8-675d-4e60-a105-19d4121bdebf\n\n# 提取简化的样本条形码（前15位字符）\n# Extract simplified barcode (first 15 characters)\nrawAnno$simple_barcode <- substr(rawAnno$aliquot_barcode,1,15)\n\n# 去重处理并保留关键列\n# Remove duplicates and keep essential columns\nsamAnno <- rawAnno[!duplicated(rawAnno$simple_barcode),c(\"cancer type\", \"simple_barcode\")]\nsamAnno <- samAnno[which(samAnno$`cancer type` != \"\"),]\n\n# 保存处理后的注释文件\n# Save processed annotation file\nwrite.table(samAnno,\"simple_sample_annotation.txt\",sep = \"\\t\",row.names = F,col.names = T,quote = F)\n\n# 快速读取表达谱数据并做数据预处理\n# Rapidly load expression matrix and perform preprocessing\nexpr <- fread(\"EBPlusPlusAdjustPANCAN_IlluminaHiSeq_RNASeqV2.geneExp.tsv\",sep = \"\\t\",stringsAsFactors = F,check.names = F,header = T) \n# 数据来自：http://api.gdc.cancer.gov/data/3586c0da-64d0-4b74-a449-5ff4d9136611\n# Data source: http://api.gdc.cancer.gov/data/1a7d7be8-675d-4e60-a105-19d4121bdebf\n\n# 转换为数据框格式并处理基因名\n# Convert to dataframe and process gene names\nexpr <- as.data.frame(expr); rownames(expr) <- expr[,1]; expr <- expr[,-1]\n\n# 提取竖线分隔符前的正式基因名\n# Extract official gene names before \"|\" separator\ngene <- sapply(strsplit(rownames(expr),\"|\",fixed = T), \"[\",1)\nexpr$gene <- gene\n\n# 去重处理（保留每个基因第一个出现的数据）\n# Remove duplicate genes (keep first occurrence)\nexpr <- expr[!duplicated(expr$gene),]\nrownames(expr) <- expr$gene; expr <- expr[,-ncol(expr)]\n\n# 对于这份泛癌数据，将略小于0的数值拉到0，否则不能取log（其他途径下载的泛癌数据可能不需要此操作）\n# For this pan-cancer dataset, adjust slightly negative values to 0 to enable log transformation (may not be needed for other pan-cancer datasets)\nexpr[expr < 0] <- 0 \n\n# 简化样本ID（取前15位字符）\n# Simplify sample IDs (first 15 characters)\ncolnames(expr) <- substr(colnames(expr),1,15)\n\n# 内存清理 \n# Memory cleanup\ngc()\n运行GSEA\nPerform GSEA analysis\n# 这里使用的是HALLMARK背景集，可以改为自己感兴趣的基因集合\n# Using HALLMARK gene set (can be replaced with custom gene sets of interest)\nmsigdb.hallmark <- read.gmt(\"h.all.v7.2.symbols.gmt\") \n\n# 30%阈值来定义高低组\n# 30% threshold for defining high/low expression groups\npct <- 0.3 \n\n# 初始化结果存储表 \n# Initialize result container\ngseaTab <- NULL\n\n# 主分析循环\n# Main Analysis Loop\nfor (i in tumors) {\n  message(\"--\",i,\"...\")\n  \n  # 获取当前癌型的样本列表 \n  # Get samples for current cancer type\n  sam <- samAnno[which(samAnno$`cancer type` == i),\"simple_barcode\"]\n  \n  # 得到特定肿瘤类型的表达谱\n  # Get expression matrix for specific cancer type\n  comsam <- intersect(colnames(expr), sam) \n  \n  # 仅提取肿瘤样本\n  # Extract tumor samples only\n  tumsam <- comsam[substr(comsam,14,14) == \"0\"] \n  \n  # 提取目标基因表达矩阵\n  # Subset target gene expression matrix\n  es <- expr[genelist,tumsam] \n  \n  # 基因级别分析 \n  # Per-gene Analysis\n  for (j in genelist) {\n    message(\"gene of \", j, \" starts...\")\n    \n    # 转置表达矩阵便于排序\n    # Transpose matrix for sorting\n    es_subset <- as.data.frame(t(es[j,tumsam]))\n    \n    # 对表达值排序\n    # Sort by expression value\n    es_subset <- es_subset[order(es_subset[,1],decreasing = T),,drop = F] \n    \n    # 取前30%为高组，取后30%为低组\n    # Define high/low expression groups (top/bottom 30%)\n    high.es <- rownames(es_subset[1:(nrow(es_subset) * pct),,drop = F]) \n    low.es <- rownames(es_subset[nrow(es_subset):(nrow(es_subset) - nrow(es_subset) * pct + 1),,drop = F]) \n    \n    # 创建分组信息表 \n    # Create sample grouping information\n    subt <- data.frame(condition = rep(c(\"high\",\"low\"),c(length(high.es),length(low.es))),\n                       row.names = c(high.es, low.es),\n                       stringsAsFactors = F)\n    \n    # 数据预处理：log2转换（加1伪计数避免零值）\n    # Data preprocessing: log2 transformation (with pseudocount)\n    gset <- log2(na.omit(expr[,rownames(subt)]) + 1)\n    \n    # 执行limma差异分析 \n    # Perform limma differential analysis\n    twoclasslimma(subtype  = subt, \n                  featmat  = gset, \n                  treatVar = \"high\", \n                  ctrlVar  = \"low\", \n                  prefix   = paste0(\"TCGA_\",i,\"_\",j), \n                  overwt   = T, \n                  sort.p   = F, \n                  verbose  = TRUE, \n                  res.path = res.path) \n    \n    # 加载差异表达结果\n    # Load differential expression results\n    res <- read.table(file.path(res.path, paste0(\"TCGA_\",i,\"_\",j,\"_limma_test_result.high_vs_low.txt\")),sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\n    \n    # 产生pre-ranked基因列表\n    # Generate a pre-ranked list of genes\n    res <- res[order(res$log2fc, decreasing = T),]\n    glist <- res$log2fc; names(glist) <- rownames(res)\n    \n    # 运行GSEA\n    # Run GSEA analysis\n    set.seed(20220407)\n    gsea <- quiet(GSEA(geneList = glist,\n                 pvalueCutoff = 1, \n                 seed = TRUE,\n                 TERM2GENE = msigdb.hallmark,\n                 verbose = TRUE))\n    \n    # 内存清理 \n    # Memory cleanup\n    gc()\n    \n    # 转换GSEA结果为数据框 \n    # Convert GSEA result to dataframe\n    gsea.df <- as.data.frame(gsea) \n    \n    # 保存当前基因的GSEA结果 \n    # Save per-gene GSEA results\n    write.table(gsea.df,file = file.path(res.path,paste0(\"gsea between high and low group of gene \",j,\" in \",i,\".txt\")),sep = \"\\t\",row.names = T,col.names = NA,quote = F)\n    \n    # 合并结果到总表 \n    # Aggregate results to master table\n    gseaTab <- rbind.data.frame(gseaTab,\n                                data.frame(tumor = i,\n                                           gene = j,\n                                           term = gsea.df$ID,\n                                           NES = gsea.df$NES,\n                                           pval = gsea.df$pvalue,\n                                           FDR = gsea.df$p.adjust,\n                                           stringsAsFactors = F),\n                                stringsAsFactors = F)\n  }\n}\n# 保存整合的GSEA结果\n# Save consolidated GSEA results\nwrite.table(gseaTab, \"TCGA_pancan_gsea_regarding_genes_of_interest.txt\",sep = \"\\t\",row.names = F,col.names = T,quote = F)\n开始画图\nPlotting\n生成泡泡图\nGenerate bubble plots\n# 设置感兴趣的通路\n# Set pathway of interest\npathOfInterest <- \"HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION\" \n\n# 提取和该通路有关的NES\n# Extract NES values related to this pathway\ntmp <- gseaTab[which(gseaTab$term == pathOfInterest),] \n\n# 颜色配置 \n# Color Configuration\nmy_palette <- colorRampPalette(c(darkblue,yellow,darkred), alpha=TRUE)(n=128)\n\n# 气泡图绘制 \n# Bubble Plot Visualization\nggplot(tmp, aes(x=tumor,y=gene)) +\n  geom_point(aes(size=-log10(FDR),color=NES)) +\n  scale_color_gradientn('NES', \n                        colors=my_palette) + \n  scale_size_continuous(range = c(1,4)) + \n  theme_bw() +\n  theme(panel.grid.minor = element_blank(), \n        panel.grid.major = element_blank(),\n        axis.text.x = element_text(angle = 45, size = 12, hjust = 0.3, vjust = 0.5, color = \"black\"),\n        axis.text.y = element_text(size = 10, color = \"black\"),\n        axis.title = element_blank(),\n        panel.border = element_rect(size = 0.7, linetype = \"solid\", colour = \"black\"),\n        legend.position = \"bottom\",\n        plot.margin = unit(c(1,1,1,1), \"lines\"))\n# 保存为PDF\n# Save as PDF\nggsave(paste0(\"GSEA regarding \",pathOfInterest,\" in pancancer.pdf\"), width = 8,height = 6)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa279panGeneGSEA_FigureYa279panGeneGSEA",
      "title": "FigureYa279panGeneGSEA/FigureYa279panGeneGSEA.html",
      "html": "FigureYa279panGeneGSEA/FigureYa279panGeneGSEA.html",
      "text": "texts/main_FigureYa279panGeneGSEA_FigureYa279panGeneGSEA.txt",
      "folder": "FigureYa279panGeneGSEA",
      "thumb": "gallery_compress/FigureYa279panGeneGSEA.webp"
    },
    "word_count": 1053,
    "lines_count": 305,
    "title": "FigureYa279panGeneGSEA",
    "description": "Demand description 想把FigureYa253panGSEA中的单基因多通路的泛癌富集分析改成”多基因，单通路的泛癌富集分析”，即把下图中的Y轴变成了基因，X轴还是癌种。 I want to modify the pan-cancer enrichment analysis in",
    "input_data_types": [
      "临床数据",
      "表达矩阵"
    ],
    "output_types": [
      "火山图",
      "统计表格"
    ],
    "technical_methods": [
      "通路分析",
      "标准化",
      "质量控制",
      "差异表达分析"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学",
      "代谢疾病"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "gene",
      "colour",
      "seed",
      "header",
      "width",
      "n",
      "pvalue",
      "vjust",
      "NES"
    ]
  },
  {
    "id": "main_FigureYa274MuSiCbulkProop_FigureYa274MuSiCbulkProop",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa274MuSiCbulkProop_FigureYa274MuSiCbulkProop.txt",
    "content": "FigureYa274MuSiCbulkProop\nFigureYa274MuSiCbulkProop\nAuthor(s)\n: Xiao Gu; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-09-12\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nDemand description\n用MuSic反卷积推算bulk组的细胞类型。\n出自\nhttps://www.nature.com/articles/s41467-018-08023-x\nUsing MuSic deconvolution to infer cell types in bulk groups.\nSource:\nhttps://www.nature.com/articles/s41467-018-08023-x\n应用场景\nApplication scenarios\nMuSic这个软件大概有三个功能：\n第一个就是直接根据单细胞数据和bulk数据预测bulk中大概含有单细胞鉴定到的哪几种细胞类型\n第二个是先聚类，然后根据聚类信息和输入的marker\nlist做，感觉主观性强\n第三个是两个单细胞数据集进行相互验证，参考意义不大\n流程跟着教程跑就好，官方详细教程见：\nhttps://xuranw.github.io/MuSiC/articles/MuSiC.html#sample-analysis-1\n跟FigureYa71ssGSEA的相似之处：核心理念都是用单细胞的数据算出来每种细胞类型的marker\ngene，然后看这些基因中的哪些在bulk中高表达。\n同样用到单细胞和bulk的FigureYa272scBulkCCCI，借助scRNA-seq找到的signature\ngenes，推断bulk RNA-seq样本的细胞类群互作网络。\nThe MuSiC software has approximately three main functions:\nThe first is to directly predict which cell types identified from\nsingle-cell data are likely present in bulk data, based on both\nsingle-cell and bulk datasets.\nThe second involves clustering first and then using the clustering\ninformation along with an input marker list, which tends to be more\nsubjective.\nThe third is mutual validation between two single-cell datasets,\nthough its reference value is relatively limited.\nThe workflow can be followed according to the tutorial. For the\nofficial detailed tutorial, see:\nhttps://xuranw.github.io/MuSiC/articles/MuSiC.html#sample-analysis-1\nSimilarities with FigureYa71ssGSEA: The core concept of both is to\nuse single-cell data to calculate marker genes for each cell type and\nthen identify which of these genes are highly expressed in bulk\ndata.\nAnother tool that also utilizes both single-cell and bulk data is\nFigureYa272scBulkCCCI. It leverages signature genes identified from\nscRNA-seq to infer cell-cell interaction networks in bulk RNA-seq\nsamples.\n比较难的就是构建数据集，本文档带大家解决这个问题。\nThe most challenging part is constructing the dataset, and this\ndocument will guide you through solving this issue.\n分两种情况，分别带大家跑通：\n第一种方案：\n不预分组\n预测bulk数据中细胞类型占比\n第二种方案：\n基于细胞类型预分组\n预测bulk数据中细胞类型占比\nWe will cover two scenarios to help you successfully complete the\nanalysis:\nOption 1: Predicting cell type proportions in bulk data\nwithout pre-grouping\n.\nOption 2: Predicting cell type proportions in bulk data\nbased on pre-grouped cell types\n.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(Seurat)\nlibrary(SeuratData)\nlibrary(patchwork)\nlibrary(dplyr)\nlibrary(MuSiC)\nlibrary(pheatmap)\nlibrary(magrittr)\nlibrary(Biobase)\nlibrary(glmGamPoi)\nlibrary(SingleCellExperiment)\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n第一种方案: 不预分组预测bulk数据中细胞类型占比\nOption 1: Predicting Cell Type Proportions in Bulk Data Without\nPre-Grouping\n输入文件\nInput Files\n构建单细胞数据集\nConstructing the Single-Cell Dataset\nifnb\n- A Seurat object with the PBMC\ncontrol/IFNB-stimulated dataset。出自\nhttps://pubmed.ncbi.nlm.nih.gov/29227470/\n，已被打包到SeuratData里，我们直接安装、加载它。\n为了友好对接目前主流的Seurat单细胞分析流程，使用SeuratData包钟的ifnb数据集做示例数据，示例数据ifnb有STIM和CTRL两组。\nifnb\n– A Seurat object containing the PBMC\ncontrol/IFNB-stimulated dataset, sourced from\nhttps://pubmed.ncbi.nlm.nih.gov/29227470/\n. This dataset\nhas been pre-packaged in SeuratData, so we can directly install and load\nit.\nTo ensure compatibility with the current mainstream Seurat\nsingle-cell analysis pipeline, we use the ifnb dataset from the\nSeuratData package as an example. The example dataset ifnb contains two\ngroups: STIM (stimulated) and CTRL (control).\n# 找网络好点的地方安装，教育网好些\n# Recommended to install in a stable network environment (educational networks work better)\n# InstallData(\"ifnb\") \nLoadData(\"ifnb\")\n# 更新Seurat对象结构至最新版本\n# Update Seurat object to latest structure\nifnb <- UpdateSeuratObject(ifnb)\n# 以下为Seurat标准分析流程，拿到使用SCTransform normalized的表达矩阵\n# Standard Seurat analysis pipeline below to obtain SCTransform-normalized expression matrix\nifnb.list <- SplitObject(ifnb, split.by = \"stim\")\n\n# 对每组数据独立进行质控和标准化\n# Perform QC and normalization independently per group\nifnb.list <- lapply(X = ifnb.list, FUN = function(x) {\n  x <- PercentageFeatureSet(x, pattern = \"^MT-\", col.name = \"percent.mt\")\n  x <- SCTransform(x, method = \"glmGamPoi\", vars.to.regress = \"percent.mt\", verbose = FALSE)\n})\n# 选择用于整合的高变基因\n# Select highly variable features for integration\nfeatures <- SelectIntegrationFeatures(object.list = ifnb.list, nfeatures = 3000)\n\n# 准备SCT校正后的数据\n# Prepare SCT-corrected data for anchor identification\nifnb.list <- PrepSCTIntegration(object.list = ifnb.list, anchor.features = features)\n\n# 识别整合锚点\n# Find integration anchors\nimmune.anchors <- FindIntegrationAnchors(object.list = ifnb.list, normalization.method = \"SCT\",\n                                         anchor.features = features)\n# 执行数据整合\n# Perform dataset integration\nimmune.combined.sct <- IntegrateData(anchorset = immune.anchors, normalization.method = \"SCT\")\n# 以下是Seurat工作流中标准的可视化和聚类分析步骤\n# These are now standard steps in the Seurat workflow for visualization and clustering\nimmune.combined.sct <- RunPCA(immune.combined.sct, npcs = 50, verbose = FALSE)\n\n# 生成PCA热图（评估PCs质量）\n# Generate PCA heatmap (evaluate PC quality)\npdf(\"DimHeatmap.pdf\",height = 20,width = 20)\nDimHeatmap(immune.combined.sct, dims = 1:50, cells = 500, balanced = TRUE,ncol = 6)\ndev.off()\n# 生成肘部图（确定显著PCs数量）\n# Generate elbow plot (determine significant PCs)\npdf(\"ElbowPlot.pdf\",height = 5,width = 10)\nElbowPlot(immune.combined.sct, ndims = 50)\ndev.off()\n由于SCTransform\nnormalized的效果很好，所以使用更多的PC能揭示更多的生物学信息，这里选择30个PC。\nSince SCTransform normalization yields excellent results, using more\nprincipal components (PCs) can reveal richer biological insights. Here,\nwe select 30 PCs for downstream analysis.\n# 运行UMAP非线性降维\n# Perform UMAP nonlinear dimensionality reduction\nimmune.combined.sct <- RunUMAP(immune.combined.sct, dims = 1:30, verbose = FALSE)\n# 构建KNN\n# Build KNN\nimmune.combined.sct <- FindNeighbors(immune.combined.sct, dims = 1:30, verbose = FALSE)\n\n# 使用Louvain算法进行细胞聚类\n# Perform cell clustering with Louvain algorithm\nimmune.combined.sct <- FindClusters(immune.combined.sct, resolution = 1.2, verbose = FALSE)\n\n# 绘制基于聚类的UMAP图\n# Plot UMAP colored by cluster\npdf(\"DimPlot.cluster.pdf\",height = 5,width = 5)\nDimPlot(immune.combined.sct, label = TRUE) + NoLegend()\ndev.off()\n# 绘制基于注释的UMAP图\n# Plot UMAP colored by annotations \npdf(\"DimPlot.celltype.pdf\",height = 5,width = 5)\nDimPlot(immune.combined.sct, group.by = \"seurat_annotations\", label = TRUE) + NoLegend()\ndev.off()\n# 从Seurat对象中提取标准化后的表达矩阵\n# Extract normalized expression matrix from Seurat object\ngene_exprs.matrix <- as.matrix(immune.combined.sct@assays$SCT@data)\n# 创建元数据描述信息\n# Create metadata descriptions\nmetadata <- data.frame(labelDescription= c(\"seurat_annotations\",\"stim\",\"seurat_clusters\"),                      row.names=c(\"seurat_annotations\",\"stim\",\"seurat_clusters\"))\n\n# 提取关键表型信息（细胞类型+分组+聚类ID）\n# Extract key phenotypic information (celltype + group + cluster)\npheno.matrix <- immune.combined.sct@meta.data[,c(\"seurat_annotations\",\"stim\",\"seurat_clusters\")]\n\n# 构建ExpressionSet对象\n# Create ExpressionSet object\nscRNA.eset <- ExpressionSet(assayData = data.matrix(gene_exprs.matrix), \n                           phenoData =  new(\"AnnotatedDataFrame\", data = pheno.matrix, \n                                            varMetadata = metadata))\n\n# 检查细胞类型分布\n# Check cell type distribution\ntable(scRNA.eset$seurat_annotations)\n构建bulk的ExpressionSet对象\nConstructing Bulk ExpressionSet Object\n这里随机生成一个bulk数据。\n对于自己的数据，需要输入normalized之后的表达矩阵，然后构建bulk的ExpressionSet对象。\nHere we randomly generate a bulk dataset as an example.\nFor your own data, you need to input a normalized expression matrix\nand then construct the bulk ExpressionSet object accordingly.\n# 设置模拟样本数和基因数\n# Set number of simulated samples and genes\nnsample <- 10\nngene <- nrow(gene_exprs.matrix)\n\n# 设置随机数重点，好重复\n# Set random seed for reproducibility  \nset.seed(1) \n\n# bulk.mattrix一定要是矩阵格式\n# bulk.matrix must be in matrix format \nbulk.mattrix <- matrix(runif(ngene*nsample, min = 0, max = 1000), \n                       nrow=ngene, ncol=10)\n\n# 添加行列名称\n# Add dimension names\nrownames(bulk.mattrix) <- rownames(gene_exprs.matrix)\ncolnames(bulk.mattrix) <- paste0(\"sample\", 1:nsample)\n\n# 创建元数据描述框架\n# Create metadata description framework\nbulk.metadata <- data.frame(labelDescription= c(\"sample\"), \n                            row.names=c(\"sample\"))\nbulk.metadata\n# 构建样本表型数据\n# Build sample phenotype data\nbulk.pheno.matrix <- data.frame(sample= colnames(bulk.mattrix), \n                                row.names=colnames(bulk.mattrix))\n\n# bulk数据集构建\n# Bulk dataset construction\nbulk.eset <- ExpressionSet(assayData = data.matrix(bulk.mattrix), \n                           phenoData = new(\"AnnotatedDataFrame\", data = bulk.pheno.matrix, \n                                           varMetadata = bulk.metadata))\n估计细胞类型比例\nEstimate cell type proportions\n# 将ExpressionSet转换为SingleCellExperiment对象\n# Convert ExpressionSet to SingleCellExperiment\nscRNA.sce <- SingleCellExperiment(\n  assays = list(counts = exprs(scRNA.eset)),\n  colData = pData(scRNA.eset)\n)\n\n# 执行MuSiC细胞比例估计\n# Perform MuSiC cell proportion estimation\nEst.prop <- music_prop(\n  bulk.mtx = exprs(bulk.eset),\n  sc.sce = scRNA.sce,\n  clusters = 'seurat_annotations',\n  samples = 'stim',\n  select.ct = c(\"CD14 Mono\", \"pDC\", \"CD4 Memory T\", \"T activated\", \"CD4 Naive T\",\n                \"CD8 T\", \"Mk\", \"B Activated\", \"B\", \"DC\", \"CD16 Mono\", \"NK\", \"Eryth\")\n)\n# 查看估计结果的结构\n# Examine result structure\nnames(Est.prop)\n图3e - MuSiC估计的细胞类型比例\nFigure 3e - MuSiC estimated cell type proportions\n# 创建对称的颜色断点（用于双向颜色标尺）\n# Create symmetric color breaks (for bidirectional color scale)\nbk <- c(seq(-2,-0.1,by=0.01),seq(0,2,by=0.01))\n\n# 热图绘制\n# Generate Heatmap\npheatmap(Est.prop$Est.prop.weighted,\n         cluster_cols = F,cluster_rows = F,\n         show_colnames=T,show_rownames=T,\n         #cellheight= 10,\n         fontsize=16,\n         #cellwidth = 10,cellheight = 10,\n         treeheight_row = 0,treeheight_col_row = 10,\n         #treeheight_col = 50,\n         color = c(colorRampPalette(colors = c(\"steelblue\",\"white\"))(length(bk)/2),\n                   colorRampPalette(colors = c(\"white\",\"red\"))(length(bk)/2)),\n         border=F,border_color = \"white\",\n         breaks=bk,scale=\"row\",legend_breaks=seq(-2,2,1),\n         filename = \"Est.celltype.proportions.heatmap.pdf\")\n热图可以清楚看到随机生成的bulk数据大部分细胞为中含有单细胞鉴定的细胞类型中的pDC。\nThe heatmap clearly shows that in the randomly generated bulk data,\nmost samples contain pDC (plasmacytoid dendritic cells) - one of the\ncell types identified in the single-cell analysis.\n图2c - 抖动图\nFigure 2c - Jitter plot\n# 估计细胞类型比例的抖动图\n# Jitter plot of estimated cell type proportions\njitter.fig <- Jitter_Est(list(data.matrix(Est.prop$Est.prop.weighted),\n                             data.matrix(Est.prop$Est.prop.allgene)),\n                        method.name = c('MuSiC', 'NNLS'), title = 'Jitter plot of Est Proportions')\n\n# 保存为PDF\n# Save as PDF\nggsave(\"Est.celltype.proportions.jitterplot.pdf\",plot=jitter.fig,width =10,height = 8)\n第二种方案：基于细胞类型预分组预测bulk数据中细胞类型占比\nOption 2: Predicting cell type proportions in bulk data based on\npre-grouped cell types\n输入文件\nInput Files\n这里用原文提供的数据集，已提前预分组，有自定义marker\nlist。下载地址：\nSingle cell data:\nhttps://xuranw.github.io/MuSiC/data/Mousesubeset.rds\nBulk RNA-seq data:\nhttps://xuranw.github.io/MuSiC/data/Mousebulkeset.rds\nMarker gene list:\nhttps://xuranw.github.io/MuSiC/data/IEmarkers.RData\n自己的数据构建方式参考上面第一种方案。\nThe original dataset provided in the paper is used here, which has\nbeen pre-grouped with a custom marker list. Download links:\nSingle-cell data:\nhttps://xuranw.github.io/MuSiC/data/Mousesubeset.rds\nBulk RNA-seq data:\nhttps://xuranw.github.io/MuSiC/data/Mousebulkeset.rds\nMarker gene list:\nhttps://xuranw.github.io/MuSiC/data/IEmarkers.RData\nFor constructing your own dataset, please refer to the first option\nabove.\n# 加载小鼠Bulk数据集\n# Load Mouse bulk dataset\nMouse.bulk.eset <- readRDS(\"Mousebulkeset.rds\")\nMouse.bulk.eset\n# 加载EMTAB单细胞数据集\n# Load EMTAB single cell dataset\nMousesub.eset <- readRDS(\"Mousesubeset.rds\")\nMousesub.eset\n# 查看单细胞数据中的细胞类型级别\n# Check cell type levels in scRNA data\nlevels(Mousesub.eset$cellType)\n生成第一步分析信息。\n注意，单细胞数据集包含16种细胞类型，其中包括2种新型细胞类型和1种过渡细胞类型(CD-Trans)。在我们的分析中排除了这3种细胞类型。\n这里在分析中排除三种细胞类型，用剩余的细胞类型进行下游分析。\nProduce the first step information.\nNotice that the single cell dataset has 16 cell types, including 2\nnovel cell types and a transition cell type (CD-Trans). We exclude those\n3 cell types in our analysis.\nHere we exclude these 3 cell types from the analysis and use the\nremaining cell types for downstream analysis.\n# 创建SingleCellExperiment对象\n# Create SingleCellExperiment object\nMousesub.sce <- SingleCellExperiment(\n  assays = list(counts = exprs(Mousesub.eset)), \n  colData = pData(Mousesub.eset)               \n)\n\n# 现在运行music_basis函数\n# Now run music_basis function\nMousesub.basis <- music_basis(\n  Mousesub.sce, \n  clusters = 'cellType', \n  samples = 'sampleID',\n  select.ct = c('Endo', 'Podo', 'PT', 'LOH', 'DCT', 'CD-PC', 'CD-IC', 'Fib',\n                'Macro', 'Neutro', 'B lymph', 'T lymph', 'NK')\n)\n图3a - 聚类树状图\nFigure 3a - Cluster dendrogram\n绘制设计矩阵的树状图及各样本间相对丰度的均值\nPlot the dendrogram of design matrix and cross-subject mean of\nrealtive abundance\n# 创建PDF输出文件\n# Create PDF output file\npdf(\"Est.celltype.cluster.pdf\",width =10,height = 5)\n\n# 设置1行2列的绘图布局\n# Set 1-row x 2-column plot layout\npar(mfrow = c(1, 2))\n\n# 计算设计矩阵的欧式距离\n# Calculate Euclidean distance of design matrix\nd <- dist(t(log(Mousesub.basis$Disgn.mtx + 1e-6)), method = \"euclidean\")\n\n# 使用完全连接法进行层次聚类\n# Hierarchical clustering using Complete Linkage\nhc1 <- hclust(d, method = \"complete\" )\n\n# 绘制获得的树状图\n# Plot the obtained dendrogram\nplot(hc1, cex = 0.6, hang = -1, main = 'Cluster log(Design Matrix)')\n\n# 计算相对丰度均值的欧式距离\n# Calculate Euclidean distance of mean relative abundance\nd <- dist(t(log(Mousesub.basis$M.theta + 1e-8)), method = \"euclidean\")\n\n# 使用完全连接法进行层次聚类\n# Hierarchical clustering using Complete Linkage\nhc2 <- hclust(d, method = \"complete\")\n\n# 绘制获得的树状图 \n# Plot the obtained dendrogram\nplot(hc2, cex = 0.6, hang = -1, main = 'Cluster log(Mean of RA)')\ndev.off()\n免疫细胞聚集在一起，而肾脏特异性细胞也各自聚为一类。值得注意的是，DCT（远曲小管细胞）和PT（近端小管细胞）属于同一个高级别分组。分组阈值可由用户自行确定。这里我们将13种细胞类型划分为4个组别：\nGroup 1: 中性粒细胞\nGroup 2: 足细胞\nGroup 3:\n内皮细胞、集合管主细胞、集合管闰细胞、髓袢升支粗段、远曲小管细胞、近端小管细胞\nGroup 4:\n成纤维细胞、巨噬细胞、自然杀伤细胞、B淋巴细胞、T淋巴细胞\n小鼠肾脏分析的树状图引导递归估计包含两个步骤：\nStep 1：估计各高级别细胞群的占比(p1,p2,p3,p4)\nStep\n2：估计各细胞群内部的具体细胞类型占比(p31,p32,…,p36,p41,…,p45)\nThe immune cells are clustered together and the kidney specific cells\nare clustered together. Notice that DCT and PT are within the same\nhigh-level grouping. The cut-off is user determined. Here we cut 13 cell\ntypes into 4 groups:\nGroup 1: Neutro\nGroup 2: Podo\nGroup 3: Endo, CD-PC, CD-IC, LOH, DCT, PT\nGroup 4: Fib, Macro, NK, B lymph, T lymph\nThe tree-guided recursive estimation for mouse kidney analysis\nincludes 2 steps:\nStep 1. Estimate proportions of each high level cluster;\n(p1,p2,p3,p4)\nStep 2. Estimate cell type proportions within each cluster;\n(p31,p32,…,p36,p41,…,p45)\n# 根据层次聚类结果手动定义细胞类型分组（需根据实际聚类树调整）\n# Manually define cell type groups based on clustering results (adjust according to dendrogram)\nclusters.type = list(C1 = 'Neutro', C2 = 'Podo', C3 = c('Endo', 'CD-PC', 'LOH', 'CD-IC', 'DCT', 'PT'), C4 = c('Macro', 'Fib', 'B lymph', 'NK', 'T lymph'))\n\n# 初始化分组标签向量\n# Initialize cluster labels\ncl.type = as.character(Mousesub.eset$cellType)\n\n# 将原始细胞类型映射到聚类分组\n# Map original cell types to cluster groups\nfor(cl in 1:length(clusters.type)){\n  cl.type[cl.type %in% clusters.type[[cl]]] = names(clusters.type)[cl]\n}\n\n# 添加分组信息到单细胞数据\n# Add cluster info to scRNA data\npData(Mousesub.eset)$clusterType = factor(cl.type, levels = c(names(clusters.type), 'CD-Trans', 'Novel1', 'Novel2'))\n\n# 提取用于后续分析的13种主要细胞类型\n# Extract 13 major cell types for downstream analysis\ns.mouse = unlist(clusters.type)\ns.mouse\n# 加载预定义的标记基因集（需提前准备）\n# Load predefined marker gene sets (prepare in advance)\n(load(\"IEmarkers.RData\"))\n# This RData file provides two vectors of gene names Epith.marker and Immune.marker\n\n# 构建分组标记基因列表（与聚类分组对应）\n# Build cluster-specific marker list (must match cluster names)\nIEmarkers = list(NULL, NULL, \n                 Epith.marker, Immune.marker) # marker gene\nnames(IEmarkers) = c('C1', 'C2', 'C3', 'C4')\n# The name of group markers should be the same as the cluster names\n估算细胞类型比例\nEstimate cell type proportions\n# 将分组信息从ExpressionSet传递到SingleCellExperiment对象\n# Transfer cluster annotations from ExpressionSet to SingleCellExperiment\nMousesub.sce$clusterType <- pData(Mousesub.eset)$clusterType\n\n# 执行基于组群的MuSiC反卷积\n# Perform group-aware MuSiC deconvolution\nEst.mouse.bulk <- music_prop.cluster(\n  bulk.mtx = exprs(Mouse.bulk.eset),\n  sc.sce = Mousesub.sce,\n  group.markers = IEmarkers,\n  clusters = 'cellType',      \n  groups = 'clusterType',     \n  samples = 'sampleID',\n  clusters.type = clusters.type\n)\n图3e - MuSiC估算的细胞类型比例\nFigure 3e - MuSiC estimated cell type proportions\n# 提取加权后的细胞群比例估计结果\n# Extract weighted cell group proportion estimates\nplot.df2 <- Est.mouse.bulk$Est.prop.weighted.cluster\n\nlibrary(pheatmap)\n\n# 创建对称颜色断点（用于双向标度）\n# Create symmetric color breaks (for bidirectional scale)\nbk <- c(seq(-2,-0.1,by=0.01),seq(0,2,by=0.01))\n\n# 热图绘制\n# Generate Heatmap\npheatmap(plot.df2,\n         cluster_cols = F,cluster_rows = F,\n         show_colnames=T,show_rownames=T,\n         #cellheight= 10,\n         fontsize=16,\n         #cellwidth = 10,cellheight = 10,\n         treeheight_row = 0,treeheight_col_row = 10,\n         #treeheight_col = 50,\n         color = c(colorRampPalette(colors = c(\"steelblue\",\"white\"))(length(bk)/2),\n                   colorRampPalette(colors = c(\"white\",\"red\"))(length(bk)/2)),\n         border=F,border_color = \"white\",\n         breaks=bk,scale=\"row\",legend_breaks=seq(-2,2,1),\n         filename = \"Est.cluster.celltype.proportions.heatmap.pdf\")\n预测结果：该bulk数据中PT占据比例最大\nPrediction results: PT (Proximal Tubule) cells account for the\nhighest proportion in this bulk data.\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa274MuSiCbulkProop_FigureYa274MuSiCbulkProop",
      "title": "FigureYa274MuSiCbulkProop/FigureYa274MuSiCbulkProop.html",
      "html": "FigureYa274MuSiCbulkProop/FigureYa274MuSiCbulkProop.html",
      "text": "texts/main_FigureYa274MuSiCbulkProop_FigureYa274MuSiCbulkProop.txt",
      "folder": "FigureYa274MuSiCbulkProop",
      "thumb": "gallery_compress/FigureYa274MuSiCbulkProop.webp"
    },
    "word_count": 2004,
    "lines_count": 513,
    "title": "FigureYa274MuSiCbulkProop",
    "description": "Demand description 用MuSic反卷积推算bulk组的细胞类型。 出自",
    "input_data_types": [
      "临床数据",
      "表达矩阵",
      "单细胞"
    ],
    "output_types": [
      "热图",
      "统计表格",
      "PCA图",
      "网络图"
    ],
    "technical_methods": [
      "聚类分析",
      "标准化",
      "主成分分析",
      "网络分析",
      "质量控制"
    ],
    "biology_areas": [
      "免疫学"
    ],
    "complexity_level": "高级",
    "code_snippets": [],
    "key_parameters": [
      "C2",
      "label",
      "",
      "C3",
      "ct",
      "min",
      "markers",
      "sce",
      "width",
      "cluster_cols"
    ]
  },
  {
    "id": "main_FigureYa162boxViolin_FigureYa162boxViolin",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa162boxViolin_FigureYa162boxViolin.txt",
    "content": "FigureYa162boxViolin\nFigureYa162boxViolin\nAuthor(s)\n: Xiaofan Lu\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nDescription of requirements\n绘制两组数据关于某一连续变量的箱型 + 小提琴图 Draw box + violin plots\nof two sets of data on a continuous variable\n出自\nhttps://clinicalepigeneticsjournal.biomedcentral.com/articles/10.1186/s13148-020-0822-y\nFrom\nhttps://clinicalepigeneticsjournal.biomedcentral.com/articles/10.1186/s13148-020-0822-y\nFig. 1 Correlations between DNAm age and chronological age and other\nmolecular characteristics of DNAm age groups. c DNAmAge-ACC group\npresented with significantly higher HPVpca scores than DNAmAge-DEC group\nand was inferred to be much more sensitive to two commonly used\nchemotherapy drugs, i.e. paclitaxel and gemcitabine, as shown in (d) and\n(e), respectively. The test for association between paired samples used\nPearson’s correlation coefficient. Two-tailed statistical P values were\ncalculated by a two-sample Mann-Whitney test or Student’s t test when\nappropriate\n应用场景\nApplication Scenarios\n对比两组或多组数据，原始数据、统计量（boxplot）、统计推断（violin\nplot, 概率密度）画一起。 Compare two or more sets of data, plotting the\noriginal data, statistics (boxplot), and statistical inferences (violin\nplot, probability density) together.\n类似于FigureYa68friends，一半violin、box、一半原始数据。 Similar to\nFigureYa68friends, half is violin, box, and half is original data.\n为什么这样画？原理可参考这篇\nhttps://mp.weixin.qq.com/s/kd-WbPXPrg6K2RFNydK-mQ\n。 Why\ndraw this way? For the principle, please refer to this article\nhttps://mp.weixin.qq.com/s/kd-WbPXPrg6K2RFNydK-mQ\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nLoad the package\nlibrary(ggplot2)\nlibrary(ggpubr)\n\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # Display English error messages\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # Disable conversion of chr to factor\n两组比较，原图复现\nComparison of two groups, reproducing the original image\n输入文件\nInput file\neasy_input.csv，两组的DNA甲基化年龄。第一列是DNA甲基化年龄，第二列是分组。\neasy_input.csv, DNA methylation age of the two groups. The first column\nis DNA methylation age, and the second column is the group.\ntmp <- read.csv(\"easy_input.csv\", row.names = NULL, check.names = F, header = T, stringsAsFactors = F)\nhead(tmp)\ntable(tmp$DNAmAge)\n非参检验\nNonparametric test\np <- wilcox.test(tmp[which(tmp$DNAmAge == \"DNAmAge-ACC\"),\"est.ic50\"],tmp[which(tmp$DNAmAge == \"DNAmAge-DCC\"),\"est.ic50\"])$p.value\n开始画图\nStart plotting\n用ggplot2画图 Plotting with ggplot2\n# 设置颜色\n# Set colors\njco <- c(\"#2874C5\",\"#EABF00\")\n\nggplot(data = tmp,aes(x = DNAmAge, y = est.ic50, fill = DNAmAge))+\n  scale_fill_manual(values = jco[2:1]) + \n  geom_violin(alpha=0.4, position = position_dodge(width = .75),\n              size=0.8, color=\"black\") + # 边框线黑色 # border line black\n  geom_boxplot(notch = TRUE, outlier.size = -1, \n               color=\"black\", lwd=0.8, alpha = 0.7)+ # 背景色透明化 # background color transparent\n  geom_point(shape = 21, size=2, \n             position = position_jitterdodge(), \n             color=\"black\", alpha=1)+ # 边框线黑色 # border line black\n  theme_classic() +\n  ylab(expression(\"Estimated IC\"[50]~\" for Paclitaxel\")) +\n  xlab(\"\")  +\n  annotate(geom=\"text\", cex=6,\n           x=1.5, y=-1, # 根据自己的数据调节p value的位置 # Adjust the position of the p value based on your own data\n           label=paste0(\"P \", ifelse(p<0.001, \"< 0.001\", paste0(\"= \",round(p,3)))), # 添加P值 # Add the P value\n           color=\"black\") + \n  theme(#panel.border = element_rect(colour = \"black\", fill=NA, size=0.2), # 原图有框 # The original image has a frame\n        axis.ticks = element_line(size=0.2,color=\"black\"),\n        axis.ticks.length = unit(0.2,\"cm\"),\n        legend.position = \"none\",\n        axis.title = element_text(size = 12),\n        axis.text = element_text(size = 10))\n# 保存图像 # Save the image\nggsave(\"boxViolin.pdf\", width = 4.5, height = 4)\n多组比较 # Multiple group comparisons\n输入文件 ## Input file\neasy_input.csv，第一列是连续变量，第二列是分组。 easy_input.csv, the\nfirst column is the continuous variable, the second column is the\ngrouping.\ntmp <- read.csv(\"easy_input_multi.csv\", row.names = NULL, check.names = F, header = T, stringsAsFactors = F)\nhead(tmp)\ntable(tmp$TGFBcluster)\n组间对比及画图\nIntergroup comparison and plotting\n用ggpubr的stat_compare_means做kruskal.test Use ggpubr’s\nstat_compare_means to perform the kruskal.test\n用ggplot2画图 Use ggplot2 to plot\n# 设置组间对比，排列组合\n# Set up intergroup comparisons and permutations\nmy_comparisons <- list( c(\"Red-TGFB\", \"Pink-TGFB\"), \n                        c(\"Red-TGFB\", \"Grey-TGFB\"), \n                        c(\"Red-TGFB\", \"Blue-TGFB\"), \n                        c(\"Pink-TGFB\",\"Grey-TGFB\"),\n                        c(\"Pink-TGFB\",\"Blue-TGFB\"),\n                        c(\"Grey-TGFB\",\"Blue-TGFB\"))\n\n#set color\nblue   <- \"#5bc0eb\"\ngrey   <- \"#8693ab\"\ndarkred   <- \"#F2042C\"\nlightred  <- \"#FF7FBF\"\n\nggplot(data = tmp,aes(x = TGFBcluster, #分组列名 #Group column name\n                      y = Enrichscore, #连续变量列名 #Continuous variable column name\n                      fill = TGFBcluster))+ #按分组填充颜色 #Fill by group\n  scale_fill_manual(values = c(blue, grey, lightred, darkred)) + #用自定义颜色填充 #Fill with custom color\n  geom_violin(alpha = 0.4, position = position_dodge(width = .75), \n              size = 0.8, color=\"black\") +\n  geom_boxplot(notch = TRUE, outlier.size = -1, \n               color=\"black\", lwd=0.8, alpha = 0.7) +\n  geom_point(shape = 21, size=2, # 点的性状和大小 # Point characteristics and size\n             position = position_jitterdodge(), # 让点散开 # Spread out the points\n             color=\"black\", alpha = 1) +\n  theme_classic() + \n  ylab(\"Enrichment score\") +\n  xlab(\"TGFB cluster\") +\n  theme(axis.text.x = element_text(angle = 45, hjust = 1, size = 12),\n        #panel.border = element_rect(colour = \"black\", fill=NA, size=0.2),\n        axis.ticks = element_line(size=0.2, color=\"black\"),\n        axis.ticks.length = unit(0.2, \"cm\"),\n        legend.position = \"none\",\n        axis.title = element_text(size = 15),\n        axis.text = element_text(size = 10)) +\n\n  # 如果不要组间比较就注释掉下面这行 \n  # Comment out the following line if you don't want between-group comparisons. \n  stat_compare_means(comparisons = my_comparisons) + \n  stat_compare_means(method = \"kruskal.test\", label.y = min(tmp$Enrichscore))\np\nggsave(\"boxViolin_multipleGroups.pdf\", width = 6, height = 6)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa162boxViolin_FigureYa162boxViolin",
      "title": "FigureYa162boxViolin/FigureYa162boxViolin.html",
      "html": "FigureYa162boxViolin/FigureYa162boxViolin.html",
      "text": "texts/main_FigureYa162boxViolin_FigureYa162boxViolin.txt",
      "folder": "FigureYa162boxViolin",
      "thumb": "gallery_compress/FigureYa162boxViolin.webp"
    },
    "word_count": 743,
    "lines_count": 156,
    "title": "FigureYa162boxViolin",
    "description": "Description of requirements 绘制两组数据关于某一连续变量的箱型 + 小提琴图 Draw box + violin plots of two sets of data on a continuous variable",
    "input_data_types": [
      "突变数据"
    ],
    "output_types": [
      "散点图",
      "箱线图",
      "统计表格"
    ],
    "technical_methods": [
      "生存分析"
    ],
    "biology_areas": [
      "药物研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "colour",
      "ticks",
      "values",
      "header",
      "lwd",
      "width",
      "method",
      "angle"
    ]
  },
  {
    "id": "main_FigureYa243scMarkerGroupHeatmap_FigureYa243scMarkerGroupHeatmap",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa243scMarkerGroupHeatmap_FigureYa243scMarkerGroupHeatmap.txt",
    "content": "FigureYa243scMarkerGroupHeatmap\nFigureYa243scMarkerGroupHeatmap\n2025-5-20\n需求描述\n只要这张图中间的热图部分。scRNA分不同的cluster鉴定细胞类型；两组之间比较markers的表达高低，调整顺序绘制热图。\nRequirement Description\nI only need the heatmap portion in the center of this image. scRNA is divided into different clusters to identify cell types; marker expression levels are compared between the two groups, and the order is adjusted to create the heatmap.\n出自\nhttps://www.ahajournals.org/doi/10.1161/CIRCULATIONAHA.119.043833\nFigure 1. Neutrophils dominate the heart after myocardial infarction (MI).\nD, Gene ontologies of cell-specific differentially expressed genes. The heat maps depict genes ranked by the degree of cell-type specific enrichment. The P value of Gene Ontology enrichment in each gene set is reported. n=4 per sample.\n应用场景\n例文该图用的是bulk RNA-seq数据，小伙伴觉得特适合用来展示单细胞marker基因在多个cluster当中的表达模式。\n环境设置\n使用国内镜像安装包\nApplication Scenarios\nThis example figure uses bulk RNA-seq data, which I find particularly suitable for demonstrating the expression patterns of single-cell marker genes across multiple clusters.\nEnvironment Settings\nUsing a domestic mirror installation package\noptions(\"repos\"= c(CRAN=\"https://mirrors.tuna.tsinghua.edu.cn/CRAN/\"))\noptions(BioC_mirror=\"http://mirrors.tuna.tsinghua.edu.cn/bioconductor/\")\ninstall.packages(\"Seurat\")\ndevtools::install_github(\"satijalab/seurat-data\")\ninstall.packages(\"colorRamps\")\n加载包\nLoad package\nlibrary(Seurat)\nlibrary(SeuratData)\nlibrary(patchwork)\nlibrary(RColorBrewer)\nlibrary(colorRamps)\nlibrary(pheatmap)\nlibrary(dplyr)\nlibrary(magrittr)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 #Display English error messages\noptions(stringsAsFactors = FALSE) #禁止chr转成factor\n输入文件及前期处理\n这里用Seurat的数据，便于小伙伴套用在自己的单细胞数据上。\nInput Files and Preliminary Processing\nSeurat data is used here to facilitate application to your own single-cell data.\n# install dataset\nInstallData(\"ifnb\")\n# load dataset\nLoadData(\"ifnb\")\n# ifnb数据集中包含两个样本数据，分别为CTRL和STIM # The ifnb dataset contains two sample data, CTRL and STIM\nhead(ifnb@meta.data)\ntable(ifnb@meta.data$stim)\n# 使用splitobject将ifnb数据集分割成两个seurat对象的列表(STIM和CTRL) # Use splitobject to split the ifnb dataset into two lists of seurat objects (STIM and CTRL)\nifnb.list <- SplitObject(ifnb, split.by = \"stim\")\n\n# 对两个数据集单独进行normalize并识别各自的高变异基因 # Normalize both datasets and identify highly variable genes in each.\nifnb.list <- lapply(X = ifnb.list, FUN = function(x) {\n  x <- NormalizeData(x)\n  x <- FindVariableFeatures(x, selection.method = \"vst\", nfeatures = 2000)\n})\n\n\n# 计算两个数据中排完rank后top2000的高变异基因 # Calculate the top 2000 highly variable genes in both datasets after ranking.\nfeatures <- SelectIntegrationFeatures(object.list = ifnb.list, nfeatures = 2000)\n \n# 使用上述高变异基因在两个基因集中分别执行PCA # Perform PCA on both gene sets using the highly variable genes.\nifnb.list <- lapply(X = ifnb.list, FUN = function(x) {\n  x <- ScaleData(x, features = features, verbose = T)\n  x <- RunPCA(x, features = features, verbose = T)\n})\n# 对两个数据集进行整合 # Integrate the two datasets\n# 首先使用findinintegrationanchors函数标识锚点，然后使用IntegrateData函数将两数据集整合在一起\n# 可以通过调整k.anchor参数调整两个样本整合的强度，默认为5，数字越大整合强度越强\n# First, use the findintegrationanchors function to identify anchor points, then use the integrateData function to integrate the two datasets.\n# You can adjust the k.anchor parameter to adjust the strength of the integration between the two samples. The default value is 5; a larger number increases the integration strength.\nimmune.anchors <- FindIntegrationAnchors(object.list = ifnb.list, anchor.features = features, reduction = \"rpca\", k.anchor = 20)\nimmune.combined <- IntegrateData(anchorset = immune.anchors)\n# 对整合后的数据进行后续分析 # Perform subsequent analysis on the integrated data\nDefaultAssay(immune.combined) <- \"integrated\"\n常规单细胞流程General Single-Cell Process\n# 常规流程，scale数据，跑PCA，使用前30个PC进行降维跑UMAP，计算Neighbors，分cluster # Perform the general process: scale the data, run PCA, use the first 30 PCs for dimensionality reduction, run UMAP, calculate neighbors, and cluster.\nimmune.combined <- ScaleData(immune.combined, verbose = FALSE)\nimmune.combined <- RunPCA(immune.combined, npcs = 30, verbose = FALSE)\nimmune.combined <- RunUMAP(immune.combined, reduction = \"pca\", dims = 1:30)\nimmune.combined <- FindNeighbors(immune.combined, reduction = \"pca\", dims = 1:30)\nimmune.combined <- FindClusters(immune.combined, resolution = 0.5)\n计算marker基因",
    "chapter_info": {
      "id": "main_FigureYa243scMarkerGroupHeatmap_FigureYa243scMarkerGroupHeatmap",
      "title": "FigureYa243scMarkerGroupHeatmap/FigureYa243scMarkerGroupHeatmap.html",
      "html": "FigureYa243scMarkerGroupHeatmap/FigureYa243scMarkerGroupHeatmap.html",
      "text": "texts/main_FigureYa243scMarkerGroupHeatmap_FigureYa243scMarkerGroupHeatmap.txt",
      "folder": "FigureYa243scMarkerGroupHeatmap",
      "thumb": "gallery_compress/FigureYa243scMarkerGroupHeatmap.webp"
    },
    "word_count": 494,
    "lines_count": 82,
    "title": "FigureYa243scMarkerGroupHeatmap",
    "description": "只要这张图中间的热图部分。scRNA分不同的cluster鉴定细胞类型；两组之间比较markers的表达高低，调整顺序绘制热图。 Requirement Description I only need the heatmap portion in the center of this image. scRNA is divided into different clusters to identify cell types; marker expression levels are compared between the two groups, and the order is adjusted to create the heatmap.",
    "input_data_types": [
      "临床数据",
      "单细胞"
    ],
    "output_types": [
      "热图",
      "统计表格",
      "PCA图"
    ],
    "technical_methods": [],
    "biology_areas": [
      "免疫学"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "n",
      "dims",
      "method",
      "nfeatures",
      "verbose",
      "BioC_mirror",
      "reduction",
      "anchor",
      "resolution"
    ]
  },
  {
    "id": "main_FigureYa13GSEA_Java_update_FigureYa13GSEA_Java_update",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa13GSEA_Java_update_FigureYa13GSEA_Java_update.txt",
    "content": "FigureYa13GSEA_JavaV2_update\nFigureYa13GSEA_JavaV2_update\nAuthor(s)\n: Guangchuang Yu; Ying Ge, Yijing\nChen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n已经用\nJava版GSEA\n做出了GSEA分析结果，想自己画图。\n图一：点图 + 条码\nI have already made GSEA analysis results with\nGSEA for\nJava\nand would like to draw my own plots.\nFigure 1: Dot Map + Barcode\n出自\nhttps://science.sciencemag.org/content/354/6316/1160\nfrom\nhttps://science.sciencemag.org/content/354/6316/1160\n图二：线图 + 条码\nFigure 2: Line Chart + Barcode\n出自\nhttp://jem.rupress.org/content/214/8/2369.long\nfrom\nhttp://jem.rupress.org/content/214/8/2369.long\n图三：条码 + 热图\nFigure 3: Barcode + Heat Map\n出自\nhttps://thorax.bmj.com/content/69/1/14\nfrom\nhttps://thorax.bmj.com/content/69/1/14\n应用场景\nApplication scenario\n以Java版GSEA的输出结果作为输入，DIY结果图，把多个通路画到一张图里。\n如果你用clusterProfiler做的GSEA分析，想要DIY结果图，把多个通路画到一张图，或者把同一通路的多组对比画在一张图上，请用FigureYa60GSEA_clusterprofiler。\nUsing the output of the Java version of GSEA as input, do-it-yourself\nresult map, drawing multiple pathways into a single map.\nIf you do GSEA analysis with clusterProfiler and want to DIY the\nresult plots, plot multiple pathways to a single plot, or plot multiple\ncomparisons of the same pathway to a single plot, use\nFigureYa60GSEA_clusterprofiler.\n环境设置\nEnvironment setting\nsource(\"install_dependencies.R\")\nlibrary(plyr)\nlibrary(ggplot2)\nlibrary(RColorBrewer)\nlibrary(gridExtra)\nlibrary(grid)\nlibrary(cowplot)\n输入数据的准备\nPreparation of input data\nJava版GSEA的输出文件夹中有每个通路的Excel文件，把你感兴趣的通路的Excel文件复制到当前文件夹。\n读取xls文件，合并\nOutput folder of GSEA for Java has an Excel file for each pathway,\ncopy the Excel file for the pathway you are interested in to the current\nfolder.\nRead xls file and merge\nfnames <- Sys.glob(\"*.xls\")\nfdataset <- lapply(fnames,read.delim)\nnames(fdataset) <- fnames\nresult <- ldply(fdataset, data.frame)\nresult$pathway <- unlist(strsplit(result$.id,split = \".xls\"))\nhead(result)\n# pathway的颜色，自定义足够多的颜色\n# color of the pathway, customize enough colors\nmycol <- c(\"red\",\"navy\",\"darkgreen\",\"blueviolet\",\"chocolate4\")\n开始画图\nStart drawing\n用官方GSEA输出的Excel文件重新画图，画这种散点图最合适。如果画折线图，你会发现跟Java版GSEA输出的图像不一致。那是因为官方GSEA输出的Excel文件不是所有基因的enrichment\nscore，它只给出了这个通路内的基因的enrichment score。\nRedrawing the image with the official GSEA output Excel file is best\nfor drawing this kind of scatterplot. If you draw a line graph, you will\nfind that it is not consistent with the image output from the Java\nversion of GSEA. That’s because the official GSEA output Excel file is\nnot the enrichment score for all genes, it only gives the enrichment\nscore for genes within this pathway.\n图一：点图（enrichment score） + 条码（rank）\nFigure 1: Dot Plot (enrichment score) + Barcode (rank)\n先画点图\nFirst, draw a dot plot.\nppoint <- ggplot(result, aes(x=RANK.IN.GENE.LIST,\n                             y=RUNNING.ES,fill=pathway,group=pathway))+\n  #用带黑圈的点，优点是在点密集的位置也能看出有多个点\n  #the advantage of using dots with black circles is that you can see that there are multiple dots in locations where the dots are dense\n  geom_point(shape=21) + \n  scale_fill_manual(values = mycol) + #用自定义的颜色画点 draw dots with custom colors\n  labs(x = \"\", y = \"Enrichment Score\", title = \"\") + \n  scale_x_continuous(expand = c(0, 0)) + #让x和y轴都从0开始 let both the x and y axes start at 0\n  scale_y_continuous(expand = c(0, 0),\n                     limits =c(min(result$RUNNING.ES-0.02), max(result$RUNNING.ES+0.02))) + \n  theme_classic() + \n  theme(axis.line.x = element_blank(),axis.ticks.x = element_blank(),axis.text.x = element_blank()) + #去除x轴 remove x-axis\n  geom_hline(yintercept = 0) #在0的位置画x轴 draw the x-axis at position 0\nppoint\n如果pathway不多，还可以把legend画在左下角\nIf there are not many pathways, you can also draw the legend in the\nbottom left corner\nppoint2 <- ppoint + theme(legend.position=c(0,0),legend.justification = c(0,0)) + \n  guides(fill=guide_legend(title = NULL)) + #隐藏由fill产生的图例的title hide the title of the legend generated by the fill\n  theme(legend.background = element_blank()) +\n  theme(legend.key = element_blank())\nppoint2\n#可以用ggsave保存到文件\n#you can save it to a file using ggsave\n#ggsave(file=\"ppoint2.pdf\")\n再画条码\n散点图和后面的条码图本身就已经显示了gene\nrank，其实只有画线图的时候需要另外画gene rank。\nRedraw barcode\nThe scatterplot and the barcode plot behind it already show the gene\nrank by itself, in fact, only the line plot needs to draw the gene rank\nseparately.\nprank <- ggplot(result,aes(RANK.IN.GENE.LIST,pathway,colour=pathway))+\n  geom_tile()+\n  theme_bw() + #去除背景色 remove background color\n  scale_color_manual(values = mycol) + #用自定义的颜色画点 draw dots with custom colors\n  labs(x = \"treatment<--------------control\", y = \"\", title = \"\") + \n  scale_x_discrete(expand = c(0, 0)) + scale_y_discrete(expand = c(0, 0)) +#让x和y轴都从0开始 let both the x and y axes start at 0\n  theme(panel.grid =element_blank()) + #去除网格线 remove gridlines\n  theme(panel.border = element_blank()) + #去除外层边框 remove outer border\n  theme(axis.line = element_line(colour = \"black\"))+\n  theme(axis.line.y = element_blank(),axis.ticks.y = element_blank(),axis.text.y = element_blank())+ #去除y轴 remove y-axis\n  guides(color=FALSE)#隐藏由color产生的图例 hide the legend generated by color\nprank\n组图\nComposite image\n#用gridExtra保持上下两个图各自的高度\n#use gridExtra to keep the heights of the top and bottom graphs separate\ngA=ggplot_gtable(ggplot_build(ppoint)) #或ppoint2 or ppoint2\ngB=ggplot_gtable(ggplot_build(prank))\nmaxWidth = grid::unit.pmax(gA$widths, gB$widths)\ngA$widths <- as.list(maxWidth)\ngB$widths <- as.list(maxWidth)\n\n#然后用grid组合两个图，按同一个x坐标上下对齐\n#then combine the two plots with a grid, aligning them up and down by the same x-coordinate\ngrid.newpage()\ngrid.arrange(arrangeGrob(gA,gB,nrow=2,heights=c(.8,.3)))\n# 输出到文件\n# output to file\npdf('prettyGSEApoint.pdf',width=8,height=4)\ngrid.arrange(arrangeGrob(gA,gB,nrow=2,heights=c(.8,.3)))\ndev.off()\n图二：线图（enrichment score） + 条码（rank）\nFigure 2: Line graph (enrichment score) + Barcode (rank)\n先画线图\nDraw a line graph first\npline <- ggplot(result,aes(x=RANK.IN.GENE.LIST,y=RUNNING.ES,colour=pathway,group=pathway))+\n  geom_line(size=1) + \n  scale_color_manual(values = mycol) + #用自定义的颜色画点 draw dots with custom colors\n  labs(x = \"\", y = \"Enrichment Score\", title = \"\") + \n  scale_x_continuous(expand = c(0, 0)) + #让x和y轴都从0开始 let both the x and y axes start at 0\n  scale_y_continuous(expand = c(0, 0),\n                     limits =c(min(result$RUNNING.ES-0.02), max(result$RUNNING.ES+0.02))) + \n  theme_bw() + #去除背景色 remove background color\n  theme(panel.grid =element_blank()) + #去除网格线 remove gridlines\n  theme(panel.border = element_blank()) + #去除外层边框 remove outer border\n  theme(axis.line = element_line(colour = \"black\")) +\n  theme(axis.line.x = element_blank(),axis.ticks.x = element_blank(),axis.text.x = element_blank()) + #去除x轴 remove x-axis\n  geom_hline(yintercept = 0) + #在0的位置画x轴 draw the x-axis at position 0\n  theme(legend.position=c(0,0),legend.justification = c(0,0)) + #legend画在左下角 the legend is drawn in the lower left corner\n  guides(colour=guide_legend(title = NULL)) + #隐藏由color产生的图例的title hide the title of the legend generated by color\n  theme(legend.background = element_blank()) +\n  theme(legend.key = element_blank())\npline\n跟前面的条码图组图\nCombine with the previous barcode image\n#用gridExtra保持上下两个图各自的高度\n#use gridExtra to keep the heights of the top and bottom graphs separate\ngA=ggplot_gtable(ggplot_build(pline))#换成p1试试看 try p1 instead.\ngB=ggplot_gtable(ggplot_build(prank))\nmaxWidth = grid::unit.pmax(gA$widths, gB$widths)\ngA$widths <- as.list(maxWidth)\ngB$widths <- as.list(maxWidth)\n\n#然后用grid组合两个图，按同一个x坐标上下对齐\n#then combine the two plots with a grid, aligning them up and down by the same x-coordinate\ngrid.newpage()\ngrid.arrange(arrangeGrob(gA,gB,nrow=2,heights=c(.8,.3)))\n# 输出到文件\n# output to file\npdf('prettyGSEAline.pdf',width=5,height=4)\ngrid.arrange(arrangeGrob(gA,gB,nrow=2,heights=c(.8,.3)))\ndev.off()\n图三：条码（enrichment score + rank） + 热图\nFigure 3: Barcode (enrichment score + rank) + Heatmap\n类似于散点图，同样要先把该通路中基因的enrichment score提取出来。\n一次画一个，画到list里\nSimilar to a scatterplot, again the enrichment score of the genes in\nthe pathway has to be extracted first.\nDraw one at a time into the list\npbar <- lapply(unique(result$pathway), function(ii) {\n    dd <- result[result$pathway == ii,]\n    ggplot(dd,aes(x=RANK.IN.GENE.LIST,y=RUNNING.ES))+\n      geom_bar(stat=\"identity\",colour = \"black\")+\n      labs(x = ii, y = \"\", title = ii) +\n      theme_void() + #不画坐标系 no coordinate system is drawn\n      xlim(0, max(result$RANK.IN.GENE.LIST))\n})\npbar\n如果单画一条通路，那么这个热图应该画成有意义的。画多条就只能画这种假的了，仅用来表示左侧下调，右侧上调。\nIf a single pathway is drawn then this heatmap should be drawn to\nmake sense. Drawing more than one would have to be this fake one, used\nonly to indicate downward movement on the left and upward movement on\nthe right.\nt <- data.frame(a=as.numeric(1:1000),b=as.numeric(1:1000))\n\npheat <- ggplot(t,aes(a,1,fill=b)) +\n  geom_tile()+\n  theme_bw() + #去除背景色 remove background color\n  labs(x = \"Decreased--------------Increased\", y = \"\", title = \"\") + \n  scale_fill_gradient2(low = \"blue\", mid = \"white\", high = \"red\",midpoint = 500)+\n  scale_x_discrete(expand = c(0, 0)) + scale_y_discrete(expand = c(0, 0)) +#让x和y轴都从0开始 let both the x and y axes start at 0\n  theme(panel.grid =element_blank()) + #去除网格线 remove gridlines\n  theme(panel.border = element_blank()) + #去除外层边框 remove outer border\n  guides(fill=FALSE)#隐藏由fill产生的图例 hide the legend generated by fill\npheat\n用cowplot组图\nCombine images with cowplot\npbar[[4]] <- pheat\nplot_grid(plotlist=pbar, ncol=1,rel_heights = c(2,2,2,1))\nggsave(\"prettyGSEAbar.pdf\")\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa13GSEA_Java_update_FigureYa13GSEA_Java_update",
      "title": "FigureYa13GSEA_Java_update/FigureYa13GSEA_Java_update.html",
      "html": "FigureYa13GSEA_Java_update/FigureYa13GSEA_Java_update.html",
      "text": "texts/main_FigureYa13GSEA_Java_update_FigureYa13GSEA_Java_update.txt",
      "folder": "FigureYa13GSEA_Java_update",
      "thumb": "gallery_compress/FigureYa13GSEA_Java_update.webp"
    },
    "word_count": 1132,
    "lines_count": 235,
    "title": "FigureYa13GSEA_JavaV2_update",
    "description": "Requirement description 已经用 Java版GSEA",
    "input_data_types": [],
    "output_types": [
      "散点图",
      "热图",
      "统计表格"
    ],
    "technical_methods": [
      "通路分析"
    ],
    "biology_areas": [
      "药物研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "rel_heights",
      "",
      "colour",
      "key",
      "values",
      "width",
      "grid",
      "heights",
      "gB",
      "nrow"
    ]
  },
  {
    "id": "main_FigureYa10chromosomeV2_update_FigureYa10chromosomeV2_update",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa10chromosomeV2_update_FigureYa10chromosomeV2_update.txt",
    "content": "FigureYa10chromosomeV2_update\nFigureYa10chromosomeV2_update\nAuthor(s)\n: Zhaodong Hao; Ying Ge, Yijing Chen\nDate\n: 2025-10-09\nAcademic Citation\nIf you use this code in your work or research, we kindly request that you cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization Framework for Enhancing Biomedical Data Interpretation and Research Efficiency. iMetaMed. 1(1)\nhttps://doi.org/10.1002/imm3.70005\nTo cite package ‘RIdeogram’ in publications use:\nHao Z, Lv D, Ge Y, Shi J, Weijers D, Yu G, Chen J. 2020. RIdeogram: drawing SVG graphics to visualize and map genome-wide data on the idiograms. PeerJ Comput. Sci. 6:e251\nhttp://doi.org/10.7717/peerj-cs.251\n需求描述\nRequirement description\n用R代码画出paper里的直的染色体分布图\nUse R code to draw the straight chromosome distribution map in paper\n出自\nhttps://academic.oup.com/brain/article/138/3/616/333368\nFrom\nhttps://academic.oup.com/brain/article/138/3/616/333368\n应用场景\nApplication scenario\n差异表达基因（RNA-seq）、开放染色质（DNase/ATAC-seq）、CTCF结合位点（ChIP-seq）、突变位点（WGS）或DNA甲基化（WGBS）在染色体上的分布，或者只是画Ideogram\nDistribution of differentially expressed genes (RNA-seq), open chromatin (DNase/ATAC-seq), CTCF binding sites (ChIP-seq), mutation sites (WGS), or DNA methylation (WGBS) on chromosomes, or just drawing Ideograms\n环境设置\nEnvironment setting\nsource(\"install_dependencies.R\")\nlibrary(RIdeogram)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 display English error messages\noptions(stringsAsFactors = FALSE) #禁止chr转成factor prohibit the conversion of chr to factor\n输入文件\nInput file\n三个输入文件，其中第一个文件必需提供，第二和第三个文件非必需：\nkaryotype.csv，用于画染色体轮廓。包含五列：第一列为染色体名，第二、三列为染色体的起始和终止点。如果能提供着丝粒的开始和结束位置，就给出第四列（起始）和第五列（终止），如果着丝粒位置未知，就只给前三列。0-based基因组坐标(以0-based开始、1-based结束)。\neasy_input_heatmap.csv，用来绘制染色体heatmap。包含四列，第一列染色体名，第二、三列为染色体上的位置，第四列为相应位置上的值。例如差异基因的log2foldchange、甲基化水平等。\neasy_input_mark.csv，如果想画染色体旁边的形状标记，就要提供这个文件。包含六列，第一列type，第二列形状（只支持三种形状：box正方形、triangle三角形和circle圆。如果需要标记的特征超过3种，就用第六列里的颜色区分吧，例如红色的三角形，蓝色的三角形等），第三列染色体，第四、五列染色体上的位置，第六列颜色。\n注意：\n同一type对应的颜色一致。\nThree input files, of which the first is required and the second and third are not required:\nkaryotype.csv, used for drawing chromosome outlines. It contains five columns: the first column is the chromosome name, and the second and third columns are the start and end points of the chromosome. If the start and end positions of the centromere are available, the fourth column (start) and the fifth column (end) are included; if the centromere position is unknown, only the first three columns are provided. 0-based genomic coordinates (start with 0-based and end with 1-based).\neasy_input_heatmap.csv, used for drawing chromosome heatmaps. It contains four columns: the first column is the chromosome name, the second and third columns are the positions on the chromosome, and the fourth column is the value at the corresponding position, such as the log2 fold change of differential genes, methylation levels, etc.\neasy_input_mark.csv: If you want to draw shape markers next to the chromosomes, you need to provide this file. It contains six columns: the first column is the type, the second column is the shape (only three shapes are supported: box, triangle, and circle. If the features you need to mark exceed three types, use the color in the sixth column to differentiate, such as red triangles, blue triangles, etc.), the third column is the chromosome, the fourth and fifth columns are the positions on the chromosome, and the sixth column is the color.\nNote:\nThe color corresponding to the same type should be consistent.\n# 染色体长度、中心粒位置\n# chromosome length, centromere position\nkaryotype <- read.csv(\"karyotype.csv\")\nkaryotype\n# 染色体上的heatmap\n# heatmap on chromosomes\ngene_density <- read.csv(\"easy_input_heatmap.csv\")\nhead(gene_density)\n# 染色体旁边的形状标记\n# shape markers next to chromosomes\nRandom_RNAs_500 <- read.csv(\"easy_input_mark.csv\")\nhead(Random_RNAs_500)\n开始画图\nStart drawing\nideogram(karyotype = karyotype, \n         \n         #如果没提供easy_input_heatmap.csv，就在下面两行前面加#\n         #If easy_input_heatmap.csv is not provided, precede the following two lines with#\n         overlaid = gene_density, \n         #染色体上heatmap的配色\n         #color matching of heatmap on chromosomes\n         colorset1 = c(\"forestgreen\", \"gold\", \"deeppink3\"), \n         \n         #如果没提供easy_input_mark.csv，就在下面这行前面加#\n         #If easy_input_mark.csv is not provided, prefix the following line with#\n         label = Random_RNAs_500, \n         label_type = \"marker\",\n         \n         #染色体宽度，默认170\n         #chromosome width, default 170\n         width = 180, #注意：太宽会跑出画布外面 Note: If it's too wide, it will extend beyond the canvas\n         \n         #图例的位置\n         #position of legend\n         Lx = 160, #图例左上角跟左边的距离 distance from the top left corner of the legend to the left side\n         Ly = 20, #图例左上角跟顶端的距离 distance from the upper left corner of the legend to the top \n         \n         #输出文件\n         #output file\n         output = \"chromosome.svg\") #只支持svg格式 only svg format is supported\n\n# 可以转成png，方便查看\n# It can be converted to png for easy viewing\nconvertSVG(\"chromosome.svg\", device = \"png\")\n格式转换\nFormat conversion\n运行完上面这段，当前文件夹里会生成一个“chromosome.svg”文件，是矢量图。可以用Inkscape、Illustrator等工具打开、编辑、转换成其他格式。\n还可以运行下面这段把svg转成pdf或tiff、jpg、png等格式的文件\nAfter running the above paragraph, a file “chromosome.svg” will be generated in the current folder, which is a vector image. You can use Inkscape, Illustrator and other tools to open, edit, convert to other formats.\nYou can also run the following paragraph to svg into pdf or tiff, jpg, png and other formats of the file\n#svg2pdf或svg2tiff、svg2jpg、svg2png\n#svg2pdf or svg2tiff、svg2jpg、svg2png\nsvg2pdf(\"chromosome.svg\", \n        width = 12, height = 8, #画布大小 canvas size\n        dpi = 300)\n附：karyotype.csv文件的准备\nAppendix: Preparation of karyotype.csv file\n这里提供两种两种方法，二选一即可。  Two methods are provided here, choose one.\n方法一：用rtracklayer实现\nMethod 1: Using rtracklayer\n适合处理复杂的基因组数据  Suitable for processing complex genomic data\nlibrary(rtracklayer)\nlibrary(dplyr)\n\n# 读取 GTF 文件 \\ Read GTF file\ngtf <- import(\"your_file.gtf\")  # 使用 rtracklayer 导入 GTF 文件 \\ Use rtracklayer to import GTF file\n\n# 提取染色体信息 \\ Extract chromosome information\nkaryotype <- gtf %>%\n  as.data.frame() %>%  # 转换为数据框 \\ Convert to data frame\n  filter(type == \"chromosome\") %>%  # 筛选染色体信息 \\ Filter chromosome information\n  select(seqnames, start, end) %>%  # 提取染色体名称、起始位置和终止位置 \\ Extract chromosome name, start position, and end position\n  rename(Chromosome = seqnames, Start = start, End = end) %>%\n  mutate(Centromere_Start = NA, Centromere_End = NA)  # 如果没有着丝粒信息，可以填充 NA \\ If centromere information is unavailable, fill with NA\n\n# 如果有着丝粒信息，提取并合并 \\ If centromere information is available, extract and merge\ncentromere <- gtf %>%\n  as.data.frame() %>%\n  filter(type == \"centromere\") %>%  # 筛选着丝粒信息 \\ Filter centromere information\n  select(seqnames, start, end) %>%\n  rename(Chromosome = seqnames, Centromere_Start = start, Centromere_End = end)\n\nkaryotype <- karyotype %>%\n  left_join(centromere, by = \"Chromosome\")\n\n# 保存为 karyotype.csv \\ Save as karyotype.csv\nwrite.csv(karyotype, \"karyotype.csv\", row.names = FALSE)\n方法二：用dplyr实现\nMethod 2: Using dplyr\n适合结构简单的GTF文件  Suitable for simple GTF file structures\nlibrary(dplyr)\n\n# 读取 GTF 文件 \\ Read GTF file\ngtf <- read.table(\"your_file.gtf\", sep = \"\\t\", header = FALSE, stringsAsFactors = FALSE)\n\n# 提取染色体信息 \\ Extract chromosome information\nkaryotype <- gtf %>%\n  filter(V3 == \"chromosome\") %>%  # 筛选染色体信息 \\ Filter chromosome information\n  select(V1, V4, V5) %>%         # 提取染色体名称、起始位置和终止位置 \\ Extract chromosome name, start position, and end position\n  rename(Chromosome = V1, Start = V4, End = V5) %>%\n  mutate(Centromere_Start = NA, Centromere_End = NA)  # 如果没有着丝粒信息，可以填充 NA \\ If centromere information is unavailable, fill with NA\n\n# 如果有着丝粒信息，提取并合并 \\ If centromere information is available, extract and merge\ncentromere <- gtf %>%\n  filter(V3 == \"centromere\") %>%  # 筛选着丝粒信息 \\ Filter centromere information\n  select(V1, V4, V5) %>%\n  rename(Chromosome = V1, Centromere_Start = V4, Centromere_End = V5)\n\nkaryotype <- karyotype %>%\n  left_join(centromere, by = \"Chromosome\")\n\n# 保存为 karyotype.csv \\ Save as karyotype.csv\nwrite.csv(karyotype, \"karyotype.csv\", row.names = FALSE)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa10chromosomeV2_update_FigureYa10chromosomeV2_update",
      "title": "FigureYa10chromosomeV2_update/FigureYa10chromosomeV2_update.html",
      "html": "FigureYa10chromosomeV2_update/FigureYa10chromosomeV2_update.html",
      "text": "texts/main_FigureYa10chromosomeV2_update_FigureYa10chromosomeV2_update.txt",
      "folder": "FigureYa10chromosomeV2_update",
      "thumb": "gallery_compress/FigureYa10chromosomeV2_update.webp"
    },
    "word_count": 1013,
    "lines_count": 160,
    "title": "FigureYa10chromosomeV2_update",
    "description": "Requirement description 用R代码画出paper里的直的染色体分布图 Use R code to draw the straight chromosome distribution map in paper",
    "input_data_types": [
      "DNA-seq",
      "突变数据"
    ],
    "output_types": [
      "火山图",
      "热图",
      "统计表格"
    ],
    "technical_methods": [
      "差异表达分析"
    ],
    "biology_areas": [
      "神经科学"
    ],
    "complexity_level": "高级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "Start",
      "header",
      "width",
      "Ly",
      "Centromere_Start",
      "Centromere_End",
      "colorset1",
      "label_type"
    ]
  },
  {
    "id": "main_FigureYa118MulticlassDESeq2_FigureYa118MulticlassDESeq2",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa118MulticlassDESeq2_FigureYa118MulticlassDESeq2.txt",
    "content": "FigureYa118MulticlassDESeq2\nFigureYa118MulticlassDESeq2\nAuthor(s)\n: Xiaofan Lu, Taojun Ye\nReviewer(s)\n: Ying Ge\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n用DESeq2实现多组差异分析。能用来替换FigureYa109SubtypeGSEA中的配对差异表达过程（亚型数目>=3），并跟它无缝对接。\nRequirement description\nImplement multi group differential analysis using DESeq2. Can be used\nto replace the paired differential expression process (subtype\nnumber>=3) in FigureYa109SubtypeGSEA and seamlessly integrate with\nit.\n应用场景\n结合FigureYa109subtypeGSEA，分析每一组与其他样品的差异基因，进而找出亚型特异富集的通路；\n结合FigureYa116supervisedCluster，分析每一组与其他样品的差异基因，进而找出亚型特异的marker基因。\n注意：\n这里不涉及批次效应消除，若样本间含有批次效应，请阅读DESeq2相关document并修改该脚本，在设计矩阵中纳入batch\neffect。\n这里针对read\ncount表达矩阵作为输入的情况，如果你的数据是FPKM/RPKM或芯片数据，请参考FigureYa119Multiclasslimma\nApplication scenarios\nBased on FigureYa109 subtype GSEA, analyze the differentially\nexpressed genes between each group and other samples, and identify\nsubtype specific enriched pathways;\nUsing FigureYa116supervisedCluster, analyze the differentially\nexpressed genes between each group and other samples, and identify\nsubtype specific marker genes.\n**Note: * * This time does not involve batch effect elimination. If\nthere are batch effects between samples, please read the relevant DESeq2\ndocuments and modify the script to include batch effects in the design\nmatrix.\nFor the case where the read count expression matrix is used as input,\nif your data is FPKM/RPKM or chip data, please refer to FigureYa119\nMulticlasslimma\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\n# 加载DESeq2包，用于差异表达基因分析\n# Load the DESeq2 package for differential gene expression analysis\nlibrary(DESeq2)\n# 设置系统环境变量，使R显示英文错误信息（便于搜索解决方案）\n# Set environment variable to display error messages in English (for easier troubleshooting)\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止R自动将字符串转换为因子类型（避免数据处理时的意外转换）\n# Prevent automatic conversion of character strings to factors (avoids unexpected data type changes)\noptions(stringsAsFactors = FALSE)\n自定义函数，分别比较每一组跟其他样品之间的差异，如果有更多组，按规律补充进去即可\nCustomize functions to compare the differences between each group and\nother samples separately. If there are more groups, simply add them\naccording to the pattern\n# 创建需要配对比较的列表\n# Create a list of paired comparisons for differential expression analysis\ncreateList <- function(group=NULL) {\n  \n  tumorsam <- names(group)\n  sampleList = list()\n  treatsamList =list()\n  treatnameList <- c()\n  ctrlnameList <- c()\n  \n  #A-1: 类1 vs 其他\n  # Class 1 vs Others\n  sampleList[[1]] = tumorsam\n  treatsamList[[1]] = intersect(tumorsam, names(group[group==\"immune\"])) # 亚型名称需要根据情况修改\n                                                                              # Subtype name should be modified according to actual data\n  treatnameList[1] <- \"immune\" # 该亚型的命名\n                               # Name of this subtype\n  ctrlnameList[1] <- \"Others\" # 其他亚型的命名\n                              # Name for other subtypes\n  \n  #A-2: 类2 vs 其他\n  # Class 2 vs Others\n  sampleList[[2]] = tumorsam\n  treatsamList[[2]] = intersect(tumorsam, names(group[group==\"keratin\"]))\n  treatnameList[2] <- \"keratin\"\n  ctrlnameList[2] <- \"Others\"\n  \n  #A-3: 类3 vs 其他\n  # Class 3 vs Others\n  sampleList[[3]] = tumorsam\n  treatsamList[[3]] = intersect(tumorsam, names(group[group==\"MITF-low\"]))\n  treatnameList[3] <- \"MITF-low\"\n  ctrlnameList[3] <- \"Others\"\n  \n  #如果有更多类，按以上规律继续写\n  # Add more comparisons following the same pattern if needed\n  \n  return(list(sampleList, treatsamList, treatnameList, ctrlnameList))\n}\n\n# 配对DESeq2差异表达分析\n# Paired differential expression analysis using DESeq2\ntwoclassDESeq2 <- function(res.path=NULL, countsTable=NULL, prefix=NULL, complist=NULL, overwt=FALSE) {\n  # res.path: 结果保存路径 (Path to save results)\n  # countsTable: 表达矩阵，行名为基因，列名为样本 (Expression matrix with genes as rows and samples as columns)\n  # prefix: 输出文件前缀 (Prefix for output files)\n  # complist: 比较列表，由createList函数生成 (Comparison list generated by createList function)\n  # overwt: 是否覆盖已存在的结果文件 (Whether to overwrite existing result files)\n  \n  sampleList <- complist[[1]]\n  treatsamList <- complist[[2]]\n  treatnameList <- complist[[3]]\n  ctrlnameList <- complist[[4]]\n  allsamples <- colnames(countsTable)\n  \n  options(warn=1)\n  for (k in 1:length(sampleList)) { # 循环读取每一次比较的内容\n                                      # Loop through each comparison\n    samples <- sampleList[[k]]\n    treatsam <- treatsamList[[k]] \n    treatname <- treatnameList[k]\n    ctrlname <- ctrlnameList[k]\n    \n    compname <- paste(treatname, \"_vs_\", ctrlname, sep=\"\") # 生成最终文件名\n                                                              # Generate final output file name\n    tmp = rep(\"others\", times=length(allsamples))\n    names(tmp) <- allsamples\n    tmp[samples]=\"control\"\n    tmp[treatsam]=\"treatment\"\n    outfile <- file.path( res.path, paste(prefix, \"_deseq2_test_result.\", compname, \".txt\", sep=\"\") )\n    if (file.exists(outfile) & (overwt==FALSE)) { # 因为差异表达分析较慢，因此如果文件存在，在不覆盖的情况下（overwt=F）不再次计算差异表达\n                                                    # Skip analysis if result file exists and overwt is FALSE to save time\n      cat(k, \":\", compname, \"exists and skipped;\\n\")\n      next\n    }\n    \n    saminfo <- data.frame(\"Type\"=tmp[samples],\"SampleID\"=samples,stringsAsFactors = F)\n    cts <- countsTable[,samples]\n    coldata <- saminfo[samples,]\n    \n    # 差异表达过程，具体参数细节及输出结果解释，请参阅相关document\n    # Differential expression analysis. For parameter details and result interpretation, refer to DESeq2 documentation\n    dds <- DESeqDataSetFromMatrix(countData = cts,\n                                  colData = coldata,\n                                  design = as.formula(\"~ Type\")) # 设计矩阵仅包含亚型信息，若有批次效应请修改\n                                                                  # Design formula includes only subtype information. Modify if batch effects exist\n    \n    dds$Type <- relevel(dds$Type,ref = \"control\")\n    \n    dds <- DESeq(dds)\n    res <- results(dds, contrast=c(\"Type\",\"treatment\",\"control\"))\n    \n    resData <- as.data.frame(res[order(res$padj),])\n    resData$id <- rownames(resData)\n    resData <- resData[,c(\"id\",\"baseMean\",\"log2FoldChange\",\"lfcSE\",\"stat\",\"pvalue\",\"padj\")]\n    colnames(resData) <- c(\"id\",\"baseMean\",\"log2FC\",\"lfcSE\",\"stat\",\"PValue\",\"FDR\")\n    #输出到文件\n    # Write results to file\n    write.table(resData, file=outfile, row.names=F, col.names=T, sep=\"\\t\", quote=F)\n    cat(k, \",\")\n  }\n  options(warn=0)\n}\n输入文件\nInput file\n# 读取read count表达矩阵\n# Read read count expression matrix\nexpr <- read.table(\"easy_input_counts.txt\",sep = \"\\t\",header = T,check.names = F,stringsAsFactors = F,row.names = 1)\nexpr[1:3, 1:3]  # 查看表达矩阵前3行3列的内容\n# View the first 3 rows and 3 columns of the expression matrix\n\n# 读取亚型信息\n# Read subtype information\nsubt <- read.table(\"easy_input_subtype.txt\", sep = \"\\t\", check.names = F, stringsAsFactors = F, header = T, row.names = 1)\nhead(subt)  # 查看亚型信息数据前几行\n# View the first few rows of the subtype information\n\nn.sub.label <- unique(subt$TCGA_Subtype)  # 提取唯一的亚型名称\n                                           # Extract unique subtype names\nn.sub.label  # 显示所有亚型名称\n# Display all subtype names\n\nn.sub <- length(table(subt$TCGA_Subtype))  # 计算亚型的数量\n                                             # Calculate the number of subtypes\nn.sub  # 显示亚型数量\n# Display the number of subtypes\n开始分析\nStart analyzing\n# If result files exist, skip recalculation (avoid redundant work)\n在当前文件夹会生成3个文件，可以作为FigureYa116supervisedCluster的输入：\nSKCM_deseq2_test_result.immune_vs_Others.txt\nSKCM_deseq2_test_result.keratin_vs_Others.txt\nSKCM_deseq2_test_result.MITF-low_vs_Others.txt\n如果想跟FigureYa109SubtypeGSEA无缝对接，就继续运行下面这段，生成degs.list，然后从FigureYa109SubtypeGSEA里的“自定义分析函数”开始运行，手动把“自定义分析函数”里第160行的\ngeneList <- degs$log2FoldChange\n改为\ngeneList <- degs$log2FC\n：\nThree files will be generated in the current folder, which can be\nused as input for FigureYa116supervisedCluster:\nSKCM_deseq2_test_result.immune_vs_Others.txt\nSKCM_deseq2_test_result.keratin_vs_Others.txt\nSKCM_deseq2_test_result.MITF-low_vs_Others.txt\nIf you want to seamlessly integrate with FigureYa109SubtypeGSEA,\ncontinue running the following paragraph to generate degs.list, and then\nstart running from “Custom Analysis Functions” in\nFigureYa109SubtypeGSEA. Manually change the “geneList<- degs\n$log2FoldChange” in line 160 of “Custom Analysis Functions” to\n“geneList<- degs $log2FC”:\n# 定义差异表达分析结果文件路径\n# Define file paths for differential expression analysis results\nDEfiles <- c(\"SKCM_deseq2_test_result.immune_vs_Others.txt\",  # 免疫亚型 vs 其他亚型的差异表达结果\n             # Differential expression results for immune subtype vs others\n             \"SKCM_deseq2_test_result.keratin_vs_Others.txt\",  # 角质形成亚型 vs 其他亚型的差异表达结果\n             # Differential expression results for keratin subtype vs others\n             \"SKCM_deseq2_test_result.MITF-low_vs_Others.txt\")  # MITF-low亚型 vs 其他亚型的差异表达结果\n             # Differential expression results for MITF-low subtype vs others\n\n# 初始化空列表存储各亚型的差异表达基因数据框\n# Initialize empty list to store data frames of differentially expressed genes (DEGs)\ndegs.list <- list()\n\n# 循环读取每个亚型的差异表达分析结果\n# Loop through each subtype's DEG analysis results\nfor (i in 1:n.sub) {  # n.sub为亚型数量，由前面代码计算得出\n                      # n.sub is the number of subtypes calculated earlier\n  # 读取差异表达结果文件\n  # Read DEG analysis result file\n  degs <- read.table(DEfiles[i],  # 差异表达结果文件路径\n                     # Path to DEG result file\n                     sep = \"\\t\",  # 使用制表符分隔字段\n                     # Use tab as field separator\n                     header = T,  # 文件包含表头\n                     # File contains header\n                     check.names = F,  # 不检查列名有效性\n                     # Do not check validity of column names\n                     stringsAsFactors = F,  # 不将字符串转换为因子\n                     # Do not convert strings to factors\n                     row.names = 1)  # 使用第一列作为行名（通常为基因ID）\n                     # Use first column as row names (usually gene IDs)\n  \n  # 查看数据前几行，确认数据结构\n  # View first few rows to confirm data structure\n  head(degs)\n  \n  # 去除包含缺失值的行，并将结果存入列表\n  # Remove rows with missing values and store cleaned data in list\n  degs.list[[n.sub.label[i]]] <- as.data.frame(na.omit(degs))  # 使用亚型名称作为列表元素名称\n                                                                   # Use subtype name as list element name\n}\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa118MulticlassDESeq2_FigureYa118MulticlassDESeq2",
      "title": "FigureYa118MulticlassDESeq2/FigureYa118MulticlassDESeq2.html",
      "html": "FigureYa118MulticlassDESeq2/FigureYa118MulticlassDESeq2.html",
      "text": "texts/main_FigureYa118MulticlassDESeq2_FigureYa118MulticlassDESeq2.txt",
      "folder": "FigureYa118MulticlassDESeq2",
      "thumb": "gallery_compress/FigureYa118MulticlassDESeq2.webp"
    },
    "word_count": 1102,
    "lines_count": 253,
    "title": "FigureYa118MulticlassDESeq2",
    "description": "用DESeq2实现多组差异分析。能用来替换FigureYa109SubtypeGSEA中的配对差异表达过程（亚型数目>=3），并跟它无缝对接。 Requirement description Implement multi group differential analysis using DESeq2. Can be used",
    "input_data_types": [
      "临床数据",
      "表达矩阵"
    ],
    "output_types": [
      "火山图",
      "统计表格"
    ],
    "technical_methods": [
      "通路分析",
      "差异表达分析"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学",
      "药物研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "times",
      "header",
      "complist",
      "pvalue",
      "colData",
      "countData",
      "prefix",
      "group",
      "ref"
    ]
  },
  {
    "id": "main_FigureYa196Plus_PanPie_FigureYa196Plus_PanPie",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa196Plus_PanPie_FigureYa196Plus_PanPie.txt",
    "content": "FigureYa196Plus_PanPie\nFigureYa196Plus_PanPie\nAuthor(s)\n: Ying Ge\nDate\n: 2025-10-06\nAcademic Citation\nIf you use this code in your work or research, we kindly request that you cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization Framework for Enhancing Biomedical Data Interpretation and Research Efficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement Description\n用scatterpie包画图，展示不同临床预后分期的分布差异。\nUse the scatterpie package to visualize the distribution differences across different clinical prognostic stages.\n出自\nhttps://www.nature.com/articles/s41388-019-1026-9\nFrom\nhttps://www.nature.com/articles/s41388-019-1026-9\nFig. 4 Identification of CNV-driven rRNA metabolism-related genes with clinical relevance. f, g Pie charts showing the Chi-squared test of clinicopathologic factors for PRE in CRC (f) and LUAD (g) tumor samples from the TCGA.\n图 4 具有临床相关性的 CNV 驱动的 rRNA 代谢相关基因的鉴定。f、g饼图显示了来自TCGA的CRC（f）和 LUAD（g）肿瘤样本中 PRE 临床病理因素的卡方检验。\n应用场景\nApplication Scenarios\n搞清楚输入数据跟图的对应关系、理解每部分代码所画的内容，就可以套用到更多类型的数据上。\nOnce you understand the mapping between input data and visual outputs, as well as the role of each code block in generating plots, you can adapt this workflow to broader data types.\n环境设置\nEnvironment Configuration\nsource(\"install_dependencies.R\") # 确保依赖包已安装 # Ensure dependencies are installed\nlibrary(dplyr)         # 用于数据操作和处理 # For data manipulation and processing\nlibrary(scatterpie)    # 用于绘制散点饼图 # For drawing scatter pie charts\nlibrary(ggplot2)       # 用于数据可视化 # For data visualization\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # error messages are displayed in English\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # It is forbidden to convert chr into factor\n输入文件\nInput files\neasy_input.txt\n第一列sample ID，每行一个sample，扇形大小对应每一类sample的数量；\n第二列Risk有两类：high和low，对应表格中的两行；\n第三列往后，对应表格中的各列。\neasy_input.txt\nFirst column (Sample ID): Each row represents one sample. The sector size in visualizations corresponds to the number of samples in each category.\nSecond column (Risk): Contains two classes: High and Low, mapped to the two rows in the table.\nThird column onward: Correspond to the columns in the original table.\ndat <- read.table(\"easy_input.txt\",row.names = 1,sep = \"\\t\",header = T,check.names = F,stringsAsFactors = F)\nhead(dat)\n# 按Risk分成High和Low，计算各列数值。\n# The value of each column is calculated according to the risk divided into high and low.\ngname <- \"Risk\"\nvname <- setdiff(colnames(dat), gname)\npie.high <- pie.low <- list()\nfisher.p <- c()\nfor (i in vname) {\n  tmp <- table(dat[,gname], dat[,i])\n  p <- format(fisher.test(tmp)$p.value,digits = 2)\n  names(p) <- i\n  fisher.p <- c(fisher.p, p)\n  \n  pie.dat <- \n    tmp %>% as.data.frame() %>% group_by(Var1) %>% mutate(Pct = Freq/sum(Freq)) %>% as.data.frame()\n  \n  # 表格内的两行对应Risk的两类：Risk high和Risk low\n  # The two rows in the table correspond to the two types of Risk: Risk high and Risk low\n  pie.high[[i]] <- pie.dat[which(pie.dat$Var1 == \"High\"),]\n  pie.low[[i]] <- pie.dat[which(pie.dat$Var1 == \"Low\"),]\n}\n开始画图\nStart plotting\n# 设置颜色 / Set colors\nstatus.col <- c(\"grey80\", \"#1E1E1B\")\nM.col <- c(\"#E4DB36\", \"#E19143\")\nstage.col <- c(\"#EFF3FF\", \"#BDD7E7\", \"#6BAED6\", \"#2171B5\")\nN.col <- c(\"#E5F5E0\", \"#A1D99B\", \"#31A354\") \nT.col <- c(\"#F2F0F7\", \"#CBC9E2\", \"#9E9AC8\", \"#6A51A3\")  \n\nprepare_pie_data <- function(pie.list, group) {\n  # 获取所有可能的类别水平\n  # Get all possible category levels\n  all_levels <- unique(unlist(lapply(pie.list, function(x) as.character(x$Var2))))\n  \n  # 创建基础数据框\n  # Create base data frame\n  pie_data <- data.frame(\n    category = names(pie.list),\n    x = 1:length(pie.list),\n    y = ifelse(group == \"High\", 2, 1),\n    radius = 0.4,\n    stringsAsFactors = FALSE\n  )\n  \n  # 为所有可能的水平添加列，初始化为0\n  # Add columns for all possible levels, initialized to 0\n  for (level in all_levels) {\n    pie_data[[level]] <- 0\n  }\n  \n  # 填充饼图数据\n  # Fill pie chart data\n  for (i in 1:length(pie.list)) {\n    category <- names(pie.list)[i]\n    pie_df <- pie.list[[i]]\n    \n    for (j in 1:nrow(pie_df)) {\n      level <- as.character(pie_df$Var2[j])  # 确保转换为字符 # Ensure conversion to character\n      pct <- pie_df$Pct[j]\n      pie_data[i, level] <- pct\n    }\n  }\n  \n  return(pie_data)\n}\n\n# 调整饼图的 x 和 y 坐标\n# Adjust x and y coordinates for pie charts\npie_data_high <- prepare_pie_data(pie.high, \"High\")\npie_data_low <- prepare_pie_data(pie.low, \"Low\")\n\n# 设置 High 组饼图的坐标\n# Set coordinates for High group pie charts\npie_data_high$x <- 1:5  # x 坐标从 1 到 5\npie_data_high$y <- 2    # y 坐标固定为 2\n\n# 设置 Low 组饼图的坐标\n# Set coordinates for Low group pie charts\npie_data_low$x <- 1:5   # x 坐标从 1 到 5\npie_data_low$y <- 1     # y 坐标固定为 1\n\n# 合并数据\n# Combine data\npie_data <- rbind(pie_data_high, pie_data_low)\n\n# 创建颜色映射\n# Create color mapping\ncolor_mapping <- c(\n  \"Alive\" = status.col[1], \"Dead\" = status.col[2],\n  \"I\" = stage.col[1], \"II\" = stage.col[2], \"III\" = stage.col[3], \"IV\" = stage.col[4],\n  \"M0\" = M.col[1], \"M1\" = M.col[2],\n  \"N0\" = N.col[1], \"N1\" = N.col[2], \"N2\" = N.col[3],\n  \"T1\" = T.col[1], \"T2\" = T.col[2], \"T3\" = T.col[3], \"T4\" = T.col[4]\n)\n\n# 获取饼图数据中实际存在的列\n# Get columns that actually exist in pie chart data\navailable_cols <- intersect(names(color_mapping), colnames(pie_data))\n\n# 修正p值标签 - 确保长度匹配\n# Correct p-value labels - Ensure length matches\np_value_labels <- c(\n  paste0(\"p = \", fisher.p[\"Status\"]),\n  paste0(\"p = \", fisher.p[\"Stage\"]),\n  paste0(\"p = \", fisher.p[\"M\"]),\n  paste0(\"p = \", fisher.p[\"N\"]),\n  paste0(\"p = \", fisher.p[\"T\"])\n)\n\nprint(pie_data)\n# 创建主图 # Create main plot\np <- ggplot() +\n  # 绘制High组饼图 # Draw High group pie charts\n  geom_scatterpie(\n    aes(x = x, y = y, r = radius),\n    data = pie_data_high,\n    cols = available_cols,\n    color = \"white\",\n    alpha = 0.8\n  ) +\n  # 绘制Low组饼图 # Draw Low group pie charts\n  geom_scatterpie(\n    aes(x = x, y = y, r = radius),\n    data = pie_data_low,\n    cols = available_cols,\n    color = \"white\",\n    alpha = 0.8\n  ) +\n  # 设置颜色 # Set colors\n  scale_fill_manual(\n    name = \"Categories\",\n    values = color_mapping,\n    breaks = names(color_mapping)\n  ) +\n  # 坐标轴和主题设置 # Coordinate axis and theme settings\n  coord_equal() +\n  theme_void() +\n  theme(\n    plot.margin = margin(1, 1, 1, 1, \"cm\"),\n    #legend.position = \"bottom\",\n    #legend.box = \"horizontal\",\n    legend.text = element_text(size = 10)\n  ) +\n  # 添加标题标签 # Add title labels\n  annotate(\"text\", x = 0:5, y = 2.7, label = c(\"CRC\", \"Status\", \"Stage\", \"M\", \"N\", \"T\"), \n          size = 6, fontface = \"bold\") +\n  # 添加组标签  # Add group labels\n  annotate(\"text\", x = 0, y = 2, label = \"High\\n(n = 100)\", size = 5, hjust = 0.5, vjust = 0.5) +\n  annotate(\"text\", x = 0, y = 1, label = \"Low\\n(n = 200)\", size = 5, hjust = 0.5, vjust = 0.5) +\n  # 添加 p 值标签 # Add p-value labels\n  annotate(\"text\", x = 1:5, y = 0.3, label = p_value_labels, size = 5)+  # 设置坐标轴范围\n  # Set coordinate axis range\n  xlim(0, 6) +\n  ylim(0, 3.5)\n\n# 保存图形 # Save plot\nggsave(\"pieTable_scatterpie.pdf\", p, width = 12, height = 8)\nprint(p)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa196Plus_PanPie_FigureYa196Plus_PanPie",
      "title": "FigureYa196Plus_PanPie/FigureYa196Plus_PanPie.html",
      "html": "FigureYa196Plus_PanPie/FigureYa196Plus_PanPie.html",
      "text": "texts/main_FigureYa196Plus_PanPie_FigureYa196Plus_PanPie.txt",
      "folder": "FigureYa196Plus_PanPie",
      "thumb": "gallery_compress/FigureYa196Plus_PanPie.webp"
    },
    "word_count": 982,
    "lines_count": 204,
    "title": "FigureYa196Plus_PanPie",
    "description": "Requirement Description 用scatterpie包画图，展示不同临床预后分期的分布差异。 Use the scatterpie package to visualize the distribution differences across different clinical prognostic stages.",
    "input_data_types": [
      "临床数据"
    ],
    "output_types": [
      "散点图",
      "统计表格"
    ],
    "technical_methods": [],
    "biology_areas": [
      "癌症研究",
      "代谢疾病"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "radius",
      "values",
      "header",
      "width",
      "n",
      "vjust",
      "name",
      "Pct"
    ]
  },
  {
    "id": "main_FigureYa80GOclustering_FigureYa80GOclustering",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa80GOclustering_FigureYa80GOclustering.txt",
    "content": "FigureYa80GOclustering\nFigureYa80GOclustering\nYing Ge, Taojun Ye\n2025-5-20\n需求描述\n富集分析得到太多GO\nterm，其中好多还是相似的，怎样合理的合并？clusterProfiler有一个simplify函数，能给富集分析结果瘦身by\nremoving redundancy of enriched GO\nterms，但有时瘦的不够多。小丫找到这样一篇例文，它列出了富集的\nterm，同时在旁边给出一个短语来概括性的描述这几个相似的term：\n##Requirement description\nEnrichment analysis yields too many GO terms, many of which are still\nsimilar. How to merge them reasonably? ClusterProfiler has a simplify\nfunction that can thin down enriched GO terms by removing redundancy of\nenriched GO terms, but sometimes not enough weight is lost. Xiaoya found\nan example article that lists enriched terms and provides a phrase next\nto them to summarize these similar terms:\n出自\nhttps://www.nature.com/articles/nature22973\nfrom\nhttps://www.nature.com/articles/nature22973\n方法探讨：\nMethod exploration:\nExtended Data Figure 5 | Candidate driver genes and pathways in MB\nsubgroups. c, GO and pathway summary of recurrently mutated genes in MB.\nGO and pathway categories are\ngrouped according to functional\ntheme\nand the proportion of cases affected by individual\npathway alterations are plotted per subgroup and across the series.\n例文中关于这些相似term如何合并的描述只说grouped according to\nfunctional theme。因此，我用Y叔的GOSemSim计算GO\nterm之间的相似性，然后借助ggtree实现例文中相似GO\ngerm的标注效果。关于ggtree和GOSemSim的问题，请前往Y叔知识星球biobabble讨论。\nThe description in the example text about how these similar terms are\nmerged only states that they are grouped according to the functional\ntheme. Therefore, I used Y’s GOSemSim to calculate the similarity\nbetween GO terms, and then used ggtree to achieve the annotation effect\nof similar GO terms in the example text. Regarding the issues of ggtree\nand GOSemSim, please go to Y Uncle’s knowledge planet biobabble for\ndiscussion.\n应用场景\n多组GO富集分析结果放在一起对比；\n富集分析得到太多相似的GO\nterm，需要合并相似的，再结合背景知识概括出合适的pathway。\n##Application scenarios\nCompare multiple sets of GO enrichment analysis results together;\nEnrichment analysis yields too many similar GO terms, which need to\nbe merged and combined with background knowledge to summarize\nappropriate pathways.\n环境设置\n使用国内镜像安装包\n##Environment settings\nUse domestic image installation package\noptions(\"repos\"= c(CRAN=\"https://mirrors.tuna.tsinghua.edu.cn/CRAN/\"))\noptions(BioC_mirror=\"http://mirrors.ustc.edu.cn/bioc/\")\n\nif (!requireNamespace(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\")\nBiocManager::install(\"GOSemSim\", version = \"3.8\")\nBiocManager::install(\"ggtree\", version = \"3.8\")\n加载包\nlibrary packages\n# 中文注释：加载plyr包，用于数据处理和操作\n# English Comment: Load the plyr package for data manipulation and processing\nlibrary(plyr)\n\n# 中文注释：加载stringr包，用于字符串处理和操作\n# English Comment: Load the stringr package for string manipulation and processing\nlibrary(stringr)\n\n# 中文注释：加载ape包，用于系统发生学和进化分析\n# English Comment: Load the ape package for phylogenetic and evolutionary analysis\nlibrary(ape)\n\n# 中文注释：加载GOSemSim包，用于基因本体语义相似性分析\n# English Comment: Load the GOSemSim package for Gene Ontology semantic similarity analysis\nlibrary(GOSemSim)\n# 中文注释：加载ggplot2包，用于创建精美的统计图形\n# English Comment: Load the ggplot2 package for creating elegant statistical graphics\nlibrary(ggplot2)\n\n# 中文注释：加载ggtree包，用于可视化系统发生树\n# English Comment: Load the ggtree package for phylogenetic tree visualization\nlibrary(ggtree)\n# 中文注释：加载scales包，用于图形的坐标轴和图例缩放\n# English Comment: Load the scales package for axis and legend scaling in graphics\nlibrary(scales)\n\n# 中文注释：加载cowplot包，用于组合和排列多个ggplot图形\n# English Comment: Load the cowplot package for combining and arranging multiple ggplot figures\nlibrary(cowplot)\n\n# 中文注释：设置环境变量使R显示英文报错信息\n# English Comment: Set environment variable to display error messages in English\nSys.setenv(LANGUAGE = \"en\") \n\n# 中文注释：设置选项禁止将字符串自动转换为因子类型\n# English Comment: Set option to prevent automatic conversion of strings to factors\noptions(stringsAsFactors = FALSE)\n输入文件\n富集分析结果至少包含GO term\nID（格式为GO:0046777）和一列统计量（例如pvalue、p.ajdust、FDR等等）。\n此处用clusterProfier的enrichGO函数做的富集分析结果为例(FigureYa52GOplot的输出文件enrichGO_output.csv)，其中有一列BgRatio，斜线左侧是全基因组范围内该term里基因的数量。例文以300为阈值，去掉了基因数量超过300的term。如果你的数据没有这一列，也可以不做这一步筛选。\n##Input file\nThe enrichment analysis results should include at least GO term ID\n(in the format GO: 0046777) and a list of statistical measures (such as\np-value, p-ajdust, FDR, etc.).\nTaking the enrichGO function of clusterProfier as an example (the\noutput file enrichGO_output. csv of FigureYa52GOplot), there is a column\ncalled BgRatio, and the left side of the diagonal line represents the\nnumber of genes in this term across the entire genome. The example uses\n300 as the threshold and removes terms with a gene count exceeding 300.\nIf your data does not have this column, you can also skip this filtering\nstep.\n# 中文注释：获取当前目录下所有以\"enrichGO\"开头、\".csv\"结尾的文件名，用于批量处理多组富集分析结果\n# English Comment: Retrieve filenames of all CSV files starting with \"enrichGO\" in the current directory for batch processing of multiple enrichment analysis results\nfnames <- Sys.glob(\"enrichGO*.csv\")\n\n# 中文注释：显示获取到的文件名列表，便于确认文件匹配情况\n# English Comment: Display the list of retrieved filenames for verification\nfnames\n# 中文注释：循环读取所有文件，仅保留ID、Description、BgRatio、p.adjust四列数据\n#           ID: 功能类别标识符，Description: 功能描述，BgRatio: 背景比例，p.adjust: 校正p值\n# English Comment: Read all files in a loop, retaining only columns ID, Description, BgRatio, and p.adjust\n#                  ID: Functional category identifier, Description: Functional description, BgRatio: Background ratio, p.adjust: Adjusted p-value\nfdataset <- lapply(fnames, function(x){read.csv(x)[,c(2,3,5,7)]})\n\n# 中文注释：为数据列表添加文件名作为标识，便于后续区分不同富集分析结果\n# English Comment: Assign filenames as names for the data list to distinguish different enrichment analysis results\nnames(fdataset) <- fnames\n纵向合并多组富集结果，用于给GO term分类\n##Vertically merge multiple sets of enrichment results for GO term\nclassification\n# 中文注释：将多个富集分析结果合并为一个数据框，保留来源文件名信息\n# English Comment: Combine multiple enrichment analysis results into a single data frame while retaining source filename information\nego.all <- ldply(fdataset, data.frame)\n\n# 中文注释：从文件名中提取分组信息（去除.csv后缀），添加为新的分组变量\n# English Comment: Extract group information from filenames (remove .csv suffix) and add as a new grouping variable\nego.all$group <- unlist(strsplit(ego.all$.id, split = \".csv\"))\n\n# 中文注释：查看数据前几行和维度，确认数据结构\n# English Comment: View the first few rows and dimensions of the data to confirm structure\nhead(ego.all)\ndim(ego.all)\n# 中文注释：筛选校正p值小于0.001的显著富集结果，提高分析可靠性\n# English Comment: Filter significantly enriched results with adjusted p-value < 0.001 to improve analysis reliability\nego.all <- ego.all[ego.all$p.adjust < 0.001,] \ndim(ego.all)\n# 中文注释：提取唯一的GO term集合（保留ID、Description、BgRatio三列）\n# English Comment: Extract unique GO terms (retain ID, Description, BgRatio columns)\nego.ID <- unique(ego.all[,c(2:4)])\nhead(ego.ID)\ndim(ego.ID)\n# 中文注释：删除包含基因数少于100的GO term（去除过小的功能类别）\n# English Comment: Remove GO terms with fewer than 100 genes (filter out overly specific functional categories)\nego.ID <- ego.ID[ego.ID$Bg > 100,] \ndim(ego.ID)\n# 中文注释：查看筛选后的GO term集合\n# English Comment: View the filtered GO term collection\nhead(ego.ID)\n横向合并多组富集结果，用于画热图\nMyMerge函数出自：\nhttps://stackoverflow.com/questions/16666643/merging-more-than-2-dataframes-in-r-by-rownames\n##Horizontally merge multiple sets of enrichment results for drawing\nheat maps\nThe MyMerge function comes from:<\nhttps://stackoverflow.com/questions/16666643/merging-more-than-2-dataframes-in-r-by-rownames\n>\n# 中文注释：自定义函数用于合并多个富集分析结果，按GO term ID进行外连接\n# English Comment: Custom function to merge multiple enrichment analysis results by GO term ID using outer join\nMyMerge <- function(x, y){\n  df <- merge(x, y, by= \"ID\", all.x= TRUE, all.y= TRUE)\n  return(df)\n}\n\n# 中文注释：递归合并所有富集结果数据框，生成包含所有GO term和各组信息的完整表格\n# English Comment: Recursively merge all enrichment result data frames to create a comprehensive table with all GO terms and group information\nego.m <- Reduce(MyMerge, fdataset)\nhead(ego.m)\n# 中文注释：仅保留GO term ID和各组的p.adjust列（此处假设为三组，需根据实际组数调整）\n# English Comment: Retain only GO term ID and p.adjust columns for each group (adjust based on actual number of groups)\nego.m <- ego.m[,c(1,4,7,10)] # Modify this line if there are more than three groups\n\n# 中文注释：筛选出之前过滤得到的高质量GO term集合\n# English Comment: Filter the merged results to include only high-quality GO terms from previous filtering\nego.m <- merge(ego.ID[,1:2], ego.m, by= \"ID\", all.x= TRUE)\n\n# 中文注释：设置行名为GO term描述信息，便于后续可视化\n# English Comment: Set row names to GO term descriptions for easier visualization\nrownames(ego.m) <- ego.m$Description\nego.m$ID <- NULL\nego.m$Description <- NULL\n\n# 中文注释：将列名重命名为简洁的组标识（G1, G2, G3...）\n# English Comment: Rename column names to concise group identifiers (G1, G2, G3...)\ncolnames(ego.m) <- paste0(\"G\", seq(1:length(fnames)))\n\n# 中文注释：提示多组合并后可能存在缺失值的处理建议\n#           不推荐直接填充为1，建议采用自定义富集分析方法\n# English Comment: Note on handling missing values after merging multiple groups\n#                  Directly filling with 1 is not recommended; consider custom enrichment analysis instead\n# ego.m[is.na(ego.m)] <- 1 \nhead(ego.m)\n按GO term的相似性聚类\n##Cluster based on GO term similarity\n# 人\n# 中文注释：加载人类基因本体数据库（生物学过程），仅作示例注释（已被注释掉）\n# English Comment: Load human Gene Ontology database (Biological Process), for demonstration only (commented out)\n#hgGO <- godata('org.Hs.eg.db', ont=\"BP\")\n#save(hgGO, file=\"hgGO.rdata\")\n#(load(\"hgGO.rdata\"))\n\n# 小鼠\n# 中文注释：加载小鼠基因本体数据库（生物学过程），需运行约1分钟\n#           建议保存结果到文件以便重复使用（已保存为mmGO.rdata）\n# English Comment: Load mouse Gene Ontology database (Biological Process), takes ~1 minute to run\n#                  Recommended to save results to file for reuse (already saved as mmGO.rdata)\n#mmGO <- godata('org.Mm.eg.db', ont=\"BP\") ## or MF or CC, must match enrichment analysis parameters\n#save(mmGO, file=\"mmGO.rdata\")\n(load(\"mmGO.rdata\")) # Import previously saved file\n# 中文注释：计算GO term之间的语义相似性（使用Wang方法）\n#           该方法基于GO图结构计算相似性，结果为对称矩阵\n# English Comment: Calculate semantic similarity between GO terms using Wang method\n#                  This method computes similarity based on GO graph structure, resulting in a symmetric matrix\nego.sim <- mgoSim(ego.ID$ID, ego.ID$ID, semData=mmGO, measure=\"Wang\", combine=NULL)\nego.sim[1:3, 1:3]\n# 中文注释：设置行名和列名为GO term描述，便于结果查看和可视化\n# English Comment: Set row and column names to GO term descriptions for easier result interpretation and visualization\nrownames(ego.sim) <- ego.ID$Description\ncolnames(ego.sim) <- ego.ID$Description\nego.sim[1:3, 1:3]\n# 中文注释：基于GO相似性矩阵构建系统发生树（使用邻接法）\n#           1-ego.sim将相似性转换为距离（相似性越高，距离越近）\n# English Comment: Construct phylogenetic tree using neighbor-joining method based on GO similarity matrix\n#                  1-ego.sim converts similarity to distance (higher similarity = shorter distance)\ntree <- nj(as.dist(1-ego.sim))\n\n# 中文注释：使用ggtree包可视化GO term分类树\n#           添加叶节点标签（GO描述）、内部节点编号和适当的坐标范围\n# English Comment: Visualize GO term classification tree using ggtree package\n#                  Add tip labels (GO descriptions), internal node numbers, and appropriate coordinate limits\np <- ggtree(tree) + geom_tiplab() + # Add GO term labels\n  geom_text2(aes(subset=!isTip, label=node), hjust=-.3) + # Add node numbers\n  coord_cartesian(xlim=c(-.1,1.3)) # Adjust horizontal spacing\np\n开始画图\n注：\n根据实际情况，调整offset的值\n##Start drawing\n**Note: * * Adjust the offset value according to the actual\nsituation\n# 中文注释：根据系统发生树结构和生物学知识，手动定义4个主要分类节点\n#           这些节点编号对应之前树形图中的内部节点\n# English Comment: Define 4 major classification nodes manually based on phylogenetic tree structure and biological knowledge\n#                  These node numbers correspond to internal nodes in the previous tree visualization\nnode <- c(22,21,27,25)\n\n# 中文注释：基于指定节点将GO term划分为不同的进化分支组\n# English Comment: Group GO terms into different evolutionary clades based on specified nodes\ngtree <- groupClade(tree, .node=node)\n\n# 中文注释：使用ggtree绘制分组后的树形图，不同分支组用不同颜色区分\n# English Comment: Plot the grouped tree using ggtree, coloring different clades with distinct colors\npbase <- ggtree(gtree, \n                aes(color=group)) # Color branches by group\n\n# 中文注释：设置注释文本大小和位置参数\n# English Comment: Set parameters for annotation text size and position\nfontsize <- 4 # Font size for clade labels\noffset <- .9 # Horizontal offset for clade labels (adjust to position labels relative to heatmap)\n\n# 中文注释：构建完整的树形图，添加分类标签和GO term名称\n# English Comment: Construct the complete tree visualization with clade labels and GO term names\npnode <- pbase + \n  # 如果不想显示每个GO term名称，注释掉此行并将offset设小（如0.3）\n  # If you want to hide individual GO term names, comment this line and reduce offset (e.g., 0.3)\n  geom_tiplab(size=4, align=TRUE) + # Align and display GO term names\n  \n  # 为每个分类组添加描述性标签，颜色与对应分支匹配\n  # Add descriptive labels for each clade, colored to match corresponding branches\n  geom_cladelabel(node=node[1], align=TRUE, \n                  color = hue_pal()(length(node)+1)[2], \n                  fontsize = fontsize, offset=offset, label=\"pathway1\") +\n  geom_cladelabel(node=node[2], align=TRUE, color = hue_pal()(length(node)+1)[3], fontsize = fontsize, offset=offset, label=\"pathway2\") +\n  geom_cladelabel(node=node[3], align=TRUE, color = hue_pal()(length(node)+1)[4], fontsize = fontsize, offset=offset, label=\"pathway3\") +\n  geom_cladelabel(node=node[4], align=TRUE, color = hue_pal()(length(node)+1)[5], fontsize = fontsize, offset=offset, label=\"pathway4\") +\n  # 如果有更多分类组，继续添加类似的geom_cladelabel语句\n  # Add more geom_cladelabel statements for additional clades if needed\n  \n  coord_cartesian(xlim=c(-.1,1.5)) # Adjust x-axis limits for better visualization\n\n# 中文注释：在树形图右侧添加热图，展示各组的p.adjust值\n#           热图颜色从红色（高值）到白色（低值），表示富集显著性\n# English Comment: Add a heatmap to the right of the tree to show p.adjust values for each group\n#                  Heatmap colors range from red (high values) to white (low values), indicating enrichment significance\ngheatmap(pnode, ego.m, \n         offset=.7, # Horizontal offset of the heatmap\n         width=0.3, # Width of the heatmap\n         colnames_angle=90, hjust=0, # Rotate column names vertically\n         low = \"red\", high = \"white\") # Color gradient for the heatmap\n# 中文注释：将最终可视化结果保存为PDF文件\n# English Comment: Save the final visualization as a PDF file\nggsave(\"GOclustering.pdf\", width = 12, height = 8)\n最后生成的pdf文件是矢量图，可以在Illustrator或Inkscape中打开、编辑。\n可以参考例文的布局，手动删掉树形结构或调整各部分的位置。\nThe final generated PDF file is a vector image that can be opened and\nedited in Illustrator or Inkscape.\nYou can refer to the layout of the example text and manually delete\nthe tree structure or adjust the position of each part.\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa80GOclustering_FigureYa80GOclustering",
      "title": "FigureYa80GOclustering/FigureYa80GOclustering.html",
      "html": "FigureYa80GOclustering/FigureYa80GOclustering.html",
      "text": "texts/main_FigureYa80GOclustering_FigureYa80GOclustering.txt",
      "folder": "FigureYa80GOclustering",
      "thumb": "gallery_compress/FigureYa80GOclustering.webp"
    },
    "word_count": 1715,
    "lines_count": 312,
    "title": "FigureYa80GOclustering",
    "description": "富集分析得到太多GO term，其中好多还是相似的，怎样合理的合并？clusterProfiler有一个simplify函数，能给富集分析结果瘦身by removing redundancy of enriched GO",
    "input_data_types": [
      "DNA-seq"
    ],
    "output_types": [
      "热图",
      "统计表格"
    ],
    "technical_methods": [
      "聚类分析",
      "通路分析",
      "质量控制"
    ],
    "biology_areas": [],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "measure",
      "label",
      "ont",
      "width",
      "xlim",
      "pvalue",
      "BioC_mirror",
      "high",
      "node"
    ]
  },
  {
    "id": "main_FigureYa145target_FigureYa145target",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa145target_FigureYa145target.txt",
    "content": "FigureYa145target\nFigureYa145target\nAuthor(s)\n: Long Zhao\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-10-17\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n从形式上复现原图。 Reproduce the original image in form.\n有时没有现成的包能画出一模一样的图，我们可以通过计算图中每个元素的位置，然后画出想要的效果。\nSometimes there is no ready-made package that can draw the same image.\nWe can calculate the position of each element in the image and then draw\nthe desired effect.\n出自\nhttps://www.nature.com/articles/s41467-019-09222-w\nFrom\nhttps://www.nature.com/articles/s41467-019-09222-w\nFig. 2 Characteristics of glycosites identified with AI-ETD. f A\nglycoprotein-glycan network maps\nwhich glycans (outer circle,\n117 total) modify which proteins (inner bar, 771 total)\n.\nGlycoproteins are\nsorted by number of glycosites (scale to the\nright)\n. Glycans are organized by classification, and\nedges are colored by the glycan node from which they\noriginate\n, except for mannose-6-phosphate which has yellow\nedges. See Supplementary Fig. 11 and Supplementary Table 1 for glycan\nidentifiers.\nA glycoprotein-glycan network diagram in Fig. 2f maps which glycans\n(outer nodes) were observed on identified glycoproteins (inner column,\norganized by number of glycosites). Several discernable patterns appear,\nperhaps most notably the prevalence of high mannose glycosylation. The\nnetwork diagram also indicates that the majority of\nfucosylated,\npaucimannose, and sialylated glycans occur on proteins with multiple\nglycosylation sites\n, and it indicates which glycans contribute\nmore to heterogeneity. Supplementary Figure 11 provides a larger version\nof this network diagram with glycan identities in Supplementary Table\n1.\n图的解析\nAnalysis of the graph\n这个图展示两层信息：糖蛋白上glycan的种类，糖蛋白上glycosites的数量（数量可替换成其他分类信息，例如上调/下调，或所在的通路等等）。\nThis graph shows two layers of information: the types of glycans on\nglycoproteins and the number of glycosites on glycoproteins (the number\ncan be replaced by other classification information, such as\nup-regulation/down-regulation, or the pathway in which it is located,\netc.).\n外围弧线：classification，把glycans分为6种\n点：117个glycans，按照classification定义颜色和位置，并与外围6个classification的弧线对应\n中央矩形：看起来是矩形，其实每个矩形的纵坐标都是有意义的，其本质是771个糖蛋白，按照glycosites的数量排序，数量与右侧图例对应。\n连线：连接外围点跟中央矩形。线的两端分别对应糖蛋白的glycan和glycosites数量。颜色跟classification一致，其中一个glycan：mannose-6-phosphate的连线用黄色突出显示。\nOuter arcs: classification, which divides glycans into 6 types\nPoints: 117 glycans, with colors and positions defined by\nclassification, and corresponding to the arcs of the 6 outer\nclassifications\nCentral rectangle: It looks like a rectangle, but in fact the\nvertical coordinates of each rectangle are meaningful. In essence, it is\n771 glycoproteins, sorted by the number of glycosites, and the number\ncorresponds to the legend on the right.\nLines: Connect the outer points with the central rectangle. The two\nends of the line correspond to the number of glycans and glycosites of\nthe glycoprotein, respectively. The color is consistent with the\nclassification, and the line connecting one of the glycans:\nmannose-6-phosphate is highlighted in yellow.\n原文方法描述是用igraph画的：The\nprotein-glycan\nnetwork\n, glycan co-occurrence networks, and glycosylation\nprofiles for subcellular groups were created in R 3.2.2 using the\nigraph\nlibrary70, and the arcplot were created with\narcdiagram library。 The original method description is drawn with\nigraph: The\nprotein-glycan network\n, glycan\nco-occurrence networks, and glycosylation profiles for subcellular\ngroups were created in R 3.2.2 using the\nigraph\nlibrary70, and the arcplot were created with arcdiagram library.\n这里用ggplot2画图，先计算位置再画图。 Here we use ggplot2 to draw the\ngraph, first calculate the position and then draw the graph.\n应用场景\nApplication scenario\n展示分类、分组跟元素之间的关系。例如：glycan-数量-glycoprotein，GO-TF-targe\ngene、表观修饰-上下调-gene、enhancer-motif-promoter等。 Show the\nrelationship between classification, grouping and elements. For example:\nglycan-quantity-glycoprotein, GO-TF-target gene, epigenetic\nmodification-up and down regulation-gene, enhancer-motif-promoter,\netc.\n以TF-GO-target gene互作为例，转录组找出几个GO\n途径的基因可以放在外围的点，颜色代表不同GO\nterm，点的大小代表基因表达水平或fold\nchange。里面的矩形是我们共公共数据库找到的能够结合这些外围基因的转录因子。结果哪些转录因子激活基因，哪些抑制，就一目了然了。如果有HiC或ChIA-pet数据，hub\n位点和靶基因的互作也是同理。 Taking the TF-GO-target gene interaction as\nan example, the transcriptome finds several genes in the GO pathway and\ncan be placed on the outer points. The color represents different GO\nterms, and the size of the point represents the gene expression level or\nfold change. The rectangle inside is the transcription factor that can\nbind to these peripheral genes found in our public database. As a\nresult, it is clear at a glance which transcription factors activate\ngenes and which inhibit them. If there is HiC or ChIA-pet data, the\ninteraction between hub sites and target genes is the same.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nlibrary(ggplot2) #用于画图 #For drawing\nlibrary(dplyr) #用于数据处理 #For data processing\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 #Display English error message\noptions(stringsAsFactors = FALSE) #禁止chr转成factor #Prohibit chr from being converted to factor\n输入文件\nInput file\neasy_input_node.txt和easy_input_group.txt。从例文41467_2019_9222_MOESM5_ESM.xlsx文件整理而来。\neasy_input_node.txt，glycan及其分类，用来画外围的点和弧线；\neasy_input_group.txt，protein-glycan-数量的对应关系，用来画中央矩形和连线。每行一个protein，用\n;\n分隔多个glycon。\nOrganized from the example file 41467_2019_9222_MOESM5_ESM.xlsx.\neasy_input_node.txt, glycan and its classification, used to draw the\nouter points and arcs;\neasy_input_group.txt, the correspondence between\nprotein-glycan-quantity, used to draw the central rectangle and\nconnecting lines. One protein per line, separate multiple glycans with\n;\n.\nGlycan <- read.table(\"easy_input_node.txt\", sep = \"\\t\", head=T)\nhead(Glycan)\ndim(Glycan)\nprotein <- read.table(\"easy_input_group.txt\",head=T)\nhead(protein)\ndim(protein)\n计算图中各元素位置\nCalculate the position of each element in the graph\n计算点（Glycan）的坐标\nCalculate the coordinates of the point (Glycan)\n一共有117个点，右侧（第一、四象限）59个，左侧（二、三象限）58个。\nThere are 117 points in total, 59 on the right (first and fourth\nquadrants) and 58 on the left (second and third quadrants).\n先计算每个点与x轴的角度，再通过与x轴的角度和三角函数计算出每个点的横纵坐标。\nFirst calculate the angle between each point and the x-axis, and then\ncalculate the horizontal and vertical coordinates of each point through\nthe angle with the x-axis and trigonometric functions.\n计算角度时，因为不是整个圆，上下各缺了一块，缺的角度为30度。所以第一个蛋白角度是75度，第59个蛋白是-75度，第60个蛋白是-107度，最后一个是-255度。\nWhen calculating the angle, because it is not a complete circle, there\nis a missing piece on the top and bottom, and the missing angle is 30\ndegrees. So the angle of the first protein is 75 degrees, the 59th\nprotein is -75 degrees, the 60th protein is -107 degrees, and the last\none is -255 degrees.\n计算坐标时，考虑到后面还要画中央矩形，因此以蛋白数量/2作为半径。 When\ncalculating the coordinates, we took into account that we would need to\ndraw a central rectangle later, so we used the number of proteins/2 as\nthe radius.\nGlycan$angle <- ifelse(Glycan$Node < 60,\n                       75-(150/58*(Glycan$Node-1)),\n                       75-(150/58*(Glycan$Node-1))-30)\n\nGlycan$G.x <- cos(Glycan$angle*pi/180.0)*(nrow(protein)/2)\nGlycan$G.y <- sin(Glycan$angle*pi/180.0)*(nrow(protein)/2)\nhead(Glycan)\n计算最外围的弧线\nCalculate the outermost arc\n外围的弧线内侧是圆半径的1.1倍，外侧是1.15倍 The inner side of the\nouter arc is 1.1 times the radius of the circle, and the outer side is\n1.15 times\n# 取Gly.clu列\n# Get the Gly.clu column\ncurve <- Glycan[,3, drop=F]\n\ncurve$x.start <- Glycan$G.x*1.1\ncurve$x.end <- Glycan$G.x*1.15\ncurve$y.start <- Glycan$G.y*1.1\ncurve$y.end <- Glycan$G.y*1.15\n\n# 给弧线之间留个空隙，根据自己的数据调整数量吧\n# Leave a gap between the arcs and adjust the number according to your own data\ncurve <- curve[-c(9:10, #9是第一类Paucimannose的数量，以此类推\n#9 is the number of first-class Paucimannose, and so on\n                  45:46,73:74,107:108),]\nhead(curve)\n中央矩形\nCentral rectangle\n根据glycosites数量分成5类，其中4和5一组，>5一组，与右侧图例对应。\nAccording to the number of glycosites, they are divided into 5\ncategories, with 4 and 5 in one group and >5 in another group,\ncorresponding to the legend on the right.\nprotein.pos <- protein[,1:2]\nprotein.pos <- arrange(protein.pos, Count)\n\nprotein.pos$P.x <- 0\nprotein.pos$P.y <- seq(floor(nrow(protein)/2),-floor(nrow(protein)/2))\n\nprotein.pos$cluster <- ifelse(protein.pos$Count < 4, protein.pos$Count, ifelse(protein.pos$Count < 6, \"4\", \"5\"))\n\nhead(protein.pos)\n连接线，即Glycan-protein\nConnecting line, Glycan-protein\nconnect <- protein[,c(1,3)]\nGly.name <- strsplit(as.character(connect[,2]),split=\";\")\nconnect.count <- sapply(Gly.name,length)\nconnection <- data.frame(Protein=rep(connect$Protein,connect.count),Glycan=unlist(Gly.name))\nMerge\nseg.clu主要是为了画最后一个Glycan那一点点黄色 seg.clu is mainly used\nto draw the last little bit of yellow of Glycan\nall <- merge(connection,Glycan,by=\"Glycan\")\nall1 <- merge(all,protein.pos,by=\"Protein\")\nall1$seg.clu <- ifelse(all1$Glycan==\"HexNAc(2)Hex(6)Phospho(1)\",\"zz\",all1$Gly.clu)\nhead(all1)\n开始画图\nStart drawing\n# 自定义颜色\n# Custom color\ncols <- c(\"royalblue4\",\"gray80\",\"seagreen3\",\"powderblue\",\"steelblue\",\"goldenrod1\")\nfills <- c(\"#FFFFD4\",\"#FEE391\",\"#FEC44F\",\"#FE9929\",\"#D95F0E\")\n# 查看颜色\n# View colors\nlibrary(scales)\nshow_col(cols)\nshow_col(fills)\n# 画点\n# Draw points\np <- ggplot(all1) +\n  geom_point(aes(G.x,G.y,color=Gly.clu))\np\n# 画连线\n# Draw lines\np1 <- p + \n  geom_segment(aes(x=G.x,y=G.y,xend=P.x,yend=P.y,color=seg.clu),alpha=0.1)\np1\n# 画矩形\n# Draw rectangles\np2 <- p1 + \n  geom_rect(aes(xmin=-15,xmax=15,ymin=P.y,ymax=P.y+1,fill=cluster)) +\n  geom_rect(aes(xmin=500,xmax=530,ymin=P.y,ymax=P.y+1,fill=cluster))\np2\n# 画弧线\n# Draw an arc\np3 <- p2 + \n  geom_segment(data=curve,aes(x=x.start,xend=x.end,y=y.start,yend=y.end,color=Gly.clu),size=5)\np3\n# 清空背景和坐标轴\n# Clear background and coordinate axes\np4 <- p3 +\n  theme_minimal() +\n  theme(\n    legend.position = \"none\",\n    axis.text = element_blank(),\n    axis.title = element_blank(),\n    panel.grid = element_blank()\n    )  \np4\n# 用自定义颜色填充和画线\n# Fill and draw lines with custom colors\np5 <- p4 +\n  scale_color_manual(values=cols) +\n  scale_fill_manual(values=fills)\np5\n# 输出到文件\n# Output to file\npdf(file=\"target.pdf\", height=5, width=5.5)\n p5\ndev.off()\n后期处理\nPost-processing\n输出的PDF文件是矢量图，可以用PS或AI等矢量图编辑器打开，编辑图形和文字。\nThe output PDF file is a vector image, which can be opened with vector\nimage editors such as PS or AI to edit graphics and text.\n其实本来文字和数字都是可以在R中加的，但是还需要计算位置，莫不如在PS里修改。这里有一个PS的中间文件可以参考\ntarget.psd\n和\ntarget.tif\n。\nActually, text and numbers can be added in R, but the position needs to\nbe calculated, so it is better to modify them in PS. Here is a PS\nintermediate file for reference\ntarget.psd\nand\ntarget.tif\n.\n在用到自己数据的时候，最好先把原数据跑一遍，理解每个数字的含义，和整体的思路，再去举一反三。这里涉及到一些数学的三角函数计算，和角度的计算，还是要理解每个数字的含义的。\nWhen using your own data, it is best to run the original data first,\nunderstand the meaning of each number, and the overall idea, and then\ndraw inferences from one example. This involves some mathematical\ntrigonometric function calculations and angle calculations, and you\nstill need to understand the meaning of each number.\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa145target_FigureYa145target",
      "title": "FigureYa145target/FigureYa145target.html",
      "html": "FigureYa145target/FigureYa145target.html",
      "text": "texts/main_FigureYa145target_FigureYa145target.txt",
      "folder": "FigureYa145target",
      "thumb": "gallery_compress/FigureYa145target.webp"
    },
    "word_count": 1356,
    "lines_count": 298,
    "title": "FigureYa145target",
    "description": "Requirement description 从形式上复现原图。 Reproduce the original image in form. 有时没有现成的包能画出一模一样的图，我们可以通过计算图中每个元素的位置，然后画出想要的效果。",
    "input_data_types": [
      "RNA-seq"
    ],
    "output_types": [
      "统计表格",
      "网络图"
    ],
    "technical_methods": [
      "网络分析",
      "通路分析",
      "motif分析"
    ],
    "biology_areas": [],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "values",
      "width",
      "xmin",
      "grid",
      "xend",
      "Protein",
      "Glycan",
      "ymin",
      "xmax"
    ]
  },
  {
    "id": "main_FigureYa294HCCdrug_FigureYa294HCCdrug",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa294HCCdrug_FigureYa294HCCdrug.txt",
    "content": "FigureYa294HCCdrug\nFigureYa294HCCdrug\nAuthor(s)\n: Xiaofan Lu; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-05-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nDemand description\n希望复现这篇文章的Figure 4DE。\nWe hope to reproduce Figure 4DE of this article.\n出自：\nhttps://academic.oup.com/bib/article-abstract/22/3/bbaa164/5891146?redirectedFrom=fulltext&login=false\n图4. PPS相关生物学过程及药物靶点的鉴定。 (D)\n火山图（左）和散点图（右）展示了PPS评分与药物靶点蛋白表达的Spearman相关性及显著性（另见在线表格S11，链接：\nhttps://academic.oup.com/bib\n）。红点表示显著正相关（P\n< 0.05且Spearman’s r > 0.3）。 (E)\n火山图（左）和散点图（右）展示了PPS评分与药物靶点CERES评分的Spearman相关性及显著性（另见在线表格S11，链接：\nhttps://academic.oup.com/bib\n）。蓝点表示显著负相关（P\n< 0.05且Spearman’s r <\n−0.5）。散点图中标注了TP53突变型肝癌细胞系。\n复现方法：Yang C, Huang X, Li Y, Chen J, Lv Y, Dai S. Prognosis and\npersonalized treatment prediction in TP53-mutant hepatocellular\ncarcinoma: an in silico strategy towards precision oncology. Brief\nBioinform. 2021 May 20;22(3):bbaa164. doi: 10.1093/bib/bbaa164.\n开源数据：Gao Q, Zhu H, Dong L, Shi W, Chen R, Song Z, Huang C, Li J,\nDong X, Zhou Y, Liu Q, Ma L, Wang X, Zhou J, Liu Y, Boja E, Robles AI,\nMa W, Wang P, Li Y, Ding L, Wen B, Zhang B, Rodriguez H, Gao D, Zhou H,\nFan J. Integrated Proteogenomic Characterization of HBV-Related\nHepatocellular Carcinoma. Cell. 2019 Nov 14;179(5):1240. doi:\n10.1016/j.cell.2019.10.038. Erratum for: Cell. 2019 Oct\n3;179(2):561-577.e22.\nSource:\nhttps://academic.oup.com/bib/article-abstract/22/3/bbaa164/5891146?redirectedFrom=fulltext&login=false\nFigure 4. Identification of PPS-related biological processes and drug\ntargets. (D) Volcano plot (left) and scatter plots (right) of Spearman’s\ncorrelations and significance between PPS scores and protein expression\nof drug targets (see also Table S11 available online at\nhttps://academic.oup.com/bib\n). Red dots indicate the\nsignificant positive correlations (P < 0.05, and Spearman’s r >\n0.3). (E) Volcano plot (left) and scatter plots (right) of Spearman’s\ncorrelations and significance between PPS score and CERES score of drug\ntargets (see also Table S11 available online at\nhttps://academic.oup.com/bib\n). Blue dots indicate the\nsignificant negative correlations (P < 0.05, and Spearman’s r <\n−0.5). TP53-mutant hepatoma cell lines are labeled on the scatter\nplots.\nReproduction method: Yang C, Huang X, Li Y, Chen J, Lv Y, Dai S.\nPrognosis and personalized treatment prediction in TP53-mutant\nhepatocellular carcinoma: an in silico strategy towards precision\noncology. Brief Bioinform. 2021 May 20;22(3):bbaa164. doi:\n10.1093/bib/bbaa164.\nOpen source data: Gao Q, Zhu H, Dong L, Shi W, Chen R, Song Z, Huang\nC, Li J, Dong X, Zhou Y, Liu Q, Ma L, Wang X, Zhou J, Liu Y, Boja E,\nRobles AI, Ma W, Wang P, Li Y, Ding L, Wen B, Zhang B, Rodriguez H, Gao\nD, Zhou H, Fan J. Integrated Proteogenomic Characterization of\nHBV-Related Hepatocellular Carcinoma. Cell. 2019 Nov 14;179(5):1240.\ndoi: 10.1016/j.cell.2019.10.038. Erratum for: Cell. 2019 Oct\n3;179(2):561-577.e22.\n应用场景\nApplication scenarios\nIdentification of potential drug targets for high PPS score HCCs\n例文前面筛选出PPS genes做分子分型，然后想找high PPS\nscore病人的潜在药物。 自己的数据，可以用感兴趣的基因集替换PPS\ngenes。\n例文几个Figure的画法可参考相应的FigureYa：\nFigure 2DE、Fig. S6和Fig. S8C，可参考FigureYa85timeROC\nFigure 3ABC，可参考FigureYa161stemness\nFigure 5BC，可参考FigureYa59volcano\nFig. S3，可参考FigureYa141risk\nFig.\nS4B，可参考FigureYa92immune_gene，C可参考FigureYa68friends，D可参考FigureYa165heatmapPvalue\nFig.\nS5，可参考FigureYa30nomogram，FigureYa138NiceCalibration\nFigureYa227boxdensity复现了Figure\n5D，展示两组之间对于索拉菲尼药物治疗敏感性的差异。\nFigureYa212drugTarget复现了Figure\n5FG，利用细胞系表达谱（CCLE）及药敏结果（PRISM和CTRP），预测癌症样本的药敏结果。\nFigureYa213customizeHeatmap复现了Figure 6，实现CMap\nanalysis及画图。\nIdentification of potential drug targets for high PPS score HCCs The\nprevious analysis screened PPS genes for molecular subtyping, and now\naims to identify potential drugs for patients with high PPS scores. For\nyour own data, you can replace PPS genes with gene sets of interest.\nThe following figures from the example paper can be reproduced using\nthe corresponding FigureYa tools:\nFigure 2DE, Fig. S6, and Fig. S8C: Refer to\nFigureYa85timeROC\nFigure 3ABC: Refer to FigureYa161stemness\nFigure 5BC: Refer to FigureYa59volcano\nFig. S3: Refer to FigureYa141risk\nFig. S4B: Refer to FigureYa92immune_gene ; C: Refer to\nFigureYa68friends ; D: Refer to FigureYa165heatmapPvalue\nFig. S5: Refer to FigureYa30nomogram and\nFigureYa138NiceCalibration\nFigureYa227boxdensity reproduces Figure 5D, showing differences\nin sensitivity to sorafenib treatment between two groups.\nFigureYa212drugTarget reproduces Figure 5FG, predicting drug\nsensitivity in cancer samples using cell line expression profiles (CCLE)\nand drug response data (PRISM and CTRP).\nFigureYa213customizeHeatmap reproduces Figure 6, performing CMap\nanalysis and visualization.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(readr)\nlibrary(ggplot2)\nlibrary(ggrepel)\nlibrary(cowplot)\n\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n输入文件\nInput Files\n例文补充材料中的特征已整理到txt文件中，便于套用。\nThe features from the supplementary materials of the example paper\nhave been compiled into a txt file for easy application.\n药物靶点信息\nDrug Target Information\n来自例文补充材料Table S10，是例文作收集的target information of 6125\ncompounds。用到自己的文章里，记得引用例文哦～\nFrom Table S10 of the supplementary materials of the example paper,\nthis is the target information of 6,125 compounds collected by the\nauthors. If you use it in your own paper, remember to cite the example\npaper~\nTinfo <- read.delim(\"table s10 target.txt\",sep = \"\\t\",row.names = NULL,header = T,check.names = F,stringsAsFactors = F)\n特征基因集（以例文的PPS genes为例）\nFeature Gene Set (Using the PPS Genes from the Example Paper as an\nExample)\n实际应用时，替换为自己感兴趣的基因集。\nIn practical applications, replace it with your gene set of\ninterest.\n# PPS相关的基因和对应系数，来自例文补充材料Table S3\n# PPS-related genes and their corresponding coefficients, sourced from Table S3 of the supplementary materials in the example paper\npps.coef <- read.table(\"table s3 pps.txt\",sep = \"\\t\",row.names = NULL,header = T,check.names = F,stringsAsFactors = F)\n临床肿瘤数据\nClinical Oncology Data\n# CHCC队列HCC的表达谱（仅保留了所需的基因）\n# CHCC cohort HCC expression profiles (retaining only required genes) \ntpm <- read.table(\"LIHC-CN-TPM.subset.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\nis.element(pps.coef$Symbol, rownames(tpm))\n# CHCC队列HCC的突变信息（仅保留了TP53基因的突变信息）\n# CHCC cohort HCC mutation data (retaining only TP53 mutation information) \nmaf <- read_tsv(\"LIHC-CN-MAF.subset.txt\", comment = \"#\")\n# CHCC队列HCC的临床信息\n# CHCC cohort HCC clinical information\nsinfo <- read.delim(\"LIHC-CN-SINFO.txt\",sep = \"\\t\",row.names = NULL,check.names = F,stringsAsFactors = F,header = T)\n\n# 修正表达谱列名，前159个样本为正常，后159个样本为肿瘤\n# Adjust expression profile column names: first 159 samples are normal, last 159 are tumor\ncolnames(tpm) <- c(sinfo$`Adjacent liver tissue (N) sample ID`, sinfo$`Tumor (T) sample ID`)\n\n# 取出TP53突变的样本以及对应的表达谱\n# Extract TP53-mutated samples and their corresponding expression profiles\nmutsam <- unique(maf$Tumor_Sample_Barcode)\ntpm <- tpm[,mutsam]\n\n# 计算CHCC队列的PPS得分\n# Calculate PPS scores for the CHCC cohort\npps <- apply(tpm, 2, function(x) {x %*% pps.coef$Coefficient})\nrange(pps)\n# 加载CHCC队列蛋白组学数据（仅保留了和药物靶点有交集的蛋白）\n# Load CHCC cohort proteomics data (retaining only proteins overlapping with drug targets)\nproteome <- read.table(\"LIHC-CN-Proteome.subset.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\ncompro <- intersect(rownames(proteome), Tinfo$`Target genes`)\nproteome <- proteome[compro, names(pps)]\n细胞系数据\nCell Line Data\n原版细胞系数据下载地址：\nhttps://depmap.org/portal/download/all/\n。我下载好的在百度网盘：\nhttps://pan.baidu.com/s/1KyTmM1YA6U2uxJNGl1BcVg?pwd=mn6f\nThe original cell line data can be downloaded from:\nhttps://depmap.org/portal/download/all/\n. Pre-downloaded\nfiles are available on BaiduNetdisk:\nhttps://pan.baidu.com/s/1KyTmM1YA6U2uxJNGl1BcVg?pwd=mn6f\n# 加载细胞系信息（文件名：sample_info.csv）\n# Load cell line information (Filename: sample_info.csv)\nCinfo <- read.csv(\"sample_info.csv\", row.names = 1,check.names = F,stringsAsFactors = F,header = T)\n\n# 加载细胞系表达谱（文件名：CCLE_expression.csv）\n# Load cell line expression profiles (Filename: CCLE_expression.csv)\nexpr.ccle <- read.csv(\"CCLE_expression.csv\", row.names = 1, check.names = F, stringsAsFactors = F, header = T)\n\n# 加载CERES score（文件名：CRISPR_gene_effect.csv）\n# Load CERES scores (Filename: CRISPR_gene_effect.csv)\nceres <- read.csv(\"CRISPR_gene_effect.csv\", row.names = 1,check.names = F, stringsAsFactors = F, header = T)\n\n# 加载细胞系突变（文件名：CCLE_mutations.csv）\n# Load cell line mutation data (Filename: CCLE_mutations.csv)\nmaf.ccle <- read.csv(\"CCLE_mutations.csv\", row.names = NULL,check.names = F, stringsAsFactors = F, header = T)\n\n# 提取HCC相关携带TP53突变的细胞系，并且具有对应的表达谱和CERES值\n# Extract HCC-related cell lines with TP53 mutations that have matching expression profiles and CERES values\nCinfo.hcc <- Cinfo[which(Cinfo$primary_disease == \"Liver Cancer\"),]\nmaf.hcc <- maf.ccle[which(maf.ccle$DepMap_ID %in% rownames(Cinfo.hcc)),]\nmaf.hcc <- maf.hcc[which(maf.hcc$Hugo_Symbol == \"TP53\"),]\nmutsam.ccle <- unique(maf.hcc$DepMap_ID)\nis.element(mutsam.ccle, rownames(expr.ccle))\nis.element(mutsam.ccle, rownames(ceres))\nmutsam.ccle <- intersect(mutsam.ccle, rownames(expr.ccle))\nmutsam.ccle <- intersect(mutsam.ccle, rownames(ceres))\n\n\n# 处理表达谱并计算PPS得分\n# Process expression profiles and calculate PPS scores\n\nexpr.ccle <- expr.ccle[mutsam.ccle,]\n\n# 修改列名\n# Modify column names\ncolnames(expr.ccle) <- sapply(strsplit(colnames(expr.ccle), \" (\", fixed = T), \"[\", 1) \n\nexpr.ccle <- as.data.frame(t(expr.ccle))\n\n# 发现VARS未匹配到，GeneCards检查一下发现有同名为VARS1\n# Found that \"VARS\" was not matched; checking GeneCards revealed a synonym \"VARS1\" \nis.element(pps.coef$Symbol, rownames(expr.ccle))\n# 发现存在VARS1\n# Confirmed presence of \"VARS1\"\nis.element(\"VARS1\", rownames(expr.ccle))\n# 将VARS1替换为VARS\n# Replace \"VARS1\" with \"VARS\"\nrownames(expr.ccle)[which(rownames(expr.ccle) == \"VARS1\")] <- \"VARS\" \n\n# 此时全部匹配\n# Now all genes are matched\nis.element(pps.coef$Symbol, rownames(expr.ccle))\n# 计算PPS得分\n# Calculate PPS scores\npps.ccle <- apply(expr.ccle[pps.coef$Symbol,], 2, function(x) {x %*% pps.coef$Coefficient})\n\nrange(pps.ccle)\n# 处理CERES得分矩阵并提取共享的药物靶点\n# Process CERES score matrix and extract shared drug targets\nceres <- ceres[mutsam.ccle,]\ncolnames(ceres) <- sapply(strsplit(colnames(ceres), \" (\", fixed = T), \"[\", 1) # 修改列名\nceres <- as.data.frame(t(ceres))\ncomtarget <- intersect(Tinfo$`Target genes`, rownames(ceres)) # 提取和CERES矩阵共享的靶点\ncomtarget <- intersect(comtarget, rownames(proteome)) # 提取同时又共享CHCC蛋白谱的靶点\n\n# 将DepMapID修正为细胞系名称\n# Convert DepMap IDs to cell line names\nmapID <- Cinfo.hcc[mutsam.ccle, \"stripped_cell_line_name\"]\ncolnames(expr.ccle) <- mapID\ncolnames(ceres) <- mapID\nnames(pps.ccle) <- mapID\n相关性分析及筛选\nCorrelation Analysis and Screening\n对每个药物靶点，计算蛋白谱表达和临床样本的PPS相关性，以及CERES矩阵和细胞系的PPS相关性，设定阈值筛选候选药物靶点。原文：\n首先，计算了\n可成药蛋白表达水平与PPS之间的相关系数\n，筛选出163个相关系数大于0.30（P\n< 0.05）的蛋白靶点。\n随后，基于TP53突变型肝癌细胞系开展\nCERES评分与PPS评分的相关性分析\n，进一步鉴定出43个不良预后依赖性靶点（Spearman相关系数r\n< -0.5且P < 0.05）\nFor each drug target, calculate the correlation between proteomic\nexpression and PPS scores in clinical samples, as well as the\ncorrelation between the CERES matrix and PPS scores in cell lines. Apply\nthreshold criteria to screen for candidate drug targets. Original\ntext:\nFirst, the\ncorrelation coefficient between the expression\nlevel of druggable proteins and PPS\nwas calculated, and 163\nprotein targets were identified with correlation coefficient more than\n0.30 (P < 0.05).\nNext, through conducting\ncorrelation analysis between CERES\nscore and PPS score\nbased on TP53-mutant hepatoma cell lines,\nwe further identified 43 poor prognosis-dependent targets (Spearman’s r\n< −0.5 and P < 0.05)\ncorProteome <- corCERES <- NULL\nfor (i in comtarget) {\n  \n  # 确定该靶点所对应的药物\n  # Identify drugs corresponding to the target\n  drug <- paste(Tinfo[which(Tinfo$`Target genes` == i), \"Agent names\"], collapse = \" | \") \n  \n  ## 蛋白谱表达和临床样本的PPS相关性分析\n  ## Correlation between proteomic expression and clinical PPS scores\n  cor <- cor.test(as.numeric(proteome[i, names(pps)]),\n                  as.numeric(pps),\n                  method = \"spearman\") \n  corProteome <- rbind.data.frame(corProteome,\n                                  data.frame(target = i,\n                                             r = cor$estimate,\n                                             p = cor$p.value,\n                                             drug = drug,\n                                             row.names = i,\n                                             stringsAsFactors = F),\n                                  stringsAsFactors = F)\n  \n  ## CERES矩阵和细胞系的PPS相关性分析\n  ## Correlation between CERES scores and cell line PPS scores  \n  cor <- cor.test(as.numeric(ceres[i, names(pps.ccle)]),\n                  as.numeric(pps.ccle),\n                  method = \"spearman\")\n  corCERES <- rbind.data.frame(corCERES,\n                               data.frame(target = i,\n                                          r = cor$estimate,\n                                          p = cor$p.value,\n                                          drug = drug,\n                                          row.names = i,\n                                          stringsAsFactors = F),\n                               stringsAsFactors = F)\n  \n}\n\n# 保存到文件\n# Save results\nwrite.table(corProteome, file = \"output_correlation between proteome and pps in china cohort.txt\", sep = \"\\t\",row.names = F, col.names = T, quote = F)\nwrite.table(corCERES, file = \"output_correlation between ceres and pps in ccle dataset.txt\", sep = \"\\t\", row.names = F, col.names = T, quote = F)\n\n# 根据原文阈值筛选对应的候选靶点\n# Filter candidate targets using original thresholds\n\n# 蛋白谱靶点值与PPS需正相关\n# Positive correlation for proteome\ncandidate.proteome <- corProteome[which(corProteome$r > 0.3 & corProteome$p < 0.05),] \n\n# CERES靶点值与PPS需负相关\n# Negative correlation for CERES\ncandidate.CERES <- corCERES[which(corCERES$r < -0.5 & corCERES$p < 0.05),] \n\n# 匹配上了原文中的3个，也许还存在数据标准化问题导致结果不完全一致\n# Matched 3 targets as in original paper (minor discrepancies may exist due to data normalization)\ncandidate.target <- intersect(candidate.proteome$target, candidate.CERES$target) \n\n# 把筛选出的药物靶点保存到文件\n# Save candidate targets\nwrite.table(candidate.target, \"output_candidate.target.txt\", quote = F, row.names = F)\n开始画图\nPlotting\n# 设置颜色\n# Set color palette\ngrey <- \"#BFBFBF\"\nlightred <- \"#FDC9B5\"\nred <- \"#E9583A\"\nlightblue <- \"#37D3FF\"\nblue <- \"#137BCD\"\n蛋白谱相关性\nProteomic Correlation Analysis\n# 给颜色做编号，基础为A，显著的为B，感兴趣的为C\n# Assign color codes: A (base), B (significant), C (targets of interest)\ncorProteome$color <- \"A\" \ncorProteome[which(corProteome$r > 0.3 & corProteome$p < 0.05), \"color\"] <- \"B\"  \ncorProteome[candidate.target,\"color\"] <- \"C\" \n\n# 同理给大小做编号\n# Assign size codes following same logic \ncorProteome$size <- \"A\" \ncorProteome[which(corProteome$r > 0.3 & corProteome$p < 0.05), \"size\"] <- \"B\"\ncorProteome[candidate.target,\"size\"] <- \"C\"\n\n# 让想突出的靶点出现在列表的末尾，这样绘图时不会被其他点所遮挡\n# Reorder to ensure highlighted targets appear on top layer\ncorProteome <- corProteome[order(corProteome$color),] \n\nselecttargets <- corProteome[candidate.target,]\nselecttargets$label <- rownames(selecttargets)\n\np1 <- ggplot(corProteome, aes(r, -log10(p))) + \n  geom_point(aes(color = color, size = size)) + \n  scale_color_manual(values = c(grey, lightred, red))+ \n  scale_size_manual(values = c(1,2,3)) +  \n  xlab(\"Spearman's rank correlation coefficient\") + \n  ylab(\"-log10(P-value)\") +\n  scale_x_continuous(\n    breaks = c(-0.6,-0.3,0,0.3,0.6), \n    labels = c(-0.6,-0.3,0,0.3,0.6),\n    limits = c(-0.6, 0.6)) + \n  geom_vline(xintercept = 0.3, color=\"grey70\",\n             linetype = \"longdash\", lwd = 0.6) + \n  geom_hline(yintercept = -log10(0.05), color = \"grey70\", \n             linetype = \"longdash\", lwd = 0.6) +\n  theme_bw() +\n  theme(axis.ticks = element_line(size = 0.2, color = \"black\"),\n        axis.ticks.length = unit(0.2, \"cm\"),\n        axis.text = element_text(size = 10, color = \"black\"),\n        axis.title = element_text(size = 10, color = \"black\"),\n        panel.background = element_blank(),\n        panel.grid = element_blank(),\n        legend.position = \"none\")\np1\n# 将感兴趣的靶点信息添加上文字标签\n# Add target labels using repel to prevent overlap \np2 <- p1 + \n  geom_text_repel(data = selecttargets, \n                  aes(x = r, y = -log10(p), \n                      label = label),\n                  colour=\"black\", \n                  size = 4, \n                  box.padding = unit(1, \"lines\"), \n                  point.padding = unit(2, \"lines\"))\n\np2\n# 注意：原图中靶点下方的对应药物是后期AI的，这里建议参照生成的txt文件，将对应药物AI修饰上去\n# Note: Drug annotations shown below targets in original figure were added post-hoc using AI. Suggested workflow: Use corresponding drugs from txt file and add similar AI-assisted annotations.\nggsave(filename = \"correlation between proteome and pps in china cohort.pdf\", width = 5,height = 5)\np.proteome <- p2\nCERES相关性\nCERES Score Correlation Analysis\ncorCERES$color <- \"A\"\ncorCERES[which(corCERES$r < -0.5 & corCERES$p < 0.05), \"color\"] <- \"B\"\ncorCERES[candidate.target, \"color\"] <- \"C\"\ncorCERES$size <- \"A\"\ncorCERES[which(corCERES$r < -0.5 & corCERES$p < 0.05), \"size\"] <- \"B\"\ncorCERES[candidate.target, \"size\"] <- \"C\"\n\n# 让想突出的靶点出现在列表的末尾，这样绘图时不会被其他点所遮挡\n# Reorder to ensure highlighted targets appear on top layer\ncorCERES <- corCERES[order(corCERES$color),] \n\nselecttargets <- corCERES[candidate.target,]\nselecttargets$label <- rownames(selecttargets)\n\np1 <- ggplot(corCERES, aes(r, -log10(p))) + \n  geom_point(aes(color = color, size = size)) + \n  scale_color_manual(values = c(grey, lightblue, blue))+\n  scale_size_manual(values = c(1,2,3)) + \n  xlab(\"Spearman's rank correlation coefficient\") + \n  ylab(\"-log10(P-value)\") +\n  scale_x_continuous(\n    breaks = c(-0.8,-0.5,0,0.5,0.8), \n    labels = c(-0.8,-0.5,0,0.5,0.8),\n    limits = c(-0.8, 0.8)) + \n  geom_vline(xintercept = -0.5, color = \"grey70\", \n             linetype = \"longdash\", lwd = 0.6) + \n  geom_hline(yintercept = -log10(0.05), color = \"grey70\", \n             linetype = \"longdash\", lwd = 0.6) +\n  theme_bw() +\n  theme(axis.ticks = element_line(size = 0.2, color = \"black\"),\n        axis.ticks.length = unit(0.2, \"cm\"),\n        axis.text = element_text(size = 10, color = \"black\"),\n        axis.title = element_text(size = 10, color = \"black\"),\n        panel.background = element_blank(),\n        panel.grid = element_blank(),\n        legend.position = \"none\")\np1\np2 <- p1 + \n  geom_text_repel(data = selecttargets,\n                  aes(x = r, y = -log10(p), \n                      label = label),\n                  colour=\"black\", \n                  size = 4, \n                  box.padding = unit(1, \"lines\"), \n                  point.padding = unit(2, \"lines\"))\n\np2\n# 注意：原图中靶点下方的对应药物是后期AI的，这里建议参照生成的txt文件，将对应药物AI修饰上去\n# Note: Drug annotations shown below targets in original figure were added post-hoc using AI. Suggested workflow: Use corresponding drugs from txt file and add similar AI-assisted annotations.\nggsave(filename = \"correlation between ceres and pps in ccle dataset.pdf\", width = 5,height = 5)\np.ccle <- p2\n相关性子图\nCorrelation Subplots\nscatterProteome <- scatterCERES <- list()\nfor (i in candidate.target) {\n  tmp <- data.frame(var = as.numeric(proteome[i, names(pps)]), pps = as.numeric(pps))\n  cor <- cor.test(tmp$var,\n                  tmp$pps,\n                  method = \"spearman\")\n  \n  # 构建相关性值的文字标签\n  # Create correlation label\n  txt <- paste0(\"r = \", round(cor$estimate,2), \"\\n\", \"P = \", round(cor$p.value,4)) \n  \n  scatterProteome[[i]] <- \n    ggplot(tmp, aes(pps, var)) + \n    geom_ribbon(stat = \"smooth\", method = \"lm\", se = TRUE, \n                fill = alpha(lightred, 0.6)) + \n    geom_smooth(span = 2, method = lm, color = red, fill = NA) + \n    geom_point(color = red, size = 2) + \n    xlab(\"PPS scores\") + \n    ylab(paste0(\"Protein abundance of \", i)) +\n    theme_bw() +\n    theme(axis.ticks = element_line(size = 0.2, color = \"black\"),\n          axis.ticks.length = unit(0.2, \"cm\"),\n          axis.text = element_text(size = 10, color = \"black\"),\n          axis.title = element_text(size = 10, color = \"black\"),\n          axis.line = element_line(colour = \"black\"),\n          panel.grid.major = element_blank(),\n          panel.grid.minor = element_blank(),\n          panel.border = element_blank(),\n          panel.background = element_blank()) +\n    annotate(\"text\", \n             x = min(tmp$pps), \n             y = max(tmp$var), \n             hjust = 0, fontface = 4, \n             label = txt)\n  scatterProteome[[i]]\n  ggsave(filename = paste0(\"scatter plot between pps and protein abundance of \", i, \".pdf\"), width = 5, height = 5)\n  \n  tmp <- data.frame(var = as.numeric(ceres[i, names(pps.ccle)]), pps = as.numeric(pps.ccle))\n  cor <- cor.test(tmp$var,\n                  tmp$pps,\n                  method = \"spearman\")\n  txt <- paste0(\"r = \", round(cor$estimate,2), \"\\n\", \"P = \", round(cor$p.value, 4))\n  scatterCERES[[i]] <- \n    ggplot(tmp, aes(pps, var)) + \n    geom_ribbon(stat = \"smooth\", method = \"lm\", se = TRUE,\n                fill = alpha(lightblue, 0.6)) + \n    geom_smooth(span = 2, method = lm, color = blue, fill = NA) +\n    geom_point(color = blue, size = 2) + \n    geom_hline(yintercept = 0, color=red, \n               linetype=\"longdash\", lwd = 0.6) +\n    xlab(\"PPS scores\") + \n    ylab(paste0(\"CERES score of \", i)) +\n    theme_bw() +\n    theme(axis.ticks = element_line(size = 0.2, color = \"black\"),\n          axis.ticks.length = unit(0.2, \"cm\"),\n          axis.text = element_text(size = 10, color = \"black\"),\n          axis.title = element_text(size = 10, color = \"black\"),\n          axis.line = element_line(colour = \"black\"),\n          panel.grid.major = element_blank(),\n          panel.grid.minor = element_blank(),\n          panel.border = element_blank(),\n          panel.background = element_blank()) +\n    annotate(\"text\", \n             x = min(tmp$pps), \n             y = max(tmp$var), \n             hjust = 0, fontface = 4, \n             label = txt)\n  scatterCERES[[i]]\n  ggsave(filename = paste0(\"scatter plot between pps and ceres score of \", i, \".pdf\"), width = 5, height = 5)\n}\n组图\nComposite Figure\np <- \n  plot_grid(p.proteome, scatterProteome[[1]], scatterProteome[[2]], scatterProteome[[3]], scatterProteome[[4]], \n          p.ccle, scatterCERES[[1]], scatterCERES[[2]], scatterCERES[[3]], scatterCERES[[4]],\n          nrow = 2)\nggsave(filename = \"combined plot.pdf\", width = 12, height = 5)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa294HCCdrug_FigureYa294HCCdrug",
      "title": "FigureYa294HCCdrug/FigureYa294HCCdrug.html",
      "html": "FigureYa294HCCdrug/FigureYa294HCCdrug.html",
      "text": "texts/main_FigureYa294HCCdrug_FigureYa294HCCdrug.txt",
      "folder": "FigureYa294HCCdrug",
      "thumb": "gallery_compress/FigureYa294HCCdrug.webp"
    },
    "word_count": 2591,
    "lines_count": 556,
    "title": "FigureYa294HCCdrug",
    "description": "Demand description 希望复现这篇文章的Figure 4DE。 We hope to reproduce Figure 4DE of this article.",
    "input_data_types": [
      "蛋白质组",
      "临床数据",
      "突变数据"
    ],
    "output_types": [
      "火山图",
      "热图",
      "统计表格",
      "散点图"
    ],
    "technical_methods": [
      "标准化"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学",
      "药物研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "span",
      "ticks",
      "drug",
      "values",
      "colour",
      "header",
      "lwd",
      "width"
    ]
  },
  {
    "id": "main_FigureYa254scViolin_FigureYa254scViolin",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa254scViolin_FigureYa254scViolin.txt",
    "content": "FigureYa254scViolin\nFigureYa254scViolin\nZongcheng Li\n2025-5-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n这个小提琴图很高大上，适于差异比较展示。\nRequirement Description\nThis violin diagram is very advanced and suitable for comparing\ndifferences.\n出自\nhttps://link.springer.com/article/10.1007%2Fs00497-018-00357-2\nfrom\nhttps://link.springer.com/article/10.1007%2Fs00497-018-00357-2\nFigure S4. Integrative Analysis of Aging-Associated Differentially\nExpressed Genes with Genes from GenAge or POF/POI Database, Related to\nFigure 4 (A) Violin plots showing\nexpression levels of marker\ngenes for each cell type in young (Y) and old (O) monkey\novaries\n.\n应用场景\n三种特征同时对比展示。就像例文用该图对比展示了三个特征之下的基因表达量分布：细胞类型、marker基因、年龄。\n这里输入数据有两种形式任你选，跟单细胞数据无缝对接，对非单细胞数据非常友好。\n我们实现过例文的几个Figure：\nFigure\n1H，热图和气泡图对应展示表达谱和基因功能富集分析结果，可参考FigureYa206scHeatmap；\nFigure\n3AB，从PCA结果就能看出基因表达模式跟细胞类型的关系，可参考FigureYa222PCAgene；\nFigure\n4B，用两种颜色展示上调和下调的基因，可参考FigureYa232scRankHeatmap；\n另外，Figure\nS6H用颜色和形状展示两个层面的分组信息，画法可参考FigureYa101PCA。\nApplication Scenarios\nThe three characteristics are displayed in comparison at the same\ntime. Just like the example in this diagram, the distribution of gene\nexpression under three characteristics is compared: cell type, marker\ngene, and age.\nThere are two forms of input data for you to choose from, which is\nseamless with single-cell data and very friendly to non-single-cell\ndata.\nHere are a few examples:\nFigure 1H, heat map and bubble map correspond to the results of\nexpression profiling and gene function enrichment analysis, please refer\nto FigureYa206scHeatmap;\nFigure 3AB, the relationship between gene expression patterns and\ncell types can be seen from the PCA results, please refer to\nFigureYa222PCAgene;\nFigure 4B, showing the up- and down-regulated genes in two colors,\nsee FigureYa232scRankHeatmap;\nIn addition, Figure S6H uses color and shape to display the grouping\ninformation at two levels, which can be drawn by referring to\nFigureYa101PCA.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nlibrary(Seurat)\nlibrary(magrittr)\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(ggpubr)\nlibrary(rstatix)\nlibrary(RColorBrewer)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # error messages are displayed in English\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # chr is not allowed to be converted to factor\n输入文件\n单细胞和非单细胞数据任选其一：\n单细胞数据。sc.seurat.Rdata，单细胞RNA-seq预处理获得的文件。怎样获得这个文件？拖到文末看“附：单细胞RNA-seq数据预处理”\n非单细胞数据。easy_input.csv，只要你的数据也有三种特征，整理成的easy_input.csv的样子，就可以画这样的图。\nInput files\nChoose between single-cell and non-single-cell data:\nSingle-cell data. sc.seurat.Rdata, file obtained from single-cell\nRNA-seq pretreatment. How do I get this document? Drag to the end of the\narticle to see “Attached: Single-cell RNA-seq data preprocessing”\nNon-single-cell data. easy_input.csv, as long as your data also has\nthree characteristics, organized into a easy_input.csv appearance, you\ncan draw such a graph.\n单细胞数据\nSingle-cell data\nload(\"sc.seurat.Rdata\")\nmarkers <- c(\"DDX4\", \"AMH\", \"COL1A2\", \"ACTG2\", \"CDH5\", \"KLRB1\", \"CD163\")\n\ndf <- FetchData(sc, vars = c(markers, \"aging\", \"cluster_short\")) %>%\n  reshape2::melt(id.vars = c(\"aging\", \"cluster_short\"), \n                 variable.name = \"gene\",\n                 value.name = \"expression\") %>%\n  mutate(aging = factor(aging, levels = c(\"Y\", \"O\")),\n         cluster_short = factor(cluster_short, levels = c(\"OO\",\"GC\", \"SC\", \"SMC\",  \"EC\", \"NKT\", \"M\")))\n\n# 保存到文件，便于套用格式\n# Save to a file for easy formatting\nwrite.csv(df, \"easy_input.csv\", quote = F, row.names = F)\n非单细胞数据\neasy_input.csv，前三列是你想用来分组的三种特征，最后一列为具体数值，图中会展示该数值的分布。\nNon-single-cell data\neasy_input.csv, the first three columns are the three features you\nwant to group, and the last column is a specific value, which is shown\nin the graph.\ndf <- read.csv(\"easy_input.csv\", header = T)\n\n# 按自己的要求排序，该顺序对应图中的顺序\n# Sort according to your own requirements, the order corresponds to the order in the figure\ndf$aging <- factor(df$aging, levels = c(\"Y\", \"O\"))\ndf$cluster_short <- factor(df$cluster_short, levels = c(\"OO\",\"GC\", \"SC\", \"SMC\",  \"EC\", \"NKT\", \"M\"))\ndf$gene <- factor(df$gene, levels = c(\"DDX4\", \"AMH\", \"COL1A2\", \"ACTG2\", \"CDH5\", \"KLRB1\", \"CD163\"))\n\nhead(df)\n开始画图\n图中会横向展示cluster_short，纵向展示\ngene，每个小格内以aging分组，绘制基因表达量分布。\nStart drawing\nThe figure shows cluster_short horizontally and genes vertically, and\neach cell is grouped by aging to plot the distribution of gene\nexpression.\n复现原文\nReproduce the original text\nggplot(data = df, mapping = aes(aging, expression, fill = aging)) +\n  geom_violin(show.legend = F) +\n  scale_fill_manual(values = c(\"grey\", \"cornflowerblue\")) + # 两组分别填充灰色和蓝色 # The two groups are filled with gray and blue, respectively\n  facet_grid(gene~cluster_short) +\n  theme_bw() +\n  xlab(\"\") +\n  ylab(\"Expression level (log TPM)\") +\n  theme(panel.grid = element_blank(),\n        strip.background.x = element_rect(fill = \"lavenderblush\"), # 顶部填充粉色 # Top padded pink\n        strip.text.y = element_text(angle = 0),\n        strip.background.y = element_blank())\nggsave(\"scViolin.pdf\", width = 9, height = 7)\n美化版\n小伙伴嫌原图配色丑，我们修改一下颜色。\nBeautified version\nMy friend thinks the color of the original picture is ugly, so let’s\nmodify the color.\nggplot(df, mapping = aes(aging, expression, fill = aging, color = aging)) +\n  #geom_violin(show.legend = F) + # 画violin # Draw violin\n  scale_fill_manual(values = c(\"#2874C5\", \"#EABF00\")) + # 两组分别填充蓝色和黄色 # The two groups are filled with blue and yellow, respectively\n  scale_color_manual(values = c(\"#2874C5\", \"#EABF00\")) + # 边框跟填充颜色一致 # The border is the same color as the fill\n  \n  # 如果你喜欢，可以叠加box plot\n  # If you like, you can overlay box plots\n  geom_boxplot(outlier.size = -1, \n               show.legend = FALSE, # 不显示图例 # Legend is not displayed\n               color=\"black\", lwd=0.2, # 线的粗细 # The thickness of the line\n               alpha = 0.7) + # 透明化 # Transparency\n  # 还可以叠加散点 # Scatters can also be overlayed\n  geom_point(shape = 21, size=.6, # 点的形状和大小 # The shape and size of the dots\n             show.legend = FALSE, # 不显示图例 # Legend is not displayed\n             position = position_jitterdodge(), \n             alpha = 0.3)+ \n  # 甚至可以注释掉上面geom_violin那行，不画violin，只画box和散点\n  # You can even comment the line of geom_violin, don't draw violin, only box and scatter\n  \n  facet_grid(gene ~ cluster_short) +\n  theme_bw() +\n  xlab(\"\") +\n  ylab(\"Expression level (log TPM)\") +\n  theme(panel.grid = element_blank(),\n        strip.background.x = element_rect(fill = \"grey95\"), # 顶部填充浅灰色 # The top is filled with light gray\n        strip.text.y = element_text(angle = 0),\n        strip.background.y = element_blank())\nggsave(\"scViolin_color.pdf\", width = 9, height = 7)\n加强版\n借助ggpubr加上pvalue或显著性星标*，分面加pvalue的方法参考了这篇\nhttps://www.datanovia.com/en/blog/how-to-add-p-values-to-ggplot-facets/\nEnhanced\nWith the help of ggpubr plus pvalue or salient star*, the method of\nadding pvalue to facets refers to this\nhttps://www.datanovia.com/en/blog/how-to-add-p-values-to-ggplot-facets/\nstat.test <- df %>% \n  group_by(cluster_short, gene) %>% \n  t_test(expression ~ aging) %>%\n  adjust_pvalue(method = \"bonferroni\") %>% \n  add_significance()\n\nstat.test\n# cutpoints: 0, 1e-04, 0.001, 0.01, 0.05, 1\n# symbols: \"****\", \"***\", \"**\", \"*\", \"ns\"\n\nstat.test <- stat.test %>% add_xy_position(x = \"aging\")\n\nv1 <- ggviolin(df, x = \"aging\", y = \"expression\", \n               fill = \"aging\", \n               color = \"aging\", # 如果想要黑色边框，就删掉这行 # If you want a black border, delete this line\n               facet = c(\"gene\",\"cluster_short\")) +\n  scale_fill_manual(values = c(\"#2874C5\", \"#EABF00\")) +\n  scale_color_manual(values = c(\"#2874C5\", \"#EABF00\")) + #边框跟填充色一致 # The border is the same as the fill color\n  xlab(\"\") +\n  ylab(\"Expression level (log TPM)\") +\n  theme(panel.grid = element_blank(),\n        strip.text.y = element_text(angle = 0),\n        strip.background.x = element_rect(fill = \"grey95\"), # 顶部填充浅灰色 # The top is filled with light gray\n        strip.background.y = element_blank()) \nv1\n# 显著标星*\n# Prominently Starred*\nv1 + stat_pvalue_manual(stat.test, hide.ns = TRUE) #显著性星标 # Distinctive star\nggsave(\"scViolin_plus.pdf\", width = 9, height = 9)\n\n# 还可以同时显示pvalue数值和标星*\n# It is also possible to display both pvalue and star*\nv1 + \n  stat_pvalue_manual(stat.test, \n                     bracket.nudge.y = 1, \n                     hide.ns = TRUE, #不显示不显著的，这里有个特殊情况是图右上角M ~ DDX4出现了NaN，是因为该组所有样本表达量都为0 # The non-significant ones will not be displayed, and there is a special case here that NaN appears in M ~ DDX4 in the upper right corner of the figure, because the expression level of all samples in this group is 0\n                     label = \"{p.adj}{p.adj.signif}\", # pvalue和星标 # pvalue and star\n                     label.size = 3, # pvalue字的大小 # The size of the pvalue word\n                     vjust = -0.5) + # pvalue的上（负）下位置 # The upper (negative) lower position of the pvalue\n  scale_y_continuous(expand = expansion(mult = c(0, 0.1))) #给pvalue文字留足空间 # Leave enough space for pvalue text\n后期处理\n输出的pdf文件是矢量图，可以用Illustrator等软件打开，编辑图形和文字。\nPost-processing\nThe output pdf file is a vector illustration that can be opened with\nsoftware such as Illustrator to edit graphics and text.\n附：单细胞RNA-seq数据预处理\n以下代码出自\nFigureYa206scHeatmap\n，会生成\nsc.seurat.Rdata\n文件，可作为以上代码的输入文件。\nAttached: Single-cell RNA-seq data preprocessing\nThe following code is from ‘FigureYa206scHeatmap’ and will generate a\n‘sc.seurat.Rdata’ file, which can be used as an input file for the above\ncode.\n下载单细胞RNA-seq数据(已从微云下载，故此处不再下载)\nUMI count，从NCBI\nGSE130664\n下载：\nGSE130664_merge_UMI_count.txt.gz\n文件。\nDownload single-cell RNA-seq data (downloaded from Microcloud, so no\nmore download here)\nUMI count, download from NCBI\nGSE130664\n:\n‘GSE130664_merge_UMI_count.txt.gz’ file.\n#download.file(\"https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE130664&format=file&file=GSE130664%5Fmerge%5FUMI%5Fcount%2Etxt%2Egz\", \n              #destfile = \"GSE130664_merge_UMI_count.txt.gz\")\nmetadata，从\n例文的\nSupplementary\nTables获得：\n1-s2.0-S0092867420300568-mmc1.xlsx\nmetadata, obtained from (\nhttps://doi.org/10.1016/j.cell.2020.01.009\n)\nSupplementary Tables in [example text]:\n‘1-s2.0-S0092867420300568-mmc1.xlsx’\nRead data\numi <- read.table(file = gzfile(\"GSE130664_merge_UMI_count.txt.gz\"), header = T, row.names = 1, sep = \"\\t\")\nqc <- readxl::read_excel(\"1-s2.0-S0092867420300568-mmc1.xlsx\", sheet = 2)\nmeta <- readxl::read_excel(\"1-s2.0-S0092867420300568-mmc1.xlsx\", 3) %>% \n  column_to_rownames(\"cell\")\n数据预处理\nData preprocessing\nSee Methods:\nQUANTIFICATION AND STATISTICAL ANALYSIS -> Single-Cell RNA-Seq Data\nProcessing\n# QC of Cells\ncells <- qc %>% \n  filter(`Mapping rate` >= 0.2 &\n           `Gene number` >= 700 &\n           UMI >= 3000) %>%\n  pull(Rename)\n\n# seurat object\nsc <- CreateSeuratObject(counts = umi[,cells], meta.data = meta)\n\n# expression transformation\nsc@assays$RNA$data <- sc@assays$RNA$counts %>% \n  apply(2, function(x){\n    log2(10^5*x/sum(x)+1)\n    })\n\n# remove other cells\nsc <- sc[,sc$cluster != \"other\"]\n\n# 给cluster改名\n# Rename the cluster\nsc$cluster_short <- factor(\n  plyr::mapvalues(sc$cluster, \n                  c(\"Oocyte\", \"Natural killer T cell\", \"Macrophage\",\n                    \"Granulosa cell\", \"Endothelial cell\", \n                    \"Smooth muscle cell\", \"Stromal cell\"),\n                  c(\"OO\", \"NKT\", \"M\", \"GC\", \"EC\", \"SMC\", \"SC\")),\n  levels = c(\"OO\", \"NKT\", \"M\", \"GC\", \"EC\", \"SMC\", \"SC\"))\n\n# 给cluster自定义颜色\n# Customize the color for the cluster\ncluster_colors <- setNames(brewer.pal(7, \"Set1\"), levels(sc$cluster_short))\n\n# 保存一下，便于停下来接着跑\n# Save it so you can stop and run\n#save(sc, cluster_colors, file = \"sc.seurat.Rdata\")\n\n# 还可以把表达矩阵输出到文件\n# It is also possible to output the expression matrix to a file\n#write.csv(sc@assays$RNA@data, \"easy_input_expr.csv\", quote = F)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa254scViolin_FigureYa254scViolin",
      "title": "FigureYa254scViolin/FigureYa254scViolin.html",
      "html": "FigureYa254scViolin/FigureYa254scViolin.html",
      "text": "texts/main_FigureYa254scViolin_FigureYa254scViolin.txt",
      "folder": "FigureYa254scViolin",
      "thumb": "gallery_compress/FigureYa254scViolin.webp"
    },
    "word_count": 1434,
    "lines_count": 305,
    "title": "FigureYa254scViolin",
    "description": "这个小提琴图很高大上，适于差异比较展示。 Requirement Description This violin diagram is very advanced and suitable for comparing",
    "input_data_types": [
      "临床数据",
      "表达矩阵",
      "单细胞"
    ],
    "output_types": [
      "散点图",
      "热图",
      "统计表格",
      "箱线图"
    ],
    "technical_methods": [
      "通路分析"
    ],
    "biology_areas": [
      "药物研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "values",
      "acc",
      "header",
      "lwd",
      "width",
      "ns",
      "grid",
      "pvalue",
      "legend"
    ]
  },
  {
    "id": "main_FigureYa317RoeDot_FigureYa317RoeDot",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa317RoeDot_FigureYa317RoeDot.txt",
    "content": "FigureYa317RoeDot\nFigureYa317RoeDot\nAuthor(s)\n: Xiaofan Lu; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-05-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirements Description\n基于Ro/e分析对这些细胞亚群进行了组织富集分析，结果观察到肥大细胞和髓系细胞优先分布在动脉粥样硬化核心(AC)部位，而淋巴细胞优先分布在邻近部位。\nTissue enrichment analysis based on Ro/e revealed that mast cells and\nmyeloid cells were predominantly localized in the atherosclerotic core\n(AC), while lymphocytes were enriched in adjacent regions.\n出自：\nhttps://bmcbiol.biomedcentral.com/articles/10.1186/s12915-023-01540-2\n图1 利用单细胞RNA测序解析动脉粥样硬化的免疫景观 e\n通过Ro/e评分估算各细胞类型组织分布情况的折线图\nSource:\nhttps://bmcbiol.biomedcentral.com/articles/10.1186/s12915-023-01540-2\nFig. 1 Dissection of the immune landscape in atherosclerosis with\nscRNA-seq. e Line chart showing tissue prevalence for each cell type\nestimated by Ro/e score\n应用场景\nApplication Scenario\n根据单细胞数据，计算细胞比例分布特异度（Ro/e），并绘制折线图\n输入：Seurat对象，具有样本来源（Group）和细胞类型（Celltypes）信息\n输出：折线图（Proportion.pdf）和Ro/e表格\n把多组Ro/e绘制成热图，可参考FigureYa312CellPreference。\nCalculate cell proportion distribution specificity (Ro/e) based on\nsingle-cell data and plot a line graph\nInput: Seurat object containing sample origin (Group) and cell type\n(Celltypes) information\nOutput: Line graph (Proportion.pdf) and Ro/e table\nPlot the Ro/e values of multiple groups as a heatmap, refer to\nFigureYa312CellPreference for guidance.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(Seurat)\n# 用于从GEO里的GSE159677_series_matrix.txt.gz文件读取样本信息\n# For reading sample information from GSE159677_series_matrix.txt.gz in GEO\nlibrary(GEOquery)\nlibrary(magrittr)\nlibrary(plyr)\nlibrary(openxlsx)\nlibrary(GSVA)\n\n# 用于生成期望频数表(Ro/e计算)\n# For generating expected frequency tables (Ro/e calculation)\nlibrary(epitools)\n\nlibrary(reshape2)\nlibrary(ggplot2)\n\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n输入文件\nInput Files\n从GEO下载输入数据，\nhttps://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE159677\n。下载Supplementary\nfile表格里的\nGSE159677_RAW.tar\n，和Download\nfamily里的\nSeries Matrix File(s)\n，存放在InputData文件夹里。\nDownload input data from GEO:\nhttps://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE159677\n.\nDownload\nGSE159677_RAW.tar\nfrom the Supplementary files\ntable and\nSeries Matrix File(s)\nfrom the Download family\nsection, then store them in the InputData folder.\n单细胞数据的准备\nPreparation of Single-Cell Data\n# 单细胞数据的准备\n# 目标：生成一个注释好的Seurat对象，以备作图需求\n# Seurat对象应包含以下信息:\n# 样本分组（group）和细胞类型（Celltypes）\n# Preparation of Single-Cell Data  \n# Objective: Generate an annotated Seurat object for plotting purposes  \n# The Seurat object should contain the following information: \n# Sample grouping (group) and Cell types (Celltypes)\n\n# 设置存放输入数据的路径\n# Set input data path\ndata.path <- file.path(\"InputData\") \n\n# 读取样本信息\n# Read sample metadata\nsample.info <- getGEO(filename = file.path(data.path,\"GSE159677_series_matrix.txt.gz\"))\nsample.info <- as.data.frame(sample.info)\nsample.info$title <- gsub(\" scRNA-seq\", \"\", sample.info$title)\nsample.info <- data.frame(\n  \"geo\" = sample.info$geo_accession,\n  \"patient\" = gsub(\"(.+)\\ (.+)\\ (.+)\", \"\\\\1\\\\2\", sample.info$title),\n  \"group\" = gsub(\"(.+)\\ (.+)\\ (.+)\", \"\\\\3\", sample.info$title)\n)\n\n# 批量读取表达矩阵\n# Batch import expression matrices\nsamples <- list.dirs(\"InputData\", full.names = T)[-1]\nmtx.list <- lapply(samples, function(sample){\n  mtx = Read10X(data.dir = sample)\n  colnames(mtx) = paste0(substr(basename(sample), 1, 10), colnames(mtx))\n  return(mtx)\n})\nmtx <- do.call(cbind, mtx.list)\n\n# 生成Seurat对象\n# Create Seurat object\nseu <- CreateSeuratObject(mtx, min.cells = 3, min.features = 200)\nseu$Sample <- substr(colnames(seu), 1, 10)\nseu$Patient <- mapvalues(x = seu$Sample,\n                         from = sample.info$geo, to = sample.info$patient)\nseu$Group <- mapvalues(x = seu$Sample,\n                       from = sample.info$geo, to = sample.info$group)\n\n# 标准预处理流程\n# Standard preprocessing pipeline\nseu <- FindVariableFeatures(seu) %>% NormalizeData() %>% ScaleData()\nseu <- RunPCA(seu)\nseu <- RunUMAP(seu, dims = 1:20)\nseu <- FindNeighbors(seu, dims = 1:20) %>% FindClusters(resolution = 0.4)\nDimPlot(seu, group.by = \"seurat_clusters\", label = T)\n\n# 此处使用机器注释（实际情况中应使用手动注释）\n# Automated cell type annotation (manual annotation recommended in practice)\nmarker <- read.xlsx(\"marker.xlsx\")\nmarker <- split(marker$GeneSymbol, marker$Celltype)\nparam <- GSVA::gsvaParam(exprData = AverageExpression(seu)[[1]],  \n                         geneSets = marker)\nmarker.score <- GSVA::gsva(param)\nanno <- data.frame(\n  \"cluster\" = colnames(marker.score),\n  \"celltype\" = rownames(marker.score)[apply(marker.score, 2, which.max)]\n)\nseu$Celltypes <- mapvalues(x = seu$seurat_clusters,\n                           from = anno$cluster, to = anno$celltype)\nsaveRDS(seu, \"seu.rds\") # 保存seu对象\n计算Ro/e\nCalculate Ro/e\n# 读取Seurat对象\n# Read Seurat object \nseu <- readRDS(\"seu.rds\")\nobserve.data <- as.matrix(as.data.frame.matrix(table(seu$Group, seu$Celltypes)))\n\n# 计算Ro/e\n# Calculate Ro/e\nexpected.data <- expected(observe.data)\nRatio <- observe.data/expected.data\n\n# 输出Ro/e表格\n# Output Ro/e table \nwrite.table(Ratio, \"output_RatioOE.txt\",\n            sep = \"\\t\", row.names = F, col.names = T, quote = F)\n绘制Ro/e折线图\nPlotting Ro/e line chart\n# 生成绘图数据\n# Generate plotting data\nplot.data <- melt(Ratio)\ncolnames(plot.data) <- c(\"Group\", \"Celltype\", \"Ratio\")\nplot.data$Celltype <- factor(as.character(plot.data$Celltype),\n                             levels = colnames(Ratio)[order(Ratio[1, ])])\n\ncolor <- setNames(object = c(\"#CD2626\", \"#4682B4\"), \n                 nm = c(\"AC\", \"PA\"))\n\n# 画折线图\n# Draw line chart\nggplot(plot.data, aes(x = Celltype, y = Ratio, group = Group, color = Group))+\n  geom_point(size = 3) +\n  geom_line(linetype = \"dashed\") +\n  scale_color_manual(values = color) +\n  theme_classic() + \n  labs(x = \"\", y = \"Ro/e\", fill = \"position\") + \n  theme(axis.text.x = element_text(hjust = 0.5, size = 12, color = \"black\"),\n        axis.title.y = element_text(hjust = 0.5, size = 12, color = \"black\"),\n        axis.text.y = element_text(hjust = 0.5, size = 12, color = \"black\"),\n        axis.ticks = element_line(size = 0.2, color=\"black\"),\n        axis.ticks.length = unit(0.2, \"cm\"),\n        panel.background = element_blank(),\n        panel.grid = element_blank(),\n        \n        # 自己调整，把图例放到空白处\n        # Adjust manually to place legend in blank area\n        legend.position = c(0.9, 0.9), \n        axis.title = element_text(size = 10),\n        axis.text = element_text(size = 10))\nggsave(\"Roedot.pdf\", width = 5, height = 4)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa317RoeDot_FigureYa317RoeDot",
      "title": "FigureYa317RoeDot/FigureYa317RoeDot.html",
      "html": "FigureYa317RoeDot/FigureYa317RoeDot.html",
      "text": "texts/main_FigureYa317RoeDot_FigureYa317RoeDot.txt",
      "folder": "FigureYa317RoeDot",
      "thumb": "gallery_compress/FigureYa317RoeDot.webp"
    },
    "word_count": 751,
    "lines_count": 209,
    "title": "FigureYa317RoeDot",
    "description": "Requirements Description 基于Ro/e分析对这些细胞亚群进行了组织富集分析，结果观察到肥大细胞和髓系细胞优先分布在动脉粥样硬化核心(AC)部位，而淋巴细胞优先分布在邻近部位。 Tissue enrichment analysis based on Ro/e revealed that mast cells and",
    "input_data_types": [
      "临床数据",
      "表达矩阵",
      "单细胞"
    ],
    "output_types": [
      "热图",
      "统计表格"
    ],
    "technical_methods": [
      "通路分析"
    ],
    "biology_areas": [
      "免疫学"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "to",
      "label",
      "ticks",
      "values",
      "acc",
      "width",
      "grid",
      "pvalue",
      "object"
    ]
  },
  {
    "id": "main_FigureYa87fish_FigureYa87fish",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa87fish_FigureYa87fish.txt",
    "content": "FigureYa87fish\nFigureYa87fish\nAuthor(s)\n: Chengli Song, Taojun Ye\nReviewer(s)\n: Ying Ge\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n用R画文章里的这种肿瘤克隆进化的图。\nRequirement description\nDraw a graph of the evolution of tumor clones in the article using\nR.\n出自\nhttps://www.nature.com/articles/leu2014289\nfrom\nhttps://www.nature.com/articles/leu2014289\n应用场景\nApplication scenarios\nCreate timecourse “fish plots” that show changes in the clonal\narchitecture of tumors,\nhttps://github.com/chrisamiller/fishplot\n展示肿瘤细胞克隆进化的时间、比例等信息。\n像例文那样，在三维时间节点上共鉴定到4个克隆群，我们可以看到其中founding\nclone\n在三个时间点上占比都非常高，70%左右，除去这个主克隆外，还有三个亚克隆，在三个时间点上变化比较大，其中主要是subclone\n1 的逐渐消失，subclone2 的逐渐扩增以及subclone 3的从无到有。\n题外话：\n还有一个R包timescape，画clonal\nevolution这种鱼图也很美，\nhttps://bioconductor.org/packages/release/bioc/vignettes/timescape/inst/doc/timescape_vignette.html\n。\n克隆进化图有点像sankey，我拿来FigureYa25sankey对比着看，理解更透彻。\nDisplay information such as the time and proportion of tumor cell\nclone evolution.\nAs shown in the example text, a total of four clone groups were\nidentified at three-dimensional time points. We can see that the\nproportion of founding clones was very high at three time points, about\n70%. In addition to the main clone, there were three subclones with\nsignificant changes at the three time points, mainly the gradual\ndisappearance of subclone 1, the gradual expansion of subclone 2, and\nthe emergence of subclone 3 from scratch.\n**Off topic: * * There is also an R package called timescape, which\nis also very beautiful for drawing fish images like clonal evolution<\nhttps://bioconductor.org/packages/release/bioc/vignettes/timescape/inst/doc/timescape_vignette.html\n>.\nThe clone evolution diagram is a bit like a sankey. I compared it\nwith FigureYa25sankey for a more thorough understanding.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\n# 加载fishplot包，用于生成白血病克隆演化的鱼群图\n# Load the fishplot package for generating fish plots of leukemia clonal evolution\nlibrary(fishplot)\n# 设置环境变量使R显示英文错误信息，便于查找解决方案\n# Set environment variable to display error messages in English for easier troubleshooting\nSys.setenv(LANGUAGE = \"en\") \n\n# 全局设置禁止将字符型数据自动转换为因子类型，避免意外的数据转换\n# Globally disable automatic conversion of character strings to factors to prevent unexpected data transformation\noptions(stringsAsFactors = FALSE)\n输入数据\n需要三种输入：\neasy_input.txt，每行表示每个克隆群在不同时间节点的VAF/CCF\n占比，每列表示每个时间节点中各个克隆簇的情况。\ntimepoints，用来定义easy_input.txt的四列对应的4个时间节点。其中therapyTime列是化疗后休复期推断出的克隆群整体状况。\nparents，与时间节点相对应的各个克隆群进化关系。例图中，“0”表示主克隆，“1,\n1”表示在主克隆之后有两个平行发展的亚克隆簇，“3”表示在这个克隆簇发生时，已经有两次克隆事件。进一步根据各个时间节点，各个克隆簇占比情况，脚本便可实现。为便于理解parents的写法，结尾附上了几个例子。\nInput data\nThree types of inputs are required:\neasy_input.txt， Each row represents the VAF/CCF ratio of each\nclone group at different time points, and each column represents the\nsituation of each clone cluster at each time point.\ntimepoints， Used to define the four time nodes corresponding to\nthe four columns of easy_input.txt. The treatyTime column represents the\noverall status of the clone population inferred during the recovery\nperiod after chemotherapy.\nparents， The evolutionary relationship of each clone group\ncorresponding to the time node. In the example diagram, “0” represents\nthe main clone, “1, 1” represents two parallel sub clone clusters after\nthe main clone, and “3” represents that there have been two cloning\nevents occurring in this clone cluster. Further, based on the proportion\nof each clone cluster at each time node, the script can be implemented.\nFor the convenience of understanding the writing of ‘parents’, several\nexamples are attached at the end.\n# 从easy_input.txt文件读取数据，指定表头和制表符分隔符，并将第一列设为行名\n# Read data from easy_input.txt with headers, tab-separated, using first column as row names\nfrac <- read.table(\"easy_input.txt\", header=T, sep='\\t', row.names=1)\n\n# 显示读取的数据内容（可选调试步骤）\n# Display the loaded data (optional for debugging)\nfrac\n# 将数据框转换为矩阵格式，便于后续计算\n# Convert data frame to matrix format for numerical calculations\nfrac.table <- as.matrix(frac)\n\n# 定义时间点向量，控制鱼群图中各克隆的时间进程长度比例\n# Define time points vector to control the proportional lengths of fish head, body, and tail\ntimepoints <- c(0, 75, 110, 120) \n\n# 定义克隆谱系关系，每个元素表示对应克隆的父克隆ID（0表示无父克隆）\n# Define clonal lineage relationships (each value is the parent clone ID, 0 for root)\nparents <- c(0, 1, 1, 3)\n题外话：\n除了用上述方法构建输入以外，还可以用CloneEvol输出的结果作为输入，fisherplot可以跟ClonEvol（擅长画树枝图）无缝对接，详见：\nhttps://github.com/chrisamiller/fishplot\n里的“clonevol\nintegration”\n**Off topic: In addition to using the above methods to construct\ninputs, you can also use the results output by CloneEvol as inputs.\nFisherplot can seamlessly integrate with ClonEvol (which is good at\ndrawing tree branches), as shown in:<\nhttps://github.com/chrisamiller/fishplot\n>The\n‘clonevol integration’ in\n开始画图\nStart drawing\n# 创建fishplot对象，输入数据为克隆频率矩阵、谱系关系和时间点\n# Create fishplot object with clone frequency matrix, lineage relationships and timepoints\nfish <- createFishObject(frac.table, parents, timepoints)\n\n# 设置每个克隆的显示颜色（支持HTML颜色代码）\n# Set colors for each clone using HTML color codes\nfish <- setCol(fish, c(\"#099D79\", \"#70C7EC\", \"#E8262D\", \"#2C3789\"))\n\n# 自动计算克隆的布局结构，确定各克隆在图中的位置关系\n# Automatically calculate clone layout and positional relationships\nfish <- layoutClones(fish)\n\n# 取消注释此行可将图形输出为PDF文件\n# Uncomment to export plot as PDF file\n#pdf('fish.pdf', width=10, height=6)\n\n# 调整图形边距，在底部留出空间用于放置图例\n# Adjust plot margins to make space for legends at the bottom\npar(mar = par()$mar + c(0,0,3,0))\n\n# 绘制鱼群图展示克隆演化过程\n# Generate fishplot to visualize clonal evolution\nfishPlot(fish, shape = \"spline\",         # 曲线类型：spline(平滑曲线)或polygon(折线) / Curve type: spline or polygon\n         #title.btm = \"Clonal architecture of tumors\",  # 左下角标题(已注释) / Bottom-left title (commented)\n         cex.title = 1.2,               # 标题字号大小 / Title font size\n         pad.left = 0.25,               # 鱼头部分的倾斜角度参数 / Left padding for fish head angle\n         \n         vlines = timepoints[c(1:2,4)],  # 在指定时间点绘制垂直参考线 / Vertical lines at specified timepoints\n         col.vline = \"white\",           # 参考线颜色 / Color of vertical lines\n         vlab = c(\"PMF\", \"sAML\", \"sAML\\nREM\"),  # 垂直参考线对应的标签 / Labels for vertical lines\n         \n         bg.col = c(\"#F1F2F2\",\"#F1F2F2\",\"#F1F2F2\"),  # 背景颜色设置 / Background colors\n         border = 0.1                   # 克隆轮廓线宽度 / Clone border width\n         )\n\n# 如果需要将垂直参考线显示为虚线，取消此行注释\n# Uncomment to show vertical lines as dashed\n#abline(v=timepoints[c(1:2,4)], col=\"white\", lty=2, lwd=1)\n\n# 添加图例：显示每个克隆在PMF阶段的比例\n# Add legend for PMF stage percentages\npar(xpd = T)  # 允许图形元素绘制在绘图区域外 / Allow elements outside plot area\nlegend(\"bottomright\", \n       inset=c(.7,-.3),  # 控制图例位置(调整以适应图形) / Legend position (adjust to fit)\n       pch=16, bty=\"n\",  # 点形状和无边框 / Point shape and no border\n       col=fish@col, text.col = fish@col,  # 使用克隆对应颜色 / Use clone colors\n       legend = paste0(row.names(frac),\" \",frac$PMF,\"%\"))  # 图例内容 / Legend content\n\n# 添加图例：显示每个克隆在sAML阶段的比例\n# Add legend for sAML stage percentages\nlegend(\"bottomright\", \n       inset=c(.3,-.3),  # 调整位置 / Adjust position\n       pch=16, bty=\"n\", \n       col=fish@col, text.col = fish@col,\n       legend = paste0(frac$sAML,\"%\"))\n\n# 添加图例：显示每个克隆在sAML_REM阶段的比例\n# Add legend for sAML_REM stage percentages\nlegend(\"bottomright\", \n       inset=c(.0,-.3),  # 调整位置 / Adjust position\n       pch=16, bty=\"n\", \n       col=fish@col, text.col = fish@col,\n       legend = paste0(frac$Saml_REM,\"%\"))\n# 取消注释此行以关闭PDF图形设备\n# Uncomment to finalize PDF output\n#dev.off()\n后期加工处理\n前面输出的fish.pdf文件是矢量图，可以用illustrator等工具编辑，例如添加例文中的点、基因名，移动文字位置等等。\n或者用\nexport包\n导出矢量图，用ppt就能编辑。\nPost processing processing\nThe fish. pdf file output earlier is a vector image that can be\nedited using tools such as Illustrator, such as adding points and gene\nnames from example texts, moving text positions, and so on.\nOr use the [export package]（\nhttps://mp.weixin.qq.com/s/QziYUmpag1MQRkN_xfvZJQ\n）Export vector graphics and edit them using PowerPoint.\n附\n如果有更多克隆，要怎样设置parents，能再举个例子吗？\nAttached\nIf there are more clones, how can parents be set? Can you give\nanother example?\n# 从easy_input2.txt读取克隆频率数据，设置表头和制表符分隔符，第一列作为行名\n# Read clone frequency data from easy_input2.txt with headers, tab-separated, first column as row names\nfrac.table <- read.table(\"easy_input2.txt\", header=T, sep='\\t', row.names=1)\n\n# 显示读取的数据内容（调试用）\n# Display loaded data (for debugging)\nfrac.table\n# 将数据框转换为矩阵格式，适应fishplot包的输入要求\n# Convert data frame to matrix format for fishplot input\nfrac.table <- as.matrix(frac.table)\n\n# 定义时间点向量，控制鱼群图中各阶段的时间轴比例\n# Define time points to control temporal scale of the fishplot\ntimepoints <- c(0, 30, 75, 150) \n\n# 定义克隆演化关系（父克隆ID）：\n# 0表示无父克隆（初始克隆），其他数字表示对应行的父克隆\n# Define clonal lineage relationships (parent clone IDs):\n# 0 indicates no parent (root clone), others reference row indices\nparents <- c(0, 1, 2, 0, 4, 5)\n\n# 取消注释此行将图形输出为PDF文件\n# Uncomment to save plot as PDF\n#pdf('fish2.pdf', width=8, height=5)\n\n# 创建鱼群图对象，整合克隆频率、演化关系和时间信息\n# Create fishplot object with clone frequencies, lineage, and timepoints\nfish <- createFishObject(frac.table, parents, timepoints)\n\n# 自动计算克隆的空间布局，优化视觉展示效果\n# Calculate optimal spatial layout for clones\nfish <- layoutClones(fish)\n\n# 绘制鱼群图，使用平滑曲线连接各时间点的克隆丰度\n# Generate fishplot with spline curves connecting clone abundances\nfishPlot(fish, shape=\"spline\")\n# 取消注释此行关闭图形设备\n# Uncomment to finalize PDF output\n#dev <- dev.off()\n再进一步，互相对比着看fishplot自带的三条鱼\nhttps://github.com/chrisamiller/fishplot\n对应的代码：\nhttps://github.com/chrisamiller/fishplot/blob/master/tests/test.R\n，就能掌握写parents的规律。\nFurthermore, compare the three fish included in the fishplot with\neach other<\nhttps://github.com/chrisamiller/fishplot\n>Corresponding code:<\nhttps://github.com/chrisamiller/fishplot/blob/master/tests/test.R\n>You can master the rules of writing parents.\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa87fish_FigureYa87fish",
      "title": "FigureYa87fish/FigureYa87fish.html",
      "html": "FigureYa87fish/FigureYa87fish.html",
      "text": "texts/main_FigureYa87fish_FigureYa87fish.txt",
      "folder": "FigureYa87fish",
      "thumb": "gallery_compress/FigureYa87fish.webp"
    },
    "word_count": 1196,
    "lines_count": 259,
    "title": "FigureYa87fish",
    "description": "用R画文章里的这种肿瘤克隆进化的图。 Requirement description Draw a graph of the evolution of tumor clones in the article using",
    "input_data_types": [],
    "output_types": [
      "统计表格"
    ],
    "technical_methods": [],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "header",
      "lwd",
      "width",
      "vlab",
      "legend",
      "col",
      "vline",
      "mar",
      "inset"
    ]
  },
  {
    "id": "main_FigureYa253panGSEA_FigureYa253panGSEA",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa253panGSEA_FigureYa253panGSEA.txt",
    "content": "FigureYa253panGSEA\nFigureYa253panGSEA\nXiaofan Lu\n2025-5-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n基于FPI最高30%和最低30%的两个肿瘤组的转录组，对每个肿瘤进行基因集富集分析(GSEA)，研究高FPI和低FPI肿瘤组织之间的通路差异。\nRequirement Description\nBased on the transcriptome of the two tumor groups with the highest\nand lowest 30% FPI, gene set enrichment analysis (GSEA) was performed\nfor each tumor to study the pathway differences between high and low FPI\ntumor tissues.\n出自\nhttps://www.cell.com/iscience/fulltext/S2589-0042(20)30489-2?_returnURL=https%3A%2F%2Flinkinghub.elsevier.com%2Fretrieve%2Fpii%2FS2589004220304892%3Fshowall%3Dtrue\nfrom\nhttps://www.cell.com/iscience/fulltext/S2589-0042(20)30489-2?_returnURL=https%3A%2F%2Flinkinghub.elsevier.com%2Fretrieve%2Fpii%2FS2589004220304892%3Fshowall%3Dtrue\nFigure 3. Relationships between Ferroptosis and Signaling Pathways\nand Immunophenotypes (A and B) Enrichment analysis for metabolism\npathway (A) and cancer signaling (B) between high- and low-FPI tumor\ntissues. NES is the normalized enrichment score in the GSEA\nalgorithm.\n应用场景\n根据某一个基因的表达量高低给样本分组，然后做分组间的差异表达分析，进一步用差异分析结果做GSEA富集分析，可以推测该基因影响了哪些通路。\n进一步拓展，可将上述“某一个基因的表达量”替换为“某个基因集的富集得分”，就像这篇例文，用一组基因计算出的FPI值给样本分组，然后做分组间的差异表达分析，进一步用差异分析结果做GSEA富集分析，可以推测该基因集（FPI）跟哪些通路相关。\nApplication Scenarios\nThe samples were grouped according to the expression level of a\ncertain gene, and then the differential expression analysis between the\ngroups was performed, and the GSEA enrichment analysis was performed\nwith the results of differential analysis, which pathways affected by\nthe gene could be inferred.\nFor further expansion, you can replace the above “expression level of\na certain gene” with “enrichment score of a certain gene set”, just like\nthis example, use the FPI value calculated by a group of genes to group\nthe samples, and then do differential expression analysis between\ngroups, and further use the results of differential analysis to do GSEA\nenrichment analysis, you can infer which pathways the gene set (FPI) is\nassociated with.\n本文档将提供这两种情况的解决方案。\nThis document will provide solutions for both scenarios.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nlibrary(clusterProfiler)\nlibrary(limma)\nlibrary(ggplot2)\nlibrary(data.table)\nlibrary(ggpubr)\nlibrary(GSVA)\nsource(\"twoclasslimma.R\")\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # error messages are displayed in English\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # chr is not allowed to be converted to factor\n输入文件\neasy_input_sample_annotation.txt，样本分组信息。整理自注释文件merged_sample_quality_annotations.tsv，下载自\nhttp://api.gdc.cancer.gov/data/1a7d7be8-675d-4e60-a105-19d4121bdebf\n。\nEBPlusPlusAdjustPANCAN_IlluminaHiSeq_RNASeqV2.geneExp.tsv，表达矩阵，第一列是基因，之后是其在每个样本中的表达量。下载自\nhttp://api.gdc.cancer.gov/data/3586c0da-64d0-4b74-a449-5ff4d9136611\n。这里以TCGA数据为例，对于非肿瘤数据或其他物种数据，套用其格式即可，可忽略文中对筛选正常样本的代码，搜索“非TCGA数据”着重修改。\nInput files\neasy_input_sample_annotation.txt. Sample grouping information.\nOrganize the self-annotated file merged_sample_quality_annotations.tsv,\ndownload it from\nhttp://api.gdc.cancer.gov/data/1a7d7be8-675d-4e60-a105-19d4121bdebf\n.\nEBPlusPlusAdjustPANCAN_IlluminaHiSeq_RNASeqV2. geneExp.tsv, the\nexpression matrix, with the gene in the first column, followed by its\nexpression in each sample. Download from\nhttp://api.gdc.cancer.gov/data/3586c0da-64d0-4b74-a449-5ff4d9136611\n.\nTaking TCGA data as an example, for non-tumor data or other species\ndata, you can apply its format, you can ignore the code for screening\nnormal samples in the text, and search for “non-TCGA data” to focus on\nmodification.\n# 注释文件预处理\n# Preprocessing of annotation files\nrawAnno <- read.delim(\"merged_sample_quality_annotations.tsv\",sep = \"\\t\",row.names = NULL,check.names = F,stringsAsFactors = F,header = T) \nrawAnno$simple_barcode <- substr(rawAnno$aliquot_barcode,1,15)\nsamAnno <- rawAnno[!duplicated(rawAnno$simple_barcode),c(\"cancer type\", \"simple_barcode\")]\nsamAnno <- samAnno[which(samAnno$`cancer type` != \"\"),]\n# 输出样本分组信息\n# Output sample grouping information\nwrite.table(samAnno,\"easy_input_sample_annotation.txt\",sep = \"\\t\",row.names = F,col.names = T,quote = F)\n# 直接读取样本信息，这里是每个sample对应的肿瘤类型\n# Read the sample information directly, here is the tumor type corresponding to each sample\nsamAnno <- read.table(\"easy_input_sample_annotation.txt\", sep = \"\\t\",header = T, check.names = F)\n\n# 快速读取表达谱数据并做数据预处理\n# Quickly read the expression spectrum data and do data preprocessing\nexpr <- fread(\"EBPlusPlusAdjustPANCAN_IlluminaHiSeq_RNASeqV2.geneExp.tsv\",sep = \"\\t\",stringsAsFactors = F,check.names = F,header = T)\nexpr[1:3,1:3]\nexpr <- as.data.frame(expr); rownames(expr) <- expr[,1]; expr <- expr[,-1]\ngene <- sapply(strsplit(rownames(expr),\"|\",fixed = T), \"[\",1)\nexpr$gene <- gene\nexpr <- expr[!duplicated(expr$gene),]\nrownames(expr) <- expr$gene; expr <- expr[,-ncol(expr)]\nexpr[expr < 0] <- 0 # 对于这份泛癌数据，将略小于0的数值拉到0，否则不能取log（其他途径下载的泛癌数据可能不需要此操作） # For this pan-cancer data, pull the value slightly less than 0 to 0, otherwise the log cannot be retrieved (pan-cancer data downloaded from other channels may not need this operation)\ncolnames(expr) <- substr(colnames(expr),1,15) # 非TCGA数据可忽略这行 # This line can be ignored for non-TCGA data\ngc()\n用基因集计算富集得分（就像例文的FPI）\n两种情况，任选其一：\n第一种，用某一个基因的表达量给样本分为该基因表达量高低两组；\nCalculate the enrichment score from the gene set (like FPI in the\nexample)\nChoose one of two scenarios:\nFirst, the expression level of a certain gene is used to divide the\nsample into two groups: high and low expression of the gene;\ngenelist <- \"TP53\" # 以TP53为例 # Take TP53 as an example\nes <- log2(expr[rownames(expr) == genelist,] + 1) \nrow.names(es) <- \"genelist\"\n第二种，用基因集（例如例文用一组基因计算FPI）给样本分为该基因集富集得分高低两组。\nSecond, the samples are divided into two groups: the gene set is used\n(e.g., FPI is calculated with a set of genes) to divide the samples into\ntwo groups: the gene set enrichment score is high.\n# 把自己感兴趣的基因集写进easy_input_genelist.txt这个文件\n# 读取感兴趣的基因\n# Write the gene set you are interested in into easy_input_genelist.txt file\n# Read the gene of interest\n#genelist <- read.table(\"easy_input_genelist.txt\", header = T)$GeneSymbol\n# 或者直接从原文获取感兴趣的基因集 (TTC35/EMC2) \n# Or obtain the gene set of interest directly from the original source (TTC35/EMC2)\ngenelist <- c(\"CDKN1A\",\"HSPA5\",\"TTC35\",\"SLC7A11\",\"NFE2L2\",\"MT1G\",\"HSPB1\",\"GPX4\",\"FANCD2\",\"CISD1\",\"FDFT1\",\"SLC1A5\",\"SAT1\",\"TFRC\",\"RPL8\",\"NCOA4\",\"LPCAT3\",\"GLS2\",\"DPP4\",\"CS\",\"CARS\",\"ATP5G3\",\"ALOX15\",\"ACSL4\",\"EMC2\")\n\n# 利用GSVA计算感兴趣基因集的富集得分，作为FPI\n# The enrichment score of the gene set of interest was calculated using GSVA as FPI\nes <- gsva(expr = as.matrix(log2(expr + 1)),\n           gset.idx.list = list(\"genelist\" = genelist),\n           method = \"ssgsea\",\n           parallel.sz = 0) # 若采用LINUX或者MacOS可以设置为0，Windows请设置为1 # If you are using LINUX or MacOS, you can set it to 0, and Windows can set it to 1\nwrite.table(es, file = \"output_ssgsea enrichment score of interested gene list in pancancer.txt\",sep = \"\\t\",row.names = T,col.names = NA,quote = F)\nes <- read.table(\"output_ssgsea enrichment score of interested gene list in pancancer.txt\", sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\n差异分析及富集分析\nh.all.v7.2.symbols.gmt，这里使用的是HALLMARK背景集，可以改为自己感兴趣的基因集合，从MSigDB\nhttps://www.gsea-msigdb.org/gsea/msigdb/\n下载。\nDifference analysis and enrichment analysis\nh.all.v7.2.symbols.gmt, which uses the HALLMARK background set, can\nbe changed to your own gene collection of interest and downloaded from\nMSigDB\nhttps://www.gsea-msigdb.org/gsea/msigdb/\n.\n# 加载富集分析背景geneset\n# Load the enrichment analysis background geneset\nmsigdb.hallmark <- read.gmt(\"h.all.v7.2.symbols.gmt\") \n\n# 30%阈值来定义高低组（原文所述）\n# 30% threshold to define high and low groups (As stated in the original text)\npct <- 0.3 \n\ngseaTab <- NULL\n\n# 接下来批量做这些肿瘤中FPI高低的差异分析及GSEA富集分析\n# Next, batch FPI difference analysis and GSEA enrichment analysis were performed\ntumors <- c(\"BLCA\",\"BRCA\",\"CESC\",\"CHOL\",\"COAD\",\n            \"ESCA\",\"GBM\",\"HNSC\",\"KICH\",\"KIRC\",\n            \"KIRP\",\"LIHC\",\"LUAD\",\"LUSC\",\"PAAD\",\n            \"PRAD\",\"READ\",\"STAD\",\"THCA\",\"UCEC\") #注意：这里包含正常和肿瘤样本 # Note: Normal and tumor samples are included here\nfor (i in tumors) {\n  message(\"--\",i,\"...\")\n  sam <- samAnno[which(samAnno$`cancer type` == i),\"simple_barcode\"]\n  comsam <- intersect(colnames(es), sam) # 得到特定肿瘤类型中基因集的富集得分（或某一基因的表达量） # Obtain enrichment scores (or expression of a gene) in a specific tumor type\n  \n  tumsam <- comsam[substr(comsam,14,14) == \"0\"] # 仅提取肿瘤样本 # Only tumor samples are taken\n  # tumsam <- comsam # 对于非TCGA数据，可将上面一行替换为这行 # For non-TCGA data, you can replace the above row with this row\n  es_subset <- as.data.frame(t(es[,tumsam]))\n  es_subset <- es_subset[order(es_subset$genelist,decreasing = T),,drop = F] # 对富集得分（或基因表达量）排序 # Sort the enrichment score (or gene expression).\n  \n  high.es <- rownames(es_subset[1:(nrow(es_subset) * pct),,drop = F]) # 取前30%为高组 # The top 30% is the high group\n  low.es <- rownames(es_subset[nrow(es_subset):(nrow(es_subset) - nrow(es_subset) * pct + 1),,drop = F]) # 取后30%为低组 # The last 30% is the low group\n  \n  # 高低两组样本的limma差异表达分析\n  # Differential expression analysis of LIMMA between the two groups of samples\n  subt <- data.frame(condition = rep(c(\"high\",\"low\"),c(length(high.es),length(low.es))),\n                     row.names = c(high.es, low.es),\n                     stringsAsFactors = F)\n  gset <- log2(na.omit(expr[,rownames(subt)]) + 1)\n  twoclasslimma(subtype  = subt, # 亚型信息（必须包含一列为condition） # Subtype information (must contain a column condition)\n                featmat  = gset, # 表达谱（会自动检测数据标准化与否） # Expression profile (automatically detects whether the data is normalized or not)\n                treatVar = \"high\", # “治疗组”的名字 # Name of \"Treatment Group\".\n                ctrlVar  = \"low\", # “对照组”的名字 # Name of the \"control group\".\n                prefix   = paste0(\"TCGA_enrichment_score_\",i), # 差异表达文件的前缀 # The prefix of the diff file\n                overwt   = T, # 决定是否覆盖已经存在的差异表达结果 # Decide whether to overwrite existing differential expression results\n                sort.p   = F, # 决定是否对结果按照FDR排序 # Decide whether to sort the results by FDR\n                verbose  = TRUE, # 决定是否显示一些提示 # Decide if to show some prompts\n                res.path = \".\") # 确定结果路径 # Determine the result path\n  \n  # 加载差异表达分析结果\n  # Load differential expression analysis results\n  res <- read.table(paste0(\"TCGA_enrichment_score_\",i,\"_limma_test_result.high_vs_low.txt\"),sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\n  \n  # 产生pre-ranked基因列表\n  # Generate a list of pre-ranked genes\n  res <- res[order(res$log2fc, decreasing = T),]\n  glist <- res$log2fc; names(glist) <- rownames(res)\n  \n  # 运行GSEA富集分析\n  # Run a GSEA enrichment analysis\n  set.seed(20211114)\n  gsea <- GSEA(geneList = glist,\n               pvalueCutoff = 1, # 得到所有结果 # Get all results\n               seed = TRUE,\n               TERM2GENE = msigdb.hallmark)\n  gc()\n  gsea.df <- as.data.frame(gsea) # 数据转换为数据框 # Convert data to data frames\n  write.table(gsea.df,file = \"output_gsea between high and low group of enrichment score in pancancer.txt\",sep = \"\\t\",row.names = T,col.names = NA,quote = F)\n  \n  gseaTab <- rbind.data.frame(gseaTab,\n                              data.frame(term = gsea.df$ID,\n                                         NES = gsea.df$NES,\n                                         FDR = gsea.df$p.adjust,\n                                         tumor = i,\n                                         stringsAsFactors = F),\n                              stringsAsFactors = F)\n}\n# 将所有肿瘤的富集分析结果输出到文件\n# Output the results of the enrichment analysis of all tumors to a file\nwrite.table(gseaTab, \"output_TCGA_pancan_gsea_regarding_es_group.txt\",sep = \"\\t\",row.names = F,col.names = T,quote = F)\n开始画图 - Figure 3A\nStart Drawing - Figure 3A\n# 设置颜色\n# Set the color\ndarkblue <- \"#303B7F\"\ndarkred <- \"#D51113\"\nyellow <- \"#EECA1F\"\n\n# 生成泡泡图\n# Generate a bubble map\ntmp <- gseaTab\ntmp$term <- gsub(\"HALLMARK_\",\"\",tmp$term)\nmy_palette <- colorRampPalette(c(darkblue,yellow,darkred), alpha=TRUE)(n=128)\nggplot(tmp, aes(x=tumor,y=term)) +\n  geom_point(aes(size=-log10(FDR),color=NES)) +\n  scale_color_gradientn('NES', \n                        colors=my_palette) + \n  theme_bw() +\n  theme(panel.grid.minor = element_blank(), \n        panel.grid.major = element_blank(),\n        axis.text.x = element_text(angle = 45, size = 12, hjust = 0.3, vjust = 0.5, color = \"black\"),\n        axis.text.y = element_text(size = 10, color = \"black\"),\n        axis.title = element_blank(),\n        panel.border = element_rect(size = 0.7, linetype = \"solid\", colour = \"black\"),\n        legend.position = \"bottom\",\n        plot.margin = unit(c(1,1,1,1), \"lines\"))\nggsave(\"GSEA regarding enrichment score group in pancancer.pdf\", width = 12,height = 10)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa253panGSEA_FigureYa253panGSEA",
      "title": "FigureYa253panGSEA/FigureYa253panGSEA.html",
      "html": "FigureYa253panGSEA/FigureYa253panGSEA.html",
      "text": "texts/main_FigureYa253panGSEA_FigureYa253panGSEA.txt",
      "folder": "FigureYa253panGSEA",
      "thumb": "gallery_compress/FigureYa253panGSEA.webp"
    },
    "word_count": 1452,
    "lines_count": 251,
    "title": "FigureYa253panGSEA",
    "description": "基于FPI最高30%和最低30%的两个肿瘤组的转录组，对每个肿瘤进行基因集富集分析(GSEA)，研究高FPI和低FPI肿瘤组织之间的通路差异。 Requirement Description Based on the transcriptome of the two tumor groups with the highest",
    "input_data_types": [
      "临床数据",
      "表达矩阵",
      "RNA-seq"
    ],
    "output_types": [
      "火山图",
      "统计表格"
    ],
    "technical_methods": [
      "通路分析",
      "标准化",
      "质量控制",
      "差异表达分析"
    ],
    "biology_areas": [
      "癌症研究",
      "药物研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "colour",
      "seed",
      "header",
      "width",
      "n",
      "pvalue",
      "vjust",
      "NES",
      "prefix"
    ]
  },
  {
    "id": "main_FigureYa309cell2location_02_cell2location_signature",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa309cell2location_02_cell2location_signature.txt",
    "content": "02_cell2location_signature\nIn [1]:\nimport\nscanpy\nas\nsc\nimport\nnumpy\nas\nnp\nimport\nmatplotlib.pyplot\nas\nplt\nimport\nmatplotlib\nas\nmpl\nimport\ncell2location\nfrom\ncell2location.utils\nimport\nselect_slide\nfrom\nmatplotlib\nimport\nrcParams\nrcParams\n[\n'pdf.fonttype'\n]\n=\n42\n# enables correct plotting of text for PDFs\nIn [2]:\nresults_folder\n=\n'./results/'\n# create paths and names to results folders for reference regression and cell2location models\nref_run_name\n=\nf\n'\n{\nresults_folder\n}\n/reference_signatures'\nrun_name\n=\nf\n'\n{\nresults_folder\n}\n/cell2location_map'\nLoad datasets\n¶\n读入scRNA-seq参考数据\nIn [3]:\n# Read data\nadata_ref\n=\nsc\n.\nread\n(\n\"data/RCC_upload_final_raw_counts.h5ad\"\n)\n作者原文做了两层注释：\nmajor cell type:\nadata_ref.obs['broad_type']\nminor cell type:\nadata_ref.obs['annotation']\nIn [4]:\nadata_ref\n.\nobs\n.\nhead\n()\nOut[4]:\norig.ident\nnCount_RNA\nnFeature_RNA\npatient\npercent.mt\nsummaryDescription\nannotation\nregion\nbroad_type\n5739STDY7958790_AACTCAGTCCTCAACC-1\n5739STDY7958790\n4916.0\n301\nPD43948\n3.641172\nBlood\nPlasma-IgG\nb\nPlasma\n5739STDY7958790_AAGTCTGTCGGATGGA-1\n5739STDY7958790\n2708.0\n903\nPD43948\n7.053176\nBlood\nSwitched-memory_B\nb\nB-cell\n5739STDY7958790_ACACCCTGTGTGAAAT-1\n5739STDY7958790\n4575.0\n672\nPD43948\n2.710383\nBlood\nPlasma-IgA\nb\nPlasma\n5739STDY7958790_ACATGGTTCAGTTTGG-1\n5739STDY7958790\n2931.0\n1361\nPD43948\n8.597748\nBlood\nNaïve_B.2\nb\nB-cell\n5739STDY7958790_ACCGTAAGTCTTCTCG-1\n5739STDY7958790\n5965.0\n266\nPD43948\n0.670578\nBlood\nPlasma-IgA\nb\nPlasma\nIn [5]:\nadata_ref\n.\nshape\nOut[5]:\nIn [6]:\nsc\n.\npl\n.\numap\n(\nadata_ref\n,\ncolor\n=\n\"annotation\"\n)\nTwo major steps were in analysis using cell2location:\nWe applied a negative binomial regression model implemented in cell2location and estimated the reference signature of cell types we annotated based on scRNA-seq data. In this step, we used an unnormalized mRNA count matrix as input and filtered it to 13,042 genes and 261,202 cells (cells that were annotated as unknown, low-quality and patient specific were removed from this analysis). Donor IDs were regarded as the batch category and the following parameters were used to train the model: ‘max_epochs’ = 120, ‘batch_size’ = 2500, ‘train_size’ = 1 and ‘Ir’ = 0.002.\n按照作者Method部分的描述，我们首先对单细胞数据中的\nunknown\n,\nlow quanlity\n以及\npatient-specific\n细胞类型进行过滤\nIn [7]:\nremoved_labels\n=\n[\n'Unknown'\n,\n'Low quality'\n,\n'CD4+T_Naïve/CM-patient-specific.1'\n,\n'CD4+T_Naïve/CM-patient-specific.2'\n]\nadata_ref\n.\nobs\n[\n'annotation'\n]\n.\nisin\n(\nremoved_labels\n)\n.\nvalue_counts\n()\nOut[7]:\nIn [8]:\nadata_ref\n=\nadata_ref\n[\n~\nadata_ref\n.\nobs\n[\n'annotation'\n]\n.\nisin\n(\nremoved_labels\n)]\nadata_ref\nOut[8]:\n过滤基因\n作者最终保留了13,042个基因，但由于他没有告诉我们过滤标准，这里我们采用官方文档采用的过滤参数。\nIn [9]:\nfrom\ncell2location.utils.filtering\nimport\nfilter_genes\nselected\n=\nfilter_genes\n(\nadata_ref\n,\ncell_count_cutoff\n=\n5\n,\ncell_percentage_cutoff2\n=\n0.03\n,\nnonz_mean_cutoff\n=\n1.12\n)\n# filter the object\nadata_ref\n=\nadata_ref\n[:,\nselected\n]\n.\ncopy\n()\nstep1 Training reference models\n¶\npatient\nwere regarded as the batch category\nIn [10]:\n# prepare anndata for the regression model\ncell2location\n.\nmodels\n.\nRegressionModel\n.\nsetup_anndata\n(\nadata\n=\nadata_ref\n,\n# 10X reaction / sample / batch\nbatch_key\n=\n'patient'\n,\n# cell type, covariate used for constructing signatures\nlabels_key\n=\n'annotation'\n# multiplicative technical effects (platform, 3' vs 5', donor effect)\n# categorical_covariate_keys=['Method']\n)\nIn [11]:\n# create the regression model\nfrom\ncell2location.models\nimport\nRegressionModel\nmod\n=\nRegressionModel\n(\nadata_ref\n)\n# view anndata_setup as a sanity check\nmod\n.\nview_anndata_setup\n()\nthe following parameters were used to train the model:\n‘max_epochs’ = 120,\n‘batch_size’ = 2500, (default)\n‘train_size’ = 1 (default)\n‘Ir’ = 0.002 (default)\n保证服务器有足够多空闲的核，默认使用一半线程\nIn [16]:\nimport\ntorch\nif\ntorch\n.\ncuda\n.\nis_available\n():\nmod\n.\ntrain\n(\nmax_epochs\n=\n120\n,\nbatch_size\n=\n2500\n,\ntrain_size\n=\n1\n,\nlr\n=\n0.002\n,\nuse_gpu\n=\nTrue\n)\nIn [13]:\nmod\n.\ntrain\n(\nmax_epochs\n=\n120\n,\nbatch_size\n=\n2500\n,\ntrain_size\n=\n1\n,\nlr\n=\n0.002\n,\nuse_gpu\n=\nFalse\n)\n# 使用CPU计算\nIn [14]:\nmod\n.\nplot_history\n(\n20\n)\nIn [17]:\n# In this section, we export the estimated cell abundance (summary of the posterior distribution).\nadata_ref\n=\nmod\n.\nexport_posterior\n(\nadata_ref\n,\nsample_kwargs\n=\n{\n'num_samples'\n:\n1000\n,\n'batch_size'\n:\n2500\n,\n'use_gpu'\n:\nFalse\n}\n)\nIn [18]:\n# Save model\nmod\n.\nsave\n(\nf\n\"\n{\nref_run_name\n}\n\"\n,\noverwrite\n=\nTrue\n)\n# Save anndata object with results\nadata_file\n=\nf\n\"\n{\nref_run_name\n}\n/sc.h5ad\"\nadata_ref\n.\nwrite\n(\nadata_file\n)\nadata_file\nOut[18]:\n这里两个散点图(诊断图)具有正相关的趋势说明模型能够用来解释数据\nIn [19]:\nmod\n.\nplot_QC\n()\nIn [20]:\n# export estimated expression in each cluster\nif\n'means_per_cluster_mu_fg'\nin\nadata_ref\n.\nvarm\n.\nkeys\n():\ninf_aver\n=\nadata_ref\n.\nvarm\n[\n'means_per_cluster_mu_fg'\n][[\nf\n'means_per_cluster_mu_fg_\n{\ni\n}\n'\nfor\ni\nin\nadata_ref\n.\nuns\n[\n'mod'\n][\n'factor_names'\n]]]\n.\ncopy\n()\nelse\n:\ninf_aver\n=\nadata_ref\n.\nvar\n[[\nf\n'means_per_cluster_mu_fg_\n{\ni\n}\n'\nfor\ni\nin\nadata_ref\n.\nuns\n[\n'mod'\n][\n'factor_names'\n]]]\n.\ncopy\n()\ninf_aver\n.\ncolumns\n=\nadata_ref\n.\nuns\n[\n'mod'\n][\n'factor_names'\n]\ninf_aver\n.\niloc\n[\n0\n:\n5\n,\n0\n:\n5\n]\nOut[20]:\nACKR+_EC\nActivated KRT+ NK\nActivated NK\nActivated_B-AREG\nActivated_B-RHOB\nFO538757.2\n0.095478\n0.090512\n0.110985\n0.055967\n0.075919\nNOC2L\n0.138662\n0.127062\n0.117580\n0.117451\n0.114746\nPERM1\n0.002008\n0.000344\n0.000227\n0.001351\n0.002163\nHES4\n0.011849\n0.006743\n0.051286\n0.004431\n0.004672\nISG15\n0.412864\n0.386006\n0.502053\n0.174437\n0.136781\nIn [21]:\n# save inf_aver\ninf_aver\n.\nto_csv\n(\nf\n\"\n{\nref_run_name\n}\n/inf_aver.csv\"\n)\nIn [ ]:",
    "chapter_info": {
      "id": "main_FigureYa309cell2location_02_cell2location_signature",
      "title": "FigureYa309cell2location/02_cell2location_signature.html",
      "html": "FigureYa309cell2location/02_cell2location_signature.html",
      "text": "texts/main_FigureYa309cell2location_02_cell2location_signature.txt",
      "folder": "FigureYa309cell2location",
      "thumb": "gallery_compress/FigureYa309cell2location.webp"
    },
    "word_count": 825,
    "lines_count": 576,
    "title": "In [1]:",
    "description": "暂无描述",
    "input_data_types": [
      "单细胞"
    ],
    "output_types": [
      "散点图"
    ],
    "technical_methods": [
      "质量控制"
    ],
    "biology_areas": [],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "overwrite",
      "train_size",
      "selected",
      "inf_aver",
      "columns",
      "cell_count_cutoff",
      "use_gpu",
      "nonz_mean_cutoff",
      "batch_key",
      "cell_percentage_cutoff2"
    ]
  },
  {
    "id": "main_FigureYa154immuneSubtypes_FigureYa154immuneSubtypes",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa154immuneSubtypes_FigureYa154immuneSubtypes.txt",
    "content": "FigureYa154immuneSubtypes\nFigureYa154immuneSubtypes\nAuthor(s)\n: Yufang Wang\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n复现文章里的结果图 Reproduce the result graph in the article\n出自\nhttps://doi.org/10.1016/j.immuni.2018.03.023\nFrom\nhttps://doi.org/10.1016/j.immuni.2018.03.023\nFigure 1. Immune Subtypes in Cancer (A) Expression signature modules\nand identification of immune subtypes.\nTop: Consensus clustering of the pairwise correlation of cancer\nimmune gene expression signature scores (rows and columns). Five modules\nof shared associations are indicated by boxes.\nMiddle: Representative gene expression signatures from each module\n(columns), which robustly reproduced module clustering, were used to\ncluster TGCA tumor samples (rows), resulting in six immune subtypes\nC1–C6 (colored circles).\nBottom: Distributions of signature scores within the six subtypes\n(rows), with dashed line indicating the median.\n原文作者提供了代码to reproduce the signature scores and clusters，\nhttps://github.com/Gibbsdavidl/Immune-Subtype-Clustering\n。NOTE!\nThis method is very sensitive to the software pipeline used in\nquantifying genes. It does not work well with FPKM, RPKM, TPM, etc. The\noriginal author provided code to reproduce the signature scores and\nclusters,\nhttps://github.com/Gibbsdavidl/Immune-Subtype-Clustering\n.\nNOTE! This method is very sensitive to the software pipeline used to\nquantify genes. It does not work well with FPKM, RPKM, TPM, etc.\n后来又写了个R包\nImmuneSubtypeClassifier\n，more robust，\nhttps://github.com/Gibbsdavidl/ImmuneSubtypeClassifier\n，感兴趣的小伙伴可以去研究一下。\nThe author later wrote a more robust R package\nImmuneSubtypeClassifier\n,\nhttps://github.com/Gibbsdavidl/ImmuneSubtypeClassifier\n.\nInterested readers are encouraged to explore it.\n应用场景\nApplication Scenarios\n按免疫浸润定量结果给样本分类。 Classify samples based on immune\ninfiltration quantification results.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(ConsensusClusterPlus)\nlibrary(corrplot)\nlibrary(ggplot2)\nlibrary(dplyr)\nlibrary(reshape2)\n\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 #Display English error messages\noptions(stringsAsFactors = FALSE) #禁止chr转成factor #Disable conversion of chr to factor\n输入文件\nInput file\nmmc2.xlsx，即例文的Table\nS1，包含TCGA里33种癌症1万多个样本的免疫浸润结果。 mmc2.xlsx, also known\nas Table S1 in the example article, contains immune infiltration results\nfor over 10,000 samples from 33 cancer types collected by TCGA.\nWe integrated major immunogenomics methods to characterize the immune\ntumor microenvironment (TME) across 33 cancers analyzed by TCGA,\napplying methods for the assessment of total lymphocytic infiltrate\n(from genomic and H&E image data), immune cell fractions from\ndeconvolution analysis of mRNAseq data, immune gene expression\nsignatures, neoantigen prediction, TCR and BCR repertoire inference,\nviral RNA expression, and somaticDNAalterations (Table S1).\n实际应用时，可以提取其中某一种或相关的某几种癌症类型，做进一步分析。\nIn practical applications, one can extract specific or related cancer\ntypes for further analysis.\n#下载输入文件\n# Download the input file\n#download.file(\"https://ars.els-cdn.com/content/image/1-s2.0-S1074761318301213-mmc2.xlsx\",\"mmc2.xlsx\")\n\n#读入输入文件\n# Read the input file\ndata <- read.csv(file = \"mmc2.csv\", sep = \",\", header = T, stringsAsFactors = T)\ndim(data)\n# 过滤50%缺失值的\n# Filter 50% missing values\n# data2 <- data[apply(data, 1, function(x){sum(is.na(x)) < length(x)/2}),]\ndata2 <- data[apply(data, 1, function(x){sum(is.na(x)) < ncol(data)/2}),]\nmy_data <- na.omit(data2)\ndim(my_data)\nSTEP1: Consensus clustering of the pairwise correlation of cancer\nimmune gene expression signature scres\ndata2 <- my_data[,-c(1,2,3,4)]\ndim(data2)\ndata2 <- as.matrix(data2)\n##生成聚类矩阵，并保存至setp01文件夹内\n## Generate the clustering matrix and save it to the setp01 folder\nres <- ConsensusClusterPlus(data2, maxK = 6, reps = 1000, \n                            pItem = 0.8, pFeature = 1, title=\"step01\",\n                            clusterAlg = 'hc', distance=\"spearman\", seed=123456,\n                            plot=\"pdf\", #或\"png\"\n                            corUse=\"pairwise.complete.obs\",writeTable=T)\n选取\nconsensus matrix k=5\n的图作为最上面的热图 Select\n`consensus matrix The k=5 plot is used as the top heatmap.\nSTEP2: get the barcode plot of expression signatures of each Immune\nclusters\n自定义函数 Custom function\ngenset_barcode <- function (data, gennset,\n                            scale_col_low = \"#053061\", scale_col_mid = \"white\",\n                            scale_col_high = \"#67001f\", \n                            scale_col_na = \"grey50\",\n                            scale_name = NULL, \n                            scale_breaks = 5, \n                            scale_digits = 1,\n                            x_breaks = waiver())\n  {\n  ggplot(data, aes_string(\"TCGA.Participant.Barcode\", 1, fill = gennset)) +\n    geom_tile() + \n    facet_wrap(.~Immune.Subtype, nrow = 6) + #用分面把6个cluster画一起 # Use faceting to plot the six clusters together. \n    scale_x_continuous(expand = c(0, 0)) +\n    scale_y_continuous(expand = c(0,0)) + \n    scale_fill_gradient2(low = scale_col_low, \n                         mid = scale_col_mid, \n                         high = scale_col_high, \n                         na.value = scale_col_na,\n                         midpoint = mean(data[[gennset]], na.rm = TRUE), \n                         name = scale_name,\n                         breaks = function(x) seq(x[1], x[2], \n                                                  length.out = scale_breaks),\n                         labels = function(x) formatC(x, format = \"f\",\n                                                      digits = scale_digits)) + \n    labs(colour = \"geneset scores\") +\n    theme_void() +\n    coord_flip() + #坐标轴互换 #coordinate axis swap \n    \n    #图例 #legend \n    theme(legend.title.align = 1,\n          legend.position = 'top',\n          legend.direction = \"horizontal\")\n}\n画图 Draw a picture\nmy_data$IFN.gamma.Response <- as.numeric(as.character(my_data[,'IFN.gamma.Response']))\nmy_data$TCGA.Participant.Barcode <- as.numeric(as.factor(as.character(my_data[,'TCGA.Participant.Barcode'])))\n#View(my_data)\n\n# 用自定义函数画图\n# Draw a picture using a custom function\ngenset_barcode(my_data,\"IFN.gamma.Response\")\nggsave(\"step02/IFN.gamma.Response.pdf\", width = 2, height = 8)\ngenset_barcode(my_data,\"TGF.beta.Response\")\nggsave(\"step02/TGF.beta.Response.pdf\", width = 2, height = 8)\ngenset_barcode(my_data,\"Macrophages\")\nggsave(\"step02/Macrophages.pdf\", width = 2, height = 8)\ngenset_barcode(my_data,\"Lymphocytes\")\nggsave(\"step02/Lymphocytes.pdf\", width = 2, height = 8)\ngenset_barcode(my_data,\"Wound.Healing\")\nggsave(\"step02/Wound.Healing.pdf\", width = 2, height = 8)\nSTEP3: get the signature score distributions show cluster\ndifferences\n自定义函数 Custom function\n#自定义绘图函数\n#Custom drawing function\ngenset_density <- function(data,gennset, \n                           scale_col_low = \"#053061\", scale_col_mid = \"white\",\n                           scale_col_high = \"#67001f\", scale_col_na = \"grey50\",\n                           scale_name = NULL, scale_breaks = 5, scale_digits = 1, \n                           x_breaks = waiver())\n  {\n  ggplot(data, aes_string(x=gennset, fill = \"color\", group = \"color\")) +\n    geom_density() + \n    facet_wrap(Immune.Subtype~.,nrow = 6)+\n    geom_vline(aes_string(xintercept = mean(my_data[[gennset]],na.rm = TRUE)),\n               color = \"black\", linetype = \"dashed\", size = 1)+ \n    scale_fill_gradient2(low = scale_col_low,\n                         mid = scale_col_mid, \n                         high = scale_col_high,\n                         na.value = scale_col_na,\n                         midpoint = mean(data[[gennset]], na.rm = TRUE), \n                         name = scale_name,\n                         breaks = function(x) seq(x[1], x[2], length.out = scale_breaks),\n                         labels = function(x) formatC(x, format = \"f\",\n                                                      digits = scale_digits)) + \n    labs(colour = \"scaled scores\")+\n    theme_void() +\n    theme(legend.title.align = 1,\n          legend.position = 'top',\n          legend.direction = \"horizontal\")\n}\n\n#自定义归一化函数\n#Custom normalization function\nnormalization <- function(x){\n  return((x-min(x))/(max(x)-min(x)))}\n画图 Draw a picture\nmy_data$Immune.Subtype <- as.factor(as.character(my_data$Immune.Subtype))\n\n#生成并归一化映射颜色数值\n#Generate and normalize mapped color values\nmy_data$IFN.gamma.Response <- normalization(as.numeric(as.character(my_data[,'IFN.gamma.Response'],na.rm=TRUE)))\ntarget1 <- summarise(group_by(my_data,Immune.Subtype),target1=mean(IFN.gamma.Response))\nmy_data1 <- merge(my_data,as.data.frame(target1),all=T)\n\nmy_data$TGF.beta.Response <- normalization(as.numeric(as.character(my_data[,'TGF.beta.Response'],na.rm=TRUE)))\ntarget2 <- summarise(group_by(my_data,Immune.Subtype),target2=mean(IFN.gamma.Response))\nmy_data2 <- merge(my_data1,as.data.frame(target2),all=T)\n\nmy_data$Macrophages <- normalization(as.numeric(as.character(my_data[,'Macrophages'],na.rm=TRUE)))\ntarget3 <- summarise(group_by(my_data,Immune.Subtype),target3=mean(Macrophages))\nmy_data3 <- merge(my_data2,as.data.frame(target3),all=T)\n\nmy_data$Lymphocytes <- normalization(as.numeric(as.character(my_data[,'Lymphocytes'],na.rm=TRUE)))\ntarget4 <- summarise(group_by(my_data,Immune.Subtype),target4=mean(Lymphocytes))\nmy_data4 <- merge(my_data3,as.data.frame(target4),all=T)\n\nmy_data$Wound.Healing <- normalization(as.numeric(as.character(my_data[,'Wound.Healing'],na.rm=TRUE)))\ntarget5 <- summarise(group_by(my_data,Immune.Subtype),target5=mean(Wound.Healing))\nmy_data5 <- merge(my_data4, as.data.frame(target5),all=T)\n\nmy_data5$color <- my_data2$target1+my_data2$target2\nmy_data5$color <- normalization(my_data5[,'color'])\n\n#绘制图形 #draw graphics\ngenset_density(my_data5, 'IFN.gamma.Response')\nggsave(\"step03/IFN.gamma.Response.pdf\", width = 2, height = 8)\ngenset_density(my_data5, 'TGF.beta.Response')\nggsave(\"step03/TGF.beta.Response.pdf\", width = 2, height = 8)\ngenset_density(my_data5, 'Macrophages')\nggsave(\"step03/Macrophages.pdf\", width = 2, height = 8)\ngenset_density(my_data5, 'Lymphocytes')\nggsave(\"step03/Lymphocytes.pdf\", width = 2, height = 8)\ngenset_density(my_data5, 'Wound.Healing')\nggsave(\"step03/Wound.Healing.pdf\", width = 2, height = 8)\n说明 ## Notes\nC1-6的颜色区间不一致，如果需要统一，需要先整体求一个方差，然后映射回去。但是那样子的话，代码的可复制性就会降低。\nThe color ranges for C1-6 are inconsistent. To unify them, you need to\nfirst calculate the overall variance and then map them back. However,\nthis approach will reduce the reproducibility of the code.\n如果需要的话，过几天更新到V2版。 If necessary, we will update to\nversion 2 in a few days.\n可以先参考这篇\nhttps://mp.weixin.qq.com/s/yVLgGQQi0CQ9Q9UfIKl5aA\nYou\ncan refer to this article\nhttps://mp.weixin.qq.com/s/yVLgGQQi0CQ9Q9UfIKl5aA\n后期处理\nPost-Processing\n输出的pdf文件是矢量图，可以用Illustrator等矢量图软件打开，拼接、编辑图形和文字。\nThe output PDF file is a vector image and can be opened in vector\ngraphics software such as Illustrator to stitch and edit graphics and\ntext.\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa154immuneSubtypes_FigureYa154immuneSubtypes",
      "title": "FigureYa154immuneSubtypes/FigureYa154immuneSubtypes.html",
      "html": "FigureYa154immuneSubtypes/FigureYa154immuneSubtypes.html",
      "text": "texts/main_FigureYa154immuneSubtypes_FigureYa154immuneSubtypes.txt",
      "folder": "FigureYa154immuneSubtypes",
      "thumb": "gallery_compress/FigureYa154immuneSubtypes.webp"
    },
    "word_count": 1071,
    "lines_count": 264,
    "title": "FigureYa154immuneSubtypes",
    "description": "Requirement description 复现文章里的结果图 Reproduce the result graph in the article 出自",
    "input_data_types": [
      "临床数据"
    ],
    "output_types": [
      "散点图",
      "热图",
      "统计表格"
    ],
    "technical_methods": [
      "聚类分析",
      "标准化"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "clusterAlg",
      "colour",
      "seed",
      "header",
      "width",
      "target3",
      "xintercept",
      "nrow",
      "labels"
    ]
  },
  {
    "id": "main_FigureYa45V2_FigureYa45iClusterV2",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa45V2_FigureYa45iClusterV2.txt",
    "content": "FigureYa45 iCluster的教程答疑V2\nFigureYa45 iCluster的教程答疑V2\nZhougeng Xu, Taojun Ye\n2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n版本更新\n在原来的基础上，增加和修改了如下几处内容：\n修改了R 3.5.0以后的安装方法(保留低于R 3.5.0之前的安装方法)\n增加重要参数的说明\n将\niClusterPlus\n替换成最新的\niClusterBayes\n增加了结果输出部分，用于调用其他R包做热图\n增加了几个统计学和机器学习概念的解释\nVersion update\nOn the basis of the original, the following contents have been added\nand modified:\n-Modified the installation method after R 3.5.0 (retaining the\ninstallation method before R 3.5.0) -Add an explanation of important\nparameters -Replace ‘iClusterPlus’ with the latest’ iClusterBayes’`\n-Added a result output section for calling other R packages to create\nheat maps -Added explanations for several statistical and machine\nlearning concepts\n需求描述\niCluster分析过程答疑。\n另外，需要输出分类和特征基因，用于画paper里的这种热图。\nRequirement description\nQ&A on the iCluster analysis process.\nIn addition, it is necessary to output classification and feature\ngenes for drawing such heat maps in the paper.\n出自\nhttps://www.nature.com/articles/nature20805\nfrom\nhttps://www.nature.com/articles/nature20805\n可以用\nFigureYa17已分类的heatmap\n来画heatmap，从本代码输出的\noutput_clusterMembership.txt\n中取一列分类，作为sample分组信息。例图iCluster的两类完全分开，为了达到这种效果，需要单独画1类和2类，然后拼在一起。\nYou can use the ‘FigureYa17 Classified Heatmap’ to draw a heatmap,\nand take a column of classification from the ‘Output_clusterMembership.\ntxt’ output of this code as the sample grouping information. The two\ntypes of iCluster in the example diagram are completely separated. To\nachieve this effect, it is necessary to draw Class 1 and Class 2\nseparately and then assemble them together.\n应用场景\n使用iClusterPlus整合多种基因组数据。\n肿瘤的分子复杂性体现在基因组、表观组、转录组和蛋白组等多种水平。\n一种方法是单独对不同数据类型进行聚类，然后手动合并。而\niCluster\n则是同时使用多种来源数据进行整合分析，用于识别肿瘤亚型。\niCluster\n在2009年开发，中间经历了很多次的开发升级，目前最新版是Bioconductor上的\niClusterPlus\n,\n包括\niClusterPlus\n和\niClusterBayes\n两种算法。三者的区别在于:\niCluster(2009):\n使用lasso限制的隐变量回归识别可用于聚类的常见隐变量(common latent\nvariable)\niClusterPlus(2012): 整合了elasticnet和fused lasso算法,\n可以处理ontinuous, count, binary, multi-categorical类数据\niClusterBayes(2018): 改进了算法，比iClusterPlus速度快\n隐变量(latent\nvariable)是一个机器学习中的概念。举例说明，如果一个人面前有三个袋子，他每次抽球的时候都会说自己是从哪个袋子里拿了哪种颜色的球，你在旁边记录每个袋子抽出了什么颜色的球，在他抽取一定次数后，你就能估计每个袋子中不同颜色球的比例。但是如果他最后只汇报他抽的是什么颜色的球，而将从哪个袋子抽球的这一步\n隐藏\n了，那么选袋子这一步就是隐变量。广义上的隐变量主要就是指”不能被直接观察到，但是对系统的状态和能观察到的输出存在影响的一种东西”\nlasso, elastic net, fused lasso 是机器学习中特征选择的实现算法,\n也就是找到数据集中有代表性的属性(attribute)。\nApplication scenarios\nIntegrate multiple genomic data using iClusterPlus.\nThe molecular complexity of tumors is reflected at various levels\nsuch as genome, epigenome, transcriptome, and proteome.\nOne method is to cluster different data types separately and then\nmanually merge them. And ‘iCluster’ integrates and analyzes data from\nmultiple sources simultaneously to identify tumor subtypes.\n`ICluster was developed in 2009 and has undergone many development\nupgrades. The latest version is iCluster Plus on Bioconductor, which\nincludes two algorithms: iCluster Plus and iCluster Bayes. The\ndifference between the three is that:\n-ICluster (2009): Identification of common latent variables that can\nbe used for clustering using lasso restricted latent variable regression\n-IClusterPlus (2012): integrates elasticnet and fused lasso algorithms\nto handle continuous, count, binary, and multi categorical data\n-IClusterBayes (2018): Improved algorithm, faster than iClusterPlus\nLatent variable is a concept in machine learning. For example, if a\nperson has three bags in front of them, every time they draw a ball,\nthey will say which bag they took a ball of which color from. You can\nrecord the color of the ball drawn from each bag next to them, and after\nthey draw a certain number of times, you can estimate the proportion of\nballs of different colors in each bag. But if he only reports what color\nof ball he drew in the end and hides which bag he drew the ball from,\nthen the step of selecting the bag is a hidden variable. In a broad\nsense, latent variables mainly refer to “something that cannot be\ndirectly observed, but has an impact on the system’s state and\nobservable output”\nLasso, elastic net, fused lasso is an implementation algorithm for\nfeature selection in machine learning, which involves finding\nrepresentative attributes in a dataset.\n环境准备\nEnvironmental preparation\nsource(\"install_dependencies.R\")\n# 加载iClusterPlus包\n# Load the iClusterPlus package\nlibrary(\"iClusterPlus\")\n\n# 加载DNAcopy包 - 用于DNA拷贝数变异分析\n# Load the DNAcopy package - for DNA copy number variation analysis\nlibrary(\"DNAcopy\")\n\n# 加载GenomicRanges包 - 用于处理基因组区间数据\n# Load the GenomicRanges package - for handling genomic interval data\nlibrary(\"GenomicRanges\")\n输入数据\niClusterPlus\n和\niClusterBayes\n支持如下类型数据:\nbinary: 如体细胞变异, 有(1)/无(0)\ncatergorical: 拷贝数状态: -2 = homozygous deletion; -1 = hemizygous\ndeletion; 0 = neutral / no change; 1 = gain; 2 = high level\namplification\ncounts: 如RNA-seq count\ncontinuous: 如芯片表达量数据\n测试数据集为TCGA的GBM(glioblastoma, 胶质母细胞瘤)数据集, 可以从\nhttp://www.cbioportal.org/\n和\nhttps://portal.gdc.cancer.gov/\n中下载. - gbm_mut.txt:\n体细胞突变数据. 来自于三个芯片平台(Agilent 244K, SNP6, Illumina 550K),\n0表示无，1表示有 - gbm_exp.txt: 来自于不同平台的基因表达量归一化后数据 -\ngbm_seg.txt: DNA 拷贝数变异. Level 3经标准化和片段化(normalized and\nsegmented)数据集.\nInput data\n`IClusterPlus and iClusterBayes support the following types of\ndata:\n-Binary: If there is somatic variation, there is (1)/no (0)\n-Caterpillar: Copy number status: -2=homogeneous delta; -1 = hemizygous\ndeletion; 0 = neutral / no change; 1 = gain; 2 = high level\namplification -Counts: such as RNA seq count -Continuous: such as chip\nexpression level data\nThe test dataset is TCGA’s GBM (glioblastoma) dataset, which can be\nobtained from<\nhttp://www.cbioportal.org/\n>And<\nhttps://portal.gdc.cancer.gov/\n>Download in the\nmiddle\n-Gbm_mut.txt: Somatic mutation data From three chip platforms (Agilent\n244K, SNP6, Illumina 550K), 0 represents none, 1 represents present\n-Gbm_exp.txt: Normalized gene expression data from different platforms\n-Gbm_seg.txt: DNA copy number variation Level 3 is a standardized and\nsegmented dataset\n# 设置读入字符串时不自动转换为因子类型（R语言默认行为）\n# Set option to prevent automatic conversion of strings to factors (default behavior in R)\noptions(stringsAsFactors = FALSE)\n\n# 读取GBM基因突变数据，设置首行为列名，首列为行名，制表符分隔\n# Read GBM mutation data with header and row names, tab-separated\ngbm.mut.raw <- read.table('gbm_mut.txt', header = T, row.names = 1, sep = \"\\t\")\n\n# 查看突变数据的前3行和前6列，了解数据结构\n# View first 3 rows and 6 columns of mutation data to understand structure\ngbm.mut.raw[1:3,1:6]\n# 读取GBM拷贝数变异分段数据，设置首行为列名，制表符分隔\n# Read GBM copy number segmentation data with header, tab-separated\ngbm.seg.raw <- read.table('gbm_seg.txt', header = T, sep = \"\\t\")\n\n# 查看拷贝数变异数据的前3行，了解数据结构\n# View first 3 rows of segmentation data to understand structure\ngbm.seg.raw[1:3,]\n# 读取GBM基因表达数据，设置首行为列名，首列为行名，制表符分隔\n# Read GBM gene expression data with header and row names, tab-separated\ngbm.exp.raw <- read.table('gbm_exp.txt', header = T, row.names = 1, sep = \"\\t\")\n\n# 查看表达数据的前3行和前6列，了解数据结构\n# View first 3 rows and 6 columns of expression data to understand structure\ngbm.exp.raw[1:3,1:6]\n数据预处理\n根据\niClusterBayes()\n和\ntune.iClusterBayes()\n的要求，输入数据都必须是\n矩阵\n,\n且每一行表示是不同的样本，每一列表示的基因组的特征,如基因名或者基因区间。\nData preprocessing\nAccording to the requirements of iClusterBayes() and tune.\niClusterBayes(), the input data must be a * * matrix * *, with each row\nrepresenting a different sample and each column representing genomic\nfeatures such as gene names or gene intervals.\nCNA预处理\nCNA(Copy Number Alteration):\n过滤掉突变率不高的基因，例如设定阈值2%.\n用\napply\n对每一个基因用\nmean\n计算变异频率，根据阈值进行过滤\nCNA preprocessing\nCNA (Copy Number Mutation): Filter out genes with low mutation rates,\nsuch as setting a threshold of 2%\nUse ‘apply’ to calculate the mutation frequency for each gene using\n‘mean’, and filter based on a threshold\n# 将基因突变数据转换为矩阵格式\n# Convert mutation data frame to matrix format\ngbm.mut <- as.matrix(gbm.mut.raw)\n\n# 保留原始数据的行名（基因名）\n# Preserve row names (gene names) from original data\nrow.names(gbm.mut) <- rownames(gbm.mut.raw)\n\n# 设置最小突变频率阈值（保留突变频率>2%的基因）\n# Set minimum mutation rate threshold (retain genes mutated in >2% of samples)\nmin.rate <- 0.02\n\n# 计算每个基因的突变频率（在所有样本中的平均突变率）\n# Calculate mutation rate for each gene (average mutation frequency across samples)\nmut.rate <- apply(gbm.mut, 2, mean)\n\n# 筛选突变频率高于阈值的基因，创建新的突变矩阵\n# Filter genes with mutation rate above threshold to create new matrix\ngbm.mut2 <- gbm.mut[, which(mut.rate > min.rate)]\n\n# 查看筛选后的突变数据前5行5列，确认数据结构\n# View first 5 rows and columns of filtered mutation data to check structure\ngbm.mut2[1:5,1:5]\nCNV预处理\n由于原始或者标准化的拷贝数数据集具有很高维度和空间相关性,\n因此iCluster推荐用R包\nDNAcopy\n处理, 得到片段化结果。\nCNV preprocessing\nDue to the high dimensionality and spatial correlation of raw or\nstandardized copy number datasets, iCluster recommends using the R\npackage ‘DNAcopy’ to obtain fragmented results.\n# 查看GBM拷贝数变异分段数据的前3行\n# View the first 3 rows of GBM copy number variation segmentation data\ngbm.seg.raw[1:3,]\n移除冗余的拷贝数区域.\nRemove redundant copy number regions\n# 查看拷贝数变异数据的前3行，了解数据结构\n# View first 3 rows of copy number variation data to understand structure\ngbm.seg.raw[1:3,]\n# 加载生殖细胞CNV参考数据（hg18基因组坐标）\n# Load germline CNV reference data (hg18 genome coordinates)\ndata(variation.hg18.v10.nov.2010)\n\n# 提取CNV区域的染色体、起始和终止位置信息\n# Extract chromosome, start, and end position information for CNV regions\ncnvregion <- variation.hg18.v10.nov.2010[,3:5] \n\n# 调用DNAcopy包中的CNregions函数进行CNV区域识别和处理\n# Call CNregions function from DNAcopy package to identify and process CNV regions\ngbm.cn <- CNregions(seg=gbm.seg,  \n                    epsilon = 0,  \n                    adaptive = FALSE,  \n                    rmCNV=TRUE,  \n                    cnv=cnvregion,  \n                    frac.overlap = 0.5,  \n                    rmSmallseg = TRUE,  \n                    nProbes = 5)\n# 按样本名排序，确保样本顺序一致\n# Sort samples alphabetically to ensure consistent order\ngbm.cn <- gbm.cn[order(rownames(gbm.cn)),]\n\n# 查看处理后的CNV数据前10行5列，确认数据结构\n# View first 10 rows and 5 columns of processed CNV data to check structure\ngbm.cn[1:10,1:5]\n重要参数说明:\nseg: DNAcopy的CBS片段化后输出结果\nepsilon: 当超过临近探针的最大欧式距离时, 两个区域就不会被合并.\nepsiolon=0时表示所有区域都不会被合并将n个样本的所有唯一断裂点取并集。\nadaptive: 仅当样本数非常大时才设置为TRUE\nnProbes: 根据长度对片段进行过滤,和-rmSmallseg=TRUE联用\n如果你知道设置细胞的区间，设置\nrmCNV=TRUE\n,\n且\ncnv\n参数不能为空. CNV信息可从\nhttp://dgv.tcag.ca/dgv/app/downloads?table=DGV_Content_Summary.txt\n下载\nImportant parameter description:\n-SEG: CBS Fragmentation of DNAcopy and Output Results -Epsilon: When\nthe maximum Euclidean distance between adjacent probes is exceeded, the\ntwo regions will not be merged When epsiolon=0, it means that all\nregions will not be merged and all unique breakpoints of n samples will\nbe merged. -Adaptive: Set to TRUE only when the sample size is very\nlarge -NProbes: Filter fragments based on length, combined with -\nrmSmallseg=TRUE\nIf you know the interval for setting cells, set ‘rmCNV=TRUE’, and the\n‘cnv’ parameter cannot be empty CNV information can be obtained from<\nhttp://dgv.tcag.ca/dgv/app/downloads?table=DGV_Content_Summary.txt\n>Download\n芯片表达量预处理\n基因表达量数据, 选择样本间变化程度比较高的基因基因。\nPreprocessing of chip expression level\nSelect genes with relatively high degree of variation between samples\nbased on gene expression data.\n# 将基因表达数据转换为矩阵格式\n# Convert gene expression data frame to matrix format\ngbm.exp <- as.matrix(gbm.exp.raw)\n\n# 保留原始数据的行名（基因名）\n# Preserve row names (gene names) from original data\nrow.names(gbm.exp) <- row.names(gbm.exp.raw)\n\n# 查看表达矩阵的前5行5列，确认数据结构\n# View first 5 rows and columns of expression matrix to check structure\ngbm.exp[1:5,1:5]\n计算每个基因的方差\nCalculate the variance of each gene\ngbm.exp.var <- apply(gbm.exp, 2, var)\ngbm.exp.var.order <- gbm.exp.var[order(gbm.exp.var, decreasing = T)]\nhead(gbm.exp.var.order)\n选择方差较大的前几个基因，例如前1500, 或者大于某个阈值\n由于原来的数据集已经经过了过滤，下面的代码可以不运行，举例说明而已，\nSelect the top few genes with high variance, such as the top 1500 or\nabove a certain threshold\nSince the original dataset has already been filtered, the following\ncode can be skipped for illustration purposes only,\n# 从排序后的基因表达变异度数据中选择前1500个高变异基因\n# Select top 1500 genes with highest expression variability from sorted list\ntop_var_gene <- names(gbm.exp.var.order[1:1500])\n\n# 可选方案：基于变异度阈值筛选基因（当前被注释掉）\n# Alternative method: select genes based on variability threshold (commented out)\n# top_var_gene <- names(gbm.exp.var.oder[gbm.exp.var.oder > 1])\n\n# 筛选表达矩阵，仅保留高变异基因\n# Subset expression matrix to retain only high-variance genes\ngbm.exp <- gbm.exp[, top_var_gene]\n\n# 查看筛选后的表达矩阵维度（样本数 x 基因数）\n# Check dimensions of filtered expression matrix (samples x genes)\ndim(gbm.exp)\n注\n: 用于下载的芯片数据已经是经过归一化,\n所以此处没有归一化。\n最后确保三个数据集拥有\n相同的列名\n**Note * *: The chip data used for downloading has already been\nnormalized, so there is no normalization here.\nFinally, ensure that the three datasets have * * identical column\nnames**\n# 检查三个数据集(CNV、表达、突变)的行名(样本ID)是否完全一致\n# Check if row names (sample IDs) are identical across three datasets (CNV, expression, mutation)\nif (identical(rownames(gbm.cn), rownames(gbm.exp)) &\n    identical(rownames(gbm.cn), rownames(gbm.mut2)))\n  print(\"所有数据集的行名(样本ID)完全一致\")\nprint(\"All datasets have identical row names (sample IDs)\")\n整合分析\nFor example, it took iClusterBayes about\n2\nh to\nanalyze the simulated data sets using 6 cores of a 2.62 GHz 12-core Mac\nPro computer. However, it took the iClusterPlus about\n391\nh. – “A fully Bayesian latent variable model for\nintegrative clustering analysis of multi-type omics data”\n使用\ntune.iClusterBayes\n或\niClusterBayes\n进行整合数据分析。最多可以使用\n6\n个不同的基因组特征数据(dt1,dt2,dt3,dt4,dt5,dt6).\n主要设置三个参数\ndt1,dt2,dt3,dt4,dt5,dt6:\n输入数据集，必须都得是\n矩阵\n！\ntype: 表示数据服从的可能分布。类似于0,1的使用”binomial”,\n连续性数据使用”gaussian”, RNA-Seq的原始数据使用”poisson”\nK: 特征数.\niClusterBayes\n只能设置一个固定值，\ntune.iClusterBayes\n是设定一个区间。最终的聚类数=K+1\ncpus: 程序并行处理.\nWindows下不支持该参数\nprior.gamma:\n不同数据集的先验概率。这个\n值\n只能不断试\n如果你确定最后可以分成多少类，那么直接用\niClusterBayes\n.\nIntegrated analysis\nFor example, it took iClusterBayes about\n2\nh to\nanalyze the simulated data sets using 6 cores of a 2.62 GHz 12-core Mac\nPro computer. However, it took the iClusterPlus about\n391\nh. – “A fully Bayesian latent variable model for\nintegrative clustering analysis of multi-type omics data”\nUse ‘tune. iClusterBayes’ or’ iClusterBayes’ for integrated data\nanalysis. Up to * * 6 different genomic feature data (dt1, dt2, dt3,\ndt4, dt5, dt6) can be used. Three main parameters are set\n-Dt1, dt2, dt3, dt4, dt5, dt6: The input dataset must all be a * *\nmatrix *\n! -Type: Indicates the possible distribution that the data\nfollows. Similar to using “binary” for 0,1, “Gaussian” for continuous\ndata, and “Poisson” for RNA Seq raw data -K: Feature number\n`IClusterBayes’ can only set a fixed value, while ‘tune. iClusterBayes’\nsets an interval. The final number of clusters is K+1 -CPUS: Program\nparallel processing\nThis parameter is not supported on\nWindows\n-Prior.gama: The prior probability of different\ndatasets. This\n* value * * can only be tried continuously\nIf you are sure how many categories can be divided in the end, then\nuse ‘iClusterBayes’ directly\n# 使用iClusterBayes方法进行多组学数据整合聚类分析\n# Perform integrated clustering analysis on multi-omics data using iClusterBayes method\n\nbayfitK4 <- iClusterBayes(dt1 = gbm.mut2,       \n                          dt2 = gbm.cn,         \n                          dt3 = gbm.exp,        \n                    type=c(\"binomial\",\"gaussian\",\"gaussian\"), \n              K=3)\n如果无法确定到底能分成多少类，那么建议用\ntune.iClusterBayes\n,\n测试多个K值.\nif(!file.exists(\"Bayfit.RData\")){\n  date()\n  bayfit <- tune.iClusterBayes(cpus=9,\n                            dt1=gbm.mut2,dt2=gbm.cn,dt3=gbm.exp,\n                    type=c(\"binomial\",\"gaussian\",\"gaussian\"),\n                    K=1:6,n.burnin=18000,\n                    n.draw=12000,\n                    prior.gamma=c(0.5,0.5,0.5),\n                    sdev=0.05, thin=3)\n  date()\n  save.image(file=\"Bayfit.RData\") #需要运行40min，保存到文件里\n}\nWindows只能单核运行, 建议这一步用Mac或服务器。\n下一步，基于BIC或着误差率选择比较合适的特征数K\nIf it is uncertain how many classes can be divided, it is recommended\nto use ‘tune. iClusterBayes’ to test multiple K values\nif(!file.exists(\"Bayfit.RData\")){\ndate()\nbayfit <- tune.iClusterBayes(cpus=9,\ndt1=gbm.mut2,dt2=gbm.cn,dt3=gbm.exp,\ntype=c(\"binomial\",\"gaussian\",\"gaussian\"),\nK=1:6,n.burnin=18000,\nn.draw=12000,\nprior.gamma=c(0.5,0.5,0.5),\nsdev=0.05, thin=3)\ndate()\nSave. image (file=\"Bayfit. RData\") # needs to run for 40 minutes, save to a file\n}\nWindows can only run on a single core, it is recommended to use a Mac\nor server for this step.\nNext, select the appropriate number of features K based on BIC or\nerror rate\n# 加载预计算的iClusterBayes模型结果\n# Load precomputed iClusterBayes model results\nload(\"Bayfit.RData\")\n\n# 初始化存储不同K值模型的BIC和偏差比的变量\n# Initialize variables to store BIC and deviance ratio for different K values\nallBIC = NULL\ndevratio = NULL\n\n# 获取模型集合中不同K值的数量\n# Get the number of different K values in the model collection\nnK = length(bayfit$fit)\n\n# 遍历每个K值的模型结果\n# Loop through each model result with different K values\nfor(i in 1:nK){\n  # 收集每个K值对应的BIC信息\n  # Collect BIC information for each K value\n  allBIC = c(allBIC,bayfit$fit[[i]]$BIC)\n  # 收集每个K值对应的偏差比信息\n  # Collect deviance ratio information for each K value\n  devratio = c(devratio,bayfit$fit[[i]]$dev.ratio)\n}\n\n# 设置绘图参数：调整边距，将两个图并排显示\n# Set plotting parameters: adjust margins, display two plots side by side\npar(mar=c(4.0,4.0,0.5,0.5),mfrow=c(1,2))\n\n# 绘制BIC随聚类数K变化的曲线\n# Plot BIC values against the number of clusters (K)\nplot(1:nK, allBIC,type=\"b\",xlab=\"聚类数 k\",ylab=\"BIC值\",pch=c(1,1,19,1,1,1))\n\n# 绘制偏差比随聚类数K变化的曲线\n# Plot deviance ratio against the number of clusters (K)\nplot(1:nK,devratio,type=\"b\",xlab=\"聚类数 k\",ylab=\"偏差比\",pch=c(1,1,19,1,1,1))\n贝叶斯信息准则(BIC, Bayesian Information Criterion):\n选择模型的一个标准, 只要记住\n越小越好\n偏差比(deviance\nratio), 定于来自于glmnet包， dev.ratio=1-devriance/nulldev,\n只要记住\n越大越好\n根据上图，K=3是最优解. 提取每个样本的分类信息\nBayesian Information Criterion (BIC): A criterion for selecting a\nmodel, as long as it is remembered that the smaller the * *, the\nbetter** The deviation ratio is determined by the glmnet package, dev.\nratio=1- deviation/null dev, as long as it is remembered that the larger\nthe * *, the better**\nAccording to the above figure, K=3 is the optimal solution Extract\nclassification information for each sample\n# 从已拟合的iClusterBayes模型集合中选择最优聚类结果\n# Select the optimal clustering results from the fitted iClusterBayes model collection\n\n# 基于之前BIC和偏差比分析，选择第三个模型(K=3)作为最优模型\n# Based on previous BIC and deviance ratio analysis, select the third model (K=3) as optimal\n\n# bayfit$fit[[3]]$clusters 包含:\n# - 每个样本的聚类归属(1-3类)\n# - 基于多组学数据整合的分子亚型分类结果\n\nbest.cluster.Bayes = bayfit$fit[[3]]$clusters\n作图\niCluster\n的本质是数据分析，因此最后的热图展示不作为本次教程的重点。仅以自带的\nplotHeatmap\n展示下结果。\nDraw a graph\n`The essence of iCluster is data analysis, so the final heatmap\ndisplay is not the focus of this tutorial. Only display the results\nusing the built-in ‘plotHeatmap’.\n# 加载必要的包用于数据处理和可视化\n# Load required packages for data processing and visualization\nlibrary(magrittr)\nlibrary(lattice)   \nlibrary(gplots)\n# 提取CNV数据的染色体位置信息用于后续绘图\n# Extract chromosome position information from CNV data for plotting\nchr <- unlist(strsplit(colnames(gbm.cn), '\\\\.')) %>%  \n  extract(seq(1,length(.),by=2)) %>%  \n  gsub(\"chr\",\"\",.) %>%  \n  as.numeric()  \n\n# 对CNV数据进行值域限制，避免极端值影响可视化效果\n# Limit the range of CNV data to improve visualization\ncn.image <- gbm.cn\ncn.image[cn.image > 1.5] <- 1.5  \ncn.image[cn.image < -1.5] <- -1.5  \n\n# 对表达数据进行值域限制，避免极端值影响可视化效果\n# Limit the range of expression data to improve visualization\nexp.image <- gbm.exp\nexp.image[exp.image > 2.5] <- 2.5  \nexp.image[exp.image < -2.5] <- -2.5  \n\n# 配置热图配色方案\n# Configure color schemes for heatmaps\nbw.col <-  colorpanel(2,low=\"white\",high=\"black\")  \ncol.scheme = alist()\ncol.scheme[[1]] <- bw.col  \ncol.scheme[[2]] <- bluered(256)  \ncol.scheme[[3]] <- bluered(256)  \n\n# 绘制多组学整合热图，展示聚类结果\n# Plot integrated multi-omics heatmap to visualize clustering results\nplotHeatmap(fit= bayfit$fit[[3]] ,  \n            datasets=list(gbm.mut2,cn.image,exp.image),  \n            type=c(\"binomial\",\"gaussian\",\"gaussian\"),  \n            col.scheme = col.scheme,  \n            row.order=c(F,F,T),  \n            chr=chr,  \n            plot.chr=c(F,T,F),  \n            sparse=c(T,F,T),  \n            cap=c(F,T,F))\n输出文件\n把best.cluster.Bayes\n、特征基因和值保存到文件，就可以用自己的heatmap代码画热图了。\nOutput file\nSave best.cluster.Bayes, feature genes, and values to a file, and you\ncan use your own heatmap code to draw a heatmap.\n# 将最优聚类结果保存为制表符分隔文本文件\n# Save the optimal clustering results to a tab-separated text file\nwrite.table(best.cluster.Bayes, \n            file=\"output_clusterMembership.txt\",\n            sep='\\t',      \n            quote=F)       \n\n# 将处理后的基因突变数据转置并保存为CSV文件\n# Transpose and save processed mutation data to CSV file\nwrite.csv(t(gbm.mut2), \"output_mut2.csv\", \n          quote = F)    \n\n# 将处理后的拷贝数变异数据转置并保存为CSV文件\n# Transpose and save processed copy number variation data to CSV file\nwrite.csv(t(cn.image), \"output_cn.csv\", \n          quote = F)   \n\n# 将处理后的基因表达数据转置并保存为CSV文件\n# Transpose and save processed gene expression data to CSV file\nwrite.csv(t(exp.image), \"output_exp.csv\", \n          quote = F)\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa45V2_FigureYa45iClusterV2",
      "title": "FigureYa45V2/FigureYa45iClusterV2.html",
      "html": "FigureYa45V2/FigureYa45iClusterV2.html",
      "text": "texts/main_FigureYa45V2_FigureYa45iClusterV2.txt",
      "folder": "FigureYa45V2",
      "thumb": "gallery_compress/FigureYa45V2.webp"
    },
    "word_count": 2601,
    "lines_count": 612,
    "title": "FigureYa45 iCluster的教程答疑V2",
    "description": "iCluster分析过程答疑。 另外，需要输出分类和特征基因，用于画paper里的这种热图。 Requirement description",
    "input_data_types": [
      "表达矩阵",
      "突变数据",
      "临床数据",
      "RNA-seq",
      "DNA-seq"
    ],
    "output_types": [
      "散点图",
      "热图",
      "统计表格"
    ],
    "technical_methods": [
      "聚类分析",
      "标准化"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "高级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "ratio",
      "header",
      "overlap",
      "dt3",
      "1",
      "order",
      "fit",
      "gamma",
      "datasets"
    ]
  },
  {
    "id": "main_FigureYa197SmoothHaz_FigureYa197SmoothHaz",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa197SmoothHaz_FigureYa197SmoothHaz.txt",
    "content": "FigureYa197SmoothHaz\nFigureYa197SmoothHaz\nAuthor(s)\n: Jiawei Shi\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nDescription of the requirements\n复现平滑化的风险函数曲线（B） Reproducing the smoothed risk function\ncurve (B)\n出自\nhttps://pubmed.ncbi.nlm.nih.gov/32386405/\nfrom\nhttps://pubmed.ncbi.nlm.nih.gov/32386405/\nFigure 2: (A) Recurrence-free survival curves according to the\npresence of MIP component. (B) Smoothed hazard estimates for the\npresence of MIP component.\n图B在例文中多次出现。 Figure B appears several times in the\nexample.\n应用场景\n该图本质上就是一种核密度图。关于核密度图的基础知识可参考底部“附”。\n例文应用风险曲线探索手术切除的肺腺癌微乳头这种组织学亚型术后不同时间内的复发风险。\n我们用TCGA最新的pancancer临床信息做为输入数据，你可以顺利画出自己感兴趣的癌症的核密度图，展示某一特征随时间的变化。\n这种图在更多文章中的应用：\nScience.\n2020;eabd2161.\nNature.\n2012;486(7403):395-399. Fig.4C\n;\nOncotarget.\n2018;9(87):35742-35751.\nJAMA Oncol.\n2018;4(3):309-315.\n本次复现的图参考\nNeuro Oncol. 2015\nJul;17(7):999-1006.\nApplication Scenarios\nThis plot is fundamentally a kernel density plot. For foundational\nconcepts of kernel density estimation, refer to the Appendix.\nExample Use Case: The original study employed risk curves (a\nspecialized kernel density visualization) to explore recurrence risks\nover time in the micropapillary histological subtype of resected lung\nadenocarcinoma.\nWorkflow Adaptation: Using the latest TCGA pan-cancer clinical data\nas input, you can generate kernel density plots for any cancer type of\ninterest to visualize temporal changes in specific biological or\nclinical features.\nAdditional Literature Applications: For extended implementations of\nthis visualization approach in peer-reviewed studies, see:\nScience.\n2020;eabd2161.\nNature.\n2012;486(7403):395-399. Fig.4C\n;\nOncotarget.\n2018;9(87):35742-35751.\nJAMA Oncol.\n2018;4(3):309-315.\nDiagram reference for this reproduction:\nNeuro Oncol. 2015\nJul;17(7):999-1006.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nlibrary(survival)\nlibrary(survminer)# 生存分析 # Survival analysis\nlibrary(openxlsx) # 读取数据 # Read the data\nlibrary(muhaz)    # 风险评估 # risk assessment\nlibrary(dplyr)    # 数据清洗 # Data cleansing\nlibrary(ggplot2)  # 绘图 # plot\nlibrary(cowplot)  # 拼图 # jigsaw puzzle\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # error messages are displayed in English\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # It is forbidden to convert chr into factor\n输入文件的获得\n如果你的数据已整理成\neasy_input.csv\n的格式，就跳过这步，直接进入“构建muhaz对象”。\ninput.xlsx，是TCGA最新的pancancer临床数据，出自\nCell.\n2018;173(2):400-416.e11.\n的\n补充材料\n后面将以性别gender作为分组举例子，实际分析时，把gender替换为你感兴趣的特征对应在panclin里的列名。或者把你经过其他分析获得的分类信息作为一列添加进去。\nObtaining Input Files\nIf your data is already formatted as easy_input.csv, skip this step\nand proceed directly to the Build muhaz Object section.\nData Source\ninput.xlsx: Contains the latest TCGA pan-cancer clinical data sourced\nfrom the Supplementary Materials of the publication:\nCell.\n2018;173(2):400-416.e11.\nsupplyment\nmaterial\nGender will be used as an example of grouping, and in the actual\nanalysis, replace gender with the feature you are interested in\ncorresponding to the list name in the panclin. Or add the classification\ninformation you’ve obtained through other analyses as a column.\n# 加载TCGA pancancer临床数据\n# Load TCGA pancancer clinical data\npanclin <- read.xlsx(xlsxFile = \"input.xlsx\",sheet = 1)\ndim(panclin)\npanclin[1,] # 查看有哪些列 # See what columns there are\n# 选取感兴趣的癌症\n# Select the cancer of interest\n#panclin <- panclin[panclin$type %in% \"ACC\", ]\n\n# 按例图的72个月调整生存数据\n# Survival data were adjusted for 72 months as shown in the example figure\nclin <- panclin %>%\n  # 选取想要的列\n  # Select the columns you want\n  select(.,DFI, DFI.time, \n         gender) %>% # 后面将以性别作为分组，选取gender列，可以替换为其他感兴趣的列名 # The gender column will be grouped later, and the gender column can be replaced with other column names of interest\n  \n  # 删除没有生存结局和时间的case # Delete cases that don't have a survival ending and time\n  filter(!(is.na(.$DFI) | is.na(.$DFI.time))) %>%\n  \n  mutate(time_month = round(DFI.time/30,digits = 1)) %>%\n  mutate(survevent = ifelse(DFI == 1 & time_month <= 72, 1, 0), \n         survmonth = ifelse(time_month <=  72, time_month, 72)) \ndim(clin)\n# 保存到文件，便于套用\n# Save to a file for easy application\nwrite.csv(clin, \"easy_input.csv\", quote = F, row.names = F)\n输入文件\nInput files\neasy_input.csv，包含生存信息，和一列分组信息（此处为gender）。\neasy_input.csv，Contains survival information, and a column of grouping\ninformation (in this case, gender)\nclin <- read.csv(\"easy_input.csv\")\nhead(clin)\n构建muhaz对象\nBuild the muhaz object\nmuhaz函数的参数设置\nParameter settings for the muhaz function\ntimes，生存时间向量\ndelta，生存结局向量\nsubset，如果不指定，表示将使用所有观察值\nmin.time，max.time，设置分析时间区间段\nbw.pilot\n带宽bw值对应MISE（平均积分平方误差，mean intergrated squared\nerror）最小化的bw值\n指定核密度估计的bw值，\n默认根据Mueller and Wang\n(1994)的方法\n计算公式bw.pilot = (max.time - min.time)/(8 *\nnz^0.2)，其中nz删失的观察数\nbw.grid，对应MISE最小是的值，默认为以[0.2 * bw.pilot,20 *\nbw.pilot]为区间的21切分的bandwidth grid\nbw.smooth，用于设置平滑局部的带宽参数，如果bw.method=“global”，该参数无效，默认为5\n* bw.pilot\nbw.method，算法设置，算法包括”global”,“local”(默认值)，“knn”，使用首字母即可\nb.cor，边界效应校正类型，“b”=“both”(表示校正双边的边界效应\n)，“n”=“none”(默认值)，“l”=“left”，“r”=“right”\nn.min.grid,n.est.grid=101，前者默认51，后者默认101\nkern=“epanechnikov”\n设置核函数，使用首字母即可，默认epanechnikov\nParameter Descriptions for Kernel Density Estimation in Survival\nAnalysis\n-times: Vector of survival times. -delta: Vector of event status\nindicators (0 = censored, 1 = event occurred). -subset: Subset of\nobservations to include. If unspecified, all observations are used.\n-min.time, max.time: Define the time interval for analysis. -bw.pilot:\n-Pilot bandwidth value minimizing the Mean Integrated Squared Error\n(MISE). -Default calculation follows the method by Mueller & Wang\n(1994). -Formula: bw.pilot = (max.time - min.time) / (8 * nz^0.2), where\nnz is the number of uncensored observations. -bw.grid: Bandwidth grid\nfor MISE minimization. Default: 21 equally spaced values between [0.2 *\n-bw.pilot, 20 * bw.pilot]. -bw.smooth: Local smoothing bandwidth.\nIgnored if bw.method = “global”. Default: 5 * bw.pilot. -bw.method:\nAlgorithm for bandwidth selection:\n“global”: Global bandwidth.\n“local” (default): Locally adaptive bandwidth.\n“knn”: k-nearest neighbor-based bandwidth. (Abbreviations accepted,\ne.g., “g”, “l”, “k”).\n-b.cor: Boundary correction type:\n“b” (both): Corrects left and right boundaries.\n“n” (default): No correction.\n“l”: Left boundary only.\n“r”: Right boundary only.\n-n.min.grid: Minimum grid size. Default: 51.\nn.est.grid: Estimation grid size. Default: 101.\n-kern: Kernel function. Options:\n“epanechnikov” (default).\nOther kernels may be specified by abbreviation (e.g., “e” for\nEpanechnikov).\n构建muhaz对象\nBuild the muhaz object\nsmoothhazp <- clin %>% \n  group_by(gender) %>% #根据自己的需要修改分组列名 # Modify the group column names as needed\n  do(haz = muhaz(times = .$survmonth,delta = .$survevent,\n                 min.time = min(.$survmonth[.$survevent==1]),\n                 max.time = max(.$survmonth[.$survevent==1]),\n                 bw.grid = 7,bw.method = \"g\",b.cor = \"b\")) %>%\n  do(data.frame(Hazard = .$haz$haz.est, \n                Months = .$haz$est.grid, \n                Subgroup = .$gender))\n验证分析结果\nVerify the results of the analysis\n# 检验一下\n# Check it out\nmaxHaz <- smoothhazp %>% group_by(Subgroup) %>%\n    summarise(stratMax=max(Hazard))\nprint(maxHaz)\n# 估算HR\n# Estimate HR\nmaxHaz$stratMax[2]/maxHaz$stratMax[1]\n构建cox回归模型，对比一下\nBuild a COX regression model and compare it\n两者算出来的HR近乎相等。 The HR calculated by the two is almost\nequal.\nres.cox <- coxph(Surv(survmonth, survevent) ~ gender, data =  clin)\nsummary(res.cox)\n开始画图\nStart plotting\nmuhaz包自带plot.muhaz，这里我选择ggplot2来画图，分三步进行： The\nmuhaz package comes with plot.muhaz, here I choose ggplot2 to draw the\nplot, in three steps:\n1. 先画风险曲线\n1. Draw the risk curve first\n# 设置字体\n# Set the font\n# 施普林格·自然杂志社图片文字要求8号Helvetica or Arial，（https://www.nature.com/documents/aj-artworkguidelines.pdf）\n# Springer Nature Magazine Picture text request No. 8 Helvetica or Arial,（https://www.nature.com/documents/aj-artworkguidelines.pdf）\n\n# 检查并安装必要的包\nif (!require(extrafont)) {\n  cat(\"extrafont 包未安装，尝试安装...\\n\")\n  # 尝试安装 extrafont\n  if (!require(remotes)) install.packages(\"remotes\")\n  tryCatch({\n    install.packages(\"extrafont\")\n  }, error = function(e) {\n    remotes::install_github(\"wch/extrafont\")\n  })\n}\n# 加载字体包（如果可用）\nfont_available <- require(extrafont, quietly = TRUE)\n\nif (font_available) {\n  # 尝试加载字体\n  tryCatch({\n    # 检查是否已有字体数据\n    if (length(extrafont::fonts()) == 0) {\n      # 导入字体\n      extrafont::font_import(prompt = FALSE)\n    }\n    extrafont::loadfonts(device = \"pdf\", quiet = TRUE)\n    cat(\"字体系统初始化成功\\n\")\n  }, error = function(e) {\n    cat(\"字体初始化失败:\", e$message, \"\\n\")\n    font_available <- FALSE\n  })\n}\n\n# 如果没有字体支持，使用默认设置\nif (!font_available) {\n  cat(\"使用默认字体设置\\n\")\n  # 设置默认字体族\n  if (.Platform$OS.type == \"windows\") {\n    default_font <- \"sans\"\n  } else {\n    default_font <- \"Helvetica\"\n  }\n} else {\n  default_font <- \"Arial\"\n}\n# 自定义颜色\n# Custom colors\norange <- \"#EB292A\"\nblue <- \"#2271B4\"\n\np1 <- ggplot(smoothhazp, aes(x=Months, y=Hazard, colour= factor(Subgroup,labels = c(\"Male\",\"Female\")))) +\n  geom_line() + ggtitle(\"Kernel-smoothing hazard function plot\")+\n  scale_color_manual(values = c(blue, orange)) +\n  theme_classic() +\n  theme(plot.title = element_text(hjust=-0.1, size=8, vjust=0.2, face = \"bold\"),\n        axis.text = element_text(size=8, colour=\"black\"),\n        axis.title = element_text(size=8, colour=\"black\"),\n        legend.title = element_blank(),\n        legend.position = c(0.8,0.9)) +\n  scale_x_continuous(name = \"\", breaks = seq(0,72,12))\n\n# 如果字体可用，应用字体设置\nif (font_available) {\n  p1 <- p1 + theme(text = element_text(family = default_font))\n}\n\np1\n这样就画出了例文那样的图。\n下面是作者给出的升级版：加上风险表\nThis makes a diagram like the example text.\nHere’s an upgraded version given by the author: plus the risk\ntable\n2. 画风险表\n2. Draw a risk table\n这里我们使用survminer包的ggsurvplot构建风险表\nHere we use the ggsurvplot of the survminer package to build the risk\ntable\nfit <- survfit(Surv(survmonth, survevent) ~ gender, data = clin)\n\nggsurv <- ggsurvplot(fit, data = clin, risk.table = TRUE, \n                     legend.title = \"\",                 # 设置图例标题 # Set the legend title\n                     legend.labs = c(\"Male\", \"Female\"), # 指定图例分组标签 # Specify the legend grouping label\n                     palette = c(blue, orange),         #自定义颜色 # Custom colors\n\n                     xlab = \"Months\",fontsize=2.5,      # 调节风险表字体大小 # Adjust the font size of the risk table\n                     xlim = c(0,72), break.x.by = 12,\n                     # 设置risk table xy轴及标签格式 # Set the risk table xy axis and label format\n                     tables.theme = theme_survminer(base_size = 8,\n                                                    #base_family = \"Arial\",\n                                                    font.main = c(8, \"plain\", \"black\"),\n                                                    font.x = c(8, \"plain\", \"black\"),\n                                                    font.y = c(8, \"plain\", \"black\"),\n                                                    font.tickslab = c(8, \"plain\", \"black\")))\np2 <- ggsurv$table + \n  theme(legend.position = \"none\") + labs(title = \"\") # 删除风险表的title # Delete the title of the risk table\np2\n3. 组图\n# 组图\n# merge plots\nplot_grid(p1,p2,ncol=1,\n          rel_heights = c(1,0.4),align = 'v')\n# 保存为pdf文件，是矢量图，可以用Illustrator等工具继续编辑\n# Saved as a pdf file, it is a vector illustration that can be continued with tools such as Illustrator\npdf(\"smoothHaz.pdf\", width = 3, height = 4)\nplot_grid(p1,p2,ncol=1,\n          rel_heights = c(1,0.4),align = 'v')\ndev.off()\n# 或者保存为tiff\n# Or save as a tiff\n#ggsave(filename = \"smoothHaz.tiff\",width = 8,height = 8,units = 'cm',dpi = 300,compression='lzw')\n\n# 或者导入ppt继续编辑\n# Or import PPT to continue editing\n#export::graph2ppt(file = \"smoothHaz.pptx\",width = 3,height = 4)\n附\n核密度估计\n：一种非参数估计方法,根据已知的抽样数据推算总体概率分布的过程。\n核Kernel\n，表示核函数，常见的核函数如高斯函数（正态分布）。\nmuhaz包muhaz函数内的一个参数kern，其根据作者的用户手册提供设置选项，包括如下几种\nAppendix\nKernel Density Estimation (KDE): A non-parametric method to estimate\nthe probability density function of a population based on observed\nsample data.(\nhttps://en.wikipedia.org/wiki/Kernel_density_estimation\n)\nKernel Function: Defines the shape of the weighting function used in\nKDE. Common kernels include the Gaussian kernel (normal distribution)\nand Epanechnikov kernel.(\nhttps://en.wikipedia.org/wiki/Kernel_density_estimation\n)\nkern Parameter in the muhaz Package The kern parameter in the muhaz\nfunction specifies the kernel type. As per the package’s user manual,\navailable options include:(Above plot)\n上图摘自\n基迪奥生物\n带宽\nbandwidth\n是一个自由参数，可以调节核密度估计曲线的平滑度，核的带宽越大曲线越平滑\nThe image above is taken from\n基迪奥生物\n带宽\nbandwidth\nis a free parameter that adjusts the smoothness of the\nkernel density estimation curve, and the larger the bandwidth of the\ncore, the smoother the curve\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa197SmoothHaz_FigureYa197SmoothHaz",
      "title": "FigureYa197SmoothHaz/FigureYa197SmoothHaz.html",
      "html": "FigureYa197SmoothHaz/FigureYa197SmoothHaz.html",
      "text": "texts/main_FigureYa197SmoothHaz_FigureYa197SmoothHaz.txt",
      "folder": "FigureYa197SmoothHaz",
      "thumb": "gallery_compress/FigureYa197SmoothHaz.webp"
    },
    "word_count": 1534,
    "lines_count": 376,
    "title": "FigureYa197SmoothHaz",
    "description": "Description of the requirements 复现平滑化的风险函数曲线（B） Reproducing the smoothed risk function curve (B)",
    "input_data_types": [
      "临床数据",
      "生存数据"
    ],
    "output_types": [
      "统计表格",
      "生存曲线"
    ],
    "technical_methods": [
      "生存分析"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "rel_heights",
      "",
      "colour",
      "values",
      "time_month",
      "width",
      "grid",
      "1",
      "xlim",
      "vjust"
    ]
  },
  {
    "id": "main_FigureYa278heatmapPoints_FigureYa278heatmapPoints",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa278heatmapPoints_FigureYa278heatmapPoints.txt",
    "content": "FigureYa278heatmapPoints\nFigureYa278heatmapPoints\nAuthor(s)\n: Qian Liu; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirements Description\nHeatmap和Bubble plot叠加的图。\nHeatmap和Bubble plot用的是两套数据。\nHeatmap and Bubble plot overlay.\nThe Heatmap and Bubble plot use two different sets of data.\n出自：\nhttps://linkinghub.elsevier.com/retrieve/pii/S0092867421009454\n图2. MMRd与MMRp型结直肠癌的免疫细胞组成特征 (A)\n相对于癌旁正常组织，MMRp和MMRd肿瘤中免疫细胞簇的成分变化。\nMMRp与MMRd组间比较经Kruskal-Wallis检验校正后错误发现率(FDR)＜0.05的细胞类型以星号(*)标注。\nSource:\nhttps://linkinghub.elsevier.com/retrieve/pii/S0092867421009454\nFigure 2. The immune compartment in MMRd and MMRp CRC (A)\nCompositional changes in immune cell clusters in MMRp and MMRd tumors\nrelative to adjacent normal tissue. Kruskal-Wallis false discovery rate\n(FDR) < 0.05 for MMRp versus MMRd are marked with asterisks.\n应用场景\nApplication Scenario\nDr. Guangchuang Yu评价：上下三角的更好替代品。上下三角指的是这个图\nhttps://mp.weixin.qq.com/s/34WRZRBVPHUNRLlzNH2nzw\n同时展示同一对象的两种特征，例如同时展示多个基因在多个样本中的表达量和DNA甲基化水平等等。\nDr. Guangchuang Yu’s evaluation: A better alternative to upper and\nlower triangles. The upper and lower triangles refer to this figure\nhttps://mp.weixin.qq.com/s/34WRZRBVPHUNRLlzNH2nzw\nSimultaneously displaying two characteristics of the same object,\nsuch as showing both the expression levels and DNA methylation levels of\nmultiple genes across multiple samples, etc.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(tidyverse)\nlibrary(ggplot2)\n\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\")\n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n输入文件\nInput Files\n这里为复现原文准备数据。先筛选patient，可忽略，直接跳到“求平均值和pvalue”。\n首先查看原文excel表中的一些关于图表数据的说明：\n按患者统计的细胞数量 -\n该表格显示每位患者（列：Pid）中各免疫细胞类型（行）的细胞计数。仅总细胞数超过1000的样本被纳入分析。与图2A相关。\n按患者统计的细胞富集情况 -\n该表格显示每位患者（列：Pid）中各免疫细胞类型（行）相较于正常样本的富集程度（Pearson残差；详见方法部分）。仅总细胞数超过1000的样本被纳入分析。与图2A相关。\n组成差异分析 -\n该表格展示不同样本组（MMRd、MMRp、正常组）间免疫细胞组成的差异。采用Kruskal-Wallis检验判定显著性变化。与图2A相关。\n我们可以看到是对病人进行了一定的筛选：细胞数目总共超过 1000\n的病人才用于分析，那么我们在分析数据前就必须对数据进行一定的过滤\n首先我们将两个相关的表格数据copy出来准备为两个文件： 1.\nA_Cell_count_by_patient.txt 2. B_Cell_enrichment_by_patient.txt\nHere, data is prepared for the reproduction of the original text.\nFirst, filter the patients (this step can be ignored, proceed directly\nto “Calculating Averages and p-values”).\nNow, check some explanations about the chart data in the original\nexcel table:\nCell count by patient - Table showing the immune cell type (rows)\ncounts for each patient (Pid, columns). Only specimens with over 1000\ntotal cells are included in the analysis. Related to Figure 2A.\nCell enrichment by patient\n- Table showing the immune cell type (rows) enrichment\n(Pearson-Residual; see Methods) as compared to normals for each patient\n(Pid, columns). Only specimens with over 1000 total cells are included\nin the analysis. Related to Figure 2A.\nCompositional differences - Table showing compositional differences\nwithin the immune compartment beteen samples (MMRd, MMRp, Normal).\nKruskal-Wallis test was used to determine significant changes. Related\nto Figure 2A.\nWe can see that the patients underwent certain filtering: only\npatients with a total cell count exceeding 1,000 were included in the\nanalysis. Therefore, before analyzing the data, we must perform some\nfiltering on the dataset.\nWe will extract the two relevant tables of data and prepare them as\ntwo separate files:\nA_Cell_count_by_patient.txt\nB_Cell_enrichment_by_patient.txt\n# 读取细胞计数数据\n# Read cell count data\nA_Cell_count_by_patient <- read_table(\"A_Cell_count_by_patient.txt\") %>%\n  column_to_rownames(\"Row\")\n# 读取细胞富集分数数据 \n# Read cell enrichment score data\nB_Cell_enrichment_by_patient <- read_table(\"B_Cell_enrichment_by_patient.txt\") %>%\n  column_to_rownames(\"Row\")\n# 根据 A_Cell_count_by_patient 文件筛选出符合标准（细胞数目>1000）的病人\n# Filter patients with >1000 cells based on A_Cell_count_by_patient\nfilter_patient_small_1000cell <- colSums(A_Cell_count_by_patient) >= 1000\n\n# 根据筛选好的病人，提取表1和表2中对应的病人信息\n# Based on the screened patients, extract the corresponding patient information in Table 1 and Table 2\nfiltered_dt_A <- A_Cell_count_by_patient[, filter_patient_small_1000cell]\nfiltered_dt_B <- B_Cell_enrichment_by_patient[, filter_patient_small_1000cell]\n\n# 保存到文件，便于套用格式\nwrite.csv(filtered_dt_A, \"easy_input_A.csv\", quote = F)\nwrite.csv(filtered_dt_B, \"easy_input_B.csv\", quote = F)\n求平均值和pvalue\nCalculate averages and p-values\n图中圆圈大小和热图颜色都是同一分组内样本的平均值。\n两个文件的行名、列名保持一致。行名为细胞ID；列名为patient\nID，以分组名开头，patient有三个分组，分别是MMRp、MMRd和Normal。\neasy_input_A.csv，用于画气泡图。气泡图表示的是 %among all all immune\ncells。先求出每个patient中每种细胞所占的比例，然后再求三个分组patient各种细胞所占比例的平均值。你的数据可能不需要计算比例，例如基因表达量，直接求基因在各样本中的表达量的平均值就好。\neasy_input_B.csv，用于画热图。计算三种人群中每种细胞的\nEnrichment score vs Normal\n的平均值。\nThe circle sizes in the plot and heatmap colors both represent the\nmean values of samples within the same group.\nThe two files maintain consistent row and column names. Rows\ncorrespond to cell IDs; columns represent patient IDs, prefixed with\ngroup names. There are three patient groups: MMRp, MMRd, and Normal.\neasy_input_A.csv is used for generating the bubble plot. The bubble\nplot displays the “% among all immune cells”. First calculate the\nproportion of each cell type within every patient, then compute the\naverage proportion across patients in each of the three groups. Note:\nYour data might not require proportion calculations - for example, with\ngene expression data, you can directly calculate the average expression\nvalues of genes across samples.\neasy_input_B.csv is used for creating the heatmap. It calculates the\naverage\nEnrichment score vs Normal\nfor each cell type\nacross the three population groups.\n# 加载数据，Cell counts by patient，用于画气泡图\n# Load data for bubble plot (cell counts by patient)\nfiltered_dt_A <- read.csv(\"easy_input_A.csv\", row.names = 1)\n\n# 数据处理流程 \n# Data processing pipeline\nplot_data_A <- as.data.frame(apply(filtered_dt_A, 2, function(x) x/sum(x))) %>% \n  # 猜你可能不需要计算每种细胞所占的比例，就改用下面这行\n  #filtered_dt_A %>%#\n  #If it is not necessary to calculate the proportion of each type of cell, use the following line instead\n  #filtered_dt_A %>%#\n  rownames_to_column(var = \"Cell\") %>%\n  rowwise() %>%\n  \n  # 计算各分组均值\n  # Calculate group means\n  transmute(\n    Cell = factor(Cell, levels = rev(rownames(filtered_dt_A))),\n    Normal = mean(c_across(starts_with(\"Normal\"))),\n    MMRp = mean(c_across(starts_with(\"MMRp\"))),\n    MMRd = mean(c_across(starts_with(\"MMRd\")))\n  ) %>%\n  ungroup() %>%\n  \n  # 转换成长格式 \n  # Convert to long format\n  pivot_longer(\n    cols = -Cell,\n    names_to = \"Patient_group\",\n    values_to = \"mean_cell_number\"\n  ) %>%\n  \n  # 设置分组顺序\n  # Set group order\n  group_by(Patient_group) %>%\n  mutate(\n    Patient_group = factor(Patient_group, levels = c(\"Normal\", \"MMRp\", \"MMRd\"))\n  ) \n\n# 加载数据，Cell enrichment by patient，用于画热图\n# Load data for heatmap (cell enrichment by patient)\nfiltered_dt_B <- read.csv(\"easy_input_B.csv\", row.names = 1)\n\n# 数据处理流程 \n# Data processing pipeline\nplot_data_B <- filtered_dt_B %>%\n  rownames_to_column(var = \"Cell\") %>%\n  rowwise() %>%\n  \n  # 计算各分组均值\n  # Calculate group means\n  transmute(\n    Cell = factor(Cell, levels = rev(rownames(filtered_dt_A))),\n    Normal = mean(c_across(starts_with(\"Normal\"))),\n    MMRp = mean(c_across(starts_with(\"MMRp\"))),\n    MMRd = mean(c_across(starts_with(\"MMRd\")))\n  ) %>%\n  ungroup() %>%\n  \n  # 转换成长格式 \n  # Convert to long format\n  pivot_longer(\n    cols = -Cell,\n    names_to = \"Patient_group\",\n    values_to = \"mean_cell_number\"\n  ) %>%\n  \n  # 设置分组顺序\n  # Set group order\n  group_by(Patient_group) %>%\n  mutate(\n    Patient_group = factor(Patient_group, levels = c(\"Normal\", \"MMRp\", \"MMRd\"))\n  )\n例文图中Y轴标出了\nMMRp vs MMRd\nKruskal-Wallis false\ndiscovery rate\nFDR <- 0.5\n的细胞，因此需要计算pvalue。\n根据自己的需要，也可以不做。\nIn the example figure, the cells with\nMMRp vs MMRd\nKruskal-Wallis false discovery rate\nFDR < -0.5\nare\nmarked on the Y-axis, so the p-value needs to be calculated.\nYou can choose not to do it according to your own needs.\n# 首先构建一个计算 `Pvalue` 的函数\n# Kruskal-Wallis test function\nks <- function(Cell = Cell){\n  MMRd <- as.numeric(MMRd_cell_data[Cell, ])\n  MMRp <- as.numeric(MMRp_cell_data[Cell, ])\n  data <- c(MMRd, MMRp) \n  group = rep(\n    c(\"MMRd\", \"MMRp\"), times = c(length(MMRd), length(MMRp))\n  )\n  kruskal.test(data, group)$p.value\n}\n\n# 准备MMRd组细胞数据 \n# Prepare MMRd group cell data\nMMRd_cell_data <- filtered_dt_A %>%\n  select(starts_with(\"MMRd\"))\n\n# 准备MMRp组细胞数据\n# Prepare MMRp group cell data\nMMRp_cell_data <- filtered_dt_A %>%\n  select(starts_with(\"MMRp\"))\n\n# 计算并处理P值 \n# Calculate and process p-values\nPvalue <- data.frame(\n  Cell = row.names(filtered_dt_B),\n  Pvalue = sapply(row.names(filtered_dt_B), ks, simplify = T)\n  ) %>%\n  mutate(\n    FDR = p.adjust(Pvalue, method = \"fdr\"),\n    label = ifelse(FDR < 0.05, paste0(\"*\", str_extract(Cell, \"[0-9]+\")), str_extract(Cell, \"[0-9]+\"))\n      )\n\n# 保存结果到CSV文件 \n# Save results to CSV file\nwrite.csv(Pvalue, \"output_Pvalue.csv\", row.names = F)\n开始画图\nStart Plotting\n图中是热图 + 圈图，如果圈图放在底层，会被热图覆盖。因此我们利用\nggplot2图层叠加的道理，先画热图再画圈图。\n另外，这里存在两组不同的数据，我们很多人喜欢将数据集放在\nggplot()\n函数中，那么就会产生一个全局数据集的概念，所以我们需要将数据集放在各自的绘图函数\ngeom_tile\n和\ngeom_point()\n中来作为局部数据集。\nThe figure combines a heatmap with bubble plot. If the bubble plot\nwere placed in the bottom layer, it would be obscured by the heatmap.\nTherefore, we follow ggplot2’s layer superposition principle by drawing\nthe heatmap first, then adding the bubble plot.\nAdditionally, since we have two distinct datasets here, while many\nprefer to specify the dataset in the\nggplot()\nfunction\n(creating a global dataset concept), we instead assign the datasets\nseparately within their respective plotting functions -\ngeom_tile\nand\ngeom_point()\nto maintain them as\nlocal datasets.\n# 创建基础图形对象 \n# Create base plot object\np <- ggplot() +\n  \n  # 绘制热图部分 \n  # Heatmap layer\n  geom_tile(\n    data = plot_data_B,\n    aes(Patient_group, Cell, fill = mean_cell_number), \n    colour = \"white\", size = 1\n  ) +\n  \n  # 设置热图颜色梯度 \n  # Set heatmap color gradient\n  scale_fill_gradientn(\n    colours  = gplots::bluered(128),\n    limit = c(-50, 50),\n    breaks = c(-50, 0, 50),\n    # breaks = seq(-50, 50, by = 10),\n    labels = c(\"-50\", \"0\", \"50\"),\n    name = \"Enrichment \\nscore vs Normal\"\n    ) +\n  \n  # 绘制气泡图部分 \n  # Bubble plot layer\n  geom_point(\n    data = plot_data_A,\n    aes(Patient_group, Cell, size = mean_cell_number),\n    shape = 1\n  ) +\n  \n  # 设置气泡大小标度 \n  # Set bubble size scale\n  scale_size_area(\n    breaks = c(0.01, 0.05, 0.1, 0.15, 0.2, 0.25, 0.3),\n    labels = c(0.01, 0.05, 0.1, 0.15, 0.2, 0.25, \"> 0.3\"),\n    name = \"% among\\nall immune cells\"\n  ) + \n  \n  # 设置坐标轴和标签 \n  # Axis and label settings\n  labs(\n    x = \"\",\n    y = \"\"\n  ) +\n  scale_x_discrete(position = \"top\") +\n  \n  # 主题设置 \n  # Theme settings\n  theme_bw() +\n  theme(\n    panel.grid.major = element_blank(),\n    axis.text.x = element_text(angle = 90),\n    legend.position = \"bottom\", \n    legend.direction=\"vertical\",\n    legend.title = element_text(angle = 90),\n    legend.title.align = 0.5,\n    legend.box.just = \"left\"\n    ) +\n  \n  # 图例细节调整 \n  # Legend fine-tuning\n  guides(\n     fill = guide_colorbar(title.position = \"left\", order = 1),\n     size = guide_legend(title.position = \"left\", order = 2)\n     )\np\nY轴标星，采用\nPvalue\n中的\nlabel\n替换原本的\nyaixs 文本信息\nY-axis significance markers: Replace original axis labels with\nasterisk-tagged labels from the Pvalue$label column\n# 在基础图形p上添加y轴标签设置 \n# Add y-axis label settings to base plot p\np1 <- p +  scale_y_discrete(labels = rev(Pvalue$label), position = \"left\") \np1\n保存结果为 PDF 到本地，再通过 AI 等 PDF 编辑器进行后期的编辑。\nSave the results as PDF, then perform post-processing using PDF\neditors like Adobe Illustrator (AI).\n# 保存PDF格式图形\n# Save plot as PDF\nggsave(\"heatmap_bubble_plot_width3.pdf\", p1, height = 10, width = 3, device = \"pdf\")\n\n# 调整输出比例，就变成了方格\n# By adjusting the output ratio, it becomes a grid\nggsave(\"heatmap_bubble_plot_width1.5.pdf\", p1, height = 10, width = 1.5, device = \"pdf\")\nAI 简单的编辑后的结果：\nThe result after simple editing by AI:\nAI_edit_heatmap_bubble_plot\n最后给大家看看这篇文章作者用\nPYTHON\n版本的绘制的草图：\nFinally, let’s take a look at the sketches drawn by the author of\nthis article in the ‘PYTHON’ version:\nFigure_2.ipynb\n会话信息\nSession Info\n# 显示会话信息\n# Show session information\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa278heatmapPoints_FigureYa278heatmapPoints",
      "title": "FigureYa278heatmapPoints/FigureYa278heatmapPoints.html",
      "html": "FigureYa278heatmapPoints/FigureYa278heatmapPoints.html",
      "text": "texts/main_FigureYa278heatmapPoints_FigureYa278heatmapPoints.txt",
      "folder": "FigureYa278heatmapPoints",
      "thumb": "gallery_compress/FigureYa278heatmapPoints.webp"
    },
    "word_count": 1529,
    "lines_count": 394,
    "title": "FigureYa278heatmapPoints",
    "description": "Requirements Description Heatmap和Bubble plot叠加的图。 Heatmap和Bubble plot用的是两套数据。",
    "input_data_types": [
      "临床数据"
    ],
    "output_types": [
      "热图",
      "统计表格"
    ],
    "technical_methods": [
      "通路分析"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "colour",
      "times",
      "width",
      "pvalue",
      "order",
      "colours",
      "labels",
      "name"
    ]
  },
  {
    "id": "main_FigureYa272scBulkCCCI_FigureYa272scBulkCCCI",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa272scBulkCCCI_FigureYa272scBulkCCCI.txt",
    "content": "FigureYa272scBulkCCCI\nFigureYa272scBulkCCCI\nAuthor(s)\n: Xiaojian Liu; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-05-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nDemand description\n基于细胞类型signature识别细胞-细胞互作\nIdentifying cell-cell interactions based on cell type signatures.\n出自：\nhttps://linkinghub.elsevier.com/retrieve/pii/S009286742030341X\n图S8.\n相关性细胞互作网络分析框架及人和小鼠肿瘤中髓系细胞亚群概述（与图3和STAR方法相关）。\n(A) 相关性网络分析流程图。\n从Smart-seq2单细胞RNA测序数据中鉴定出细胞\n亚型特异性基因\n，并用于\n估算TCGA/GTEx批量RNA测序数据中的相对丰度\n。在过滤掉自身表达的基因后，计算\n高相关性基因\n。最后，基于Smart-seq2表达谱进行\n富集分析\n，以\n识别所有相关的细胞亚型并构建相关性网络\n（STAR方法）。\nSource:\nhttps://linkinghub.elsevier.com/retrieve/pii/S009286742030341X\nFigure S8. Analysis Framework for Correlative Cell-Cell Interaction\nNetworks and Summary of Myeloid Cell Subsets in Human and Mouse Tumors,\nRelated to Figure 3 and STAR Methods. (A) Workflow illustrating\ncorrelative network analysis. Cell\nsubtype specific\ngenes\nwere identified from the Smart-seq2 scRNA-seq dataset and\nwere used to\nestimate the relative abundance in TCGA/GTEx bulk\nRNA-seq datasets.\nAfter filtering the self-expressed genes,\nhigh correlative genes\nwere calculated. Finally, an\nenrichment analysis\nbased on Smart-seq2 profile was\nperformed to\nidentify all correlated cell subtypes and build the\ncorrelative network\n(STAR Methods).\n应用场景\nApplication scenarios\n借助scRNA-seq找到的signature genes，推断bulk\nRNA-seq样本的细胞类群互作网络，最后用igraph（静态）和networkD3（动态）两种网络可视化工具来展示结果。\n本文档作者写了个R包scBulkCCCI，以便小伙伴运行例文的workflow。\nscBulkCCCI：correlative cell-cell interaction networks based on\ncombining scRNA-seq and TCGA datasets\n包的自带描述文档，见ScBulkCCCI/README.md\n示例部分数据，储存在ScBulkCCCI/data，scRNA-seq数据太大，未内置在包中，根据说明去下载；\n数据经过预处理：数据预处理的code查看ScBulkCCCI包下ScBulkCCCI_DataPreprocess.R，\n位于ScBulkCCCI/example；\n示例运行代码ScBulkCCCI.R，于ScBulkCCCI/example；\nUsing signature genes identified from scRNA-seq, we inferred cell\npopulation interaction networks in bulk RNA-seq samples, and finally\nvisualized the results using two network visualization tools: igraph\n(static) and networkD3 (dynamic).\nThe author of this document developed an R package, scBulkCCCI, to\nhelp users run the workflow described in the example.\nscBulkCCCI: Correlative cell-cell interaction networks based on\ncombining scRNA-seq and TCGA datasets\nPackage documentation: See ScBulkCCCI/README.md.\nExample datasets: Stored in ScBulkCCCI/data. Note that the scRNA-seq\ndata is too large to be included in the package—please download it\nseparately as instructed.\nPreprocessed data: The preprocessing code can be found in\nScBulkCCCI/example/ScBulkCCCI_DataPreprocess.R.\nExample execution code: ScBulkCCCI.R, located in\nScBulkCCCI/example\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(\"ScBulkCCCI\")\nlibrary(\"pheatmap\")\nlibrary(\"RColorBrewer\")\nlibrary(\"ggplot2\")\nlibrary(\"ggthemes\")\nlibrary(\"plyr\")\nlibrary(\"dplyr\")\nlibrary(\"stringr\")\nlibrary(\"tibble\")\nlibrary(\"tidyr\")\n\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n输入文件\nInput Files\n输入文件包含两部分：scRNA-seq、bulk\nRNA-seq（以TCGA数据为例，也可以用其他RNA-seq数据）。\nThe input files consist of two parts: scRNA-seq and bulk RNA-seq\n(using TCGA data as an example, though other RNA-seq data can also be\nused).\nscRNA-seq 数据\nscRNA-seq data\n下载地址：\nGSE146771\nDownload link:\nGSE146771\nCRC.Leukocyte.Smart-seq2.Metadata.txt: 细胞类群信息\nCellName: 细胞ID\nTissue: 细胞所属组织类型\nGlobal_Cluster: 一级分类\nSub_Cluster: 二级分类\nCRC.Leukocyte.Smart-seq2.TPM.txt:\n细胞基因定量矩阵，列是细胞，行是基因\nCRC.Leukocyte.Smart-seq2.Metadata.txt: Cell population\ninformation\nCellName: Cell ID\nTissue: Tissue type of the cell\nGlobal_Cluster: First-level classification\nSub_Cluster: Second-level classification\nCRC.Leukocyte.Smart-seq2.TPM.txt: Cell gene expression matrix\n(columns: cells, rows: genes)\n# 读取TPM标准化后的单细胞表达矩阵\n# Read TPM-normalized single-cell expression matrix\nCRC_Leukocyte_SM_RNA <- read.table(\"CRC.Leukocyte.Smart-seq2.TPM.txt\",header = T)\nbulk RNAseq数据\nBulk RNA-seq Data\n从\nUCSC Xena\n下载后进行预处理（COAD and\nREAD），预处理代码见ScBulkCCCI安装包中的example/ScBulkCCCI_DataPreprocess.R。已打包到R包里，直接加载即可。\ndataMerge_normal_allgene.rds: 列是样本，行是基因ID\ndataMerge_tumor_allgene.rds: 列是样本，行是基因ID\nPreprocessed data (COAD and READ) downloaded from\nUCSC Xena\n. The preprocessing code is\navailable in the ScBulkCCCI package under\nexample/ScBulkCCCI_DataPreprocess.R. The processed data is bundled in\nthe R package and can be directly loaded.\ndataMerge_normal_allgene.rds: Column is sample, row is gene ID\ndataMerge_tumor_allgene.rds: Column is sample, row is gene ID\ndataMerge_tumor_allgene <- readRDS(paste(libPath, \"/data/dataMerge_tumor_allgene.rds\",sep=\"\")); dim(dataMerge_tumor_allgene)\n特征基因\nSignature Genes\n特征基因用于相关性互作分析\n怎样筛选自己的Signature Genes？\n可参考例文的“Identification of signature\ngenes”，里面描述了接seurat的筛选标准。单细胞数据前期处理及seurat常规流程可参考FigureYa177RNAvelocity。\n对于异质性较大的样品，可参考FigureYa223scNMF，不用seurat，而是借助NMF和聚类分析找marker\ngene。\n这里直接整理例文的\nTable\nS4 of paper\n，已打包到R包里，直接加载即可。\nCCgene_normal.rds: 正常组织富集的免疫细胞类群的signature\ngenes；第一列基因，第二列细胞类群名\nCCgene_tumor.rds: 肿瘤组织富集的免疫细胞类群的signature\ngenes；第一列基因，第二列细胞类群名\nSignature Genes were Used for Correlative Interaction Analysis\nHow to Select Your Own Signature Genes?\nRefer to the example section “Identification of signature genes”. It\ndescribes the Seurat-based selection criteria. For single-cell data\npreprocessing and standard Seurat workflow, refer to\nFigureYa177RNAvelocity.\nFor highly heterogeneous samples, refer to FigureYa223scNMF. Instead\nof Seurat, it uses NMF and clustering to identify marker genes.\nHere we directly provide the curated Table S4 of the paper\nTable\nS4 of paper\n, which has been packaged into the R package and can be\nloaded directly.\nCCgene_normal.rds: Signature genes for immune cell populations\nenriched in normal tissues; Column 1: gene names, Column 2: cell\npopulation names\nCCgene_tumor.rds: Signature genes for immune cell populations\nenriched in tumor tissues; Column 1: gene names, Column 2: cell\npopulation names\n# 从预存RDS文件中加载正常组织的细胞周期特征基因\n# Load cell cycle signature genes for normal tissue from pre-saved RDS file\nCCgene_normal <- readRDS(paste(libPath, \"/data/CCgene_normal.rds\",sep=\"\"))\n\n# 从预存RDS文件中加载肿瘤组织的细胞周期特征基因\n# Load cell cycle signature genes for tumor tissue from pre-saved RDS file\nCCgene_tumor <- readRDS(paste(libPath, \"/data/CCgene_tumor.rds\",sep=\"\"))\n\n# 查看正常组织特征基因前几行\n# Preview first few rows of normal tissue signature genes\nhead(CCgene_normal)\n# 查看肿瘤组织特征基因前几行\n# Preview first few rows of tumor tissue signature genes\nhead(CCgene_tumor)\n相关性矩阵\nCorrelation matrix\n基于\n批量RNA测序\n数据和\n标记基因\n评估各细胞簇的丰度\nEvaluate the abundance of each cluster based on\nbulk\nRNAseq\ndata and\nmarker genes\n# 计算正常组织细胞亚型基因表达的相关性矩阵\n# Calculate correlation matrix for normal tissue cell subtype gene expression\ncor_matrix_normal = corMatrix(CCgene_normal, \n                              cluste = \"cluster\",\n                              dataMerge_normal_allgene)\n# 显示相关性矩阵维度\n# Show correlation matrix dimensions\ndim(cor_matrix_normal)\n# 计算肿瘤组织细胞亚型基因表达的相关性矩阵\n# Calculate correlation matrix for tumor tissue cell subtype gene expression\ncor_matrix_tumor = corMatrix(CCgene_tumor, \n                             cluste = \"cluster\",\n                             dataMerge_tumor_allgene)\n# 显示相关性矩阵维度\n# Show correlation matrix dimensions\ndim(cor_matrix_tumor)\n富集分析\nEnrichment analysis\n高相关性基因 - 针对特定细胞亚型与其他细胞亚型\nHighly correlated genes - For a specific cell subtype and another\ncell subtype\n分析成果：从调整后的相关性矩阵中获得的、特定细胞亚型与其他亚型的非自身表达基因的排序相关性结果\n步骤1：鉴定自身表达基因\n步骤2：通过自身表达基因调整相关性矩阵\nAchievement: the ranked correlated non-self-expressed genes from the\nadjusted correlation matrix for a specific cell subtype\nstep 1. Identify self-expressed genes\nstep 2. Adjust correlation matrix by self-expressed genes\n# 从正常组织特征基因中提取唯一的亚群名称列表，并选择第一个亚群\n# Extract unique subcluster names from normal tissue signature genes and select the first one\nsubcluter_name= unique(CCgene_normal$cluster)[1] #unique(CCgene_normal$cluster)[1] #unique(CCgene_normal$cluster)[1]\n\n# 筛选与指定亚群高度相关且非自身表达的基因\n# Filter genes highly correlated with target subcluster but not self-expressed\nhighCorNonSelfGenes <- highCorGene(subcluter_name= subcluter_name,\n                                  Sub_Cluster=\"Sub_Cluster\", CellName=\"CellName\",\n                                  cellMetaData= CRC_Leukocyte_SM_MD, ScExMatrix=CRC_Leukocyte_SM_RNA,\n                                  cor_matrix=cor_matrix_normal,TopMethod=\"Positive\")\n# 绘制相关性排名图\n# Plot correlation rank\nhighCorNonSelfGenes$correlatioRankPlot\n富集评分 - 针对特定细胞亚型与多个细胞亚型\nEnrich score - For a specific cell subtype and multiple cell\nsubtype\n# 合并正常和肿瘤组织的所有独特亚群名称\n# Combine all unique subcluster names from normal and tumor tissues\nallClusters <- unique(c(as.character(CCgene_normal$cluster), as.character(CCgene_tumor$cluster))) \n#allClusters<- unique(CRC_Leukocyte_SM_MD$Sub_Cluster)\n\n# 执行一对多亚群富集分析（使用前13个高相关基因）\n# Perform one-to-multiple subcluster enrichment analysis (using top 13 correlated genes)\nES <- oneToMultiple(allClusters= allClusters,\n                   topCorGene=names(highCorNonSelfGenes$CorGeneRank[1:13]),\n                   cellMetaData= CRC_Leukocyte_SM_MD, ScExMatrix=CRC_Leukocyte_SM_RNA,\n                   Sub_Cluster=\"Sub_Cluster\", CellName=\"CellName\")\nscale(na.omit(ES))\n# 创建绘图数据框（包含标准化分数和颜色分组信息）\n# Create plotting dataframe (with normalized scores and color groups)\nESData = data.frame(name = rownames(scale(na.omit(ES))),ES=scale(na.omit(ES)))\nESData$colorInfo = as.factor(ifelse(ESData$ES>0, \"pos\", \"neg\"))\n\n# 富集分数可视化\n# Enrichment Score Visualization\nggplot() + geom_bar(data = ESData,aes(x=name, y=ES, fill=colorInfo),stat = \"identity\") + \n  geom_hline(yintercept=1, color=\"blue\", linetype=\"dashed\") +\n  scale_fill_manual(values=c(\"#87CEFA\", \"#6495ED\")) +\n  labs(x = \"Correlative cell cluster\", y = \"Enrichment score\", title = paste(\"Enrichment analysis for\",subcluter_name,sep = \" \")) +\n  theme_base() +\n  theme(axis.text.x = element_text(size = 15, vjust = 0.5, hjust = 0.5, angle = 90)) + \n  theme(legend.position=\"none\") +\n  theme(plot.title = element_text(hjust = 0.5))\n# 保存为PDF\n# Save as PDF\nggsave(\"EnrichScore.pdf\", width = 12, height = 8)\n相关性网络分析 - 针对多细胞亚型间互作\nCorrelative network - For multiple cell subtypes and multiple cell\nsubtypes\n# 合并正常和肿瘤组织的所有独特亚群名称\n# Combine all unique subcluster names from normal and tumor tissues\nallClusters = unique(c(as.character(CCgene_normal$cluster), as.character(CCgene_tumor$cluster))) #unique(CRC_Leukocyte_SM_MD$Sub_Cluster)\n\n# 例文选了top 13 highly correlated non-self-expressed genes were selected from the adjusted correlation matrix.\n# 根据自己的数据调整\n# The reference selected top 13 highly correlated non-self-expressed genes from the adjusted correlation matrix.\n# Adjust parameters according to your own data\ntopGeneNum <- 13 \n\n{\n  # 正常组织亚群相互作用分析\n  # Normal tissue subcluster interaction analysis\n  normal_subtype_ES = cellCellInteraction(specificSubtypes = unique(CCgene_normal$cluster),\n                                          allClusters = allClusters, # unique(c(CCgene_normal$cluster, CCgene_tumor$cluster)), #unique(CRC_Leukocyte_SM_MD$Sub_Cluster)\n                                          cor_matrix = cor_matrix_normal,\n                                          cellMetaData= CRC_Leukocyte_SM_MD,\n                                          ScExMatrix=CRC_Leukocyte_SM_RNA,\n                                          Sub_Cluster=\"Sub_Cluster\",\n                                          CellName=\"CellName\",\n                                          topGeneNum = topGeneNum,\n                                          TopMethod=\"Positive\")\n  \n  # 肿瘤组织亚群相互作用分析\n  # Tumor tissue subcluster interaction analysis\n  tumor_subtype_ES = cellCellInteraction(specificSubtypes = unique(CCgene_tumor$cluster),\n                                         allClusters = allClusters, # unique(c(CCgene_normal$cluster, CCgene_tumor$cluster)),\n                                         cor_matrix = cor_matrix_tumor,\n                                         cellMetaData= CRC_Leukocyte_SM_MD,\n                                         ScExMatrix=CRC_Leukocyte_SM_RNA,\n                                         Sub_Cluster=\"Sub_Cluster\",\n                                         CellName=\"CellName\",\n                                         topGeneNum = topGeneNum,\n                                         TopMethod=\"Positive\")\n}\n# 添加组织来源标签\n# Add tissue origin labels\nnormal_subtype_ES$tissue = \"normal\"\ntumor_subtype_ES$tissue = \"tumor\"\n\n# 合并正常和肿瘤结果\n# Merge normal and tumor results\nsubtype_ES <- rbind(normal_subtype_ES,tumor_subtype_ES)\n\n# 保存肿瘤特异相互作用结果\n# Save tumor-specific interaction results\nwrite.table(tumor_subtype_ES, file = \"output_tumor_subtype.Correlative.cell_cell.interactions.txt\", quote = F, row.names = F, sep = \"\\t\") #\n\n# 保存合并后的相互作用结果\n# Save merged interaction results\nwrite.table(subtype_ES, file = \"output_correlative.cell_cell.interactions.txt\", quote = F, row.names = F, sep = \"\\t\")\n比较ScBulkCCCI与原文的相关细胞相互作用结果。\nCompare the result of correlative cell cell interactions between\nScBulkCCCI and paper.\n# 筛选hM03开头的亚群且富集分数>1的相互作用\n# Filter interactions for hM03-prefixed subtypes with enrichment score >1\ndplyr::filter(subtype_ES, grepl(\"^hM03\", specificSubtype), EnrichScore>1)\n# 筛选hM04开头的亚群且富集分数>1的相互作用\n# Filter interactions for hM04-prefixed subtypes with enrichment score >1\ndplyr::filter(subtype_ES, grepl(\"^hM04\", specificSubtype), EnrichScore>1)\n# 筛选hM12开头的亚群且富集分数>1的相互作用\n# Filter interactions for hM12-prefixed subtypes with enrichment score >1\ndplyr::filter(subtype_ES, grepl(\"^hM12\", specificSubtype), EnrichScore>1)\n# 筛选hM13开头的亚群且富集分数>1的相互作用\n# Filter interactions for hM13-prefixed subtypes with enrichment score >1\ndplyr::filter(subtype_ES, grepl(\"^hM13\", specificSubtype), EnrichScore>1)\nhM13_TAM-SPP1的富集分析结果在ScBulkCCCI中与文献报道一致。 The\nenrichment analysis result of\nhM13_TAM-SPP1\nfrom ScBulkCCCI\nis the same result as paper show.\n此外，hM03、hM04或hM12的富集分析结果并不完全相同，但具有相似性。\nWhat’s more, the enrichment analysis results of hM03, hM04 or hM12\nare not identical, but they are similar.\n开始画图\nPlotting\n# 读取肿瘤亚群间相互作用结果文件\n# Read tumor subtype interaction results file\ntumor_subtype_ES <- read.table(\"output_tumor_subtype.Correlative.cell_cell.interactions.txt\", header = T, sep = \"\\t\")\n\n# 筛选显著相互作用（EnrichScore > 1.96，相当于p<0.05）\n# Filter significant interactions (EnrichScore > 1.96, approx. p<0.05)\nnetworkData <- dplyr::filter(tumor_subtype_ES, EnrichScore>1.96, specificSubtype != otherSubtype)\n\n# 重新加载单细胞元数据\n# Reload single-cell metadata\nCRC_Leukocyte_SM_MD <- read.table(paste(libPath, \"/data/CRC.Leukocyte.Smart-seq2.Metadata.txt\",sep=\"\"),header = T, sep=\"\\t\", check.names = F);dim(CRC_Leukocyte_SM_MD)\n# 获取网络数据与元数据中的共同亚群\n# Get overlapping subtypes between network and metadata\noverlap <- intersect(unique(c(networkData$specificSubtype,networkData$otherSubtype)), CRC_Leukocyte_SM_MD$Sub_Cluster)\n\n# 从元数据中提取节点信息\n# Extract node information from metadata\nnodes <- dplyr::filter(CRC_Leukocyte_SM_MD,Sub_Cluster %in% overlap) %>%\n  select(Sub_Cluster, Global_Cluster) %>%\n  dplyr::distinct(Sub_Cluster,Global_Cluster) \n\n# 构建完整节点列表\n# Build complete node list\nnodes <- merge(data.frame(node = unique(c(networkData$specificSubtype,networkData$otherSubtype))), nodes, by.x=\"node\", by.y=\"Sub_Cluster\", all = T)\nnodes[is.na(nodes)] =\"Not annotation\"\n下面分别用igraph（静态）和networkD3（动态）两种网络可视化工具来展示Enrichment\nanalysis结果。\nBelow we present the Enrichment analysis results visualized using two\nnetwork tools: igraph (static) and networkD3 (interactive).\n通过igraph绘制网络\nPlot network by igraph\n# 加载igraph网络分析包\n# Load igraph network analysis package\nlibrary(\"igraph\")\n# 从数据框创建无向图对象\n# Create undirected graph object from data frame\ng <- graph_from_data_frame(networkData, directed=F, vertices=nodes)\n\n# 设置节点标签大小（0.75倍默认大小）\n# Set vertex label size (0.75x default)\nV(g)$label.cex=0.75\n\n# 设置节点标签颜色为黑色\n# Set vertex label color to black\nV(g)$label.color <- \"black\"\n\n# 使用RColorBrewer的Paired调色板设置节点颜色\n# Set vertex colors using RColorBrewer's Paired palette\nV(g)$color <- brewer.pal(n = 12, name =\"Paired\")[as.numeric(as.factor(V(g)$Global_Cluster))]\n\n# 设置节点边框颜色为白色\n# Set vertex frame color to white\nV(g)$frame.color <- \"white\"\n\n\n# 创建PDF输出文件\n# Create PDF output file\npdf(\"network_igraph.pdf\")\n\n# 绘制网络图\n# Plot network graph\nplot(g)\n\n# 添加图例\n# Add legend\nlegend(x=-1.5, y= 1, unique(as.factor(V(g)$Global_Cluster)), pch=21,\n       col=\"#777777\", pt.bg=unique(brewer.pal(n = 12, name =\"Paired\")[as.numeric(as.factor(V(g)$Global_Cluster))]), \n       pt.cex=2, cex=.8, bty=\"n\", ncol=1)\n\n# 关闭图形设备\n# Close graphics device\ndev.off()\n绘制动态网络\nPlot dynamic network\n#install.packages(\"networkD3\")\nlibrary(magrittr)\nlibrary(networkD3)\n\n# 创建节点属性数据框\n# Create node attributes dataframe\nnodeData <- data.frame(name=nodes$node,\n                       group= as.factor(nodes$Global_Cluster))\n\n# 创建边列表数据框\n# Create edge list dataframe\nlinkData <- data.frame(source = (match(networkData$specificSubtype, nodeData$name)-1),\n                       target = (match(networkData$otherSubtype, nodeData$name)-1))\n\n# 交互式网络绘制 \n# Interactive Network Visualization\nforceNetwork(\n  Links = linkData,\n  Nodes = nodeData,\n  Source = \"source\",\n  Target = \"target\",\n  NodeID = \"name\",Group = \"group\", legend = T, opacityNoHover = 1,zoom=T)\n# 输出到网页文件\n# Output to a web page file\nforceNetwork(\n  Links = linkData,\n  Nodes = nodeData,\n  Source = \"source\",\n  Target = \"target\",\n  NodeID = \"name\",Group = \"group\", legend = T, opacityNoHover = 1,zoom=T) %>%\n  saveNetwork(file = 'network.html')\n打开\nnetwork.html\n文件，即可查看动态网络。\nOpen the ‘network.html’ file and you can view the dynamic\nnetwork.\n附：Cell type enrichment across tissues\nAttached: Cell type enrichment across tissues\nCRC_Leukocyte_10x_MD <- read.table(paste(libPath, \"/data/CRC.Leukocyte.10x.Metadata.txt\",sep=\"\"),header = T, sep=\"\\t\", check.names = F);dim(CRC_Leukocyte_10x_MD)\nCRC_Leukocyte_10x_MD_FIilter = dplyr::filter(CRC_Leukocyte_10x_MD, grepl(\"^hM\",Sub_Cluster))\n\nRoe <- calTissueDist(CRC_Leukocyte_10x_MD_FIilter,colname.cluster=\"Sub_Cluster\", colname.tissue=\"Tissue\")\npheatmap::pheatmap(Roe, cluster_rows = F, cluster_cols = F, \n                   color = colorRampPalette(brewer.pal(n = 7, name =\"YlOrRd\"))(50),\n                   display_numbers = TRUE,number_color = \"black\")\n参考文献\nReference\nZhang L, Li Z, Skrzypczynska KM, Fang Q, Zhang W, O’Brien SA, He Y,\nWang L, Zhang Q, Kim A, Gao R, Orf J, Wang T, Sawant D, Kang J, Bhatt D,\nLu D, Li CM, Rapaport AS, Perez K, Ye Y, Wang S, Hu X, Ren X, Ouyang W,\nShen Z, Egen JG, Zhang Z, Yu X. Single-Cell Analyses Inform Mechanisms\nof Myeloid-Targeted Therapies in Colon Cancer. Cell. 2020 Apr\n16;181(2):442-459.e29. doi: 10.1016/j.cell.2020.03.048. PMID:\n32302573.\nZhang L, Yu X, Zheng L, Zhang Y, Li Y, Fang Q, Gao R, Kang B, Zhang\nQ, Huang JY, Konno H, Guo X, Ye Y, Gao S, Wang S, Hu X, Ren X, Shen Z,\nOuyang W, Zhang Z. Lineage tracking reveals dynamic relationships of T\ncells in colorectal cancer. Nature. 2018 Dec;564(7735):268-272. doi:\n10.1038/s41586-018-0694-x. Epub 2018 Oct 29. PMID: 30479382.\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa272scBulkCCCI_FigureYa272scBulkCCCI",
      "title": "FigureYa272scBulkCCCI/FigureYa272scBulkCCCI.html",
      "html": "FigureYa272scBulkCCCI/FigureYa272scBulkCCCI.html",
      "text": "texts/main_FigureYa272scBulkCCCI_FigureYa272scBulkCCCI.txt",
      "folder": "FigureYa272scBulkCCCI",
      "thumb": "gallery_compress/FigureYa272scBulkCCCI.webp"
    },
    "word_count": 1932,
    "lines_count": 502,
    "title": "FigureYa272scBulkCCCI",
    "description": "Demand description 基于细胞类型signature识别细胞-细胞互作 Identifying cell-cell interactions based on cell type signatures.",
    "input_data_types": [
      "临床数据",
      "表达矩阵",
      "单细胞"
    ],
    "output_types": [
      "散点图",
      "热图",
      "统计表格",
      "网络图"
    ],
    "technical_methods": [
      "聚类分析",
      "网络分析",
      "通路分析",
      "标准化"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "Target",
      "values",
      "Sub_Cluster",
      "cellMetaData",
      "header",
      "Source",
      "width",
      "vertices",
      "cluster_cols"
    ]
  },
  {
    "id": "main_FigureYa170ImmuLncRNA_FigureYa170ImmuLncRNA",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa170ImmuLncRNA_FigureYa170ImmuLncRNA.txt",
    "content": "FigureYa170ImmuLncRNA\nFigureYa170ImmuLncRNA\nAuthor(s)\n: Rongfang Shen\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement\n希望在展示代码的时候能做一些讲解，讲的容易理解一些，原文写的有些看不懂。\nI’d appreciate some explanations when presenting the code to make it\neasier to understand, as the original paper is a bit difficult to\nunderstand.\n出自\nhttps://www.nature.com/articles/s41467-020-14802-2\nFrom\nhttps://www.nature.com/articles/s41467-020-14802-2\nFig.1 Identification of immune-related lncRNAs across cancer types. d\nThe number of immune-related lncRNAs identified in each cancer type. The\ntop y-axis shows the number of lncRNAs and the bottom y-axis shows the\nproportion of lncRNAs. Source data are provided as a Source Data\nfile.\n利用偏相关系数和GSEA算法鉴定免疫相关的lncRNA，作者提供了R包，算法的主要精华其实已经给我们了。接下来我们就一步步解析，看文章里method部分如何对应算法R\ncode。 The authors provide an R package for identifying immune-related\nlncRNAs using the partial correlation coefficient and the GSEA\nalgorithm. The key points of the algorithm are already provided. Next,\nwe will analyze it step by step to see how the method section in the\narticle corresponds to the R code for the algorithm.\n应用场景\nApplication Scenarios\n对lncRNA做功能注释，也可以用于甲基化数据等。 Functional annotation of\nlncRNAs can also be applied to methylation data, etc.\n双坐标轴图通常用来对比展示数据之间的变化趋势相关关系： Dual-axis\ncharts are often used to compare and display trends and correlations\nbetween data:\n散点图 + 线性回归，展示3组数据的相关性，A vs. B 和 A\nvs. C，可参考FigureYa62twoAxis。\n柱形图 + 折线图，像本篇例文这样，一个是数量，另一个是比例。\nScatter plot + linear regression, showing the correlation between\nthree data sets, A vs. B and A vs. C. See FigureYa62twoAxis.\nBar chart + line chart, like the example in this article, one\nshowing quantity and the other showing proportion.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(ComplexHeatmap)\nlibrary(TCGAbiolinks)\nlibrary(SummarizedExperiment)\nlibrary(dplyr)\nlibrary(tidyverse)\nlibrary(fgsea)\nlibrary(ggplot2)\nlibrary(ImmuLncRNA)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 #Display English error messages\noptions(stringsAsFactors = FALSE) #禁止chr转成factor #Disable conversion of chr values to factors\n加载自定义函数，做标准化 Load custom functions for normalization\nAdjust_mrna <- function(mrna){\n  mRow30 <- which(apply(mrna,1,function(v){return((sum(v==0)/length(v))>=0.3)}))\n  mRemv <- mRow30\n  if(length(mRemv)==0){\n      mRNA_out0 <- mrna\n    }else{\n      mRNA_out0 <- mrna[-(mRemv),]\n    }\n    mRNA_exp_inter <- log2(mRNA_out0+0.001)\n    return(mRNA_exp_inter)\n}\n\nAdjust_lncrna <- function(lncrna){\n  lncRow50 <- which(apply(lncrna,1,quantile,probs=0.5)==0)\n    lncRow90 <- which(apply(lncrna,1,quantile,probs=0.9)<=0.1)\n    lncRemv <- union(lncRow50,lncRow90)\n    if(length(lncRemv)==0){\n      lncRNA_out0 <- lncrna\n    }else{\n      lncRNA_out0 <- lncrna[-(lncRemv),]\n    }\n    lncRNA_exp_inter <- log2(lncRNA_out0+0.001)\n    return(lncRNA_exp_inter)\n}\n输入文件的准备\nPreparing the Input File\n如果你只想画这种双坐标图，就把自己的数据整理成easy_input.csv的格式，直接跳到“开始画图”。\nIf you only want to draw this dual-coordinate graph, format your data as\neasy_input.csv and jump directly to “Start Drawing.”\n数据下载\nData Download\n以ACC为例，其余癌种同；下载数据后根据GENECODE的注释划分lncRNA表达矩阵和mRNA表达矩阵。数据处理为排除read数为0后进行Log转化。\nUsing ACC as an example, the same procedure applies to other cancer\ntypes. After downloading the data, divide the lncRNA expression matrix\ninto an mRNA expression matrix based on GENECODE annotations. Data\nprocessing includes excluding reads with zero counts and performing log\ntransformation.\n数据处理方法按照文章所示： The data processing method is as shown in\nthe article:\nRNA-Seqbased gene expression profile data were obtained from the TCGA\nproject via the R package\n“TCGAbiolinks”\n56. We\ndownloaded the\nfragments per kilobase of transcript per\nmillion\nmapped reads-based gene expression and the raw read\ncount for 33 types of cancer. Based on the gene annotations in\nGENCODE\n, we divided the gene expression profiles into\nlncRNA and protein-coding gene expression for each cancer type. The\nlncRNAs were further classified into different subtypes based on the\nclassification in GENCODE. In total, 19,663 coding genes and 15,513\nlncRNAs were included. Next, we excluded the coding genes and lncRNAs\nwith zero reads in all samples. The expression values of lncRNAs and\nprotein-coding genes were logtransformed.\n下载表达矩阵 Download expression matrix\nquery <- GDCquery(project = \"TCGA-ACC\",\n                  data.category = \"Transcriptome Profiling\",\n                  data.type = \"Gene Expression Quantification\", \n                  workflow.type = \"HTSeq - FPKM\", sample.type = c(\"Primary solid Tumor\"))\nGDCdownload(query, method = \"api\", files.per.chunk = 10)\nacc <- GDCprepare(query)\n#保存到文件，便于以后重复使用\n#Save to file for future reuse\nsave(acc, file = \"acc.rda\")\n提取protein coding RNA和lncRNA的gene_id和gene_name对应关系\nExtract protein coding Correspondence between gene_id and gene_name\nfor RNA and lncRNA\n根据\nlncRNA的分类\nlncRNA分为以下几种 According to the\nlncRNA\nclassification\nlncRNAs are classified into the following\ncategories:\nlncRNA的注释文件可以从\ngenecode\n下载，全部rna的基因注释可以从\n这里\n下载。\nThe lncRNA annotation file can be downloaded from\ngenecode\n.\nGene annotations for all RNAs can be downloaded from\nhere\n.\n# protein_coding RNA\ngtf_mrna_v22 <- rtracklayer::import('gencode.v27.annotation.gtf') %>% as.data.frame()\ngtf_mrna_v22 <- dplyr::select(gtf_mrna_v22,c(\"gene_id\",\"gene_type\", \"gene_name\")) %>% \n  subset(., gene_type == \"protein_coding\") %>% unique()\ngtf_mrna_v22$gene_id <- str_split(gtf_mrna_v22$gene_id, \"\\\\.\") %>% lapply(., \"[[\", 1) %>% unlist()\nwrite.table(gtf_mrna_v22, \"gtfmRNA22.txt\", row.names = F, sep = \"\\t\")\n\n# lncRNA\ngtf_lnc_v22 <- rtracklayer::import(\"gencode.v22.long_noncoding_RNAs.gtf.gz\") %>%  as.data.frame() %>% dplyr::select(., c(\"gene_id\", \"gene_type\", \"gene_name\")) %>% unique()\ngtf_lnc_v22$gene_id <- str_split(gtf_lnc_v22$gene_id, \"\\\\.\") %>% lapply(., \"[[\", 1) %>% unlist()\nwrite.table(gtf_lnc_v22, \"gtflncRNA22.txt\", row.names = F, sep = \"\\t\")\n(load(\"acc.rda\"))\nacc.dat <- as.data.frame(assay(acc))\n\ngtf_mrna_v22 <- read.table(\"gtfmRNA22.txt\", header = T, sep = \"\\t\")\nhead(gtf_mrna_v22)\ngtf_lnc_v22 <- read.table(\"gtflncRNA22.txt\", header = T, sep = \"\\t\")\nhead(gtf_lnc_v22)\n\n# mRNA\n# 用于immune pathway的富集\n# Used for immune pathway enrichment\nacc_mrna <- acc.dat[rownames(acc.dat) %in% gtf_mrna_v22$gene_id, ]\nacc_mrna <- Adjust_mrna(acc_mrna)\n#write.table(acc_mrna, \"acc_mrna.txt\", sep = \"\\t\")\n\n# mRNA\n# genesymbol作为rowname，用来做免疫纯度估计\n# genesymbol as rowname, used for immune purity estimation\nacc_mrna2 <- merge(gtf_mrna_v22[, c(\"gene_id\", \"gene_name\")], acc.dat, by.x = 1, by.y = 0) %>%\n  .[, -1]\nacc_mrna2 <- aggregate(.~gene_name, acc_mrna2, max)\nrownames(acc_mrna2) <- acc_mrna2$gene_name; acc_mrna2 <- acc_mrna2[, -1]\nacc_mrna2 <- Adjust_mrna(acc_mrna2)\nwrite.table(acc_mrna2, \"purityinput.txt\", sep = \"\\t\", quote = F)\n\n# lncRNA\nacc_lnc <- merge(gtf_lnc_v22[, c(\"gene_id\", \"gene_name\")], acc.dat, by.x = 1, by.y = 0) %>% .[, -1]\nacc_lnc <- aggregate(.~gene_name, acc_lnc, max)\nrownames(acc_lnc) <- acc_lnc[, 1]; acc_lnc <- acc_lnc[, -1]\nacc_lnc <- Adjust_lncrna(acc_lnc)\nacc_mrna[1:3, 1:3]\nacc_lnc[1:3, 1:3]\n#write.table(acc_lnc, \"acc_lnc.txt\", sep = \"\\t\")\nImmuLncRNA算法解析\nImmuLncRNA Algorithm Analysis\n注：这里代码都可以从R包\nImmuLncRNA\n中得到。\nNote: The code here can be obtained from the R package\nImmuLncRNA\n.\nStep1: estimate tumor purity\n问：文章找跟免疫相关的lncRNA, 为什么要消掉肿瘤纯度这个因素呢？ Q:\nWhen searching for immune-related lncRNAs in this article, why does it\neliminate the factor of tumor purity?\n大鹏答：本质上你找差异基因，也是要考虑肿瘤纯度，这是很重要covariate\n都要放在deseq里的model.matrix里 ，只是忽略了而已。你测的是bulk组织，\n测的是各组分平均表达量，当然组分比例不同，平均表达值就不同。肿瘤组织你的取样就那一点，并不能实际反应肿瘤全貌，存在取样差异，还不一定是浸润差异。所以这里不过用partial\npearson消除纯度的影响。我曾经矫正纯度或者利用Isopure分解的方法 和laser\ncapture\ndissection肿瘤的样本比较过，还是得到更好的结果。个人觉得confounding\nfactor重要的，还是要消除。 Dapeng’s Answer: Essentially, when searching\nfor differentially expressed genes, tumor purity must also be\nconsidered. This is very important. The covariate should be included in\nthe model.matrix in DESeq, but it was simply ignored. You are measuring\nbulk tissue and the average expression level of each component. Of\ncourse, different component proportions will result in different average\nexpression values. The sample size of the tumor tissue you sampled is\nlimited and doesn’t truly reflect the full tumor landscape. Sampling\nvariability exists, not necessarily differences in infiltration.\nTherefore, partial Pearson analysis is used here to eliminate the\ninfluence of purity. I’ve previously corrected for purity or used the\nIsopure decomposition method to compare samples obtained with laser\ncapture dissection, and still achieved better results. Personally, I\nthink the confounding factor is important and should be eliminated.\n至于差异基因，也有文章表明，考虑把肿瘤纯度加入，得到结果会更好。 As\nfor differentially expressed genes, some articles suggest that\nincorporating tumor purity can yield better results.\n还有些类型的肿瘤本身就癌巢就很小，大量免疫浸润，例如anaplastic\nthyroid\ncancer，测起来本身就是纯度低啊，照样做测序、芯片。只是做基因组测序\n想办法，提高肿瘤纯度了 Some tumor types, such as anaplastic thyroid\ncancer, have inherently small cancerous nests and extensive immune\ninfiltration. Therefore, sequencing and microarray analysis are still\nrecommended. It’s just genomic sequencing, but we’re looking for ways to\nimprove tumor purity.\n下面用estimate包计算肿瘤纯度 The following uses the estimate package\nto calculate tumor purity.\nlibrary(estimate)\n\n# estimate包计算浸润水平\n# estimate package calculates infiltration level\nfilterCommonGenes(\"purityinput.txt\", output.f=\"exp_deal.gct\", id=\"GeneSymbol\")\nestimateScore(\"exp_deal.gct\", \"estimate_score_all.gct\", platform=\"illumina\")\nest_score_all <- readLines(\"estimate_score_all.gct\")\nest_scores <- unlist(strsplit(est_score_all[grep(\"ESTIMATEScore\",est_score_all)],\"\\t\")) %>% \n  .[3:length(.)] %>% as.numeric()\n#肿瘤纯度 #tumorpurity\nTumour_purity <- cos(0.6049872018+0.0001467884*est_scores)\nsamples_name <- unlist(strsplit(est_score_all[grep(\"NAME\",est_score_all)],\"\\t\")) %>% \n  .[3:length(.)]\nnames(Tumour_purity) <- samples_name %>% str_replace_all(., \"\\\\.\", \"-\")\n#去除一些不要用的中间变量\n#Remove some unused intermediate variables\nrm(acc_mrna2, samples_name, est_score_all, est_scores)\nStep2: pcc\n在矫正免疫浸润水平的基础上算lncRNA和mRNA的偏相关系数(pcc)，算出RS。\nCalculate the partial correlation coefficient (PCC) between lncRNA and\nmRNA based on the correction for immune infiltration level and calculate\nRS.\n了解偏相关系数点击\n这里\nfun_mtx_pcr即为偏相关系数的主要算法。 To learn more about partial\ncorrelation coefficients, click\nhere\nfun_mtx_pcr\nis the main algorithm for partial correlation coefficients.\n#这一步非常耗费内存:生成的相关矩阵是行为lncRNA，列为mRNA的矩阵\n#This step is very memory-intensive: the resulting correlation matrix is a matrix with lncRNAs as rows and mRNAs as columns\nfun_mtx_pcr <- function(x,y,z){\n    r12=cor(t(x),t(y))\n    r13=cor(t(x),z)\n    r23=cor(z,t(y))\n    r123=r13%*%r23\n    rup=r12-r123\n    rd1=sqrt(1-r13*r13)\n    rd2=sqrt(1-r23*r23)\n    rd=rd1%*%rd2\n    rm(r12, r13, r23, r123, rd1, rd2)\n    gc()\n    rrr=rup/rd\n    return(rrr)\n}\nall(colnames(acc_lnc) == colnames(acc_mrna))\nall(colnames(acc_mrna) == names(Tumour_purity))\nn = ncol(acc_lnc) #样本数目\ngn = 1 #偏相关矫正的影响因素个数，这里只有肿瘤纯度一个。\n#Number of influencing factors for partial correlation correction. Here, only the tumour purity is used.\npcor <- fun_mtx_pcr(acc_lnc,acc_mrna, Tumour_purity)\n#计算统计量和P值\n#Calculate statistics and P-values\nstatistic <- pcor*sqrt((n-2-gn)/(1-pcor^2))\np.value <- 2*pnorm(-abs(statistic))\nrownames(pcor) <- rownames(acc_lnc) ; rownames(p.value) <- rownames(acc_lnc)\ncolnames(pcor) <- rownames(acc_mrna) ; colnames(p.value) <- rownames(acc_mrna)\n#计算RS: 也就是按照pvalue排序，根据正负相关赋予pvalue一个方向\n#Calculate RS: Sort by p-value and assign a direction to the p-value based on positive or negative correlation.\nRS <- -log10(p.value)*sign(pcor)\nRS[1:5, 1:5]\nStep3: fgsea\n接着采用fgsea对lncRNA做通路富集 Then fgsea was used to enrich lncRNA\npathways.\nload(\"pathways.rda\")\nk=0.995\nfgseaRes_all <- c()\n\nfor(i in 1:nrow(RS)){\n  ##remove the rows contain Infs\n  if(sum( is.infinite(RS[i,])) != 0){\n      next()\n    }\n  ranks <- RS[i,]\n  fgseaRes <- fgsea(pathways, ranks, minSize=1, maxSize=5000, nperm=1000)\n  sigValue <- c()\n  for(j in 1:nrow(fgseaRes)){\n      if(fgseaRes$ES[j]>0){\n        sig_ij <- 1 - 2*fgseaRes$pval[j]\n      }else{\n        sig_ij <- 2*fgseaRes$pval[j] - 1\n      }\n      sigValue <- c(sigValue,sig_ij)\n      \n    }\n    lncRNA <- rownames(RS)[i]\n    fgseaRes_i <- cbind(lncRNA,fgseaRes,sigValue)\n    fgseaRes_all <- rbind(fgseaRes_all,fgseaRes_i)\n}\n\n#筛选符合标准的gsea结果\n# Filter GSEAS results that meet the criteria\nsig_ind <- which(abs(fgseaRes_all$sigValue) >= k & fgseaRes_all$padj < 0.05)\n#即可求出lncRNA-pathway pairs\n# Calculate lncRNA-pathway pairs\nsig_pairs <- fgseaRes_all[sig_ind,1:2] %>% as.data.frame()\n跟原文结果比较\nCompare with the original results\n上述所有代码都在R包ImmuLncRNA中可以得到，一行代码搞定所有。 All the\nabove code is available in the R package ImmuLncRNA; it takes only one\nline of code.\n文章运行结果可以从其\n网页版界面\n中得到。\nThe results of the article can be found on its\nwebpage\n.\n我们下载画图所需的两个文件：Lnc_Pathways_Sig.txt &\nLnc_Pathways_All.txt We download the two files required for drawing:\nLnc_Pathways_Sig.txt & Lnc_Pathways_All.txt\n# 用R包ImmuLncRNA计算\n# Calculation using R package ImmuLncRNA\nacc_pack <- immu.LncRNA(acc_mrna, acc_lnc, adjusted=TRUE, Tumor_purity, pathways, k = 0.995)\n\n# 比较\n# Compare\npan_pairs <- read.table(\"Lnc_Pathways_Sig.txt\", header = T, sep = \"\\t\")\npan_pairs <- pan_pairs[, c(\"cancer_type\", \"lncRNA_symbol\")] %>% unique()\nwrite.table(pan_pairs, \"pan_lnc_sig.txt\", sep = \"\\t\")\n\nacc_lncrna <- unique(sig_pairs$lncRNA)\nacc_article <- pan_pairs[pan_pairs$cancer_type == \"ACC\", \"lncRNA_symbol\"] %>% unique()\nlength(intersect(acc_lncrna, acc_article))\n分解每一步骤算出的结果和原文大部分是一样的，不一致应该是由于数据预处理上的问题，原文acc输入的lncRNA数目有6501个，我们处理后只有5616\nThe results calculated in each step are largely consistent with the\noriginal paper. The discrepancy is likely due to data preprocessing\nissues. The original acc input contains 6501 lncRNAs, while ours only\ncontains 5616 after processing.\n计算lncRNA proportion\nCalculate lncRNA proportions\n# 加载前面计算获得的免疫相关lncRNA数量，用于top y-axis\n# Load the previously calculated immune-related lncRNA counts for the top y-axis\npan_pairs <- read.table(\"pan_lnc_sig.txt\", header = T, sep = \"\\t\")\npdat <- table(pan_pairs$cancer_type) %>% as.data.frame()\n\n# 计算lncRNA proportion，用于bottom y-axis\n# 每个癌症中所有lncRNA的数目，看“跟原文结果比较”部分的文字描述，获得Lnc_Pathways_All.txt文件\n# all <- data.table::fread(\"Lnc_Pathways_All.txt\", select = c(\"cancer_type\", \"lncRNA_symbol\")) %>%\n#                            unique()\n# write.table(all, \"pan_lnc_all.txt\", sep = \"\\t\")\n# Calculate lncRNA proportions for the bottom y-axis\n# The number of all lncRNAs in each cancer type is described in the \"Comparison with the original results\" section. Obtain the Lnc_Pathways_All.txt file.\n# all <- data.table::fread(\"Lnc_Pathways_All.txt\", select = c(\"cancer_type\", \"lncRNA_symbol\")) %>%\n# unique()\n# write.table(all, \"pan_lnc_all.txt\", sep = \"\\t\")\n\nall <- read.table(\"pan_lnc_all.txt\", header = T, sep = \"\\t\")\nall <-  table(all$cancer_type) %>% as.data.frame()\npdat <- merge(pdat, all, by = \"Var1\")\ncolnames(pdat) <- c(\"Cancer_type\", \"Sig\", \"All\")\npdat$Prop <- pdat$Sig/pdat$All\nwrite.csv(pdat, \"easy_input.csv\", quote = F, row.names = F)\n开始画图\nStart drawing the graph\n画法参考了FigureYa62twoAxis中的方法一。 The drawing method is based\non Method 1 in FigureYa62TwoAxis.\npdat <- read.csv(\"easy_input.csv\")\nhead(pdat)\n#按照原图的顺序排列纵坐标\n# Arrange the ordinates according to the order of the original image\npdat$Cancer_type <- factor(pdat$Cancer_type, levels = c(\"BRCA\", \"CHOL\", \"LIHC\", \"PAAD\", \"BLCA\", \"KICH\", \"KIRC\", \"KIRP\", \"PRAD\", \"TGCT\", \"CESC\", \"OV\", \"UCEC\", \"UCS\", \"SKCM\", \"SARC\", \"DLBC\", \"LAML\",\n\"THYM\", \"GBM\", \"LGG\", \"UVM\", \"HNSC\", \"ACC\", \"PCPG\", \"THCA\", \"LUAD\", \"LUSC\", \"MESO\", \"ESCA\", \"STAD\", \"COAD\", \"READ\"))\n\n#默认两个Y轴范围是一样的，然而实际数据Y1和Y2范围差距很大，因此需要用Y1和Y2的数值计算两个Y轴的比例\n# By default, the two Y-axis ranges are the same, but the actual data ranges of Y1 and Y2 differ significantly, so the scale of the two Y-axes needs to be calculated using the values of Y1 and Y2.\n(scaleFactor <- max(pdat$Sig)/ max(pdat$Prop))\n# 自定义配色方案\n# Custom color scheme\nlibrary(scales)\nmycols <- c(brewer_pal(palette = \"Reds\")(3),\n            brewer_pal(palette = \"Blues\")(9),\n            brewer_pal(palette = \"Purples\")(9),\n            brewer_pal(palette = \"YlOrRd\")(9),\n            brewer_pal(palette = \"OrRd\")(3))\nmycols\n# 或者自己挨个设置颜色\n#mycols <- c(\"\",\"\") # \"\"里写颜色编码\n# Or set the color yourself\n#mycols <- c(\"\",\"\") # Write the color code in \"\"\n\np <- ggplot(pdat, aes(x=pdat$Cancer_type)) + \n  # 画柱形图\n  # Draw a bar chart\n  geom_bar(aes(y = pdat$Sig / scaleFactor , fill = pdat$Cancer_type), stat = \"identity\", size = 0.8, width = 0.7) +\n  scale_fill_manual(values = mycols) + #自定义bar的颜色 #Customize the color of the bar \n\n  # 画折线图\n  # Draw a line chart \n  geom_point(aes(y = pdat$Prop), shape = 21, fill = \"white\") +\n  geom_line(aes(y = pdat$Prop, group = 1)) +\n  \n  scale_x_discrete(expand = expand_scale(mult = c(0.04,0.04)), #上下留空 #Leave the top and bottom blank \n                   limits = rev(levels(pdat$Cancer_type))) + \n  scale_y_continuous(name = \"Proportions of immune-related lncRNAs\",  \n                     sec.axis=sec_axis(trans = ~. * scaleFactor, \n                                       name = \"Number of immune-related lncRNAs\",\n                                       breaks = c(1000, 2000, 3000, 4000, 5000, 6000)),\n                     expand = c(0, 0)) + #画右侧Y轴 # Draw the right Y axis\n  labs(x=\"\") + \n  theme_bw() + #去除背景色 # Remove the grid lines\n  theme(panel.grid = element_blank()) + #去除网格线 # Do not draw the legend\n  theme(legend.position = \"none\") + #不画图例 # Do not draw the legend\n  coord_flip() #坐标轴互换，因此图中x轴对应纵坐标癌症名 # Swap the axes so the x-axis corresponds to the cancer name on the y-axis\np\nggsave(\"ImmuLncRNA.pdf\", width = 5, height = 8)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa170ImmuLncRNA_FigureYa170ImmuLncRNA",
      "title": "FigureYa170ImmuLncRNA/FigureYa170ImmuLncRNA.html",
      "html": "FigureYa170ImmuLncRNA/FigureYa170ImmuLncRNA.html",
      "text": "texts/main_FigureYa170ImmuLncRNA_FigureYa170ImmuLncRNA.txt",
      "folder": "FigureYa170ImmuLncRNA",
      "thumb": "gallery_compress/FigureYa170ImmuLncRNA.webp"
    },
    "word_count": 2082,
    "lines_count": 447,
    "title": "FigureYa170ImmuLncRNA",
    "description": "Requirement 希望在展示代码的时候能做一些讲解，讲的容易理解一些，原文写的有些看不懂。 I’d appreciate some explanations when presenting the code to make it",
    "input_data_types": [
      "表达矩阵",
      "临床数据",
      "DNA-seq"
    ],
    "output_types": [
      "散点图",
      "热图",
      "统计表格"
    ],
    "technical_methods": [
      "通路分析",
      "标准化"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "id",
      "nperm",
      "values",
      "rrr",
      "header",
      "gn",
      "width",
      "grid",
      "n"
    ]
  },
  {
    "id": "main_FigureYa322SSEA_FigureYa322SSEA",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa322SSEA_FigureYa322SSEA.txt",
    "content": "FigureYa322SSEA\nFigureYa322SSEA\nAuthor(s)\n: Xiaofan Lu; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-05-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nDemand description\n这篇文章中SSEA算法可否复现？数据没有限制，想学习一下这个计算流程。\nCan the SSEA algorithm in this paper be reproduced? There are no data\nrestrictions, and I’d like to learn this computational workflow.\n出自：\nhttps://www.nature.com/articles/ncomms15107\nSource:\nhttps://www.nature.com/articles/ncomms15107\n应用场景\nApplication scenarios\n计算通路的亚型富集得分(SSEA)，并绘制各亚型SSEA得分雷达图。\n如果只想画雷达图，可以套用easy_input_SSEA.txt的格式调整自己的数据，直接前往“开始画图”。\n适合同时展示多组数据的多个特征。\n一组数据多个特征或多组数据一个特征，可参考FigureYa8radar\n，画成花瓣雷达图。\nCalculate the subtype enrichment scores (SSEA) for pathways and plot\nradar charts of SSEA scores for each subtype.\nIf you only want to draw the radar chart, you can format your data\naccording to the structure of easy_input_SSEA.txt and go directly to the\n“Start plotting” section.\nSuitable for simultaneously displaying multiple features across\nmultiple datasets.\nA single dataset with multiple features or multiple datasets with a\nsingle feature, you can refer to FigureYa8radar to create petal-style\nradar charts.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(openxlsx)\nlibrary(GSVA)\nlibrary(org.Hs.eg.db)\nlibrary(ggplot2)\nlibrary(fmsb)\nlibrary(fgsea)\nlibrary(dplyr)\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n自定义函数\nCustom Functions\n输入文件\nInput Files\nTCGA-READ.htseq_counts.tsv.gz，TCGA-COAD.htseq_counts.tsv.gz，表达谱eset。TCGA其他癌症类型表达数据可以到XENA下载\nhttps://xenabrowser.net/datapages/\n41467_2017_BFncomms15107_MOESM425_ESM.xlsx，样本分组信息subtype。\nsignature.xlsx，基因集signature【包含up和down两个列表】\nTCGA-READ.htseq_counts.tsv.gz, TCGA-COAD.htseq_counts.tsv.gz -\nExpression profiles (eset). For other TCGA cancer type expression data,\nvisit XENA:\nhttps://xenabrowser.net/datapages/\n41467_2017_BFncomms15107_MOESM425_ESM.xlsx - Sample subtype\nclassification information.\nsignature.xlsx - Gene signatures [contains both UP and DOWN\nlists]\nSYMBOL <- tmp$SYMBOL[match(rownames(eset), tmp$ENSEMBL)]\neset <- eset[!duplicated(SYMBOL) & !is.na(SYMBOL), ]\nrownames(eset) <- SYMBOL[!duplicated(SYMBOL) & !is.na(SYMBOL)]\n\n### 读取亚型信息\n### Read subtype information\nsubtype <- read.xlsx(\"41467_2017_BFncomms15107_MOESM425_ESM.xlsx\",\n                     startRow = 3)\nsubtype <- subtype[subtype$Dataset.ID == \"TCGA\", ]\nrownames(subtype) <- subtype$Sample.ID\n\n### 整理样本信息\n### Process sample information\ncomsam <- intersect(colnames(eset), subtype$Sample.ID)\neset <- eset[, comsam]\nsubtype <- subtype[comsam, \"CRIS.Assignment\"]\n计算通路得分\nCalculate pathway scores\ncolnames(score) <- pathway\n\n# 输出各亚型SSEA得分\n# Output SSEA scores for each subtype\nwrite.table(score, \"easy_input_SSEA.txt\", \n            row.names = T, col.names = NA, sep = \"\\t\", quote = F)\n开始画图\nPlotting\n绘制雷达图\nDraw radar chart\ndev.copy2pdf(file = file.path(\"SSEA.radar.pdf\"),\n             width = 8, height = 8)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa322SSEA_FigureYa322SSEA",
      "title": "FigureYa322SSEA/FigureYa322SSEA.html",
      "html": "FigureYa322SSEA/FigureYa322SSEA.html",
      "text": "texts/main_FigureYa322SSEA_FigureYa322SSEA.txt",
      "folder": "FigureYa322SSEA",
      "thumb": "gallery_compress/FigureYa322SSEA.webp"
    },
    "word_count": 345,
    "lines_count": 106,
    "title": "FigureYa322SSEA",
    "description": "Demand description 这篇文章中SSEA算法可否复现？数据没有限制，想学习一下这个计算流程。 Can the SSEA algorithm in this paper be reproduced? There are no data",
    "input_data_types": [
      "临床数据"
    ],
    "output_types": [
      "统计表格"
    ],
    "technical_methods": [
      "通路分析"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "LANGUAGE",
      "quote",
      "stringsAsFactors",
      "width",
      "startRow",
      "names",
      "height",
      "file"
    ]
  },
  {
    "id": "main_FigureYa124AssociationHeatmap_FigureYa125FishertestV2",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa124AssociationHeatmap_FigureYa125FishertestV2.txt",
    "content": "FigureYa125FishertestV2\nFigureYa125FishertestV2\nXiaofan Lu, Enyu Lin, Taojun Ye\n2025-5-20\n需求描述\n两个指标（miRNA和FAP蛋白）按照高低分为四组，计算两个指标的相关性和p\nvalue，用热图展示。\n#Requirement description\nDivide the two indicators (miRNA and FAP protein) into four groups\naccording to their levels, calculate the correlation and p-value between\nthe two indicators, and display them using a heatmap.\n出自\nhttp://cancerres.aacrjournals.org/content/78/7/1751\nfrom\nhttp://cancerres.aacrjournals.org/content/78/7/1751\nFigure 4. E–F, Comparison of the miR-508 ISH scores and the CALD1 and\nFAP IHC scores in colorectal cancer tissues. The correlations are shown\nin European cohort (n ¼ 128; E) and Renji cohort 2 (n ¼ 100; Fisher\nexact test; F).\n应用场景\n本质上就是把连续型因素分类后，研究两种因素间的相关性，用列联表热图展示，同时做Fisher’s\nexact test。\n可用于计算和展示miRNA跟靶基因，或转录因子跟靶基因之间的相关关系。\n在“小丫画图”微信公众号回复“相关性”，查看更多相关性展示方式。\n#Application scenarios\nEssentially, it is to classify continuous factors, study the\ncorrelation between two factors, display it using a contingency table\nheatmap, and conduct Fisher’s exact test.\nCan be used to calculate and display the correlation between miRNA\nand target genes, or transcription factors and target genes.\nReply to “Relevance” on “Xiaoya Pictorial” WeChat official account to\nsee more ways to display relevance.\n环境设置\n#Environment settings\n# 设置系统环境变量，使R显示英文报错信息 (Set system environment variable to display error messages in English)\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止R在读取数据时自动将字符串转换为因子 (Prevent R from automatically converting strings to factors when reading data)\noptions(stringsAsFactors = FALSE)\n输入文件\neasy_input.txt，两个连续型变量在每个样本里的观测值。每行一个样本，两列分别是两个观测值，此处是miRNA\nISH scores和FAP IHC scores。\n#Input file\neasy_input.txt， The observed values of two continuous variables in\neach sample. Each row contains one sample, and the two columns represent\ntwo observations, namely miRNA ISH scores and FAP IHC scores.\n# 从easy_input.txt文件读取数据，假设首行为列名 (Read data from easy_input.txt, assuming the first row contains column names)\nsimdata <- read.table(\"easy_input.txt\",header = T)\n# 查看数据前几行，了解数据结构 (View the first few rows of the data to understand its structure)\nhead(simdata)\n# 计算两个连续变量之间的相关系数 (Calculate the correlation coefficient between two continuous variables)\n# 此结果将在后续作为图表标题的一部分 (This result will be used as part of the chart title later)\nr.cor <- cor(simdata$miR.508, simdata$FAP)\n# 打印相关系数结果 (Print the correlation coefficient)\nr.cor\n# 计算相关系数的p值，用于检验相关性的显著性 (Calculate the p-value for the correlation coefficient to test its significance)\n# 结果同样会用于图表标题 (This result will also be used in the chart title)\np.cor <- cor.test(simdata$miR.508, simdata$FAP)$p.value\n# 打印p值结果 (Print the p-value)\np.cor\n附：这里的输入数据是模拟出来的，生成方法如下：\nAttachment: The input data here is simulated, and the generation\nmethod is as follows:\n连续变量分类\n例文把两个因素都分为四组：Positive，Moderate，Weak，Negative。\n因此，我们根据四分位数将数据分割为四种类型：\n#Continuous variable classification\nThe example text divides both factors into four groups: positive,\nmoderate, weak, and negative.\nTherefore, we divide the data into four types based on quartiles:\n# 根据miR.508表达量的四分位数将数据分为四类 (Classify data into four categories based on quartiles of miR.508 expression)\n# 分类标签参考示例设置 (Classification labels follow the example provided)\n# 因子水平按降序排列，便于后续可视化 (Factor levels sorted in descending order for visualization)\nsimdata$miR.508_classify <- factor(cut(simdata$miR.508, quantile(simdata$miR.508), \n                                       labels = c(\"Negative\", \"Weak\", \"Moderate\", \"Positive\")),\n                                   levels = c(\"Positive\", \"Moderate\", \"Weak\", \"Negative\")) \n\n# 可选方案：根据中位数将数据分为高低两类 (Alternative: classify data into two categories based on median)\n# 此代码行被注释，保留作为参考 (This line is commented out for reference)\n#simdata$miR.508_classify <- factor(cut(simdata$miR.508, c(0, median(simdata$miR.508),max(simdata$miR.508)), \n#                                       labels = c(\"Negative\", \"Positive\")), \n#                                   levels = c(\"Positive\", \"Negative\"))\n\n# 根据FAP表达量的四分位数将数据分为四类 (Classify data into four categories based on quartiles of FAP expression)\n# 分类标签与示例一致 (Classification labels consistent with the example)\n# 因子水平按升序排列 (Factor levels sorted in ascending order)\nsimdata$FAP2_classify <- factor(cut(simdata$FAP, quantile(simdata$FAP), \n                             labels = c(\"Negative\", \"Weak\", \"Moderate\", \"Positive\")), \n                         levels = c(\"Negative\", \"Weak\", \"Moderate\", \"Positive\")) \n\n# 创建miR.508和FAP2分类的列联表 (Create contingency table for miR.508 and FAP2 classifications)\n# 将列联表转换为数据框格式 (Convert contingency table to data frame format)\ntab_classify <- as.data.frame.array(table(simdata$miR.508_classify,simdata$FAP2_classify)) \n# 打印列联表查看结果 (Print contingency table to inspect results)\ntab_classify\n# 对分类变量执行Fisher精确检验 (Perform Fisher's exact test on the contingency table)\n# 当分类较多时需要增加workspace参数以避免内存不足错误 (Increase workspace for large contingency tables)\n# 通常设置为1e9可满足大多数情况需求 (Typical value of 1e9 suffices for most cases)\np.fisher <- fisher.test(tab_classify, workspace = 1e9)$p.value \n# 打印Fisher检验的p值 (Print p-value from Fisher's exact test)\np.fisher\n注意：\n由于不同字符串的排序不同，或者是最终列联表的横纵坐标编号不同，请一定在绘制完成后仔细核对原始数据和计数矩阵，谨防映射关系出错。\n**Attention: * * Due to different sorting of strings or different\nhorizontal and vertical coordinate numbers in the final contingency\ntable, please carefully check the original data and count matrix after\ndrawing to avoid mapping errors.\n开始画图\n下面用base plot一笔一笔画图：\n#Start drawing\nBelow is a stroke by stroke plot using the base plot:\nsessionInfo()",
    "chapter_info": {},
    "word_count": 637,
    "lines_count": 112,
    "title": "FigureYa125FishertestV2",
    "description": "两个指标（miRNA和FAP蛋白）按照高低分为四组，计算两个指标的相关性和p value，用热图展示。 Divide the two indicators (miRNA and FAP protein) into four groups",
    "input_data_types": [
      "临床数据"
    ],
    "output_types": [
      "散点图",
      "热图",
      "统计表格"
    ],
    "technical_methods": [
      "motif分析"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "LANGUAGE",
      "stringsAsFactors",
      "levels",
      "header",
      "workspace",
      "labels"
    ]
  },
  {
    "id": "main_FigureYa8radar_FigureYa8radarChart",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa8radar_FigureYa8radarChart.txt",
    "content": "FigureYa8 Radar chart\nFigureYa8 Radar chart\nAuthor(s)\n: Zhaodong Hao; Ying Ge, Yijing Chen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n用R代码画出paper里的图\nDraw the figure in paper with R code\n出自\nhttps://www.nature.com/articles/nplants2015221\nfrom\nhttps://www.nature.com/articles/nplants2015221\n使用场景\nUsage scenario\n场景一：评估一个总体的不同组分的比例变化\n场景二：评价同一衡量体系下的各项不同指标\nScenario 1: Evaluate the proportional changes of different components\nof a whole\nScenario 2: Evaluate different indicators under the same measurement\nsystem\n环境设置\nEnvironment setting\nsource(\"install_dependencies.R\")\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 display English error messages\noptions(stringsAsFactors = FALSE) #禁止chr转成factor prohibit the conversion of chr to factor\n输入数据\nInput data\n包含Name、ratio、fill、text_size、text_color的文件，用tab间隔\n不用修改任何代码，直接准备好输入文件就ok了\n输入文件的txt文本中，第一行即各列的名称，不能修改\nFile containing name, ratio, fill, text_size, text_color, separated\nby tabs\nYou don’t have to change any code, just prepare the input file\ndirectly and it’s fine.\nIn the txt text of the input file, the first line is the name of each\ncolumn, which cannot be modified.\nmydata <- read.table(\"easy_input.txt\", sep = \"\\t\", header = T, stringsAsFactors = F, colClasses = c(\"character\", \"numeric\", \"character\", \"integer\", \"character\"))\nhead(mydata)\n开始画图\nStart drawing\n画布将设置为21cm * 29.7cm（宽高）的A4纸\n1cm = 35.43307px\nThe canvas will be set to 21cm * 29.7cm (width and height) A4\npaper\n1cm = 35.43307px\n准备svg语句\nPrepare the svg statement\n1.画4个圆\n1.Draw 4 circles\nsvg圆语句格式为<circle cx cy r\nstyle=“stroke:#006600;fill:#00cc00”/>，其中参数cx、cy定义原点坐标，r定义圆半径，style定义线颜色宽度类型填充等（其中，stroke定义线的颜色，stroke-width定义线的宽度，stroke-dasharray定义虚线，fill定义圆的填充颜色）\nThe SVG circle statement format is <circle cx cy r\nstyle=“stroke:#006600;fill:#00cc00”/>, where the parameters cx and cy\ndefine the coordinates of the origin, r defines the radius of the\ncircle, and style specifies the line color, width, type, fill, etc.\n(where stroke specifies the line color, stroke-width specifies the line\nwidth, stroke-dasharray specifies the dashed line, and fill specifies\nthe fill color of the circle).\n#定义圆的原点，及最外圆的图形半径\n#define the origin of the circle, and the radius of the graph of the outermost circle\nrx<-10.5 * 35.43307\nry<-7.5 * 35.43307\nrr<-5.00 * 35.43307\n#将svg语句写入circos\n#write svg statement to circos\ncircos <- data.frame(paste(\"<circle cx=\\\"\", rx, \"\\\" cy=\\\"\", ry, \"\\\" r=\\\"\", .25 * rr, \"\\\" style=\\\"stroke:#b7b7b7; stroke-width:1; stroke-dasharray: 10 5; fill:none\\\"/>\", sep = \"\"),\n                     paste(\"<circle cx=\\\"\", rx, \"\\\" cy=\\\"\", ry, \"\\\" r=\\\"\", .50 * rr, \"\\\" style=\\\"stroke:#6c6b6b; stroke-width:2; fill:none\\\"/>\", sep = \"\"),\n                     paste(\"<circle cx=\\\"\", rx, \"\\\" cy=\\\"\", ry, \"\\\" r=\\\"\", .75 * rr, \"\\\" style=\\\"stroke:#b7b7b7; stroke-width:1; stroke-dasharray: 10 5; fill:none\\\"/>\", sep = \"\"),\n                     paste(\"<circle cx=\\\"\", rx, \"\\\" cy=\\\"\", ry, \"\\\" r=\\\"\", 1.00*rr, \"\\\" style=\\\"stroke:#6c6b6b; stroke-width:2; fill:none\\\"/>\", sep = \"\")\n)\n2.通过路径（path）画花瓣\n2.Draw flower petals through a path\n原理图\nschematic diagram\n绘图者：Zhaodong Hao\n花瓣的语句格式为<path d=“Mx,y Cx1,y1 x2,y2 x3,y3” style=“stroke:\n#006666; fill:none;”/>\n，其中的参数M表示“移动到”，M后的x,y表示路径起点坐标,C表示“三次贝塞尔曲线到”，C后的x1,y1\nx2,y2 x3,y3分别表示贝塞尔曲线2个控制点和终点坐标\nDrawn by Zhaodong Hao\nPetal statement format is <path d=“Mx,y Cx1,y1 x2,y2 x3,y3”\nstyle=“stroke: #006666; fill:none;”/> , where the parameter M means\n“move to”, x,y after M means the coordinates of the starting point of\nthe path, C means “three times Bézier curve to”, C after the x1,y1 x2,y2\nx3,y3 represent the Bézier curve two control points and end point\ncoordinates respectively.\n#根据输入文件中确定每个花瓣旋转角度\n#determine the angle of rotation of each petal from the input file\nangle_base <- 360/nrow(mydata)\n\nfor (i in 1: nrow(mydata)) {\n  mydata[i, 6] <- angle_base * (i-1)\n}\nnames(mydata)[6] <- \"angle\"\n\n#贝塞尔曲线控制点坐标设置\n#Bézier curve control point coordinate setting\ncx1<-rx - 35/(nrow(mydata)/6) - 20 * mydata$ratio #35是经测试获得的花瓣不重叠时控制点坐标相对原点X轴最佳位移,35/(nrow(mydata)/6)即根据用户自定义的花瓣个数计算最佳位移,减去20 * mydata$ratio是为了根据ratio大小调整花瓣宽度 35 is the optimal displacement of the control point coordinates relative to the X-axis of the origin when the petals do not overlap, 35/(narrow(mydata)/6) is the optimal displacement calculated according to the user-defined number of petals, minus 20 * mydata$ratio to adjust the width of the petals according to the size of the ratio.\ncy1<-ry - mydata$ratio * 59 / 0.25 #经测试,花瓣曲线控制点的y轴位移为59px时获得的花瓣的长度是0.25倍的最外圆半径 After testing, the length of the petal obtained when the y-axis displacement of the petal curve control point is 59px is 0.25 times the radius of the outermost circle.\ncx2<-rx + 35/(nrow(mydata)/6) + 20 * mydata$ratio\ncy2<-cy1\n\n#将花瓣语句写入mydata\n#write petal statements to mydata\nmydata$bezier <- paste(\"<path d=\\\"M\",rx,\",\",ry,\" C\", cx1, \",\", cy1, \",\", cx2, \",\", cy2, \",\",rx,\",\",ry,\"\\\" transform=\\\"rotate(\", mydata$angle, \" \",rx,\" \",ry,\")\\\"\", \" fill=\\\"#\", mydata$fill, \"\\\" stroke = \\\"black\\\" stroke-width = \\\"0.5px\\\" />\", sep = \"\")\n3.文本语句\n3.Text statements\nsvg文本格式为<text x y font-size fill\n>words</text>，x，y是文本左下角的坐标\nThe svg text is formatted as <text x y font-size fill\n>words</text>, x, y are the coordinates of the lower left\ncorner of the text\n#设置文本坐标\n#set text coordinates\ntx<-rx - nchar(mydata$Name) * 3#根据文字长度设置X轴位移 set the X-axis displacement according to the text length\nty<-ry - rr - 6\n#将文本语句写入mydata，rotate函数参数包括旋转角度及旋转中心点坐标\n#write the text statement to mydata, the parameters of the rotate function include the rotation angle and the coordinates of the center of rotation.\nmydata$text <- paste(\"<text x=\\\"\", tx, \"\\\" y=\\\"\", ty, \"\\\" font-size=\\\"\", mydata$text_size, \"\\\" transform=\\\"rotate(\", mydata$angle, \" \",rx,\" \",ry,\")\\\"\", \" fill=\\\"#\", mydata$text_color, \"\\\" >\", mydata$Name, \"</text>\", sep = \"\")\n将准备好的svg语句写入.svg文件\nWrite prepared svg statements to .svg file\n首先写入XML声明、svg dtd、svg代码开始标签</svg>\nFirst write the XML declaration, svg dtd, svg code start tag\n</svg>\nfirst_line <- data.frame(\"<?xml version=\\\"1.0\\\" standalone=\\\"no\\\"?>\",\n                         \"<!DOCTYPE svg PUBLIC \\\"-//W3C//DTD SVG 1.1//EN\\\"\",\n                         \"\\\"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd\\\">\",\n                         \"\",\n                         paste(\"<svg id=\\\"svg\\\" width=\\\"744.0945\\\" height=\\\"1052.362\\\">\", \"\\t\")#画布设置为21cm * 29.7cm（宽高）的A4纸 set the canvas to A4 paper with dimensions of 21cm by 29.7cm (width and height).\n)\nwrite.table(first_line[1, 1], \"radar.svg\", col.names = FALSE, row.names = FALSE, quote = FALSE)\nwrite.table(first_line[1, 2], \"radar.svg\", col.names = FALSE, row.names = FALSE, quote = FALSE, append = TRUE)\nwrite.table(first_line[1, 3], \"radar.svg\", col.names = FALSE, row.names = FALSE, quote = FALSE, append = TRUE)\nwrite.table(first_line[1, 4], \"radar.svg\", col.names = FALSE, row.names = FALSE, quote = FALSE, append = TRUE)\nwrite.table(first_line[1, 5], \"radar.svg\", col.names = FALSE, row.names = FALSE, quote = FALSE, append = TRUE)\n写入准备好的画圆、花瓣、文本语句\nWrite the prepared drawing circles, petals, and text\nwrite.table(circos[1, 1], \"radar.svg\", col.names = FALSE, row.names = FALSE, quote = FALSE, append = TRUE)\nwrite.table(circos[1, 2], \"radar.svg\", col.names = FALSE, row.names = FALSE, quote = FALSE, append = TRUE)\nwrite.table(circos[1, 3], \"radar.svg\", col.names = FALSE, row.names = FALSE, quote = FALSE, append = TRUE)\nwrite.table(circos[1, 4], \"radar.svg\", col.names = FALSE, row.names = FALSE, quote = FALSE, append = TRUE)\nwrite.table(mydata$bezier, \"radar.svg\", col.names = FALSE, row.names = FALSE, quote = FALSE, append = TRUE)\nwrite.table(mydata$text, \"radar.svg\", col.names = FALSE, row.names = FALSE, quote = FALSE, append = TRUE)\n\n#最后一行写入svg代码结束标签</svg>\n#write svg code end tag on last line</svg>\nlast_line <- data.frame(paste(\"</svg>\"))\nwrite.table(last_line[1, 1], \"radar.svg\", col.names = FALSE, row.names = FALSE, quote = FALSE, append = TRUE)\n输出文件\nOutput file\n*.svg文件，矢量图，可以用illustrator、Inkscape等工具打开\n还可以转成pdf文件。\n*.svg files, vector graphics, can be opened with illustrator,\nInkscape and other tools\nIt can also be converted to a pdf file.\nlibrary(rsvg)\nrsvg_pdf(\"radar.svg\", file = \"radar.pdf\")\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa8radar_FigureYa8radarChart",
      "title": "FigureYa8radar/FigureYa8radarChart.html",
      "html": "FigureYa8radar/FigureYa8radarChart.html",
      "text": "texts/main_FigureYa8radar_FigureYa8radarChart.txt",
      "folder": "FigureYa8radar",
      "thumb": "gallery_compress/FigureYa8radar.webp"
    },
    "word_count": 1081,
    "lines_count": 168,
    "title": "FigureYa8 Radar chart",
    "description": "Requirement description 用R代码画出paper里的图 Draw the figure in paper with R code",
    "input_data_types": [],
    "output_types": [
      "统计表格"
    ],
    "technical_methods": [],
    "biology_areas": [],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "LANGUAGE",
      "quote",
      "stringsAsFactors",
      "colClasses",
      "header",
      "append",
      "names",
      "1cm",
      "file"
    ]
  },
  {
    "id": "main_FigureYa155ATAC_FigureYa155ATAC",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa155ATAC_FigureYa155ATAC.txt",
    "content": "FigureYa155ATAC\nFigureYa155ATAC\nAuthor(s)\n: Long Zhao\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-10-04\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\nIf you use circlize in published research, please cite:\nGu, Z. circlize implements and enhances circular visualization in R.\nBioinformatics 2014.\n需求描述\nRequirement Description\n复现染色质开放程度差异的热图。 Reproduce a heatmap showing\ndifferences in chromatin accessibility.\n出自\nhttps://www.nature.com/articles/nm.4479\nFrom\nhttps://www.nature.com/articles/nm.4479\nFigure 4 MeXis alters chromosome architecture at the Abca1 locus.\nHeat maps of the accessibility regions in WT and MeXis−/−\nmacrophages with or without GW3965 treatment.\nTop, genome-wide accessibility sites significantly induced by GW3965\nin both WT and MeXis−/− macrophages.\nBottom, accessibility sites significantly induced by GW3965 only in\nWT macrophages. Significance was determined on the basis of a P value\nthreshold of 0.05 using DESeq2 in the bioconductor statistical\npackage.\n图的解读\nFigure Interpretation\n原文中图片d主要表示在有GW3965处理下，abca1基因上WT的染色质开放程度要高于KO。而作为对照，Tlr4\n基因没有明显变化。另一方面，图e表示，在没有处理的条件下，野生型和突变体一系列基因没有染色质开放程度差异，但是在有处理的条件下，突变体的染色质开放程度要低于野生型。其中highlight了Abca1的几个peak的变化。\nFigure d in the original article primarily indicates that under GW3965\ntreatment, chromatin accessibility at the abca1 locus is higher in WT\nthan in KO. In contrast, the Tlr4 gene showed no significant changes. On\nthe other hand, Figure e shows that, without treatment, there is no\ndifference in chromatin accessibility between the wild-type and mutant\ngenes for a range of genes. However, under treatment, chromatin\naccessibility in the mutant is lower than that in the wild-type. Changes\nin several Abca1 peaks are highlighted.\n应用场景\nApplication Scenarios\n用热图展示染色质开放程度差异，同样适用于ChIP-seq数据。 Using heatmaps\nto display differences in chromatin accessibility is also applicable to\nChIP-seq data.\n环境设置\nEnvironment Setup\n安装要用到的软件： Install required software:\npfastq-dump，\nhttps://github.com/inutano/pfastq-dump\nfastqc，\nhttps://www.bioinformatics.babraham.ac.uk/projects/fastqc/\nbowtie2，\nhttps://sourceforge.net/projects/bowtie-bio/files/bowtie2/2.3.5.1/\nsamtools，\nhttp://samtools.sourceforge.net/\nsambamba，\nhttp://lomereiter.github.io/sambamba/\nmacs2，\nhttps://github.com/taoliu/MACS/wiki/Install-macs2\ndeeptools，\nhttps://deeptools.readthedocs.io/en/develop/content/installation.html\n安装R包 Install R packages\nsource(\"install_dependencies.R\")\nlibrary(dplyr)\nlibrary(DESeq2)\nlibrary(ChIPseeker)\nlibrary(GenomicFeatures)\nlibrary(stringr)\nlibrary(ComplexHeatmap)\nlibrary(circlize)\nlibrary(RColorBrewer)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 #Display English error message\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # Disable conversion of chr to factor\n输入文件的准备 # Prepare the input file\n如果你已经获得\nrawCount.txt\n文件，就可以跳过这步，直接进入“开始画图”。\nIf you already have the\nrawCount.txt\nfile, you can skip\nthis step and proceed directly to “Start Drawing.”\n下载参考基因组\nDownload the reference genome\n从\nensembl\n下载基因组DNA序列fa和注释gtf文件\nDownload the genomic DNA sequence fa and annotation gtf files from\nensembl\n下载sra数据\nDownload sra data\nSETP 1 在原文找到ID：Data availability. The source data used in the\nmanuscript can be accessed using the following accession numbers:\nGSE98910 (RNA-seq), GSE97207 (ATAC-seq), GSE104027 (ChIP–seq), and\nGSE107977 (microarray).\nSETP 2 在GEO数据库中搜索GSE97207，进入页面\nhttps://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE97207\nSETP 3 点击SRP102711，进入\nhttps://www.ncbi.nlm.nih.gov//sra/?term=SRP102711\n，点击右上角Send\nto——File_——Summary，会下载到\nsra_result.csv\n文件，里面有样本信息。\nSETP 4 继续点击右上角Send\nto——File_——Runinfo，会下载到\nSraRunInfo.csv\n文件，里面有下载链接\ndownload_path\n.\nSETP 1 Find the ID in the original article: Data availability. The\nsource data used in this manuscript can be accessed using the following\naccession numbers: GSE98910 (RNA-seq), GSE97207 (ATAC-seq), GSE104027\n(ChIP-seq), and GSE107977 (microarray).\nSETP 2 Search for GSE97207 in the GEO database and go to the page\nhttps://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE97207\n.\nSETP 3: Click SRP102711 and go to\nhttps://www.ncbi.nlm.nih.gov//sra/?term=SRP102711\n. Click\nSend to > File > Summary in the upper right corner. This will\ndownload the\nsra_result.csv\nfile, which contains sample\ninformation. - SETP 4 Continue clicking “Send to” in the upper right\ncorner, then “File” and “Runinfo.” This will download the\nSraRunInfo.csv\nfile, which contains the download link\ndownload_path\n.\nSETP 5 提取下载链接并下载SRR文件 SETP 5 Extract the download link and\ndownload the SRR file.\n#awk '{FS = \",\"; print $10}' SraRunInfo.csv > SRRurl.txt\n#这里用wget，你可以尝试迅雷等工具\n#Using wget here, you can try tools like Xunlei.\n#wget -c -i SRRurl.txt\nmkdir 0sra\nmv SRR* 0sra\nSETP 6 把sra数据转换成fastq数据 SETP 6 Convert SRA data to Fastq\ndata\n# pfastq-dump，并行更快，代替fastq-dump\n# pfastq-dump, parallel and faster, replaces fastq-dump\nfor i in 0sra/*; do echo \"pfastq-dump -t 10 --gzip -O ./ $i\"; done > command.pfastq.sh\nsh command.pfastq.sh\nSTEP 7\n根据\nsra_result.csv\n和\nSraRunInfo.csv\n，手动整理成\nsamples.conf\n文件。分为两列，第一列是SRRxxxx，第二列是对应的需要改成的样本名。\nSTEP 7: Manually organize\nsra_result.csv\nand\nSraRunInfo.csv\ninto the\nsamples.conf\nfile. The\nfile is divided into two columns: the first column is SRRxxxx, and the\nsecond column is the corresponding sample name to be modified.\n质控、alignment，bam文件转成bigwig文件用于下游分析\nQuality control, alignment, and converting bam files to BigWig files\nfor downstream analysis\nwashu brower 展示bigwig文件\nWashu browser displays bigwig files\n用\nwashu\nepigenome\nbrowser\n查看bigwig文件。这里截图出来，确实能够重复出原文的趋势。 Use\nwashu epigenome\nbrowser\nto view bigwig files. The screenshots shown here do indeed\nreproduce the trends in the original article.\nwashu也是大多数文章中的可视化方法，可以输出svg或者pdf格式。对三维基因组的可视化也做得很好，强烈推荐。\nwashu is also the visualization method used in most articles and can\noutput SVG or PDF formats. It also does a good job of visualizing 3D\ngenomes and is highly recommended.\nCall peak\nfor i in *.bam; do x=${i/.bam/}; echo \"macs2 callpeak --nomodel -t $i -q 0.01 -f BAM -g mm --keep-dup all --llocal 10000 -n $x 2> $x.macs2.log\"; done > command.macs2.sh\nsh command.macs2.sh\nIntersect and merge peak file\n有多次生物学重复，下面是不同生物学重复之间peak overlap的处理方法：\nThere are multiple biological replicates. Here’s how to handle peak\noverlap between replicates:\n基本原理就是4个生物学重复中任意两个有overlap我们就认为这个peak是可信的。\nThe basic principle is that if any two of the four replicates overlap,\nwe consider the peak to be reliable.\noverlap的标准就是overlap的部分占两个生物学重复的50%以上。 The overlap\ncriterion is that the overlap accounts for at least 50% of the two\nreplicates.\necho -e \"1\\t2\n1\\t3\n1\\t4\n2\\t3\n2\\t4\n3\\t4\" > paire.txt\n\nfor i in KO_DM KO_GW WT_DM WT_GW; do cat paire.txt | while read line; do all=($line); first=${all[0]}; second=${all[1]}; echo \"bedtools intersect -wa -a $i\\_$first\\_peaks.narrowPeak -b KO_DM\\_$second\\_peaks.narrowPeak -f 0.5 -F 0.5 > $i.$first.$second.tmp.bed\nbedtools intersect -wa -a KO_DM\\_$second\\_peaks.narrowPeak -b $i\\_$first\\_peaks.narrowPeak -f 0.5 -F 0.5 > $i.$second.$first.tmp.bed\ncat $i.$first.$second.tmp.bed $i.$second.$first.tmp.bed | bedtools sort | bedtools merge -d -150 > $i.$first.$second.tmp_merge.bed\"; done; done > command.sh\n\nsed -i 's/\\\\_/_/g' command.sh\nsh command.sh\n\nfor i in KO_DM KO_GW WT_DM WT_GW; do cat $i*.tmp_merge.bed | bedtools sort | bedtools merge -d -150 | awk '!x[$0]++' > $i.bed; done\n\nrm -rf *.tmp.bed *.tmp_merge.bed\n\n# 把所有的peak文件merge到一起，主要用于后面每个peak中read count数量的计算\n# Merge all peak files together, primarily for subsequent calculation of read counts within each peak.\ncat *.bed |bedtools sort | bedtools merge -i - > allMerge.bed\npeak注释\nPeak Annotation\npeak注释到基因层面，主要用Guangchuang Yu的ChIPseeker。 Peaks are\nannotated at the gene level, primarily using Guangchuang Yu’s\nChIPseeker.\n这里用gtf文件做了一个txdb注释文件，同样适用于bioconductor中没有txdb的物种。\nHere, a txdb annotation file is created using a gtf file. This also\nworks for species without a txdb file in Bioconductor.\n除了生成txdb注释文件，还会输出一个bed文件，用于后面的进行reads的定量。\nIn addition to generating the txdb annotation file, a bed file is also\noutput for subsequent read quantification.\n# 生成txdb注释文件\n# Generate txdb comment file\nTxDb.MM9 <- makeTxDbFromGFF(\"mm9.gtf\", format=\"gtf\", organism=\"Mus musculus\")\n\npeak <- readPeakFile(\"allMerge.bed\",head=F)\npeakAnn <- annotatePeak(peak, TxDb=TxDb.MM9, level=\"gene\")\npeakAnn <- as.data.frame(peakAnn)\nwrite.table(peakAnn,\"peakAnn.txt\",sep=\"\\t\",quote=F,row.names=F)\n\npeakSaf <- peakAnn[,c(12,1,2,3)]\npeakSaf$Strand <- \".\"\ncolnames(peakSaf) <- c(\"GeneID\",\"Chr\",\"Start\",\"End\",\"Strand\")\npeakSaf$GeneID <- paste(peakSaf$GeneID,1:nrow(peakSaf),sep=\"_\")\nwrite.table(peakSaf,\"peak.saf\",sep=\"\\t\",quote=F,row.names=F)\nFeatureCount定量reads\nFeatureCount read quantification\nfeatureCounts -a peak.saf -F SAF -T 20 -o rawCount.txt *.bam\n开始画图\nStart plotting\nrawCount.txt，前面生成的。每行一个基因，前6列是基因位置信息，后面每列是一个样本的read\ncount。可以类比成RNA-seq的read count进行差异分析。 rawCount.txt,\ngenerated earlier. Each line contains one gene. The first six columns\ncontain gene location information, and the following columns each\ncontain the read count for a sample. This can be compared to RNA-seq\nread count analysis for differential analysis.\n先筛选显著差异基因，然后画图。 First, screen for significantly\ndifferentially expressed genes, then plot the graph.\ndata <- read.table(\"rawCount.txt\",head=T)\nrownames(data) <- data[,1]\ndata <- data[,-c(1:6)]\ncolnames(data) <- substring(colnames(data),1,7)\n\n# 用DESeq2计算差异\n# Calculate the difference using DESeq2\nsample <- data.frame(conditions=substring(colnames(data),1,5))\nddsFullCountTable <- DESeqDataSetFromMatrix(countData = data,colData = sample,  design= ~ conditions)\ndds <- DESeq(ddsFullCountTable)\nrawcount <- as.data.frame(counts(dds, normalized=TRUE))\n\n# WT_GW > WT_DM，并且KO_GW > KO_DM作为上面的heatmap\n# WT_GW > WT_DM, and KO_GW > KO_DM as the heatmap above\n# WT_GW > WT_DM，但是KO_GW <= KO_DM作为下面的heatmap\n# WT_GW > WT_DM, but KO_GW <= KO_DM as the heatmap below\ncontrast_WT_GW_WT_DM <- c(\"conditions\",\"WT_GW\",\"WT_DM\")\nres_WT_GW_WT_DM <- results(dds,contrast=contrast_WT_GW_WT_DM)\nup1 <- rownames(subset(as.data.frame(res_WT_GW_WT_DM), as.data.frame(res_WT_GW_WT_DM)$log2FoldChange > 0 & as.data.frame(res_WT_GW_WT_DM)$padj <= 0.05))\n\ncontrast_KO_GW_KO_DM <- c(\"conditions\", \"KO_GW\", \"KO_DM\")\nres_KO_GW_KO_DM <- results(dds,contrast=contrast_KO_GW_KO_DM)\nup2 <- rownames(subset(as.data.frame(res_KO_GW_KO_DM), as.data.frame(res_KO_GW_KO_DM)$log2FoldChange > 0 & as.data.frame(res_KO_GW_KO_DM)$padj <= 0.05))\n\ntop <- intersect(up1,up2)\nbottom <- setdiff(up1,up2) \ntop_df <- rawcount[top,]\nbottom_df <- rawcount[bottom,]\n\n#处理成平均数\n#Process into average\ntop_df_matrix <- matrix(c(rowMeans(top_df[,9:12]),rowMeans(top_df[,1:4]),rowMeans(top_df[,13:16]),rowMeans(top_df[,5:8])),ncol=4)\ncolnames(top_df_matrix) <- c(\"WT_DM\",\"KO_DM\",\"WT_GW\",\"KO_GW\")\nrownames(top_df_matrix) <- rownames(top_df)\n\nbottom_df_matrix <- matrix(c(rowMeans(bottom_df[,9:12]),rowMeans(bottom_df[,1:4]),rowMeans(bottom_df[,13:16]),rowMeans(bottom_df[,5:8])),ncol=4)\ncolnames(bottom_df_matrix) <- c(\"WT_DM\",\"KO_DM\",\"WT_GW\",\"KO_GW\") \nrownames(bottom_df_matrix) <- rownames(bottom_df)\n\n#计算percentage\n#Calculate percentage\ntop_perce <- top_df_matrix\nfor (i in 1:4){ \n    top_perce[,i] <- top_df_matrix[,i]/top_df_matrix[,3]*100 \n    } \nbottom_perce <- bottom_df_matrix\nfor (i in 1:4){ \n        bottom_perce[,i] <- bottom_df_matrix[,i]/bottom_df_matrix[,3]*100 \n} \n\n# 排序\n# Sort\nord_top <- order(top_perce[,3],top_perce[,4],decreasing=T)\nht1 <- top_perce[ord_top,]\nord_bottom <- order(bottom_perce[,3],bottom_perce[,4],decreasing=T)\nht2 <- bottom_perce[ord_bottom,]\n\n# 注释mark的位点\n# Comment the mark position\nlocations <- which(str_match(rownames(ht2),\"ENSMUST00000030010*\")!=\"NA\")\nlabels <- c(\"Abca 1 (site 1)\",\"Abca 1 (site 2)\",\"Abca 1 (site 3)\")\n\n# 颜色设置\n# Color settings\n# 这里作者玩了个小trick：小于50%的都是白色\n# The author used a little trick here: all sites with less than 50% are white.\ncol <- c(rep(\"white\",5), brewer.pal(6,\"YlOrRd\")) \nseq <- seq(0,100,10)\n\nha <- rowAnnotation(foo = anno_mark(at = locations, labels = labels))\na <- Heatmap(ht1,col = colorRamp2(seq,col),\n    show_row_names=F,cluster_columns = FALSE,\n    cluster_rows=F, show_column_names = F,\n    name=\"Percentage\")\n\nb <- Heatmap(ht2,col = colorRamp2(seq,col),\n    show_row_names=F,cluster_columns = FALSE,\n    cluster_rows=F,show_column_names = T,\n    right_annotation = ha, show_heatmap_legend =F)\n\npdf(file=\"heatmap.pdf\",width=3,height=6)\na%v%b\ndev.off()\nheatmap\n这里剩下位点有点少，原文在作比较的时候用的pvalue<=0.05,而不是用的矫正后的p值。如果按照原文的话，会得到多的基因。但是，还是没有原文说的6个位点Abca1。\nThere are a few remaining loci here. The original paper used\npvalue<=0.05 for comparisons, rather than corrected p-values.\nFollowing the original paper would yield more genes. However, the six\nAbca1 loci mentioned in the original paper are still missing.\n一种猜测就是原文做了4次生物学重复，而作者可能在其中选择某几个重复去做，而不是全部，然后通过不断的尝试，选在最能证明观点的数据进行可视化。\nOne hypothesis is that the original paper used four biological\nreplicates, and the authors may have selected a few of these replicates,\nrather than all, and then, through repeated trial and error, selected\nthe data that best supported their findings for visualization.\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa155ATAC_FigureYa155ATAC",
      "title": "FigureYa155ATAC/FigureYa155ATAC.html",
      "html": "FigureYa155ATAC/FigureYa155ATAC.html",
      "text": "texts/main_FigureYa155ATAC_FigureYa155ATAC.txt",
      "folder": "FigureYa155ATAC",
      "thumb": "gallery_compress/FigureYa155ATAC.webp"
    },
    "word_count": 1499,
    "lines_count": 353,
    "title": "FigureYa155ATAC",
    "description": "Requirement Description 复现染色质开放程度差异的热图。 Reproduce a heatmap showing differences in chromatin accessibility.",
    "input_data_types": [
      "临床数据",
      "DNA-seq",
      "突变数据"
    ],
    "output_types": [
      "热图",
      "统计表格"
    ],
    "technical_methods": [
      "质量控制"
    ],
    "biology_areas": [
      "药物研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "level",
      "show_heatmap_legend",
      "acc",
      "format",
      "show_row_names",
      "width",
      "cluster_columns",
      "pvalue",
      "colData"
    ]
  },
  {
    "id": "main_FigureYa180FGAplotV2_FigureYa180FGAplotV2",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa180FGAplotV2_FigureYa180FGAplotV2.txt",
    "content": "FigureYa180FGAplotV2\nFigureYa180FGAplotV2\nAuthor(s)\n: Enyu Lin\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement\ncBioPortal上的Fraction Genome Altered的算法 The Fraction Genome\nAltered algorithm on cBioPortal\nhttps://groups.google.com/forum/#!topic/cbioportal/4DvUVuRgrTw\n出自\nhttps://www.cbioportal.org/study/summary?id=kirc_tcga_pan_can_atlas_2018\nfromhttps://www.cbioportal.org/study/summary?id=kirc_tcga_pan_can_atlas_2018\n另外一篇文章用了Fraction Genome\nAltered的概念，但算法跟cBioPortal但不同。 Another article used the\nconcept of Fraction Genome Altered, but the algorithm was different from\nthat of cBioPortal.\n出自\nhttps://www.nature.com/articles/oncsis201214\nfromhttps://www.nature.com/articles/oncsis201214\nFigure 1. Fraction (%) of the FGL, FGG and FGA among ccRCC case\nsubgroups. P-values between subgroups were as follows: males vs females\n(P=0.002), age (<50, vs ⩾50 years, P=0.06), any family history of\ncancer (P=0.02), stage (P<0.00001), grade (P<0.0001), ever vs\nnever smoking (P=0.05), VHL wild-type cases vs those with VHL promoter\nhypermethylation (P=0.03), VHL wild-type cases vs those with VHL\nsequence alterations (P=0.17). REF, referent group.\ncBioPortal提供的Fraction Genome\nAltered算的是总体的，没有区分gain和lost，想用cBioPortal的算法分别计算fraction\nof genome gained (FGG) 和fraction of the genome lost\n(FGL)，并使用临床信息比较各个分组间的差异。输入TCGA的CNV数据，计算FGA、FGG、FGL，复现文章的图。\nThe Fraction Genome Altered provided by cBioPortal is overall and does\nnot distinguish between gain and lost. the algorithm of cBioPortal was\nintended to calculate fraction of genome gained (FGG) and fraction of\nthe genome lost (FGL) respectively, and clinical information was used to\ncompare the differences among the groups. Input the CNV data of TCGA,\ncalculate FGA, FGG, and FGL, and reproduce the figures of the\narticle.\n应用场景\nApplication Scenarios\n自己的测序数据，用cBioPortal的算法计算Fraction Genome Altered (FGA)。\nOur own sequencing data were used to calculate Fraction Genome Altered\n(FGA) using the algorithm of cBioPortal.\n或者使用TCGA的数据，计算不同临床分组的FGA、FGG和FGL，并进行差异检验。\nAlternatively, the data from TCGA can be used to calculate the FGA, FGG\nand FGL of different clinical groups and conduct difference tests.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(ggplot2)\nlibrary(magrittr)\nlibrary(patchwork)\nlibrary(Rmisc)\nlibrary(Cairo)\nlibrary(stringr)\n\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息  # Display an English error message\noptions(stringsAsFactors = FALSE) #禁止chr转成factor  # prohibit chr from being converted to factor\n自定义函数计算mean、se和p值 Custom functions calculate mean, se and p\nvalues\ncal_ms <- function(x,y){\n  table1=data.frame()\n  for (i in y) {\n    name=summarySE(x,measurevar=c(colnames(x)[ncol(x)]), groupvars=c(colnames(x)[i]))[[1]]\n    mean=summarySE(x, measurevar=c(colnames(x)[ncol(x)]), groupvars=c(colnames(x)[i]))[[3]] #mean\n    se=summarySE(x, measurevar=c(colnames(x)[ncol(x)]), groupvars=c(colnames(x)[i]))[[5]] #se\n    \n    table=data.frame(group=rep(colnames(x)[i],length(mean)),subgroup=name,mean=mean,se=se)\n    table1=rbind(table1,table)\n    \n  }\n  table1$subgroup=factor(table1$subgroup,levels=unique(table1$subgroup))\n  table1$group=factor(table1$group,levels=unique(table1$group))\n  return(table1)\n}#计算mean和se,排序  # Calculate mean and se, sort\ncal_p=function(x,y){\n  table2=data.frame()\n  for (i in y) {\n    m<-aov(x[,ncol(x)]~as.factor(x[,i]))\n    summary(m)\n    table=cbind(rep(colnames(x)[i],nrow((TukeyHSD(m))[[1]])),(TukeyHSD(m))[[1]])\n    table2=rbind(table2,table) \n  }\n  return(table2)\n}#计算p值  # Calculate the p value\nsignif=function(table1,table2){\n  signif1=c()\n  for (i in 1:length(table(table2[,1]))) {\n    signif1=c(signif1,\"Ref\",table2[table2[,1]==levels(table1[,1])[i],5][1:length(table1[table1[,1]==names(table(table2[,1])[i]),\"subgroup\"])-1])\n  }#提取p值  # Extract the P-value\n  for (i in 1:length(signif1)) {\n    if (!is.na(as.numeric(signif1[i]))) {\n      signif1[i]=ifelse(signif1[i]>0.05,\"\",ifelse(signif1[i]<=0.0001,\"****\",ifelse(signif1[i]<=0.001,\"***\",ifelse(signif1[i]<=0.01,\"**\",ifelse(signif1[i]<=0.05,'*')))))\n    }\n  }#转换标记  # Conversion Markup\n  return(signif1)\n}#准备显著性标记的数据  # Prepare the data for salient marking\nmar=function(tableGL){\n  mar=round(max(tableGL[,\"mean\"]+tableGL[,\"se\"]),1)+0.05\n  return(mar)\n}#ggplot坐标长度  #ggplot coordinate length\n输入文件\nInput File\n从Xena获取TCGA_KIRC的cnv数据、clinical数据。 Obtain the cnv data and\nclinical data of TCGA_KIRC from Xena.\n数据来源：Data source:\nhttps://xenabrowser.net/datapages/?cohort=TCGA%20Kidney%20Clear%20Cell%20Carcinoma%20(KIRC)&removeHub=https%3A%2F%2Fxena.treehouse.gi.ucsc.edu%3A443\n# 加载Xena上TCGA_KIRC的nocnv数据\n# Load the nocnv data of TCGA_KIRC on Xena\nSegment <- read.delim(\"SNP6_nocnv_genomicSegment.gz\") \n# 加载Xena上TCGA_KIRC的临床数据\n# Load the clinical data of TCGA_KIRC on Xena\nKIRC <- read.delim(\"KIRC_clinicalMatrix\")\n再导入cBioPortal上FGA的数据，用于验证算法的结果。 Then import the FGA\ndata from cBioPortal to verify the results of the algorithm.\n数据来源：Data source:\nhttps://www.cbioportal.org/study/summary?id=kirc_tcga_pan_can_atlas_2018\n# 单独导入VHL突变数据(来自cBioPortal)\n# Import VHL mutation data separately (from cBioPortal)\nVHL <- read.delim(\"PATIENT_DATA_oncoprint.tsv\", header=FALSE, stringsAsFactors=FALSE) \n# 导入cBioPortal上KIRC的数据\n# Import KIRC data from cBioPortal\ncBio <- read.delim(\"kirc_tcga_pan_can_atlas_2018_clinical_data.tsv\", stringsAsFactors=FALSE)\nhead(Segment) #注意最后一列的value值的单位是log2(copy number/2)   # Note that the unit of the value in the last column is log2(copy number/2)\n计算Fraction Genome Altered (FGA)\nCalculate Fraction Genome Altered (FGA)\n先贴上计算公式便于理解： First, attach the calculation formula for\neasier understanding:\n因此，Segment中的value值即是log2R。如果是自己的测序数据则要注意是否是log2R，还是copy\nnumber（见文末的注意事项）。 Therefore, the value in the Segment is\nlog2R. If it is your own sequencing data, pay attention to whether it is\nlog2R or copy number (see the precautions at the end of the text).\n数据清洗\nData cleaning\nSegment$bases=Segment$end-Segment$start\nSegment$sample%<>%str_sub(end=-4)\nVHL=t(VHL)\ncolnames(VHL)=VHL[2,]\nVHL=VHL[-1:-2,]\nVHL=cbind(VHL,'VHL'=c(rep('Mut',175),rep('Wild',nrow(VHL)-175)))\nVHL=as.data.frame(VHL)\nVHL=VHL[,c(1,8)]\ncolnames(VHL)[1]='Patient'\nclinical=KIRC[,c(1,19,38,64,55)]\nclinical$sampleID%<>%str_sub(end=-4)\nclinical%<>%unique.data.frame()\ncolnames(clinical)=c('Patient','Age','Gender','Stage','Grade')\nclinical$Age=ifelse(clinical$Age>=65,'Older','Younger')\nclinical=clinical[!clinical$Stage=='[Discrepancy]',]\nclinical=clinical[!(clinical$Grade==''|clinical$Grade=='GX'),]\nmer=merge(clinical,VHL,all=FALSE)\n计算FGA、FGG和FGL\nCalculate FGA, FGG and FGL\ndata=data.frame()\n\nfor (i in 1:length(table(Segment$sample))) {\n  tmp=Segment[Segment$sample==names(table(Segment$sample))[i],]\n  if (length(tmp[abs(tmp$value)>0.2,\"bases\"][6])==0) {\n    FGA=0\n  } else {\n    FGA=sum(tmp[abs(tmp$value)>0.2,\"bases\"])/sum(tmp[,\"bases\"])\n  }\n  \n  if (length(tmp[tmp$value>0.2,\"bases\"][6])==0) {\n    FGG=0\n  } else {\n    FGG=sum(tmp[tmp$value>0.2,\"bases\"])/sum(tmp[,\"bases\"])\n  }\n  \n  if (length(tmp[tmp$value<(-0.2),\"bases\"][6])==0) {\n    FGL=0\n  } else {\n    FGL=sum(tmp[tmp$value<(-0.2),\"bases\"])/sum(tmp[,\"bases\"])\n  }\n  \n  tmp=data.frame(Patient=names(table(Segment$sample))[i],FGA=FGA,FGG=FGG,FGL=FGL)\n  data=rbind(data,tmp)\n}\n合并数据、导出数据\nMerge data, export data\nAll=merge(mer,data,all=FALSE)\nsave(All,file='all_data.Rdata')\nwrite.csv(All,file = 'KIRC_FGA.csv',row.names = F)\n对比cBioPortal上的FGA数据\nCompare the FGA data on cBioPortal\ncBio_FGA=cBio[,c(2,22)]\ncolnames(cBio_FGA)=c('Patient','FGA_cBio')\ncBio_FGA=cBio_FGA[!is.na(cBio_FGA$FGA_cBio),]\nCOMPARE=merge(cBio_FGA,All[,c(1,7)],all=FALSE)\nCOMPARE$FGA%<>%round(4)\ntable(COMPARE$FGA==COMPARE$FGA_cBio)\n# 查看不一致的样本\n# View inconsistent samples\nhead(COMPARE[!COMPARE$FGA==COMPARE$FGA_cBio,])\n结论：大部分数据是一致的，个别样本不同考虑是采用的cnv文件的不同（见文末的注意事项）。\nConclusion: The majority of the data are consistent. The differences in\nindividual samples are due to the different cnv files used (see the\nnotes at the end of the text).\n复现文献的Figure\nReproduce the Figure of the literature\n计算mean和se和p值并画图，这里用的检验方法是AONVA，并使用TukeyHSD进行组间比较（结果只取reference组和其他组的显著性以便于显示）。\nCalculate the mean, se and p values and draw graphs. The test method\nused here is AONVA, and TukeyHSD is used for inter-group comparison (the\nresults only take the significance of the reference group and other\ngroups for easy display).\ntable1=cal_ms(All[,c(1:6,7)],2:6) #(保持最后一列是目标变量) #(Keep the last column as the target variable)\ntable2=cal_p(All[,c(1:6,7)],2:6)#(保持最后一列是目标变量) #(Keep the last column as the target variable)\nsignif1=signif(table1,table2)\ntable3=cal_ms(All[,c(1:6,9)],2:6) #FGL\ntable4=cal_p(All[,c(1:6,9)],2:6)  #FGL\nsignif2=signif(table3,table4) #FGL\ntable5=cal_ms(All[,c(1:6,8)],2:6) #FGG\ntable6=cal_p(All[,c(1:6,8)],2:6)  #FGG\nsignif3=signif(table5,table6) #FGG\ntableGL=rbind(cbind(table3,class=rep('FGL',nrow(table3))),cbind(table5,class=rep('FGG',nrow(table5)))) #合并FGL、FGG  # Merge FGL and FGG\n\n#画图 \n# Drawing\ns=10 #统一字体大小  # Uniform font size\norinpl <- ggplot(tableGL, aes(x = subgroup, \n                       y = mean,fill=class))+\n  geom_bar(stat = 'identity',position=\"stack\",width = 0.3) +\n  scale_x_discrete(name=\"\")+\n  theme_classic()+\n  theme(axis.line.y =element_line(size=0.8),\n        axis.text.y =element_text(face='bold',size=s),\n        axis.title.y = element_text(face='bold',size=s+2,vjust = 3),\n        axis.ticks.y =element_line(size=0.2),\n        axis.text.x = element_text(angle=90,hjust =1,vjust = 0.3,face='bold',size=s),\n        legend.position = c(0.85,0.95),\n        legend.key.height =  unit(0.1, \"inch\"),\n        legend.key.width  =  unit(0.22, \"inch\"),\n        legend.text = element_text(face='bold',size=s),\n        legend.background = element_blank(),\n        panel.grid.major.y = element_line(size=0.5,colour = 'grey80'),\n        plot.margin = unit(c(1.2, 2, 0.3, 1), \"lines\"),\n        legend.title=element_blank())+\n\n  scale_fill_manual(values  = c(\"#db5049\",\"#2082be\"),breaks=c(\"FGG\",\"FGL\"),\n                    labels=c(\"Fraction Genome Gained\",\"Fraction Genome Lost\"))+\n  scale_y_continuous(limits = c(0,0.4),breaks =seq(0,0.8,0.1),\n                     labels=seq(0,0.8,0.1)*100,expand = c(0,0),\n                     name  = \"Percent Genome Altered\")+\n  facet_grid(cols = vars(group),scales = \"free_x\",space = \"free_x\",switch = \"x\")+theme(\n    strip.text.x = element_text(size = s, face = \"bold\",vjust = 0),\n    strip.background = element_blank(),\n    strip.placement = \"outside\")\norinpl\n#ggsave(file='FGA.png',orinpl,height = 6,width=9,units = c(\"in\"),dpi = 1200)\nggsave(file='FGA.pdf',orinpl,height = 6,width=9,units = c(\"in\"))\n自定义进阶版FGA图\nCustom advanced FGA map\n文献中的Figure 1 没有标注p值和se，所以画个自定义进阶版的FGA图。 The\nP-value and se are not marked in Figure 1 of the literature, so a custom\nadvanced version of the FGA diagram is drawn.\ngap=0.05 #图纵坐标间隔 # Vertical coordinate interval of the graph\n\n# 左侧部分(FGA)\n# Left Part (FGA)\nif (T) {\np1=ggplot(table1, aes(x = subgroup, \n                      y = -mean,fill=rep(\"0\",nrow(table1))))+\n  geom_bar(stat = 'identity') +\n  geom_errorbar(aes(ymax = -mean -se, ymin = -mean+se),position = position_dodge(0.9), width = 0.15)+\n  scale_x_discrete(name=\"\",position = \"top\")+\n  geom_text(aes(y = -mean-se-0.007, label = signif1),position = position_dodge(0.9), size = ifelse(signif1=='Ref',1.8,3), fontface = \"bold\",angle=90)+\n  theme_bw()+\n  theme(axis.line.y =element_line(size=0.8),\n        axis.ticks.y =element_line(size=0.2),\n        axis.text.y = element_blank(),\n        axis.title.x = element_text(vjust = -2),\n        plot.margin = unit(c(0.3, -1.7, 0.3, 0.3), \"lines\"),\n        legend.title=element_blank())+\n  coord_flip()+\n  scale_fill_manual(values  = c(\"#FFD034\"),breaks=c(\"0\"),labels=c(\"Copy number-altered genome\"))+\n  scale_y_continuous(limits = c(-mar(table1),0),\n                     breaks =seq(-0.5,0,gap),labels=abs(seq(-0.5,0,gap)),expand = c(0.01,0),\n                     name  = \"FGA (Fraction of Genome Altered)\",position = \"left\")\n\np3=p1 + \n  facet_grid(rows = vars(group),scales = \"free_y\",space = \"free_y\")+\n  theme(strip.text.y = element_text(size = 10, angle= -90,vjust =1))\n}#画图  # Drawing\n#p3\n\n# 右侧部分(FGG/FGL)\n# Right Part (FGG/FGL)\nif (T) {\n\np2 <- ggplot(tableGL, aes(x = subgroup, \n                      y = ifelse(class=='FGG',-mean,mean),fill=class))+\n  geom_bar(stat = 'identity') +\n  geom_errorbar(data=tableGL[tableGL$class=='FGL',],aes(ymax = mean+se, ymin =mean-se),position = position_dodge(0.9), width = 0.15)+\n  geom_errorbar(data=tableGL[tableGL$class=='FGG',],aes(ymax = -mean-se, ymin =-mean+se),position = position_dodge(0.9), width = 0.15)+\n  geom_text(data=tableGL[tableGL$class=='FGG',],aes(y = -mean -se-0.01, label = signif2),position = position_dodge(0.9), size = ifelse(signif2=='Ref',1.8,3), fontface = \"bold\",angle=90)+\n  geom_text(data=tableGL[tableGL$class=='FGL',],aes(y = mean+se+0.01, label = signif3),position = position_dodge(0.9), size = ifelse(signif3=='Ref',1.8,3), fontface = \"bold\",angle=-90)+\n  scale_x_discrete(name=\"\")+\n  theme_bw()+\n  theme(axis.line.y =element_line(size=0.8),\n        axis.ticks.y =element_line(size=0.2),\n        axis.text.y = element_blank(),\n        axis.title.x = element_text(vjust = -2),\n        plot.margin = unit(c(0.3, 0.3, 0.3, -1), \"lines\"),\n        legend.title=element_blank())+\n  coord_flip()+\n  scale_fill_manual(values  = c(\"#f17d80\",\"#79BEDB\"),breaks=c(\"FGG\",\"FGL\"),\n                    labels=c(\"Copy number-Gained genome\",\"Copy number-lost genome\"))+\n  scale_y_continuous(limits = c(-mar(tableGL[tableGL$class=='FGG',]),mar(tableGL[tableGL$class=='FGL',])),breaks =seq(-0.5,0.5,gap),\n                     labels=abs(seq(-0.5,0.5,gap)),expand = c(0.01,0),\n                     name  = \"FGG or FGL (Fraction of Genome Gained or lost)\")\n\n\np4 <- p2+ \n  facet_grid(rows = vars(group),scales = \"free_y\",space = \"free_y\",switch = \"y\")+\n  theme(strip.text.y = element_text(size = 10, angle= -90,vjust = 1))\n\n}\n#p4\n\n# 中间部分\n# Middle Part\npp=ggplot()+\ngeom_text(data = tableGL, \n          aes(label = subgroup, x=subgroup), y = 0.5,\n          size = 0.8*11/.pt, # match font size to theme\n          hjust = 0.5, vjust = 0.5)+\ntheme_minimal()+\n  theme(axis.line.y =element_blank(),\n        axis.ticks.y =element_blank(),\n        axis.text.y =element_blank(),\n        axis.title.y =element_blank(),\n        axis.title.x =element_blank(),\n        plot.margin = unit(c(0.3, 0, 0.3, 0), \"lines\")\n        )+\n  coord_flip()+\n  scale_y_reverse()\nppa=pp+\n  facet_grid(rows = vars(group),scales = \"free_y\",space = \"free_y\",switch = \"y\")+theme(strip.text.y = element_text(size = 0, angle= 45,vjust = 200))\n\n#输出\n# Output\npal <- p3 + ppa + p4 + \n  plot_layout(widths = c(7,1,7),guides = 'collect')& theme(legend.position = 'bottom')\npal\n#ggsave(file='FGA.png',pal,height = 6,width=12,units = c(\"in\"),dpi = 1200)\nggsave(file='FGA_plus.pdf',pal,height = 6,width=12,units = c(\"in\"))\n注意事项\nPrecautions\nFGA的计算是依赖于cnv数据，即CNV calling生成的segmentation\nfile。所以不同的CNV\ncalling流程和不同的参数设置会产生不同的cnv数据（具体可以看egmentation\nfile中的Start、End、Num_Probes、Segment_Mean），这也是为何上述计算结果有部分患者的FGA与cbioportal的不同。\nThe calculation of FGA relies on cnv data, namely the segmentation file\ngenerated by CNV calling. So different CNV calling processes and\ndifferent parameter Settings will generate different cnv data\n(specifically, you can refer to Start, End, Num_Probes, Segment_Mean in\nthe egmentation file). This is also the reason why the FGA of some\npatients in the above calculation results differs from that of\ncbioportal.\n另外，想使用TCGA的cnv数据自己计算的话需要注意只有xena上的TCGA（不是GDC）和GDC官网上的\nSNP_N_GenomeWideSNP_6_D01_680066.nocnv_grch38.seg.v2.txt\n才能和cbioportal上的一致（C11b版本的不同）。\nBesides, If you want to calculate the cnv data from TCGA by yourself,\nplease note that only TCGA on xena (not GDC) and\nSNP_N_GenomeWideSNP_6_D01_680066.nocnv_grch38.seg.v2.txt\non the GDC official website can be used with cbiopor Consistency on tal\n(differences in the C11b version).\nGDC官网下载的segmentation\nfile里的Segment_Mean也是公式中的log2R（官网说明:\nhttps://docs.gdc.cancer.gov/Data/Bioinformatics_Pipelines/CNV_Pipeline/\n）。\nDownload segmentation from the GDC official website The log2R\nSegment_Mean and formula in the file (website: <\nhttps://docs.gdc.cancer.gov/Data/Bioinformatics_Pipelines/CNV_Pipeline/\n>).\n如果自己的测序数据则要注意，如果是copy\nnumber还需要按照上述公式进行转换。 If it is your own sequencing data,\nyou should pay attention. If it is a copy number, it also needs to be\nconverted according to the above formula.\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa180FGAplotV2_FigureYa180FGAplotV2",
      "title": "FigureYa180FGAplotV2/FigureYa180FGAplotV2.html",
      "html": "FigureYa180FGAplotV2/FigureYa180FGAplotV2.html",
      "text": "texts/main_FigureYa180FGAplotV2_FigureYa180FGAplotV2.txt",
      "folder": "FigureYa180FGAplotV2",
      "thumb": "gallery_compress/FigureYa180FGAplotV2.webp"
    },
    "word_count": 1505,
    "lines_count": 391,
    "title": "FigureYa180FGAplotV2",
    "description": "Requirement cBioPortal上的Fraction Genome Altered的算法 The Fraction Genome Altered algorithm on cBioPortal",
    "input_data_types": [
      "临床数据",
      "突变数据"
    ],
    "output_types": [
      "统计表格"
    ],
    "technical_methods": [],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "signif1",
      "table1",
      "p3",
      "cohort",
      "ymax",
      "angle",
      "margin",
      "height"
    ]
  },
  {
    "id": "main_FigureYa30Plus_nomogram_app_index",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa30Plus_nomogram_app_index.txt",
    "content": "Nomogram Calculator - 医生临床决策助手\n🏥 Nomogram Calculator\n患者生存率预测工具 - 基于Cox回归模型\n年龄 (Age):\n岁\n性别 (Sex):\n女性 (Female)\n男性 (Male)\n胆红素 (Bilirubin):\nmg/dL\n铜 (Copper):\nμg/dL\n疾病分期 (Stage):\nStage 1\nStage 2\nStage 3\nStage 4\n治疗方案 (Treatment):\n对照组 (Control)\n治疗1 (Treatment 1)\n治疗2 (Treatment 2)\n计算生存率\n计算中...\n📊 预测结果\n2年生存率\n-\n5年生存率\n-\n8年生存率\n-\n说明：\n基于Cox比例风险模型计算\n适用于临床决策参考\n结果仅供参考，请结合临床综合判断\n📈 Nomogram评分可视化\n低风险 (≥80%)\n中风险 (50-80%)\n高风险 (<50%)\nℹ️ 关于此工具\n模型来源：\n基于临床数据训练的Cox回归模型\n预测因子：\n年龄、性别、胆红素、铜、疾病分期、治疗方案\n适用人群：\n肝病患者（基于PBC数据集训练）\n参考文献：\nFigureYa: A Standardized Visualization Framework",
    "chapter_info": {
      "id": "main_FigureYa30Plus_nomogram_app_index",
      "title": "FigureYa30Plus_nomogram_app/index.html",
      "html": "FigureYa30Plus_nomogram_app/index.html",
      "text": "texts/main_FigureYa30Plus_nomogram_app_index.txt",
      "folder": "FigureYa30Plus_nomogram_app",
      "thumb": null
    },
    "word_count": 81,
    "lines_count": 47,
    "title": "Nomogram Calculator - 医生临床决策助手",
    "description": "低风险 (≥80%) 中风险 (50-80%) 高风险 (<50%)",
    "input_data_types": [
      "临床数据",
      "生存数据"
    ],
    "output_types": [],
    "technical_methods": [
      "生存分析"
    ],
    "biology_areas": [
      "药物研究"
    ],
    "complexity_level": "高级",
    "code_snippets": [],
    "key_parameters": []
  },
  {
    "id": "main_FigureYa112Plus_venn_FigureYa112venn",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa112Plus_venn_FigureYa112venn.txt",
    "content": "FigureYa112venn\nFigureYa112venn\nYuhui Li, Taojun Ye\n2025-5-20\n需求描述\nvenny\nhttp://bioinfogp.cnb.csic.es/tools/venny/\n，新出来个选项，颜色填充by%，然而只能填充灰色，我想要彩色，而且venny只能保存成png，我想要pdf矢量图。没有现成的R包能直接实现这样的按百分比填充颜色的效果。输入四个基因列表，画出venn图。\n##Requirement description\nvenny<\nhttp://bioinfogp.cnb.csic.es/tools/venny/\n>A new\noption has been introduced, color filling by%, but only gray can be\nfilled. I want color, and Venny can only save as PNG. I want a PDF\nvector image. There is no ready-made R package that can directly achieve\nthe effect of filling colors by percentage. Enter four gene lists and\ndraw a Venn diagram.\n出自\nhttp://bioinfogp.cnb.csic.es/tools/venny/\nfrom\nhttp://bioinfogp.cnb.csic.es/tools/venny/\n应用场景\n展示4组元素（例如差异表达基因）数量重叠，数量多颜色深，数量少颜色浅，一目了然。\n##Application scenarios\nDisplay 4 groups of elements (such as differentially expressed genes)\nwith overlapping quantities, with darker colors for larger quantities\nand lighter colors for smaller quantities, making it clear at a\nglance.\n环境设置\n使用国内镜像安装包\n##Environment settings\nUse domestic image installation package\n# 设置CRAN镜像为清华大学镜像源（Set CRAN mirror to Tsinghua University mirror source）\noptions(\"repos\"= c(CRAN=\"https://mirrors.tuna.tsinghua.edu.cn/CRAN/\"))\n\n# 设置Bioconductor镜像为中国科学技术大学镜像源（Set Bioconductor mirror to University of Science and Technology of China mirror source）\noptions(BioC_mirror=\"http://mirrors.ustc.edu.cn/bioc/\")\n加载包\nlibrary packages\n# 加载Venn图绘制包（Load package for drawing Venn diagrams）\nlibrary(VennDiagram)\n# 加载彩色Venn图绘制包（Load package for colorful Venn diagrams）\nlibrary(colorfulVennPlot)\n# 加载数据可视化包（Load data visualization package）\nlibrary(ggplot2)\n# 加载数据处理包（Load data processing package）\nlibrary(dplyr)\n# 加载管道操作符包（Load pipe operator package）\nlibrary(magrittr)\n# 加载数据读取包（Load data reading package）\nlibrary(readr)\n# 加载函数式编程包（Load functional programming package）\nlibrary(purrr)\n# 加载颜色方案包（Load color palette package）\nlibrary(RColorBrewer)\n# 加载图形设备包（Load graphics device package）\nlibrary(grDevices)\n# 加载高级图形渲染包（Load advanced graphics rendering package）\nlibrary(Cairo)\n# 加载字符串处理包（Load string processing package）\nlibrary(stringr)\n# 加载数据框增强包（Load enhanced data frame package）\nlibrary(tibble)\n# 加载数据整理包（Load data tidying package）\nlibrary(tidyr)\n# 设置英文环境以显示英文报错信息（Set English environment to display English error messages）\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止字符串自动转换为因子类型（Disable automatic conversion of strings to factors）\noptions(stringsAsFactors = FALSE)\n输入文件\n四个基因列表文件，每个文件中是这组内的所有基因名。\n##Input file\nFour gene list files, each containing the names of all genes within\nthis group.\n# 生成文件名列表（Generate a list of file names）\nfilenames <- paste0(\"easy_input_\", 1:4, \".txt\")\n\n# 读取多个文本文件并存储为列表（Read multiple text files and store as a list）\n# map函数对每个文件名执行read_table读取数据（The map function reads data for each file name using read_table）\n# 然后提取第一列数据（Then extract the first column of data）\ndata_ls <- filenames %>% map(., ~read_table(.x, col_names = FALSE)) %>% map(., ~.x$X1)\n# 重命名列表元素（Rename list elements）\nnames(data_ls) <- paste0(\"G\", 1:length(data_ls))\n\n# 查看数据结构（View data structure）\nstr(data_ls)\n# 使用venn.diagram包绘制韦恩图检验数据（Use the venn.diagram package to draw a Venn diagram for data verification）\n# x参数传入数据集（The x parameter takes the dataset）\n# filename指定输出图片路径（The filename parameter specifies the output image path）\nvenn.diagram(x = data_ls, filename = \"venn_test.png\")\n下面将用\ncolorfulVennPlot\n包画图，这个包画韦恩图最全，当然使用也是最复杂的。\n优点：\n可以自己定义每个区域的颜色，这刚好能够满足我们按比例填充颜色的需求。\n缺点：\n每个区域的数字也要自己来提供，就需要先计算。\n包里自带的画四组venn图的函数长这样：\nBelow, we will use the colorfulVennPlot package to draw Venn\ndiagrams, which is the most comprehensive and complex to use.\nAdvantages: You can define the color of each area by yourself, which\nperfectly meets our need to fill colors proportionally. Disadvantage:\nThe numbers for each region also need to be provided by oneself, so they\nneed to be calculated first. The function length for drawing four sets\nof Venn diagrams included in the package is as follows:\nplotVenn4d(x, labels = c('A','B','C','D'),\n  Colors = c('red', 'yellow', 'green', 'pink','darkgreen','blue','lightblue','tan', \n  'yellowgreen','orange','purple','white','grey','plum','brown'),\n  Title = NULL, shrink = 1, rot=45)\n参数解释：\nx\n,\n一个带有\nnames\n属性的数字向量，其长度与韦恩图中\n子区域\n数量一致,\n通常用数字代表\n子区域\n中元素的数量。\n其名称属性为\n0\n与\n1\n的组合的字符串，\n1\n表示在韦恩图中某个类别为\n肯定\n，\n0\n表示否定。\n如\n\"1010\"\n表示在左起第1个椭圆内，且在左起第3个椭圆内，且不在左起第2个或第4个椭圆内。\nlabels\n,\n表示指定椭圆的标签，从左到右排列，字符串向量指定。\nColors\n,\n表示指定\n子区域\n的fill颜色，顺序与\nx\n一一对应。\nrot\n, 表示指定韦恩图的旋转角度。\nTitle\n, 表示指定标题。\n下面将根据\nplotVenn4d\n的特点构造数据：\n计算\n子区域\n编号。\n根据\n子区域\n编号计算各个\n子区域\n中元素的数量。\n计算\n子区域\n的数量占所有区域数量之和的\n百分比\n。\n根据\n百分比\n构造颜色向量。\nParameter explanation: x is a numerical vector with the name\nattribute, whose length is consistent with the number of subregions in\nthe Venn diagram, and is usually represented by numbers to indicate the\nnumber of elements in the subregions. A string whose name attribute is a\ncombination of 0 and 1, where 1 represents a positive category in the\nVenn diagram and 0 represents a negative category. For example, “1010”\nindicates that it is within the first ellipse from the left, within the\nthird ellipse from the left, and not within the second or fourth ellipse\nfrom the left. labels, Indicate the label of the specified ellipse,\narranged from left to right, with a string vector specified. Colors,\nIndicate the fill color of the specified subregion, in order\ncorresponding to x one by one. rot, Indicates the rotation angle of the\nspecified Venn diagram. Title, Indicate the specified title. The\nfollowing will construct data based on the characteristics of\nplotFenn4d: calculate the subregion number. Calculate the number of\nelements in each subregion based on the subregion number. Calculate the\npercentage of the number of subregions to the sum of all regions.\nConstruct color vectors based on percentages.\n计算子区域元素数量、百分比\n##Calculate the number and percentage of elements in the\nsubregion\n# 计算子区域数量（Calculate the number of sub-regions）\n# 公式为2^n - 1，n为数据集数量（Formula: 2^n - 1, where n is the number of datasets）\nnumber_area <- 2^length(data_ls) - 1\n\n# 子区域编号（Sub-region numbering）\n## 自定义函数：将整数转换为二进制字符串（Custom function: Convert integer to binary string）\nintToBin <- function(x){\n  if (x == 1)\n    1\n  else if (x == 0)\n    NULL\n  else {\n   mod <- x %% 2\n   c(intToBin((x-mod) %/% 2), mod)\n  }\n}\n\n# 生成子区域编号（Generate sub-region codes）\nx_area <- seq(number_area) %>% map(., ~intToBin(.x)) %>%  # 转换为二进制字符串（Convert to binary string）\n  map_chr(., ~paste0(.x, collapse = \"\")) %>%  # 合并为字符串（Combine into string）\n  map_chr(., ~str_pad(.x, width = length(data_ls), side = \"left\", pad = \"0\"))  # 左侧补零（Pad with zeros on the left）\n计算子区域中元素的数量、百分比：\nCalculate the number and percentage of elements in the\nsubregion:\n# 计算所有数据集的并集（Calculate the union of all datasets）\nG_union <- data_ls$G1 %>% union(data_ls$G2) %>% \n  union(data_ls$G3) %>% union(data_ls$G4)\n\n# 自定义函数：计算特定子区域中的元素（Custom function: Calculate elements in a specific sub-region）\narea_calculate <- function(data_ls, character_area){\n  # 将二进制编码转换为逻辑向量（Convert binary code to logical vector）\n  character_num <- 1:4 %>% map_chr(., ~substr(character_area, .x, .x)) %>% \n    as.integer() %>% as.logical()\n  \n  # 初始化元素集合为并集（Initialize element set as the union）\n  element_alone <- G_union\n  \n  # 对每个数据集进行交集或差集运算（Perform intersection or difference operations for each dataset）\n  for (i in 1:4) {\n    element_alone <- \n      if (character_num[i]) {\n        intersect(element_alone, data_ls[[i]])  # 如果编码位为1，则取交集（If code bit is 1, take intersection）\n      } else {\n        setdiff(element_alone, data_ls[[i]])  # 如果编码位为0，则取差集（If code bit is 0, take difference）\n      }\n  }\n  return(element_alone)  # 返回子区域元素集合（Return element set of the sub-region）\n}\n\n# 计算每个子区域的元素（Calculate elements for each sub-region）\nelement_ls <- map(x_area, ~area_calculate(data_ls = data_ls, character_area = .x))\n\n# 计算每个子区域的元素数量（Calculate the number of elements in each sub-region）\nquantity_area <- map_int(element_ls, length)\n\n# 计算每个子区域元素数量的百分比（Calculate the percentage of elements in each sub-region）\npercent_area <- (quantity_area / sum(quantity_area)) %>% round(3)  # 四舍五入保留3位小数（Round to 3 decimal places）\npercent_area <- (percent_area * 100) %>% paste0(\"%\")  # 转换为百分比格式（Convert to percentage format）\n计算每个区域的颜色\n使用\nRColorBrewer\n中的色板构造颜色向量。\n##Calculate the color of each region\nConstruct color vectors using the palette in RColorBrewer.\n# 计算色板长度（Calculate the length of the color palette）\n# 基于元素数量的范围确定（Determined by the range of element counts）\nlength_pallete <- max(quantity_area) - min(quantity_area) + 1\n\n# 生成颜色渐变（Generate color gradient）\n# 使用YlGn调色板，可以替换为其他调色板（Use YlGn color palette, can be replaced with others）\n# 可选调色板: Blues, BuGn, BuPu, GnBu, Greens, Greys, Oranges, OrRd, PuBu, PuBuGn, PuRd, Purples, RdPu, Reds, YlGn, YlGnBu, YlOrBr, YlOrRd\ncolor_area <- colorRampPalette(brewer.pal(n = 7, name = \"YlGn\"))(length_pallete)\n\n# 创建颜色映射表（Create color mapping table）\ncolor_tb <- tibble(quantity = seq(min(quantity_area), max(quantity_area), by = 1),\n                   color = color_area) \n\n# 数据整理与颜色映射（Data organization and color mapping）\n# 按元素数量分组并嵌套数据（Group and nest data by element count）\n# 连接颜色映射表（Join color mapping table）\n# 按数量排序并展开数据（Sort by quantity and unnest data）\nnest1 <- tibble(quantity = quantity_area, percent = percent_area, area = x_area) %>% \n  group_by(quantity) %>% nest() %>% \n  left_join(color_tb, by = \"quantity\") %>% \n  arrange(quantity) %>% \n  unnest()\n开始画图\n##Start drawing\n# 准备Venn图数据：显示数量（Prepare Venn diagram data: Show quantities）\nregions <- nest1$quantity\nnames(regions) <- nest1$area\n\n# 使用CairoPDF创建高质量PDF（Create high-quality PDF using CairoPDF）\nCairoPDF(file = \"venn_num.pdf\", width = 8, height = 6)\nplot.new()  # 初始化绘图（Initialize plotting）\n\n# 绘制4维Venn图（Plot 4-dimensional Venn diagram）\n# regions: 各区域数值（Values for each region）\n# Colors: 颜色映射（Color mapping）\n# Title: 标题（Title）\n# labels: 各组标签（Labels for each group）\nplotVenn4d(regions, Colors = nest1$color, Title = \"\", \n           labels = paste0(\"G\", 1:4)) # 标签顺序与输入文件对应（Labels correspond to input files）\ndev.off()  # 关闭绘图设备以保存文件（Close plotting device to save file）\n# 准备Venn图数据：显示百分比（Prepare Venn diagram data: Show percentages）\nregions <- nest1$percent\nnames(regions) <- nest1$area\n\n# 创建百分比版本的Venn图（Create percentage version of Venn diagram）\nCairoPDF(file = \"venn_percent.pdf\", width = 8, height = 6)\nplot.new()  # 初始化绘图（Initialize plotting）\nplotVenn4d(regions, Colors = nest1$color, Title = \"\", \n           labels = paste0(\"G\", 1:4)) # 标签顺序与输入文件对应（Labels correspond to input files）\ndev.off()  # 关闭绘图设备以保存文件（Close plotting device to save file）\n后期处理\n输出的pdf是矢量图，可以用Illustrator等软件打开，调整字号等。\n参考来源：\n一些漂亮的venn图\n如何使用R来绘制韦恩图（Venn\nDiagram）\n用\nR 的 venn 包画五组数据的文氏图\nR语言画维恩图–VennDiagram\nR语言基础绘图——韦恩图\n详解R语言画韦恩图\ncolorfulVennPlot\ncolorfulVennPlot源代码\n数字转二进制\n##Post processing\nThe output PDF is a vector image, which can be opened with software\nsuch as Illustrator and adjusted for font size.\nReference source:\n[Some beautiful Venn pictures]（\nhttps://www.cnblogs.com/xianghang123/archive/2013/03/25/2980623.html\n)\nHow to use R to draw Venn Diagram（\nhttp://blog.sciencenet.cn/home.php?mod=space&uid=2985160&do=blog&id=957210\n)\n[Draw Venn diagrams of five sets of data using R’s Venn package]（\nhttps://nachtzug.xyz/2019/01/19/venn-diagram-with-R-venn-package/\n)\n[R Language Drawing VennDiagram]（\nhttps://www.jianshu.com/p/a653ea616407\n)\n[Basic Drawing of R Language - Wayne Diagram]（\nhttps://shengxin.ren/article/130\n)\n[Detailed explanation of R language drawing Wayne diagram]（\nhttps://blog.csdn.net/u011808596/article/details/80974250\n)\n*\ncolorfulVennPlot\n[ColorfulVennPlot Source Code]（\nhttps://github.com/cran/colorfulVennPlot/tree/master/R\n)\n[Convert numbers to binary]（\nhttps://stackoverflow.com/questions/12088080/how-to-convert-integer-number-into-binary-vector\n)\nsessionInfo()",
    "chapter_info": {},
    "word_count": 1442,
    "lines_count": 348,
    "title": "FigureYa112venn",
    "description": "venny http://bioinfogp.cnb.csic.es/tools/venny/ ，新出来个选项，颜色填充by%，然而只能填充灰色，我想要彩色，而且venny只能保存成png，我想要pdf矢量图。没有现成的R包能直接实现这样的按百分比填充颜色的效果。输入四个基因列表，画出venn图。",
    "input_data_types": [],
    "output_types": [
      "火山图",
      "统计表格"
    ],
    "technical_methods": [
      "质量控制",
      "差异表达分析"
    ],
    "biology_areas": [],
    "complexity_level": "高级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "area",
      "id",
      "shrink",
      "quantity",
      "uid",
      "Title",
      "width",
      "n",
      "side"
    ]
  },
  {
    "id": "main_FigureYa159LR_RF_V2_FigureYa159LR_RF_V2",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa159LR_RF_V2_FigureYa159LR_RF_V2.txt",
    "content": "FigureYa159LR_RFV2\nFigureYa159LR_RFV2\nAuthor(s)\n: Xiaofan Lu\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement\n虽然FigureYa65SVM里有lasso和SVM，还想试试RF和LR，而且用五折交叉验证画AUC也有点问题。\nAlthough FigureYa65SVM includes lasso and SVM, I’d also like to try RF\nand LR. Also, plotting AUC using 5-fold cross-validation is a bit of a\nchallenge.\n出自\nhttps://www.nature.com/articles/ncomms4963\nFrom\nhttps://www.nature.com/articles/ncomms4963\nFigure 3 | The predictive power of pseudogene expression in\nclassification of UCEC subtypes. (a) The UCEC dataset (n 1⁄4 306) was\nsplit into training (n 1⁄4 223) and test (n 1⁄4 83) sets. (b) Schematic\nrepresentation of feature selection and classifiers building through\nfivefold cross-validation within the training set. (c) The receiver\noperating characertistic curves of the three classifiers based on the\ncross-validation within the training set. (d) The receiver operating\ncharacertistic curve from applying the best-performing classifier (SVM)\nbuilt from the whole training set to the test set.\n应用场景\nApplication scenarios\n在LASSO降维的基础上，采用logistic regression或Random\nforest的方法，进行5-fold cross-validation评估LASSO selected\nfeature的预测效能。 On the basis of LASSO dimensionality reduction,\nlogistic regression or Random forest methods are used to conduct 5-fold\ncross-validation to evaluate the prediction performance of LASSO\nselected features.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nLoad the package\nlibrary(glmnet) # 做LASSO和LR # Perform LASSO and LR\nlibrary(randomForest) # 做RF # Perform RF\nlibrary(pROC) # 绘制ROC # Plot ROC\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # Display English error messages\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # Disable conversion of chr values to factors\n输入文件\nInput File\neasy_input.csv，带有分组信息的矩阵，这里用跟FigureYa65SVM同一个输入文件，数据预处理过程可参考FigureYa65SVM。\neasy_input.csv, a matrix with grouping information. This is the same\ninput file used for FigureYa65SVM. For data preprocessing, refer to\nFigureYa65SVM.\n可自行准备，至少包含以下信息： You can prepare this yourself, but it\nshould contain at least the following information:\n第一列：sample ID\n第二列：样本分组信息，最好为二分类变量\n第三列之后：表达矩阵\nFirst column: Sample ID\nSecond column: Sample group information, preferably binary\nvariables\nThird and subsequent columns: Expression matrix\n# 加载输入数据\n# Load input data\ndat <- read.csv(\"easy_input.csv\",row.names = 1,header = T,check.names = F,stringsAsFactors = F) \nsam <- rownames(dat) # 取出样本名 # Extract sample names\n按例文的方法一步步实现\nFollow the example step by step\n包含四步： Consists of four steps:\n第一步：构建5-fold交叉验证的样本集\n第二步：LASSO回归在训练集里筛选变量\n第三步：利用LR在4折数据中构建预测模型，验证余下1折\n第四步：利用RF在4折数据中构建预测模型，验证余下1折\nStep 1: Construct a sample set for 5-fold cross-validation\nStep 2: Use LASSO regression to select variables in the training\nset\nStep 3: Use LR to construct a predictive model on 4-fold data and\nvalidate it on the remaining 1-fold\nStep 4: Use RF to construct a predictive model on 4-fold data and\nvalidate it on the remaining 1-fold\n# 1. 例文第一步：构建5-fold交叉验证的样本集\n# 1. Example Step 1: Construct a sample set for 5-fold cross-validation\n\n# 自定义函数分割样本（无重复）\n# Custom function to split samples (no duplication)\ncreateFolds <- function(strat_id, k, seed = 123456) {\n  set.seed(seed)\n  if(k > length(strat_id)) {\n    k <- length(strat_id)\n  } \n  perm <- sample(length(strat_id))\n  strat_id <- factor(strat_id, levels=sample(unique(strat_id)))\n  \n  strat_order <- order(strat_id[perm])\n  \n  num_item_per_fold_ceil <- ceiling(length(strat_id) / k)\n  \n  fold_ids <- rep(seq_len(k), times= num_item_per_fold_ceil)\n  fold_ids <- fold_ids[seq_along(strat_id)]\n  \n  folds <- split(perm[strat_order], fold_ids)\n  names(folds) <- paste0(\"Fold\", seq_len(k))    \n  return(folds)\n}\n\n# 样本随机分为5-fold且不重复\n# Randomly divide samples into 5 folds without duplication\nn.fold <- 5 # 交叉验证次数 # Number of cross-validation runs\nseed = 12345678 # 设置种子使得结果可重复 # Set the seed to make the results reproducible\nfold <- createFolds(sam,n.fold,seed = seed)\n\ntest_pred_LR <- test_pred_RF <- NULL # 初始化结果数据框 # Initialize the result data frame\nfor (i in 1:n.fold) {\n  train_sam <- sam[-fold[[i]]] # 去除该折，即余下4折为训练集 # Remove this fold, so the remaining 4 folds are the training set\n  test_sam <- setdiff(sam,train_sam) # 余下样本为测试集 # The remaining samples are the test set\n  \n  # 训练集数据\n  # Training set data\n  train_dat <- dat[train_sam,]\n  train_dat$group <- ifelse(train_dat$group == \"NR\",0,1)\n  \n  # 验证集数据\n  # Validation set data\n  test_dat <- dat[test_sam,]\n  test_dat$group <- ifelse(test_dat$group == \"NR\",0,1)\n  \n  # 2. 例文第二步：LASSO回归在训练集里筛选变量\n  # 2. Example, step 2: LASSO regression filters variables in the training set\n  set.seed(seed)\n  x <- as.matrix(train_dat[,setdiff(colnames(train_dat),\"group\")])\n  y <- train_dat$group\n  cvfit = cv.glmnet(x, y, \n                    nfold=10, #10-fold cross-validation\n                    family = \"binomial\", type.measure = \"class\")\n  myCoefs <- coef(cvfit, s=\"lambda.min\")\n  lasso_fea <- rownames(coef(cvfit, s = 'lambda.min'))[coef(cvfit, s = 'lambda.min')[,1]!= 0] # 提出系数非0的变量 # Extract variables with non-zero coefficients\n  lasso_fea <- setdiff(lasso_fea,\"(Intercept)\")\n\n  # 3. 例文第三步：利用LR在4折数据中构建预测模型，验证余下1折\n  # 3. Example, Step 3: Use LR to build a prediction model on 4 folds of data and validate on the remaining 1    fold\n  # 用lasso features构建LR预测模型\n  # Build an LR prediction model using lasso features\n\n  cat(\"LR\",i,\"...\\n\")\n  model_LR <- glm(group ~ ., \n                  data = train_dat[,c(\"group\",lasso_fea)], \n                  family = \"binomial\")\n  \n  # 基于LR算法预测验证集概率，并合并真实结果\n  # Predict the probability of the validation set based on the LR algorithm and merge the actual results\n  test_pred_LR <- rbind.data.frame(test_pred_LR,\n                                   data.frame(prob = predict(model_LR, newdata = test_dat,type=\"response\"),\n                                              group = test_dat$group,\n                                              stringsAsFactors = F),\n                                   stringsAsFactors = F)\n       \n  # 4. 例文第四步：利用RF在4折数据中构建预测模型，验证余下1折\n  # 4. Example Step 4: Use RF to build a prediction model on 4 folds of data and validate the remaining fold\n  # 用lasso features构建RF预测模型\n  # Build an RF prediction model using lasso features\n  cat(\"RF\",i,\"...\\n\")\n  model_RF <- randomForest(group ~ ., \n                           data = train_dat[,c(\"group\",lasso_fea)],\n                           ntree = 1000, # 树的数目，例文为1000 # Number of trees, 1000 in the example\n                           nPerm = 50, # 扰动次数，一般为50 # Number of perturbations, typically 50\n                           mtry = floor(sqrt(ncol(train_dat)-1)), \n                           proximity = T,\n                           importance = T)\n  \n  # 基于RF算法预测验证集概率，并合并真实结果\n  # Predict the probability of the validation set based on the RF algorithm and merge the actual results\n  test_pred_RF <- rbind.data.frame(test_pred_RF,\n                                   data.frame(prob = predict(model_RF, newdata = test_dat,type=\"response\"),\n                                              group = test_dat$group,\n                                              stringsAsFactors = F),\n                                   stringsAsFactors = F)  \n  cat(\"\\n\")\n}\n开始画图\nStart drawing\n绘制ROC，对比LR和RF。 Draw ROC and compare LR and RF.\njco <- c(\"#2874C5\",\"#EABF00\")\n\npdf(\"LR_RF.pdf\")\nLR.roc <- plot.roc(test_pred_LR$group,test_pred_LR$prob,ylim=c(0,1),xlim=c(1,0),\n                   smooth=F, #绘制平滑曲线 #Draw a smooth curve\n                   ci=TRUE, \n                   main=\"\",\n                   col=jco[1],#线的颜色 #Line color\n                   lwd=2, #线的粗细 #Line thickness\n                   legacy.axes=T,\n                   print.auc = F)\nRF.roc <- plot.roc(test_pred_RF$group,test_pred_RF$prob,ylim=c(0,1),xlim=c(1,0),\n                   smooth=F, #绘制平滑曲线 #绘制平滑曲线 #Draw a smooth curve\n                   ci=TRUE,  \n                   main=\"\",\n                   col=jco[2],#线的颜色 #Line color\n                   lwd=2, #线的粗细 #Line thickness\n                   legacy.axes=T,\n                   print.auc = F,\n                   add = T)\nlegend.label <- c(\"AUC\",paste0(\"LR: \",round(LR.roc$auc,3)),paste0(\"RF: \",round(RF.roc$auc,3)))\nlegend(\"bottomright\", \n       legend = legend.label,\n       col = c(NA,jco[1:2]),\n       lwd = 2,\n       bty=\"n\")\ninvisible(dev.off())\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa159LR_RF_V2_FigureYa159LR_RF_V2",
      "title": "FigureYa159LR_RF_V2/FigureYa159LR_RF_V2.html",
      "html": "FigureYa159LR_RF_V2/FigureYa159LR_RF_V2.html",
      "text": "texts/main_FigureYa159LR_RF_V2_FigureYa159LR_RF_V2.txt",
      "folder": "FigureYa159LR_RF_V2",
      "thumb": "gallery_compress/FigureYa159LR_RF_V2.webp"
    },
    "word_count": 970,
    "lines_count": 214,
    "title": "FigureYa159LR_RFV2",
    "description": "Requirement 虽然FigureYa65SVM里有lasso和SVM，还想试试RF和LR，而且用五折交叉验证画AUC也有点问题。 Although FigureYa65SVM includes lasso and SVM, I’d also like to try RF",
    "input_data_types": [
      "临床数据",
      "表达矩阵"
    ],
    "output_types": [
      "PCA图"
    ],
    "technical_methods": [],
    "biology_areas": [],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "measure",
      "add",
      "seed",
      "times",
      "header",
      "lwd",
      "importance",
      "newdata",
      "ylim"
    ]
  },
  {
    "id": "main_FigureYa237circVenn_FigureYa237circVenn",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa237circVenn_FigureYa237circVenn.txt",
    "content": "FigureYa237circVenn\nFigureYa237circVenn\nAuthor(s)\n: Xiao Gu\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n我想实现这幅韦恩图，觉得蛮有意思的\nRequirement Description\nI want to draw this Venn diagram, I think it’s quite interesting\n出自\nhttps://www.mdpi.com/2073-4425/11/5/544\nfrom\nhttps://www.mdpi.com/2073-4425/11/5/544\nFigure 1. Venn diagram showing the gene expression profile of plant\norgans. Each compartment indicates the included organs and the number of\ngenes expressed in it. A gene is considered expressed in an organ when\nits expression is > -2 log2 reads per kilobase per million mapped\nreads (RPKM) and “not expressed” when its expression is ≤ -2 log2\nRPKM.\n应用场景\n展示多组之间的overlap genes、以及每组specific\ngenes，通常会用到venn图（可参考FigureYa112venn），有太多组需要对比的话还可以像例文这样画成环形图。\nApplication Scenarios\nTo show the overlap genes between multiple groups and each specific\ngene, a venn diagram is usually used (FigureYa112venn), and if there are\ntoo many groups to compare, you can draw a donut chart like the example\ntext.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nlibrary(ggVennDiagram) # 找overlap基因 # Find overlap genes\nlibrary(ggplot2)\nlibrary(magrittr)\nlibrary(RColorBrewer)\n\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # An error message is displayed in English\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # chr is not allowed to be converted to factor\n输入差异表达分析结果\n如果你的数据已经找完overlap，并整理成easy_input.csv的格式，就可以跳过这步，直接进入“输入overlap”。\nEnter the results of the differential expression analysis\nIf your data has already been found for overlapping and organized\ninto a easy_input.csv format, you can skip this step and go directly to\n“Enter Overlap”.\n输入文件\nSKCM_*_test_result.*.txt，差异表达分析结果，出自FigureYa118MulticlassDESeq2和FigureYa120MulticlassedgeR。\nInput files\nSKCM_*_test_result.*.txt, differential expression analysis results\nfrom FigureYa118MulticlassDESeq2 and FigureYa120MulticlassedgeR.\n并不局限于差异表达分析结果文件。只要每个文件中有一列ID即可。\nIt is not limited to differential expression analysis result files.\nAs long as there is a column ID in each file, it is sufficient.\n怎样获得差异表达分析结果？\n用FigureYa59Plus_GEO2DEG获得芯片的差异表达分析结果文件\neasy_input_limma.csv\n用FigureYa118MulticlassDESeq2、FigureYa119Multiclasslimma和FigureYa120MulticlassedgeR获得RNA-seq的差异表达分析结果。\nHow do I get the results of differential expression analysis?\nObtain the differential expression analysis result file\n‘easy_input_limma.csv’ of the chip with FigureYa59Plus_GEO2DEG\nDifferential expression analysis of RNA-seq was obtained with\nFigureYa118MulticlassDESeq2, FigureYa119Multiclasslimma, and\nFigureYa120MulticlassedgeR.\nfnames <- Sys.glob(\"*.txt\") # 读取当前文件夹下的所有txt文件 # Read all txt files in the current folder\nfnames # 检查一下读取的文件名 # Check the file name of the read\n#根据自己的数据修改阈值，不根据FDR筛选基因的话就删掉这行\n# Modify the threshold according to your own data, and delete this line if you do not screen genes based on FDR\nadjcutoff <- 0.05\n# 自定义函数读取文件并筛选差异表达基因，只保留基因名\n# The custom function reads the file and screens the differentially expressed genes, keeping only the gene name\nread_cut_ID <- function(file){\n  df <- read.table(file, header = T)\n  DEG <- df[df$FDR <= adjcutoff, ]$id #不想根据FDR筛选基因的话就删掉这行，改用下一行 # If you don't want to screen genes based on FDR, delete this line and use the next line instead\n  # DEG <- df$id \n}\nfdataset <- lapply(fnames, read_cut_ID)\n\nnames(fdataset)\n# 把组名改为字母ABCD等等\n# Change the group name to the letters ABCD, etc\nnames(fdataset) <- LETTERS[1:length(fnames)]\nnames(fdataset)\n找overlap\n使用ggVennDiagram包里的process_region_data处理数据，统计任意并集元素。\nFind overlap\nUse the process_region_data in the ggVennDiagram package to process\ndata and count arbitrary union elements.\nset <- process_region_data(venn = Venn(fdataset)) %>% as.data.frame(.)\n\ndt_all <- set[,c(\"count\", \"name\")]\ncolnames(dt_all) <- c(\"num\", \"name\")\n\n# 将ggVennDiagram包里面name列两个元素之间的..删除\n# Delete the two points between the two elements in the name column in the ggVennDiagram package\ndt_all$name <- gsub(\"\\\\..\", \"\\\\\", dt_all$name)\n\n# 根据自己情况决定是否删除没有overlap的区域（即overlap基因数为0），\n# Decide whether to delete the non-overlapping region (i.e., the number of overlapping genes is 0) according to your own situation.\n#dt_all %<>% subset(., num!=0) # 删除overlap基因数为0的区域\n画图\nDrawing\n# 给每个区域一样的值，保证每个区域占据长度高度一致\n# Give the same value to each region to ensure that the length of each region is consistent\ndt_all$value <- 100\ndt_all$level <- nchar(dt_all$name)\ndt_all$level %<>% factor(., levels = c(1:max(.)) %>% rev())\n\nlevel <- levels(dt_all$level)\ndt_all_final <- c()\nfor (i in level) {\n  dt <- subset(dt_all,level==i)\n  dt_all_final <- rbind(dt_all_final, dt)\n}\ndt_all_final$label <- paste0(dt_all_final$name, \"\\n\", dt_all_final$num)\ndt_all_final$name %<>% factor(., levels = .)\n\np <- ggplot(dt_all_final, aes(x = level, y = value, fill = num)) +\n  geom_bar(stat=\"identity\", position = \"fill\", width = 1, colour = \"black\")+\n  scale_fill_gradientn(colours=c(\"white\", \"forestgreen\")) +\n  geom_text(aes(label = label),color=\"black\", size = 4, position = position_fill(vjust = 0.5))+\n\n  coord_polar(theta=\"y\",direction=-1)+ #direction=-1 逆时针方向 # direction=-1 counterclockwise\n  theme_bw() +\n  theme(legend.position='none')+\n  theme(panel.grid = element_blank(),\n        axis.ticks = element_blank(),\n        axis.text = element_blank(),\n        axis.title = element_blank(),\n        panel.border=element_blank())\n\np\nggsave(filename = \"Circled_Venn_diagram.pdf\", plot = p, width = 10, height = 10)\n输入overlap\n输入文件\neasy_input.csv，这里直接用例文提供的各组之间的overlap基因画图（文章附件Supplemental\nTable S3.csv）。\n每种组合放到一列，例如第一列的列名ABCDEF，即ABCDEF组的共有基因，有32030个基因名，对应圆心上的数字32030。以此类推其后各列。\nEnter overlap\nInput files\neasy_input.csv, here is the direct use case provided for the mapping\nof overlap genes between groups (article attachment Supplemental Table\nS3.csv).\nEach combination is placed in a column, for example, the first column\nis named ABCDEF, which is the common gene of the ABCDEF group, which has\n32030 gene names, corresponding to the number 32030 in the center of the\ncircle. And so on for the next columns.\ndf <- read.csv(\"easy_input.csv\")\nname <- colnames(df) %>% as.vector(.)\ndt_all <- c()\nfor (i in name) {\n  sub_df <- df[,i] %>% .[which(!.%in%\"\")] #删除空值的元素 # Remove null elements # 统计每个区域的元素数量 # Count the number of elements in each region\n  dt <- data.frame(name=i, num=length(sub_df))\n  dt_all <- rbind(dt_all, dt)\n}\n画图\n与第一部分相同\nDrawing\nSame as the first part\n# 给每个区域一样的值，保证每个区域占据长度高度一致\n# Give the same value to each region to ensure that the length of each region is consistent\ndt_all$value <- 100\ndt_all$level <- nchar(dt_all$name)\ndt_all$level %<>% factor(., levels = c(1:max(.)) %>% rev())\n\nlevel <- levels(dt_all$level)\ndt_all_final <- c()\nfor (i in level) {\n  dt <- subset(dt_all,level==i)\n  dt_all_final <- rbind(dt_all_final, dt)\n}\ndt_all_final$label <- paste0(dt_all_final$name, \"\\n\", dt_all_final$num)\ndt_all_final$name %<>% factor(., levels = .)\n\n# 小技巧\n# 如果等比例按照基因数量填充颜色，圆心数量远大于其他区域，其他区域都会是很浅的颜色\n# 为了达到较好的视觉效果，我们把>1000个基因的区域统一定义为1000\n# Tips\n# If you fill the color according to the number of genes in equal proportions, the number of circle centers is much larger than that of other regions, and the other regions will be very light colors\n# In order to achieve a better visual effect, we define the region > 1000 genes as 1000\ndt_all_final[dt_all_final$num > 1000, ]$num <- 1000 # 根据自己的数据调整，或删掉这行 # Adjust to your own data, or delete this line\n\np <- ggplot(dt_all_final,aes(x = level,y = value,fill = num)) +\n  geom_bar(stat=\"identity\",position = \"fill\", width = 1,colour = \"black\") +\n  scale_fill_gradientn(colours=c(\"white\", \"forestgreen\")) +\n  geom_text(aes(label = label),color=\"black\", size = 4, position = position_fill(vjust = 0.5)) +\n  \n  # 想和原文一样标签为白色底色的话run下面这句，但效果感觉不好\n  # If you want to be labeled with a white background like the original text, run the following sentence, but the effect doesn't feel good\n  #geom_label(aes(label = name),fill=\"white\",color=\"black\", size = 3, \n  #           label.padding = unit(0.15, \"lines\"),label.r = unit(0,\"lines\"),\n  #           position = position_fill(vjust = 0.5))+ \n  coord_polar(theta=\"y\",direction=-1)+ #direction=-1 逆时针方向  # direction=-1 counterclockwise\n  theme_bw() +\n  theme(legend.position='none') +\n  theme(panel.grid = element_blank(),\n        axis.ticks = element_blank(),\n        axis.text = element_blank(),\n        axis.title = element_blank(),\n        panel.border = element_blank())\np\nggsave(\"Circled_Venn_diagram_ori.pdf\", plot = p, width = 10,height = 10)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa237circVenn_FigureYa237circVenn",
      "title": "FigureYa237circVenn/FigureYa237circVenn.html",
      "html": "FigureYa237circVenn/FigureYa237circVenn.html",
      "text": "texts/main_FigureYa237circVenn_FigureYa237circVenn.txt",
      "folder": "FigureYa237circVenn",
      "thumb": "gallery_compress/FigureYa237circVenn.webp"
    },
    "word_count": 1079,
    "lines_count": 209,
    "title": "FigureYa237circVenn",
    "description": "我想实现这幅韦恩图，觉得蛮有意思的 Requirement Description I want to draw this Venn diagram, I think it’s quite interesting",
    "input_data_types": [],
    "output_types": [
      "火山图",
      "统计表格"
    ],
    "technical_methods": [
      "差异表达分析"
    ],
    "biology_areas": [],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "colour",
      "ticks",
      "header",
      "width",
      "grid",
      "vjust",
      "colours",
      "venn"
    ]
  },
  {
    "id": "main_FigureYa219GMM_FigureYa219GMM",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa219GMM_FigureYa219GMM.txt",
    "content": "FigureYa219GMM\nFigureYa219GMM\nAuthor(s)\n: Xiaofan Lu\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n这篇文章里用了高斯混合模型，从10个候选miRNA筛出了8个，并且获得了每个miRNA的系数，计算riskscore。\nRequirement Description\nIn this paper, a Gaussian mixture model was used to screen out 8 of\nthe 10 candidate miRNAs, and the coefficients for each miRNA were\nobtained to calculate the riskscore.\n出自\nhttps://www.thno.org/v10p8771.pdf\nfrom\nhttps://www.thno.org/v10p8771.pdf\nFigure 4. The pattern of AUC and 1023 logistic regression models were\nbased on Gaussian finite mixture models. (A) The pattern of the logistic\nregression model correlated with the AUC scores and was identified by a\nGaussian mixture. There are eight clusters of 1023 combinations.\n应用场景\n通过排列组合构建所有可能的逻辑回归并计算每个模型下的AUC，通过高斯混合模型聚类确定最优模型簇，并根据最高AUC得到最终预测模型。\nApplication Scenarios\nAll possible logistic regressions were constructed through\npermutations and combinations, and the AUC under each model was\ncalculated, the optimal model cluster was determined by Gaussian mixture\nmodel clustering, and the final prediction model was obtained according\nto the highest AUC.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nlibrary(mclust)\nlibrary(miRBaseVersions.db)\nlibrary(miRBaseConverter)\nlibrary(pROC)\nlibrary(SimDesign)\nsource(\"twoclasslimma.R\") #差异表达分析 # Differential expression analysis\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # error messages are displayed in English\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # chr is not allowed to be converted to factor\n自定义函数 Custom functions\ndisplay.progress = function (index, totalN, breakN=20) {\n  \n  if ( index %% ceiling(totalN/breakN)  ==0  ) {\n    cat(paste(round(index*100/totalN), \"% \", sep=\"\"))\n  }\n}\n输入文件\n分别从TCGA和来自GEO的数据集提取三阴性乳腺癌和\n癌旁样本\n。提取二者共有的miRNA，用于后续分析。\nTCGA的miRNA数据\nBRCA-miRNA.txt，TCGA-miRNA表达矩阵。\ntcga.sinfo.txt，TCGA数据样本信息。\n来自GEO的miRNA芯片数据\ngse40525.expr.txt，GSE40525表达矩阵。\ngse40525.sinfo.txt，GSE40525样本信息。\nInput files\nTriple-negative breast cancer and\nparacancerous\nsamples\nwere extracted from TCGA and datasets from GEO,\nrespectively. miRNAs common to both were extracted for subsequent\nanalysis.\nmiRNA data for TCGA\nBRCA-miRNA.txt, TCGA-miRNA expression matrix.\ntcga.sinfo.txt. TCGA data sample information.\nmiRNA microarray data from GEO\ngse40525.expr.txt, GSE40525 expression matrix.\ngse40525.sinfo.txt, GSE40525 sample information.\n# 设置目标事件\n# Set the target event\nevent <- \"PFI\" # 数据里包括OS, PFI, DFI，原文研究复发 # Data include OS, PFI, DFI, and the original study of recurrence\n\n# 加载TCGA-miRNA表达谱\n# Load the TCGA-miRNA expression profile\ntcga.mirna <- read.table(\"BRCA-miRNA.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\nmiRNAs <- row.names(tcga.mirna)\nver <- checkMiRNAVersion(miRNAs,verbose = T) # 查看miRNA版本 # Check the miRNA version\nres1 <- miRNA_NameToAccession(miRNAs, version = ver) # v21 高度匹配 # v21 height match\nres2 <- miRNA_AccessionToName(res1$Accession,targetVersion = \"v21\") # 使用v21版来匹配miRNA # Use v21 to match miRNAs\nresult1 <- cbind(miRNAs,res2)\n\n# 加载GSE40525数据\n# Load GSE40525 data\ngse40525.mirna <- read.table(\"gse40525.expr.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\nmiRNAs <- rownames(gse40525.mirna)\nver <- checkMiRNAVersion(miRNAs,verbose = T) # 查看miRNA版本 # Check the miRNA version\nres1 <- miRNA_NameToAccession(miRNAs, version = ver)\nres2 <- miRNA_AccessionToName(res1$Accession,targetVersion = \"v21\") # 使用同样的v21版来匹配miRNA # Use the same v21 version to match the miRNA\nresult2 <- cbind(miRNAs,res2)\n\n# 加载样本信息并提取三阴性乳腺癌和癌旁样本\n# Load sample information and extract triple negative breast cancer and paracancerous samples\n## TCGA\ntcga.sinfo <- read.table(\"tcga.sinfo.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\ntcga.sinfo <- tcga.sinfo[,c(\"PAM50\",event)] # 原文研究复发 # Original study recurrence\ntcga.sinfo <- as.data.frame(na.omit(tcga.sinfo)) # 去掉无复发状态的样本 # Samples with no recurrence were removed\nbasal.tcga <- intersect(rownames(tcga.sinfo[tcga.sinfo$PAM50 == \"Basal\",,drop = F]),colnames(tcga.mirna)) # 选取三阴性样本（这里我得到的三阴性乳腺癌比原文多大概60个，也许是造成结果不一致的原因） # Triple negative samples were selected (here I got about 60 more triple negative breast cancers than in the original text, which may be the reason for the inconsistent results)\nnormal.tcga <- colnames(tcga.mirna)[substr(colnames(tcga.mirna),14,15) == \"11\"]\nnormal.tcga <- intersect(substr(basal.tcga,1,12),substr(normal.tcga,1,12)) # 只取三阴性乳腺癌的癌旁 # Only the paracancerous group of triple-negative breast cancer was taken\nnormal.tcga <- paste0(normal.tcga,\"-11\") # 添加样本名后缀 # Add a suffix to the sample name\ntcga.mirna <- tcga.mirna[,c(basal.tcga,normal.tcga)] # 重做表达谱，仅包含三阴性和三阴性癌旁 # Reworked the expression profile to include only the triple-negative group and the triple-negative paracancer group\ntcga.mirna$mirna <- result1$TargetName # 替换v21版本miRNA名称 # Replace the v21 miRNA name\ntcga.mirna <- as.data.frame(na.omit(tcga.mirna[!duplicated(tcga.mirna$mirna),])) # 去重去空值 # Remove duplicate values and null values\nrownames(tcga.mirna) <- tcga.mirna$mirna; tcga.mirna <- tcga.mirna[,setdiff(colnames(tcga.mirna),\"mirna\")]\nwrite.table(tcga.mirna,\"tcga.miRNA.expr.TNBC.txt\",sep = \"\\t\",row.names = T,col.names = NA,quote = F)\n\n## GSE40525\ngse40525.sinfo <- read.table(\"gse40525.sinfo.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\nbasal.gse <- rownames(gse40525.sinfo[gse40525.sinfo$`1:SUBTYPE (OF TUMOR OR MATCHED TUMOR)` == \"Basal-like\" & \n                                       gse40525.sinfo$`1:TISSUE` == \"Breast primary tumor\",,drop = F]) # 提取三阴性乳腺癌 # Extraction of triple negative breast cancer\nnormal.gse <- rownames(gse40525.sinfo[gse40525.sinfo$`1:SUBTYPE (OF TUMOR OR MATCHED TUMOR)` == \"Basal-like\" \n                                      & gse40525.sinfo$`1:TISSUE` == \"Peritumor breast tissue\",,drop = F]) # 只取三阴性乳腺癌的癌旁 # Only take the next cancer of triple negative breast cancer\ngse.mirna <- gse40525.mirna[,c(basal.gse,normal.gse)]\ngse.mirna$mirna <- result2$TargetName\ngse.mirna <- as.data.frame(na.omit(gse.mirna))\nrownames(gse.mirna) <- gse.mirna$mirna; gse.mirna <- gse.mirna[,setdiff(colnames(gse.mirna),\"mirna\")]\nwrite.table(gse.mirna,\"gse40525.miRNA.expr.TNBC.txt\",sep = \"\\t\",row.names = T,col.names = NA,quote = F)\n\n# 取出共有的miRNA\n# Remove the common miRNA\ncomgene <- intersect(rownames(tcga.mirna),rownames(gse.mirna))\ntcga.mirna <- log2(tcga.mirna[comgene,] + 1) # TCGA数据对数化 # Logarithmicization of TCGA data\ngse.mirna <- gse.mirna[comgene,]\n\n# 修改行名以免后续模型报错\n# Change the row name to prevent subsequent models from reporting errors\nrownames(tcga.mirna) <- gsub(\"-\",\"_\",rownames(tcga.mirna))\nrownames(gse.mirna) <- gsub(\"-\",\"_\",rownames(gse.mirna))\n正常与癌旁的差异表达\nTCGA和GEO来源的miRNA数据分别做差异表达分析，然后取交集。\n这步会生成差异表达分析结果文件：gse_tnbc_limma_test_result.tumor_vs_normal.txt和tcga_tnbc_limma_test_result.tumor_vs_normal.txt\nDifferential expression of normal and adjacent cancer\nThe miRNA data derived from TCGA and GEO were analyzed for\ndifferential expression and then intersected.\nThis step generates differential expression analysis results\nfile:gse_tnbc_limma_test_result.tumor_vs_normal.txt\nand\ntcga_tnbc_limma_test_result.tumor_vs_normal.txt\n# TCGA\nsubt <- data.frame(condition = rep(c(\"tumor\",\"normal\"),c(length(basal.tcga),length(normal.tcga))),\n                   row.names = colnames(tcga.mirna))\ntwoclasslimma(subtype  = subt, # subtype information (must contain a column named 'condition')\n              featmat  = na.omit(tcga.mirna), # expression file (fill detect data scale automatically)\n              treatVar = \"tumor\", # name of treatment group\n              ctrlVar  = \"normal\", # name of control group\n              prefix   = \"tcga_tnbc\", # prefix of the DE file\n              overwt   = TRUE, # whether over write files that already existed\n              sort.p   = TRUE, # if sorting the results by adjusted p value\n              verbose  = TRUE, # if showing verbose result\n              res.path = \".\") # path for result\n# GSE40525\nsubt <- data.frame(condition = rep(c(\"tumor\",\"normal\"),c(length(basal.gse),length(normal.gse))),\n                   row.names = colnames(gse.mirna))\ntwoclasslimma(subtype  = subt, # subtype information (must contain a column named 'condition')\n              featmat  = na.omit(gse.mirna), # expression file (fill detect data scale automatically)\n              treatVar = \"tumor\", # name of treatment group\n              ctrlVar  = \"normal\", # name of control group\n              prefix   = \"gse_tnbc\", # prefix of the DE file\n              overwt   = TRUE, # whether over write files that already existed\n              sort.p   = TRUE, # if sorting the results by adjusted p value\n              verbose  = TRUE, # if showing verbose result\n              res.path = \".\") # path for result\n# 取出差异表达基因\n# Extract differentially expressed genes\nres1 <- read.table(\"tcga_tnbc_limma_test_result.tumor_vs_normal.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\nres2 <- read.table(\"gse_tnbc_limma_test_result.tumor_vs_normal.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\n\ndeg1 <- res1[which(res1$padj < 0.05 & abs(res1$log2fc > 1)),]  # Extract differentially expressed miRNAs\ndeg2 <- res2[which(res2$padj < 0.05 & abs(res1$log2fc > 1)),] # Extract differentially expressed miRNAs\n\ndeg <- intersect(rownames(deg1),rownames(deg2)) # 提取交集的miRNA # Extract intersecting miRNAs\n逻辑回归模型\nLogistic regression model\n# 排列组合构建可能的逻辑回归模型\n# Permutations and combinations to build possible logistic regression models\nflist <- list()\nfor (i in 1:length(deg)) {\n  message(\"--generate \",i,\" miRNA model...\")\n  tmp <- combn(deg, m = i) # 选取miRNA数目为i情况下的排列组合 # Select the permutations and combinations when the number of miRNAs is i\n  for (j in 1:ncol(tmp)) {\n   f <- as.formula(paste0(event,\" ~ \",paste(tmp[,j],collapse = \" + \"))) # 构建当前模型 # Build the current model\n   flist <- append(flist, f) # 1023个模型，即2的10次方-1个模型 # 1,023 models, which is 2 to the power of 10 minus 1 models\n  }\n}\n# 运行逻辑回归模型并计算AUC\n# Run the logistic regression model and calculate the AUC\ndf <- cbind.data.frame(tcga.sinfo[basal.tcga, event, drop = F],\n                       scale(t(tcga.mirna[deg,basal.tcga])))\npred_LR <- list()\naucDF <- NULL\nn.model <- 2^length(deg)-1\nfor (i in 1:n.model) {\n  \n  # 显示运行进程\n  # Displays the running process\n  display.progress(index = i,\n                   totalN = n.model)\n  \n  f <- flist[[i]] # 提出当前逻辑回归公式 # Propose the current logistic regression formula\n  g <- setdiff(as.character(f),c(event,\"~\")) # 拆分公式得到当前公式里的miRNA # Split the formula to get the miRNA in the current formula\n  g <- unlist(strsplit(g,\" + \",fixed = T))\n  \n  # 运行逻辑回归\n  # Run logistic regression\n  l <- glm(formula = f, \n           data = df, \n           family = \"binomial\", \n           control = list(maxit = 50), \n           na.action = na.exclude)\n  \n  # 预测TCGA乳腺癌的复发\n  # Predict the recurrence of TCGA breast cancer\n  pred_LR[[i]] <- data.frame(prob = predict(l, newdata = df,type=\"response\"),\n                             group = df[,event],\n                             stringsAsFactors = F)\n  \n  # 计算AUC\n  # Calculate AUC\n  a <- quiet(auc(pred_LR[[i]]$group,\n             pred_LR[[i]]$prob))\n  \n  # 生成结果\n  # Generate results\n  aucDF <- rbind.data.frame(aucDF,\n                            data.frame(model = i, # 当前模型数目 # Current number of models\n                                       auc = a, # 当前模型的AUC # AUC of the current model\n                                       n.mirna = length(g), # 当前模型包含的miRNA数目 # The number of miRNAs contained in the current model\n                                       stringsAsFactors = F),\n                            stringsAsFactors = F)\n}\n运行高斯混合模型，并画图\nRun the Gaussian mixture model and draw it\nmod <- Mclust(aucDF[,1:2])\naucDF$mclust <- as.numeric(mod$classification)\ntable(aucDF$mclust) # 查看有多少类 # See how many classes there are\n# 保存到文件\n# Save to file\nwrite.table(aucDF,\"output_auc for all models with GMM clusters.txt\",sep = \"\\t\",row.names = F,quote = F)\n\n# 设置颜色\n# Set the color\ndarkred  <- \"#F2042C\"\nlightred <- \"#FF7FBF\"\nnake     <- \"#F8C364\"\ncyan     <- \"#00B3D0\"\ndarkblue <- \"#21498D\"\n\npdf(\"GMM cluster of all auc model combination.pdf\", width = 5,height = 4)\npar(bty = \"o\", mgp = c(2,0.5,0), mar = c(3.1,4.1,1.1,1.1),tcl = -.25,las = 1)\nplot(mod,\n     what = \"classification\",\n     colors = c(darkblue,darkred,cyan,lightred,nake), # 注意根据颜色判别类，蓝色第一类，红色第二类，绿色第三类，黄色第四类，灰色第五类 # Note that the classes are judged according to color, blue category 1, red category 2, green category 3, yellow category 4, gray category 5\n     xlab = paste0(\"Sorted logistic regression models (1:\",n.model,\")\"),\n     ylab = \"\")\nmtext(\"AUC of training models\", side = 2, line = 2.5, las = 3)\ntext(300,0.46,\"cluster 1\", cex = 1.3)\ntext(600,0.58,\"cluster 2\", cex = 1.3)\ntext(100,0.65,\"cluster 3\", cex = 1.3)\ntext(600,0.68,\"cluster 4\", cex = 1.3)\ntext(900,0.64,\"cluster 5\", cex = 1.3)\ninvisible(dev.off())\n# 由图片可以看出末尾灰色区域（第五类）的类有着较高的AUC，取出第五类里AUC最大的逻辑回归公式\n# As you can see from the picture, the class in the gray area (category 5) at the end has a higher AUC, and the logistic regression formula with the largest AUC in category 5 is extracted\ntmp <- aucDF[which(aucDF$mclust == 5),]\nmaxAuc <- tmp[which.max(tmp$auc),\"auc\"]\nprint(maxAuc) # 最大的AUC # Maximum AUC\nbestModel <- flist[[tmp[which.max(tmp$auc),\"model\"]]]\nprint(bestModel) # 最优的模型 # Optimal model\ng <- setdiff(as.character(bestModel),c(event,\"~\")) # 拆分公式得到当前公式里的miRNA # Split the formula to get the miRNA in the current formula\ng <- unlist(strsplit(g,\" + \",fixed = T)) # 最终组成模型的miRNA（9个miRNA的组合，原文是8个）# The final miRNA that makes up the model (a combination of 9 miRNAs, the original text is 8)\n\n# 把筛选到的miRNA保存到文件\n# Save the screened miRNA to a file\nwrite.table(g,\"output_miRNA_selected.txt\",sep = \"\\t\",row.names = F,col.names = F,quote = F) # 输出miRNA # Export miRNA\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa219GMM_FigureYa219GMM",
      "title": "FigureYa219GMM/FigureYa219GMM.html",
      "html": "FigureYa219GMM/FigureYa219GMM.html",
      "text": "texts/main_FigureYa219GMM_FigureYa219GMM.txt",
      "folder": "FigureYa219GMM",
      "thumb": "gallery_compress/FigureYa219GMM.webp"
    },
    "word_count": 1667,
    "lines_count": 284,
    "title": "FigureYa219GMM",
    "description": "这篇文章里用了高斯混合模型，从10个候选miRNA筛出了8个，并且获得了每个miRNA的系数，计算riskscore。 Requirement Description In this paper, a Gaussian mixture model was used to screen out 8 of",
    "input_data_types": [
      "临床数据",
      "表达矩阵",
      "突变数据"
    ],
    "output_types": [
      "火山图",
      "统计表格"
    ],
    "technical_methods": [
      "聚类分析",
      "差异表达分析"
    ],
    "biology_areas": [
      "癌症研究",
      "药物研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "header",
      "targetVersion",
      "width",
      "newdata",
      "prob",
      "side",
      "breakN",
      "prefix",
      "group"
    ]
  },
  {
    "id": "main_FigureYa75bubble_volcano_FigureYa75bubble_volcano",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa75bubble_volcano_FigureYa75bubble_volcano.txt",
    "content": "FigureYa75base_volcano\nFigureYa75base_volcano\nAuthor(s)\n: Haitao Wang, Taojun Ye\nReviewer(s)\n: Ying Ge\nDate\n: 2025-10-25\n需求描述\nRequirement description\n用base plot画美美的火山图\nCreate a beautiful volcano map using a base plot\n应用场景\nApplication scenarios\n同时展示多个特征，同时展示P value、ajust P\nvalue、分组、size、score等。\n例如基因的火山图\nDisplay multiple features simultaneously, including P value, ajust P\nvalue, grouping, size, score, etc.\nFor example, a volcano map of genes\n出自\nhttps://www.nature.com/articles/s41467-018-06944-1\nfrom\nhttps://www.nature.com/articles/s41467-018-06944-1\n或展示富集分析结果\nOr display the enrichment analysis results\n出自\nhttp://dx.doi.org/10.1016/j.neuron.2017.09.008\nfrom\nhttp://dx.doi.org/10.1016/j.neuron.2017.09.008\n想用ggplot2来画火山图，请参考FigureYa59Volcano。\nIf you want to use ggplot2 to draw a volcanic map, please refer to\nFigure Ya59Volcano.\n环境设置\nEnvironment settings\n# 设置R运行环境显示英文错误信息（便于国际交流或搜索解决方案）\n# Set R environment to display error messages in English (for international communication or troubleshooting)\nSys.setenv(LANGUAGE = \"en\") \n\n# 全局设置字符串不自动转换为因子（避免旧版本R的默认行为导致问题）\n# Globally disable automatic conversion of strings to factors (prevent issues from legacy R default behavior)\noptions(stringsAsFactors = FALSE)\n输入文件\nInput file\n第一列是gene名，后面包含列5列特征值。\n可以换成其他值，例如富集分析结果。\nThe first column is the gene name, followed by 5 columns of feature\nvalues.\nIt can be replaced with other values, such as enrichment analysis\nresults.\n# 读取CSV文件创建数据框，包含自定义参数设置\n# Read CSV file to create dataframe with custom parameters\ndat <- read.csv(\"easy_input.csv\",  # 文件路径/文件名\n                header = TRUE,     # 首行作为列名（默认值可简写为T）\n                row.names = 1,    # 将第一列设为行名（注意：该列不再作为数据列）\n                check.names = FALSE) # 禁止自动修正特殊字符列名（如空格/括号）\n\n# 显示数据框前6行（默认6行，可通过n参数修改）\n# Display first 6 rows of dataframe (default, adjustable via n parameter)\nhead(dat)\n# 显示数据框维度（行数 列数）\n# Show dataframe dimensions (rows columns)\ndim(dat)\n把各列数据整理成画图所需的格式\nOrganize the columns of data into the format needed to draw the\ngraphs\n开始画图\nStart drawing\n# 创建PDF输出文件（宽度7英寸，高度6英寸）\n# Create PDF output file (7 inches wide, 6 inches tall)\npdf(\"base_volcano.pdf\", 7, 6)\n\n# 设置图形参数\n# Set graphic parameters\npar(xpd = F,  # 禁止绘图超出绘图区域\n               # Prevent plotting outside plot region\n    mar = par()$mar + c(0,0,0,6))  # 右侧增加6行边距用于图例\n                                   # Add 6-line right margin for legends\n\n# 绘制基础火山图\n# Draw base volcano plot\nplot(fc, p, log='y',  # y轴取对数\n                      # Logarithmic y-axis\n     col=paste(cols.code[as.character(dat$group)], \"BB\", sep=\"\"),  # 带透明度的分组颜色\n                                                                  # Group colors with transparency\n     pch=16,  # 实心圆点\n              # Solid circles\n     ylab=bquote(~-Log[10]~\"P value\"),  # y轴标签（数学表达式）\n                                        # y-axis label (math expression)\n     xlab=\"Enrich score\",  # x轴标签\n                          # x-axis label\n     cex=ifelse(i, sizes, 1),  # 高亮pathway使用指定大小，其他为1\n                              # Use specified size for highlighted pathways, 1 for others\n     xlim=range(fc * 1.2))  # x轴范围扩大1.2倍\n                            # Expand x-axis range by 1.2x\n\n# 添加水平参考线\n# Add horizontal reference lines\nabline(h=1/0.05, lty=2, lwd=1)  # p=0.05的虚线\n                                  # Dashed line for p=0.05\nabline(h=1/max(pp[which(p.adjust(pp, \"bonf\") < 0.001)]), lty=3, lwd=1)  # Bonferroni校正阈值\n                                                                        # Bonferroni correction threshold\n\n# 添加垂直参考线\n# Add vertical reference lines\nabline(v=-0.5, col=\"blue\", lty=2, lwd=1)  # 左侧阈值线\n                                         # Left threshold line\nabline(v=0.5, col=\"red\", lty=2, lwd=1)  # 右侧阈值线\n                                        # Right threshold line\n\n# 标记显著pathway（Bonferroni校正p<0.001）\n# Highlight significant pathways (Bonferroni p<0.001)\nw <- which(p.adjust(pp,\"bonf\") < 0.001)  # 获取显著索引\n                                        # Get significant indices\npoints(fc[w], p[w], pch=1, cex=ifelse(i[w], dat[w,\"size\"],1))  # 添加空心圆圈标记\n                                                              # Add hollow circle markers\n\n# 定义颜色透明度函数\n# Define color transparency function\nadd.alpha <- function(col, alpha=1){\n  if(missing(col))\n    stop(\"Please provide a vector of colours.\")\n  apply(sapply(col, col2rgb)/255, 2, \n        function(x) \n          rgb(x[1], x[2], x[3], alpha=alpha))  \n}\n\n# 为显著pathway添加半透明文本标签\n# Add semi-transparent text labels for significant pathways\ncols.alpha <- add.alpha(cols.code[dat[w,]$group], alpha=0.6)  # 60%透明度\n                                                              # 60% transparency\ntext(fc[w], p[w], names(fc[w]), \n     pos=4,  # 文本位于点右侧（1=下，2=左，3=上，4=右）\n            # Text position (1=below, 2=left, 3=above, 4=right)\n     col=cols.alpha)  # 使用半透明颜色\n                     # Use semi-transparent colors\n\n# 添加点大小图例\n# Add size legend\npar(xpd = TRUE)  # 允许绘图超出绘图区域\n                # Allow plotting outside plot region\nf <- c(0.01,0.05,0.1,0.25)  # 图例大小值\n                            # Legend size values\ns <- sqrt(f*50)  # 计算对应点大小\n                # Calculate corresponding point sizes\nlegend(\"topright\",\n       inset=c(-0.2,0),  # 图例向右偏移20%\n                        # Legend offset 20% to right\n       legend=f, pch=16, pt.cex=s, bty='n', col=paste(\"#88888888\"))  # 灰色半透明图例\n                                                                     # Grey semi-transparent legend\n\n# 添加分组颜色图例\n# Add group color legend\nlegend(\"bottomright\", \n       inset=c(-0.25,0),  # 图例向右偏移25%\n                         # Legend offset 25% to right\n       pch=16, col=cols.code, legend=cols.names, bty=\"n\")  # 无边框图例\n                                                          # No-border legend\n\n# 关闭图形设备\n# Close graphic device\ndev.off()\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa75bubble_volcano_FigureYa75bubble_volcano",
      "title": "FigureYa75bubble_volcano/FigureYa75bubble_volcano.html",
      "html": "FigureYa75bubble_volcano/FigureYa75bubble_volcano.html",
      "text": "texts/main_FigureYa75bubble_volcano_FigureYa75bubble_volcano.txt",
      "folder": "FigureYa75bubble_volcano",
      "thumb": "gallery_compress/FigureYa75bubble_volcano.webp"
    },
    "word_count": 605,
    "lines_count": 164,
    "title": "FigureYa75base_volcano",
    "description": "Requirement description 用base plot画美美的火山图 Create a beautiful volcano map using a base plot",
    "input_data_types": [],
    "output_types": [
      "火山图",
      "统计表格"
    ],
    "technical_methods": [
      "通路分析"
    ],
    "biology_areas": [
      "神经科学"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "pos",
      "header",
      "lwd",
      "xlim",
      "1",
      "legend",
      "col",
      "p",
      "mar"
    ]
  },
  {
    "id": "main_FigureYa157ChIPpvalue_FigureYa157ChIPpvalue",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa157ChIPpvalue_FigureYa157ChIPpvalue.txt",
    "content": "FigureYa157ChIPpvalue\nFigureYa157ChIPpvalue\nDate:2025-5-20\nAuthor:Wen Wang\nReviewer:Ying Ge、Junyi Shen\n需求描述Description of requirements\n计算ChIP-seq样本间的p-value。The p-value between ChIP-seq samples was calculated\n出自From\nhttps://www.nature.com/articles/s41588-018-0044-9\nFig. 1 | Deregulated MYCN binds active chromatin and amplifies transcription in neuroblastoma.\ng, RNA Pol II meta-gene across\nall active genes upon MYCN shutdown\n. The regions encompassing the TSS and gene body are enlarged, and significance is indicated. Bottom right, distribution plots of RNA Pol II traveling ratio (TR) for all active genes. Differences in the TR distributions at 0 and 2 h are significant (Welch’s two-tailed t test):\nP < 1 × 10−9,\nP < 1 × 10−6,\nP < 1 × 10–3.\n应用场景Application scenarios\n用于判断全基因组范围的结合是否有global change，适用于校正过的ChIP-seq数据。Used to determine whether there is a global change in genome-wide binding, and is suitable for corrected ChIP-seq data\n加spike-in的定量ChIP-seq，例如这篇用到的Add spike-in quantitative ChIP-seq, such as the one used in this article ChIP-RX\nhttps://mp.weixin.qq.com/s/tY-MunnBeFQ9A4_Svswu0g\n校正过的普通ChIP-seq，校正方法看这篇For the corrected ordinary ChIP-seq, see this article for the correction method\nhttps://www.notion.so/Paper-191102-ChIPseqSpikeInFree-8e225f58252144d0b1a0a15f99020b66\n环境设置Environment settings\n根据自己的系统选择下载链接Choose the download link according to your system\n加载自定义函数Load custom functions\n# load signal capture methods\nsource(\"./corelib.R\")\n\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息Displays the error message in English\noptions(stringsAsFactors = FALSE) #禁止chr转成factor  Prohibiting CHR from converting to factor\n参数设置Parameter settings\ntest_region_length = 50\noutputName <- \"siteProTest_example.pdf\"\n\nbedFile <- c(\"refGene_hg19_TSS.bed\") \nbigWigFiles <- c(\"GSM2113508_SHEP21_0HR_POL2_CHIP_RX.chiprx.scaled.bedgraph.bw\", \n                 \"GSM2113516_SHEP21_2HR_POL2_CHIP_RX.chiprx.scaled.bedgraph.bw\",\n                 \"GSM2113512_SHEP21_24HR_POL2_CHIP_RX.chiprx.scaled.bedgraph.bw\")\nlabels <- c(\"0hr\", \"2hr\", \"24hr\") # same length as bigWigFiles\nnormalization_constant <- c(0, 0, 0) # 0 means use Fold for nromalization constant, same length as bigWigFiles\ncolors <- c(\"black\", \"navy\", \"red\")\n\nresolution <- 50 #分辨率，数值越低，画出来的曲线越平滑，运行时间越长resolution, the lower the value, the smoother the drawn curve and the longer the running time\nspan <- 1000 #上下游展示范围，需要是resolution的整数倍The upstream and downstream display range needs to be an integer multiple of resolution\ncoreNumber <- 3 #留出一个核用来干别的事情Set aside a nucleus to do something else\ncaptureMethod = \"security\"\n输入文件的准备Preparation of input files\n需要bw文件和bed文件。BW files and bed files are required\nbedgraph和bw文件已上传至微云BedGraph and BW files have been uploaded to Weiyun：\nhttps://share.weiyun.com/5aNaSWO\n，可直接下载bw文件，跳过下载和转bw，直接进入“准备bed文件”You can directly download the BW file, skip the download and convert BW, and go directly to \"Prepare the BED file\"。\n下载bedgraph文件Download the bedgraph file\n原文提供了bedgraph文件，下载后先转成bw文件The original text provides a bedgraph file, which is converted into a bw file after downloading\n在原文中搜\nGSE\n，搜到\nGSE80154\n，进入页面Search\nfor GSE\nin the original text, find\nthe GSE80154\n, and enter the page\nhttps://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE80154\n，拉到底，在Supplementary file里点击custom，勾选3个时间点SHEP21的PolII ChIP-RX数据bedgraph文件，点击Download下载Pull to the end, click custom in the Supplementary file, check the PolII CHIP-RX data bedgraph file of SHEP21 at 3 time points, and click Download to download\nbedgraph转bw  Bedgraph to BW\n# 下载hg19的染色体长度的文件Download the file for chromosome length of HG19\n#wget http://hgdownload.cse.ucsc.edu/goldenPath/hg19/bigZips/hg19.chrom.sizes\nfor file in *.bedgraph; do ./wigToBigWig $file hg19.chrom.sizes $file.bw; done\n准备bed文件Prepare the bed file\n原文用的是all active genes upon MYCN shutdown，没有提供基因名，这里就以所有基因的TSS为例。The original text uses all active genes upon MYCN shutdown, and the gene name is not provided, here is the TSS of all genes as an example.\n如果做转录终止位点的统计检验，就把bed文件换成转录终止位点If you do a statistical test of the transcription termination site, replace the bed file with the transcription termination site。\n下载自Download from\nhttps://raw.githubusercontent.com/Shicheng-Guo/AnnotationDatabase/master/hg19/refGene_hg19_TSS.bed\n# load bed file\nbed <- read.table(bedFile)\n统计检验Statistical tests\ntest_region_signal <- c()\nfor(i in 1:length(bigWigFiles)){\n  # caputre signal\n  # test region\n  seqname <- bed[, 1]\n  midpoints <- as.integer((bed[, 2] + bed[, 3] - 1) / 2)\n  test_region <- data.frame(seqname = seqname, start = as.integer(midpoints - test_region_length/2), end = as.integer(midpoints + test_region_length/2))\n  capture_signal <- average_signal_caputer_around_region(bigWigFiles[i], test_region, captureMethod = captureMethod, cores = as.integer(coreNumber))\n\n  if(normalization_constant[i] == 0) {\n    normalization_constant[i] <- as.numeric(system(paste(\"./bigWigInfo\", bigWigFiles[i] , \"| grep mean | cut -d ' ' -f 2\"), intern = T))\n  }\n  capture_signal <- capture_signal / normalization_constant[i]\n  test_region_signal <- rbind(test_region_signal, t(capture_signal))\n}\n\n# 0h跟2h比0h is compared to 2h\nttest <- t.test(x=test_region_signal[1,],\n                y=test_region_signal[2,],\n                alternative=\"two.sided\",paired=T)\nttest\nttest$p.value\n# 2h跟24h比2h and 24h ratio\nttest <- t.test(x=test_region_signal[2,],\n                y=test_region_signal[3,],\n                alternative=\"two.sided\",paired=T)\nttest\nttest$p.value\ncapture signal\n提取信号画图的方法跟FigureYa44profile一样，这里以TSS为例画图，供参考。The method of extracting signals is the same as that of FigureYa44profile, here is a TSS example for reference\nisNormalChrosome <- !grepl(\"_\", bed$V1)\nbed <- bed[isNormalChrosome, ]  \n\naverage_signal <- c()\nfor(i in 1:length(bigWigFiles)){\n  # caputre signal\n  capture_signal <- signal_caputer_around_sites(bigWigFiles[i], bed, resolution = resolution, span = span, captureMethod = captureMethod, cores = as.integer(coreNumber))\n  if(normalization_constant[i] == 0) {\n    normalization_constant[i] <- as.numeric(system(paste(\"./bigWigInfo\", bigWigFiles[i], \"| grep mean | cut -d ' ' -f 2\"), intern = T))\n    }\n  capture_signal <- capture_signal / normalization_constant[i]\n  average_signal <- rbind(average_signal, capture_signal)\n}\n\n#这步比较耗时，我们把抽取的信号保存到`site_average_signal.csv`文件里。This step is time-consuming, and we save the extracted signal to the 'site_average_signal.csv' file.\nwrite.table(average_signal, \"average_signal.txt\", quote = F, row.names = F, col.names = F)\n画图Drawing\n# 读入前面获得的signal   Read the previously obtained signal\naverage_signal <- read.table(\"average_signal.txt\", header = F)\n\nminimum <- min(average_signal) - (max(average_signal) - min(average_signal)) * 0.1\nmaximum <- max(average_signal) + (max(average_signal) - min(average_signal)) * 0.1 * length(bigWigFiles)\n\ndatapoints <- span / resolution\n\npdf(outputName, width = 4, height = 6)\nplot(1:(datapoints*2 + 1), average_signal[1, ], \n     type = \"l\", lwd = 3, col = colors[1], \n     xaxs = \"i\", yaxs = \"i\", xaxt = \"n\", \n     xlab = \"\", ylab = \"Scaled reads/bp\", \n     ylim = c(minimum, maximum))\n\nfor(i in 2:length(bigWigFiles)){\n  lines(1:(datapoints*2 + 1), average_signal[i, ], col = colors[i], lwd = 3)\n}\n\nlegend(\"topright\", col = colors, legend = labels, lty = 1, lwd = 3, bty = \"n\")\n\naxis(side = 1, at = datapoints, \"TSS\")\n\ndev.off()\n后期处理Post-processing\n输出的pdf文件是矢量图，可以用illustrator等软件打开编辑，添加星号*和线段。The output PDF file is a vector image, which can be opened and edited with software such as illustrator, adding asterisks* and line segments\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa157ChIPpvalue_FigureYa157ChIPpvalue",
      "title": "FigureYa157ChIPpvalue/FigureYa157ChIPpvalue.html",
      "html": "FigureYa157ChIPpvalue/FigureYa157ChIPpvalue.html",
      "text": "texts/main_FigureYa157ChIPpvalue_FigureYa157ChIPpvalue.txt",
      "folder": "FigureYa157ChIPpvalue",
      "thumb": "gallery_compress/FigureYa157ChIPpvalue.webp"
    },
    "word_count": 864,
    "lines_count": 151,
    "title": "FigureYa157ChIPpvalue",
    "description": "计算ChIP-seq样本间的p-value。The p-value between ChIP-seq samples was calculated 出自From https://www.nature.com/articles/s41588-018-0044-9",
    "input_data_types": [
      "临床数据",
      "DNA-seq"
    ],
    "output_types": [
      "统计表格"
    ],
    "technical_methods": [
      "标准化"
    ],
    "biology_areas": [],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "paired",
      "span",
      "acc",
      "header",
      "lwd",
      "width",
      "ylim",
      "side",
      "pvalue"
    ]
  },
  {
    "id": "main_FigureYa12box_FigureYa12box",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa12box_FigureYa12box.txt",
    "content": "FigureYa12 box\nFigureYa12 box\nAuthor(s)\n: Guangchuang Yu; Ying Ge, Yijing\nChen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n用R代码画出paper里的图\nDrawing plots in paper with R code\n图1\nFigure 1\n图2\nFigure 2\n出自\nhttps://www.frontiersin.org/articles/10.3389/fphys.2018.00399/full\nfrom\nhttps://www.frontiersin.org/articles/10.3389/fphys.2018.00399/full\n使用场景\nUsage scenario\n用boxplot展示基因表达量分布，同时计算p value。\nUse a boxplot to show the distribution of gene expression and\ncalculate the p-value.\n输入数据\nInput data\n1. 基因表达量列表\n1. gene expression list\neasy_input_expr.csv，多个sample中所有基因的表达量。\n包含stage1, stage2,\nstage3，各10个样本，stage以样本名后面\n_数字\n标识。\neasy_input_expr.csv, expression of all genes in multiple samples.\nIt includes stage1, stage2, and stage3, with 10 samples each. Stage\nis indicated by\n_number\nfollowing the sample name.\nsource(\"install_dependencies.R\")\nrequire(ggplot2)\nrequire(tidyr)\nrequire(cowplot)\nd <- read.csv(\"easy_input_expr.csv\", row.names=1)\ndim(d)\nhead(d)\n总共有12403个基因的表达量\nThere are 12403 gene expression in total\n2. 差异表达的基因名列表\n2. list of differentially expressed gene names\n单独一列基因名；\n或者第一列是基因名，后面是其他信息。\na single column of gene names;\nOr the first column is the gene name followed by other\ninformation.\nup<-read.table(\"easy_input_up.txt\",header = T, as.is = T, row.names = 1)\ndown<-read.table(\"easy_input_down.txt\",header = T, as.is = T, row.names = 1)\n开始画图\nStart drawing\n1. 多组画在同一个绘图区域\n1. multiple groups in the same drawing area\n分别绘制上下调的基因，然后用cowplot来拼。\nDraw the upregulated and downregulated genes separately, then combine\nthem using cowplot.\nrequire(tidyr)\nrequire(ggplot2)\n\nbox <- lapply(list(up=row.names(up), down=row.names(down)), function(ii) {\n    dd <- d[ii,]\n    dd$gene = rownames(dd)\n    \n    ## 宽变长，变成tidy data frame，好用于ggplot2画图\n    ## The width becomes length and becomes tidy data frame, which is easy to use for ggplot2 drawing.\n    d2 <- gather(dd, sample, expr, 1:30)\n    \n    ## 通过sample名，衍生出stage变量\n    ## derive the stage variable from the sample name\n    d2$stage <- paste('stage', sub(\".*_(\\\\d)$\", \"\\\\1\", d2$sample))\n\n    ## 用one way anova计算 p value\n    ## calculate p value with one way anova\n    pvalues <- sapply(d2$gene, function(x) {\n        res <- aov(expr ~ stage, data = subset(d2, gene == x))\n        summary(res)[[1]]$'Pr(>F)'[1] #\n    })\n    pv <- data.frame(gene = d2$gene, pvalue = pvalues)\n\n    ## 画boxplot，并标识p-value\n    ## draw boxplot and identify p-value\n    ggplot(d2, aes(gene, expr, fill=stage)) + \n      geom_boxplot() + \n      geom_text(aes(gene, y=max(d2$expr) * 1.1, \n                    label=paste(\"p = \",round(pvalue, 2))),\n                data=pv, #\n                inherit.aes=F) + #\n      xlab(NULL)+ylab(\"Relative expression (log2)\")\n})\n\n#拼图\n#pictures put together\nrequire(cowplot)\nplot_grid(plotlist=box, labels=c(\"A\", \"B\"), ncol=1)\n#保存到pdf文件\n#save as pdf file\nggsave(file=\"box1.pdf\")\n如果想用“*\n”或“\n**”来标记是否<0.05或<0.001，这样做：\n把pvalue变成sigcode，然后再下面画图代码中\nlabel=paste(\"p = \",round(pvalue, 2))\n标记p值的地方，改成\nlabel = sigcode\n即可。\nIf you want to use “*\n” or “\n**” to denote <0.05 or\n<0.001, proceed as follows:\nChange p-value to sigcode, and then in the plotting code below,\nchange\nlabel=paste(\"p = \",round(pvalue, 2))\nwhere the\np-value is labeled to\nlabel = sigcode\n.\nbox <- lapply(list(up=row.names(up), down=row.names(down)), function(ii) {\n    dd <- d[ii,]\n    dd$gene = rownames(dd)\n    d2 <- gather(dd, sample, expr, 1:30)\n    d2$stage <- paste('stage', sub(\".*_(\\\\d)$\", \"\\\\1\", d2$sample))\n    pvalues <- sapply(d2$gene, function(x) {\n        res <- aov(expr ~ stage, data = subset(d2, gene == x))\n        summary(res)[[1]]$'Pr(>F)'[1] #\n    })\n    pv <- data.frame(gene = d2$gene, pvalue = pvalues)\n    \n    ## Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1\n    pv$sigcode <- cut(pv$pvalue, c(0, 0.001, 0.01, 0.05, 0.1, 1), \n                    labels=c('***', '**', '*', '.', ' '))\n\n    ggplot(d2, aes(gene, expr, fill=stage)) + \n      geom_boxplot() + \n      geom_text(aes(gene, y=max(d2$expr) * 1.1, \n                    label=pv$sigcode),\n                data=pv, inherit.aes=F) + \n      xlab(NULL)+ylab(\"Relative expression (log2)\")\n})\n\nrequire(cowplot)\nplot_grid(plotlist=box, labels=c(\"A\", \"B\"), ncol=1)\nggsave(file=\"box2.pdf\")\n2. 多个小图拼成一个大图\n2. Multiple small images into one large image\nbox2 <- lapply(c(row.names(up), row.names(down)), function(i) {\n    dd <- d[i,]\n    dd$gene = rownames(dd)\n    d2 <- gather(dd, sample, expr, 1:30)\n    \n    ## 通过sample名，衍生出stagge变量\n    ## derive the stagge variable from the sample name.\n    d2$stage <- paste('stage', sub(\".*_(\\\\d)$\", \"\\\\1\", d2$sample))\n\n    ## 用one way anova计算 p value\n    ## calculate p value with one way anova\n    res <- aov(expr ~ stage, data = d2)\n    pv1 <- summary(res)[[1]]$'Pr(>F)'[1]\n    pv1.lab <- paste(\"one-way ANOVA p =\", round(pv1,3))\n\n    ## t检验用于比较第3阶段与第1阶段\n    ## t test for comparing stage 3 vs stage 1\n    pv2 <- t.test(expr~stage, data=subset(d2, stage!='stage 2'))$p.value\n    pv2.lab <- paste(\"stage III vs stage I p =\", round(pv2, 3))\n\n    lab <- paste(dd$gene, pv1.lab, pv2.lab, sep=\"\\n\")\n\n    label <- ggdraw() + draw_label(lab)\n    plot_grid(label, \n              ggplot(d2, aes(stage, expr, fill=stage)) +\n                geom_boxplot() +\n                xlab(\"\") +\n                ylab(paste(\"Relative \",dd$gene,\" expression (log2)\")) +\n                theme(axis.title.y = element_text(size = 10)), #调整y轴标题字号 adjust y-axis title font size\n              ncol=1, rel_heights=c(.3, 1))\n})\n\nplot_grid(plotlist=box2, ncol=6)\nggsave(file=\"box3.pdf\")\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa12box_FigureYa12box",
      "title": "FigureYa12box/FigureYa12box.html",
      "html": "FigureYa12box/FigureYa12box.html",
      "text": "texts/main_FigureYa12box_FigureYa12box.txt",
      "folder": "FigureYa12box",
      "thumb": "gallery_compress/FigureYa12box.webp"
    },
    "word_count": 689,
    "lines_count": 193,
    "title": "FigureYa12 box",
    "description": "Requirement description 用R代码画出paper里的图 Drawing plots in paper with R code",
    "input_data_types": [
      "临床数据"
    ],
    "output_types": [
      "火山图",
      "箱线图",
      "统计表格"
    ],
    "technical_methods": [
      "差异表达分析"
    ],
    "biology_areas": [],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "rel_heights",
      "label",
      "gene",
      "down",
      "data",
      "size",
      "header",
      "ncol",
      "up",
      "plotlist"
    ]
  },
  {
    "id": "main_FigureYa164PCA3D_FigureYa164PCA3D",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa164PCA3D_FigureYa164PCA3D.txt",
    "content": "FigureYa164PCA3D\nFigureYa164PCA3D\nAuthor(s)\n: Bin Wei\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement\n像文章里这样的3D PCA图，展示不同组sample的关系。 A 3D PCA plot like\nthe one in the article, showing the relationships between different\nsample groups.\nFigure 1 Different immune phenotypes between glioma grades (A)\nPrincipal components analysis of immune-related genes between\nglioblastoma (GBM) and lower grade glioma (LGG).\nFigure 2 An 8-gene local immune signature for patients with\nglioblastoma (GBM) (C) Distribution of samples based on the whole genome\nexpression data. (D) High- and low-risk patients distributed on 2 sides\nbased on the immune system process gene set.\n出自\nhttps://n.neurology.org/content/86/24/2226\nSource:\nhttps://n.neurology.org/content/86/24/2226\n应用场景\nApplication Scenarios\n场景一：PCA一般用作质控，对测序数据的batch effect有个整体的评价。\nScenario 1: PCA is generally used for quality control, providing an\noverall assessment of the batch effect of sequencing data.\n场景二：展示分组之间特定基因的差异。对比例文Figure 2 C和D，C用whole\ngenome expression data，所有样本都混在一起，D用immune-related gene\nsets就可以看出 clearly divided patients into 2 sections, indicating\ntheir remarkable difference in immune phenotype. 类似的像例文Figure 1\nA用immune-related gene set 做PCA，indicating distinct immune phenotypes\namong histologic grades。 Scenario 2: Showing differences in specific\ngenes between groups. Compare Figures 2 C and D. C uses whole genome\nexpression data, lumping all samples together. D, using immune-related\ngene sets, clearly divides patients into two sections, indicating their\nremarkable differences in immune phenotype. Similarly, Figure 1 A uses\nthe immune-related gene set for PCA, indicating distinct immune\nphenotypes among histologic grades.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nLoad the package\nlibrary(rgl)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # Display English error messages\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # Disable conversion of chr to factor\n输入文件\nInput File\n如果你自己的数据已经整理成easy_input\n文件的格式，就直接跳到“PCA分析”。\nIf your data is already organized in easy_input\nformat, skip\ndirectly to “PCA Analysis.”\n输入文件的下载\nDownload the Input File\n基因表达矩阵，CGGA.mRNA_array_301_gene_level.20191128.txt，每行一个基因，每列一个sample。从CGGA下载：\nExpression\nData (gene level)\n，解压； Gene expression matrix,\nCGGA.mRNA_array_301_gene_level.20191128.txt, one gene per row, one\nsample per column. Download\nExpression\nData (gene level)\nfrom CGGA and unzip it.\n分组信息，CGGA.mRNA_array_301_clinical.20191128.txt，至少包含CGGA_ID和Grade两列，这里用Grade为LGG和GBM分组。从CGGA下载：\nClinical\nData\n，解压； Grouping information,\nCGGA.mRNA_array_301_clinical.20191128.txt, contains at least two\ncolumns: CGGA_ID and Grade. Here, Grade is used to group LGG and GBM.\nDownload\nClinical\nData\nfrom CGGA and unzip it.\n从MSigDB下载免疫相关基因，用这个方法还可以下载其他感兴趣通路的基因：\nDownload immune-related genes from MSigDB. This method can also be used\nto download genes for other pathways of interest:\nimmune\nsystem process,\nM13664\n基因集合，重命名为”IMMUNE_SYSTEM_PROCESS_M13664.txt”；\nimmune\nresponse,\nM19817\n基因集合，重命名为”IMMUNE_RESPONSE_M19817.txt”。\nimmune\nsystem process, M13664\ngene set, renamed\n“IMMUNE_SYSTEM_PROCESS_M13664.txt”;\n[immune response, The gene set\nM19817\nhas been renamed to “IMMUNE_RESPONSE_M19817.txt”.\n读取基因表达矩阵\nRead the gene expression matrix\n#exp_data <- read.table(\"CGGA.mRNA_array_301_gene_level.20191128.txt\", header=T, row.names=1, sep=\"\\t\")\n# 为方便传输，只保留小数点后1位\n# For ease of transmission, only one decimal place is retained\n#write.csv(round(exp_data,1), \"easy_input_expr_ori.csv\", quote = F)\nexp_data <- read.csv(\"easy_input_expr_all.csv\", row.names = 1)\nexp_data[1:3,1:3]\n读取分组信息\nRead group information\n用到两列：CGGA_ID和Grade Use two columns: CGGA_ID and Grade\nclinical_data <- read.table(\"CGGA.mRNA_array_301_clinical.20191128.txt\", header=T, sep=\"\\t\")\nclinical_data <- clinical_data[!is.na(clinical_data$Grade), ]\nclinical_data[1,]\ntable(clinical_data$Grade)\n# 获取LGG样本名称，Grade里的WHO II和WHO III定义为LGG\n# Get the LGG sample name. WHO II and WHO III in Grade are defined as LGG.\nlgg_sample <- as.character(subset(clinical_data, Grade %in% c(\"WHO II\", \"WHO III\"))[, \"CGGA_ID\"])\nlgg_sample <- lgg_sample[lgg_sample %in% colnames(exp_data)]\nwrite.table(lgg_sample, \"easy_input_group1.txt\", quote = F, row.names = F)\n\n# 获取GBM样本名称，Grade里的WHO IV定义为LGG\n# Get the GBM sample name. WHO IV in Grade is defined as LGG.\ngbm_sample <- as.character(subset(clinical_data, Grade %in% c(\"WHO IV\"))[, \"CGGA_ID\"])\ngbm_sample <- gbm_sample[gbm_sample %in% colnames(exp_data)]\nwrite.table(gbm_sample, \"easy_input_group2.txt\", quote = F, row.names = F)\n读取参与特定通路的基因\nRead genes involved in a specific pathway\n# 读取基因集合 # Read the gene collection\nimmune_response <- as.character(read.table(\"IMMUNE_RESPONSE_M19817.txt\", skip=2)[, 1])\nimmune_system_process <- as.character(read.table(\"IMMUNE_SYSTEM_PROCESS_M13664.txt\", skip=2)[, 1])\nimmune_genes <- unique(c(immune_response, immune_system_process))\nimmune_genes <- immune_genes[immune_genes %in% rownames(exp_data)]\n\n# 获取感兴趣的基因表达谱 # Obtain gene expression profiles of interest\nimmune_data <- exp_data[immune_genes, c(lgg_sample, gbm_sample)]\nimmune_data[1:5, 1:5]\n# 保存到文件 # Save to file\nwrite.csv(immune_data, \"easy_input_expr.csv\", quote = F)\nPCA分析\nPCA analysis\n# 读取基因表达矩阵 # Read gene expression matrix\nimmune_data <- read.csv(\"easy_input_expr.csv\", row.names = 1)\nimmune_data[1:3,1:3]\ndim(immune_data)\n# 做PCA # Perform PCA\npca <- prcomp(t(immune_data))\n开始画图\nStart plotting\n# 两个分组的sample ID\n# Sample IDs for the two groups\nlgg_sample <- read.table(\"easy_input_group1.txt\", header = T)$x\ngbm_sample <- read.table(\"easy_input_group2.txt\", header = T)$x\n\n# 准备颜色\n# Prepare the colors\nlgg_color <- rep(\"yellow\", length(lgg_sample))\nnames(lgg_color) <- lgg_sample\ngbm_color <- rep(\"red\", length(gbm_sample))\nnames(gbm_color) <- gbm_sample\ngroups <- c(lgg_color, gbm_color)\n运行下面这段，会跳出画图窗口，用鼠标拖拽到合适的角度、拉伸窗口到合适的大小后，保存图。\nRun the following code and a drawing window will pop up. Drag the mouse\nto the desired angle and size, then save the image.\n# 3d PCA图\n# 3D PCA plot\nplot3d(pca$x[,1:3], # 取前三个主成分 # Take the first three principal components\n       xlab=\"Comp.1\", ylab=\"Comp.2\", zlab=\"Comp.3\", \n       col=groups, # 按groups填充颜色 # Fill color by group\n       type=\"s\", # 画球，'p' for points, 's' for spheres, 'l' for lines, 'h' for line segments \n# Draw spheres, 'p' for points, 's' for spheres, 'l' for lines, 'h' for line segments\n       size=1, #球的大小 # Size of the spheres\n       lwd=2, box=T)\n# 保存(目前只能保存为png)\n#rgl.snapshot(\"PCA.png\")\n# Save (Currently only saves to png)\n#rgl.snapshot(\"PCA.png\")\n有时我们希望同一篇文章中的多个3D图形保持同一角度来展示，那就把角度保存下来，每次画图都加载这个角度。\nSometimes, we want to display multiple 3D graphs in the same article\nfrom the same angle. To do this, save the angle and load it each time\nyou draw.\n#手动调好3D图形位置，获得角度\n# Manually adjust the 3D shape's position and obtain the angle\nmyMatrix <- par3d()\nuserMatrix <- myMatrix$userMatrix\nwindowRect <- myMatrix$windowRect\n# 把角度保存到文件\n# Save the angle to a file\n#save(userMatrix, windowRect, file = \"mypar3d.RData\")\n\n# 载入之前调好的角度\n# Load the previously adjusted angle\n(load(\"mypar3d.RData\"))\nhead(userMatrix) # a 4 by 4 matrix describing user actions to display the scene.\nhead(windowRect) # integer. A vector of four values indicating the left, top, right and bottom of the displayed window (in pixels). Applies to the whole device.\npar3d(userMatrix=userMatrix, windowRect=windowRect)\nrglwidget()\n# 保存(目前只能保存为png)\n# Save (Currently only saves as PNG)\n#rgl.snapshot(\"PCA.png\")\n由于是3D图，需要在弹出的窗口自己调整角度，所以待调整完角度后再添加legend\nSince this is a 3D graph, you’ll need to adjust the angle in the pop-up\nwindow. Add the legend after adjusting the angle.\n也可以用Illustrator等软件手动添加图例，更灵活。 You can also manually\nadd the legend using software like Illustrator for greater\nflexibility.\nlegend3d(\"topright\", # legend的位置 # Legend position\n         legend = c(\"LGG (n=173)\", \"GBM (n=124)\"), # 手写文字 # Handwritten text\n         bty = \"n\", # 不带边框 # No border\n         cex = 2, # 文字大小 # Text size\n         pch = 16, # 圆形 # Circle\n         col = c(\"yellow\", \"red\")) # 颜色跟图中一致 # Colors consistent with the image\n# 保存(目前只能保存为png) # Save (Currently only saves to PNG)\nrgl.snapshot(\"PCA.png\")\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa164PCA3D_FigureYa164PCA3D",
      "title": "FigureYa164PCA3D/FigureYa164PCA3D.html",
      "html": "FigureYa164PCA3D/FigureYa164PCA3D.html",
      "text": "texts/main_FigureYa164PCA3D_FigureYa164PCA3D.txt",
      "folder": "FigureYa164PCA3D",
      "thumb": "gallery_compress/FigureYa164PCA3D.webp"
    },
    "word_count": 1034,
    "lines_count": 217,
    "title": "FigureYa164PCA3D",
    "description": "Requirement 像文章里这样的3D PCA图，展示不同组sample的关系。 A 3D PCA plot like the one in the article, showing the relationships between different",
    "input_data_types": [
      "临床数据",
      "表达矩阵"
    ],
    "output_types": [
      "统计表格",
      "PCA图"
    ],
    "technical_methods": [
      "主成分分析",
      "通路分析",
      "质量控制"
    ],
    "biology_areas": [
      "免疫学"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "windowRect",
      "header",
      "lwd",
      "n",
      "legend",
      "col",
      "type",
      "box",
      "xlab"
    ]
  },
  {
    "id": "main_FigureYa19Lollipop_FigureYa19Lollipop",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa19Lollipop_FigureYa19Lollipop.txt",
    "content": "FigureYa19 Lollipop\nFigureYa19 Lollipop\nAuthor(s)\n: Dekang Lv; Ying Ge, Yijing Chen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n用R代码画出paper里的Lollipop，棒棒糖🍭。\nDraw the Lollipop in the paper using R code, lollipop 🍭.\n出自\nhttps://www.nature.com/articles/nature22973\nfrom\nhttps://www.nature.com/articles/nature22973\n应用场景\nApplication scenario\n某个基因的突变发生在哪个重要的结构域？推测该位点的突变影响了蛋白质功能。\n场景一：展示TCGA某个癌症类型里某个基因的突变位点。\n场景二：对比不同癌症/亚型的突变位点。\nIn which important structural domain does the mutation of a gene\noccur? It is speculated that the mutation of this site affects protein\nfunction.\nScenario 1: Show the mutation site of a gene in a cancer type in\nTCGA.\nScenario 2: Compare the mutation sites of different\ncancers/subtypes.\n环境设置\nEnvironment setting\nsource(\"install_dependencies.R\")\nlibrary(TCGAbiolinks)\nlibrary(maftools)\nlibrary(trackViewer)\nlibrary(RColorBrewer)\n下载TCGA数据\nDownload TCGA data\n如果你要画的基因突变信息已经保存在类似\neasy_input.csv\n的文件里，就可以跳过这步，直接进入“输入数据”。\n下载突变信息作为输入数据。\nIf genetic mutation information you want to draw is already saved in\na file like\neasy_input.csv\n, you can skip this step and go\ndirectly to\nInput data\n.\nDownload the mutation information as input data.\nmutquery <- GDCquery(project = \"TCGA-LIHC\",\n                     data.category = \"Simple Nucleotide Variation\",\n                     data.type = \"Masked Somatic Mutation\",\n                     workflow.type = \"Aliquot Ensemble Somatic Variant Merging and Masking\")\nGDCdownload(mutquery)\nmut<-GDCprepare(mutquery)\n\n#运行下面这行，会把所有基因的突变数据保存到文件里，你可以用这个文件做更多的事情。\n#run the line below will save the mutation data for all the genes to a file, which you can use to do more.\n#write.csv(mut,\"TCGA_SNV.csv\")\n\n#画棒棒糖图只需要其中的一个基因，我们单独抽提出来，此处提取TP53。\n#draw a lollipop plot requires only one of these genes, which we extract separately, here we extract TP53.\nwrite.table(mut[mut$Hugo_Symbol == \"TP53\",],\"easy_input.txt\",row.names = F,quote = F,sep = \"\\t\")\n输入数据\nInput data\n需要结构域和突变信息。\nStructural domains and mutation information are required.\n突变信息\nMutation information\n此处直接用TCGA的突变数据，有很多列，其中\nRefSeq``HGVSp\nHGVSp_Short\n三列是必须的。\n因此，你也可以只准备这三列。\nHere, the mutation data from TCGA is used directly, with many\ncolumns, of which three columns\nRefSeq\nHGVSp\nHGVSp_Short\nare mandatory.\nTherefore, you can also prepare only these three columns.\ndf<-read.table(\"easy_input.txt\",as.is = T,sep = \"\\t\",header = T)\n\n#筛掉氨基酸未突变的行\n#screen out rows with unmutated amino acids\nnewdf<-df[!is.na(df$HGVSp),]\n结构域\nStructural domains\n根据基因名（此处是TP53）和refseq\nID从maftools提供的蛋白domain注释中提取某个基因的domain注释\nExtract the domain annotation of a gene from the protein domain\nannotation provided by maftools according to the gene name (TP53 here)\nand refseq ID\ngff = readRDS(file = system.file('extdata', 'protein_domains.RDs', package = 'maftools'))\nrefseqid <- strsplit(x = as.character(newdf$RefSeq), split = '.', fixed = TRUE)[[1]][1]\nprotein_inform <- gff[HGNC %in% \"TP53\"][refseq.ID == refseqid,]\n从突变注释中提取氨基酸位置\nExtract amino acid positions from mutation annotations\n先写个函数，用于从突变注释中提取氨基酸位置\nFirst write a function for extracting amino acid positions from\nmutation annotations\nextractpos <- function(maf_aachange){\n  prot.spl = strsplit(x = as.character(maf_aachange), split = '.', fixed = TRUE)\n  prot.conv = sapply(sapply(prot.spl, function(x) x[length(x)]), '[', 1)\n  pos = gsub(pattern = 'Ter.*', replacement = '',x = prot.conv)\n  pos = gsub(pattern = '[[:alpha:]]', replacement = '', x = pos)\n  pos = gsub(pattern = '\\\\*$', replacement = '', x = pos)\n  pos = gsub(pattern = '^\\\\*', replacement = '', x = pos)\n  pos = gsub(pattern = '\\\\*.*', replacement = '', x = pos)\n  pos = as.numeric(sapply(X = strsplit(x = pos, split = '_', fixed = TRUE), FUN = function(x) x[1])) \n  aa = paste0(unlist(regmatches(maf_aachange, gregexpr(\"p[.].[0-9]+\",maf_aachange))),\"X\")\n  mutpos = data.frame(position = pos, mutation = maf_aachange, aa = aa, stringsAsFactors = F)\n  return(mutpos[order(mutpos$pos),])\n}\n从突变注释中提取氨基酸位置\nExtract amino acid positions from mutation annotations\npos <- extractpos(newdf$HGVSp_Short)\nhead(pos)\n统计不同氨基酸突变类型的突变频率\nCount the mutation frequency of different amino acid mutation\ntypes\nnrpos <- pos[!duplicated(pos),]\nrownames(nrpos) <- nrpos$mutation\nnrpos$rate <- 1\nnrpos[names(table(pos$mutation)),]$rate <-table(pos$mutation)\nhead(nrpos)\n开始画图\nStart drawing\n#首先将上面获得的蛋白domain注释信息写入一个GRanges对象\n#first write the protein domain annotation information obtained above to a GRanges object\nfeatures <- GRanges(\"chr1\", IRanges(start=protein_inform$Start,end=protein_inform$End,names=protein_inform$Description))\nfeatures$height <- 0.07 #domain box高 domain box high\nfeatures$fill<-brewer.pal(9,\"Set1\")[1:3] #domain box颜色 domain box color\n\n#将突变点的信息写入一个GRanges对象\n#Write information about the mutation point to a GRanges object\nna_rows <- is.na(nrpos$position) | is.na(nrpos$mutation)\nnrpos <- nrpos[!na_rows, ]\nsample.gr <- GRanges(\"chr1\", IRanges(nrpos$position, width=1, names=nrpos$mutation))\nsample.gr$label.parameter.rot <- 90 #label角度 label angle\nsample.gr$label <- as.character(nrpos$rate) #点中的标记 markers in the point\nsample.gr$label.col <- \"white\" #点中标记的颜色 color of the markers in the point\nsample.gr$color <-sample.gr$border <- brewer.pal(9,\"Set1\")[4] #点及连线颜色 point and line color\nsample.gr$score<- log2(nrpos$rate) #点所在高度（纵坐标） height of the point (vertical coordinate) \n\npdf(\"test1.pdf\",width=24,height = 5)\nlolliplot(sample.gr, features,xaxis = c(protein_inform$Start,protein_inform$End),yaxis = F, ylab = F,type=\"circle\")\ndev.off()\n突变点太拥挤，解决办法是分上下两层，点可随机分。\n注意这里也可按照临床信息分类（只能分2类），这样更有意义，下面把点随机分上下两层：\nThe mutation pointa are too crowded, the solution is to divide them\ninto upper and lower layers, and the points can be randomly divided.\nNote that it can also be classified according to clinical information\n(it can only be divided into 2 categories), which is more meaningful.\nThe points are randomly divided into upper and lower layers below:\ntorb <- sample(c(\"top\", \"bottom\"), length(sample.gr), replace=TRUE)\nsample.gr$SNPsideID <- torb\nsample.gr$color[torb==\"bottom\"] <- sample.gr$border[torb==\"bottom\"] <- brewer.pal(9,\"Set1\")[7]\n\npdf(\"test2.pdf\",width=21)\nlolliplot(sample.gr, features,xaxis = c(protein_inform$Start,protein_inform$End),yaxis = F, ylab = F,type=\"circle\")\ndev.off()\n点内的标记太多，去掉1\nThere are too many marks in the point, remove 1\nlabs<-sample.gr$label\nlabs[labs==\"1\"]<-\"\"\nsample.gr$label <- labs\npdf(\"test3.pdf\",width=21)\nlolliplot(sample.gr, features,xaxis = c(protein_inform$Start,protein_inform$End),yaxis = F, ylab = F,type=\"circle\")\ndev.off()\n根据突变频率设置点大小\nSet point size according to mutation frequency\nsample.gr$cex <- log10(nrpos$rate) + 0.4\npdf(\"test4.pdf\",width=21)\nlolliplot(sample.gr, features,xaxis = c(protein_inform$Start,protein_inform$End),yaxis = F, ylab = F,type=\"circle\")\ndev.off()\n进一步根据突变位置整合突变,如将p.Y126D 和 p.Y126D 合并成p.Y126X\nFurther integrate mutations according to the mutation position, such\nas merging p.Y126D and p.Y126D into p.Y126X\nnewpos <- pos[!duplicated(pos$position),]\nnewpos$aachange <- newpos$mutation\nnewpos <- newpos[!is.na(newpos$position), ]\nrownames(newpos) <-newpos$position\nduppos <- names(table(pos$position)[table(pos$position)>1])\nnewpos[duppos,]$aachange <- newpos[duppos,]$aa\n\nsample.gr <- GRanges(\"chr1\", IRanges(newpos$position, width=1, names=newpos$aachange))\nsample.gr$label.parameter.rot <- 45\nsample.gr$label <- as.character(table(pos$position))\nsample.gr$label.col <- \"white\"\nsample.gr$color <-sample.gr$border <- brewer.pal(9,\"Set1\")[4]\nsample.gr$score<- log2(table(pos$position))\nlabs<-sample.gr$label\nlabs[labs==\"1\"]<-\"\"\nsample.gr$label <- labs\ntorb <- sample(c(\"top\", \"bottom\"), length(sample.gr), replace=TRUE)\nsample.gr$SNPsideID <- torb\nsample.gr$color[torb==\"bottom\"] <- sample.gr$border[torb==\"bottom\"] <- brewer.pal(9,\"Set1\")[7]\n\npdf(\"test5.pdf\",width=21)\nlolliplot(sample.gr, features,xaxis = c(protein_inform$Start,protein_inform$End),yaxis = F, ylab = F,type=\"circle\")\ndev.off()\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa19Lollipop_FigureYa19Lollipop",
      "title": "FigureYa19Lollipop/FigureYa19Lollipop.html",
      "html": "FigureYa19Lollipop/FigureYa19Lollipop.html",
      "text": "texts/main_FigureYa19Lollipop_FigureYa19Lollipop.txt",
      "folder": "FigureYa19Lollipop",
      "thumb": "gallery_compress/FigureYa19Lollipop.webp"
    },
    "word_count": 894,
    "lines_count": 209,
    "title": "FigureYa19 Lollipop",
    "description": "Requirement description 用R代码画出paper里的Lollipop，棒棒糖🍭。 Draw the Lollipop in the paper using R code, lollipop 🍭.",
    "input_data_types": [
      "临床数据",
      "突变数据"
    ],
    "output_types": [
      "统计表格"
    ],
    "technical_methods": [],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "pos",
      "pattern",
      "header",
      "split",
      "width",
      "mutpos",
      "xaxis",
      "spl",
      "replace",
      "gff"
    ]
  },
  {
    "id": "main_FigureYa17WGCNA_heatmap_FigureYa17WGCNA_heatmap",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa17WGCNA_heatmap_FigureYa17WGCNA_heatmap.txt",
    "content": "FigureYa17 WGCNA_heatmap\nFigureYa17 WGCNA_heatmap\nAuthor(s)\n: Ying Ge; Yijing Chen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n用R代码画出paper里WGCNA module的heatmap\nDraw the heatmap of the WGCNA module in paper using R code\n出自\nhttps://www.cell.com/cell/abstract/S0092-8674(18)30511-7\nfrom\nhttps://www.cell.com/cell/abstract/S0092-8674(18)30511-7\n使用场景\nUsage scenario\nWGCNA找出了gene\nmodule，展示各module的基因在各组样本中的表达谱变化。\nWGCNA identified gene modules to show the changes in the expression\nprofiles of the genes of each module in each group of samples.\n输入数据的预处理\nPreprocessing of input data\n用FigureYa15WGCNA_module输出了各个gene\nmodule内的基因表达量，每个module保存在一个csv文件中，位于当前文件夹。\nWGCNA已经按照共表达特征给基因分成了多个module，因此，这里不需要再做聚类，直接按照module内基因的数量给基因排序，再用热图的方式可视化。\n如果你的数据已经保存成像\neasy_input.csv\n的格式，就可以跳过这步，直接进入“开始画图”。\nGene expression within each gene module was output using\nFigureYa15WGCNA_module, and each module was saved in a csv file located\nin the current folder.\nWGCNA has already divided genes into modules according to\nco-expression characteristics, so there is no need to do clustering\nhere, and genes are directly sorted according to the number of genes\nwithin a module, and then visualized by heatmap.\nIf your data has been saved in a format like\neasy_input.csv\n, you can skip this step and go directly to\n“Start drawing”.\nsource(\"install_dependencies.R\")\nfnames<-Sys.glob(\"*.csv\")\nfnames\n读取这些module，合并。\nRead these modules, merge them.\nfdataset<-lapply(fnames,read.csv)\nnames(fdataset) <- fnames\n\nlibrary(plyr)\nresult <- ldply(fdataset, data.frame)\nhead(result)\ndf<-result[,2:22]\ndf$module<-unlist(strsplit(result$.id,split = \".csv\"))\nhead(df)\n按照module内基因数量从多到少，给基因排序。\nOrder the genes according to the number of genes within the module\nfrom most to least.\n#先按module内基因的数量为module排序\n#sort the module first by the number of genes in the module\nmodule.num<-table(df$module)\nmodule.num.sort<-module.num[order(module.num,decreasing =TRUE)]\nmodule.num.sort\nkeys<-names(module.num.sort)\nkeysDF<-data.frame(module=keys,order=1:length(keys))\nkeysDF\n#再按这个module的顺序为基因排序\n#then sort the genes in the order of this module\ndf.merged<-merge(df,keysDF,by.x = 'module',by.y = 'module',all.x = T, all.y = F)\ndf.sort <- df.merged[order(df.merged$order),]\nwrite.table(df.sort[1:22],\"easy_input.txt\",row.names = F, quote = F)\n开始画图\nStart drawing\n#读取带有module信息的基因表达量文件\n#read gene expression file with module information\ndf.exp<-read.table(\"easy_input.txt\",header = T, as.is = T)\nrow.names(df.exp)<-df.exp$X\nhead(df.exp)\ndim(df.exp)\nlibrary(pheatmap)\n#设置sample的分组\n#set the grouping of sample\nannotation_col = data.frame(\n  type = factor(rep(c(\"BALB\",\"C57\",\"NOD\",\"PWK\",\"SPRET\"),c(4,4,4,4,4))),\n  treatment = factor(rep(c(\"notx\",\"notx\",\"KLA\",\"KLA\"),5))\n)\nrownames(annotation_col) = colnames(df.exp[,3:22])\n\n#设置基因的分组，也就是module\n#set the grouping of genes, also known as the module\nannotation_row = data.frame(df.exp$module)\nrownames(annotation_row) = df.exp$X\ncolnames(annotation_row)<-\"WGCNA.module\"\n\n#为sample和基因的分组设置颜色\n#module的名字作为module的颜色\n#set colors for grouping of sample and gene\n#the name of the module is used as the color of the module\nmodule.name<-names(table(df.exp$module))\nnames(module.name)<-module.name\n\nann_colors = list(\n  treatment = c(notx = \"black\", KLA = \"white\"),#给两种处理设置颜色 set colors for both treatments\n  type = c(BALB = \"orange\", C57 = \"#007C46\", NOD = \"#00D0D1\", PWK = \"#333D7E\", SPRET = \"#A25BAA\"),\n  WGCNA.module = module.name\n)\n\n#画heatmap\n#draw heatmap\npheatmap(df.exp[,3:22],cellwidth = 12, cellheight = 0.2, fontsize = 8,\n         scale=\"row\", #为基因做scale scale for Genes\n         cluster_rows=F,cluster_cols=F,#不聚类 not clustered\n         color = colorRampPalette(c(\"#00A9E0\", \"white\", \"firebrick3\"))(50),\n         show_colnames=F,show_rownames =F,\n         annotation_col = annotation_col,\n         annotation_row = annotation_row,\n         annotation_colors = ann_colors,\n         border_color = \"NA\",\n         filename = \"heatmap.pdf\")\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa17WGCNA_heatmap_FigureYa17WGCNA_heatmap",
      "title": "FigureYa17WGCNA_heatmap/FigureYa17WGCNA_heatmap.html",
      "html": "FigureYa17WGCNA_heatmap/FigureYa17WGCNA_heatmap.html",
      "text": "texts/main_FigureYa17WGCNA_heatmap_FigureYa17WGCNA_heatmap.txt",
      "folder": "FigureYa17WGCNA_heatmap",
      "thumb": "gallery_compress/FigureYa17WGCNA_heatmap.webp"
    },
    "word_count": 453,
    "lines_count": 125,
    "title": "FigureYa17 WGCNA_heatmap",
    "description": "Requirement description 用R代码画出paper里WGCNA module的heatmap Draw the heatmap of the WGCNA module in paper using R code",
    "input_data_types": [
      "临床数据"
    ],
    "output_types": [
      "热图",
      "统计表格"
    ],
    "technical_methods": [
      "聚类分析"
    ],
    "biology_areas": [
      "药物研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "annotation_col",
      "header",
      "notx",
      "cluster_cols",
      "order",
      "cellwidth",
      "annotation_row",
      "decreasing",
      "type",
      "BALB"
    ]
  },
  {
    "id": "main_FigureYa5bubbles_FigureYa5bubbles",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa5bubbles_FigureYa5bubbles.txt",
    "content": "FigureYa5 bubbles\nFigureYa5 bubbles\nAuthor(s)\n: Dekang Lv; Ying Ge, Yijing Chen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n想模仿出2016年XieWei老师那篇Nature的泡泡图。 I want to imitate the\nbubble chart of Nature by Professor Xie Wei in 2016.\n出自\nhttp://dx.doi.org/10.1038/nature18606\nfrom\nhttp://dx.doi.org/10.1038/nature18606\n使用场景\nUsage scenario\n同时展示pvalue和表达量，例如：\n场景一、展示motif的pvalue和motif对应的转录因子的表达量，就能看出哪个转录因子在哪个group里富集且表达量高，预示着它对细胞状态的改变（例如细胞分化、转移、应激）起关键调控作用。\n场景二、做基因功能富集分析时，展示富集的通路qvalue和基因数量或geneRatio。\nShow both p-value and expression quantity simultaneously, for\nexample:\nScenario 1, showing the p-value of the motif and the expression of\nthe corresponding transcription factor of the motif, one can see which\ntranscription factor is enriched and highly expressed in which group,\npredicting that it plays a key regulatory role in the alteration of the\ncellular state (e.g., cell differentiation, metastasis, and stress).\nScenario 2: When doing gene function enrichment analysis, display the\nq-value of the enriched pathway and the number of genes or\ngeneRatio.\n输入数据\nInput data\n第一种：\n把自己的数据整理成easy_input.txt的格式，就可以跳过“输入数据的格式化”，直接进入“开始画图”。第一列是基因名，后面几列依次是各个sample里motif的pvalue，然后是motif的名字，后面是FPKM值。\n第二种：\nmotif的pvalue，用homer找motif，产生knownResults.txt，其中包含了在peak（目标基因组区域）中富集的已知motif。一共10个sample，分别保存在10个文件夹里。\nRNA-seq表达值，在终端里运行下面两行代码，下载并解压缩FPKM：\nwget\nftp://ftp.ncbi.nlm.nih.gov/geo/series/GSE66nnn/GSE66582/suppl/GSE66582_stage_FPKM.txt.gz\ngunzip GSE66582_stage_FPKM.txt.gz\n需要对输入数据进行格式化。\nThe first:\nOrganize your data into easy_input.txt format, you can skip\n“Formatting input data” and go directly to “Start drawing”. The first\ncolumn is the gene name, followed by the p-value of the motif in each\nsample, then the name of the motif, followed by the FPKM value.\nThe second:\nThe p-value of motifs, using homer to find motifs, produces\nknownResults.txt, which contains known motifs enriched in the peak\n(target genomic region). There are 10 samples in total, which are saved\nin 10 folders respectively.\nRNA-seq expression values, run the following two lines of code in a\nterminal, download and extract FPKM:\nwget\nftp://ftp.ncbi.nlm.nih.gov/geo/series/GSE66nnn/GSE66582/suppl/GSE66582_stage_FPKM.txt.gz\ngunzip GSE66582_stage_FPKM.txt.gz\nThe input data needs to be formatted.\n输入数据的格式化\nFormatting input data\nsource(\"install_dependencies.R\")\n开始画图\nStart drawing\n你可以把自己的数据整理成easy_input.txt这样的格式，就可以跳过上面调整格式的步骤。\n第一列是基因名，后面几列依次是各个sample里motif的pvalue，然后是motif的名字，后面是FPKM值。\nYou can organize your data into a format like easy_input.txt so you\ncan skip the formatting adjustment steps mentioned above.\nThe first column is the gene name, the following columns are the\npvalue of the motif in each sample, followed by the name of the motif,\nfollowed by the FPKM value.\nmergefpkm<-read.table(\"easy_input.txt\",header = T,as.is = 1)\nhead(mergefpkm)\nm5[m5$`-logP`>500,]$`-logP`<-500\nquantile(m5$`-logP`,probs = c(0:10)/10)\nm5[m5$`-logP`<10,]$`-logP`<-10\nquantile(m5$`-logP`,probs = c(0:10)/10)\nquantile(m5$FPKM,probs = c(0:10)/10)\nm5[m5$FPKM>20,]$FPKM<-20\nquantile(m5$FPKM,probs = c(0:10)/10)\n#filtered_motifs.pdf，按照paper的描述筛选出来的motif\n#filtered_motifs.pdf, filtered motifs according to the paper's description\np1<-ggplot(m5,aes(type,id,size=`-logP`))+\n  geom_point(shape=21,aes(fill=FPKM),position =position_dodge(0))+\n  theme_minimal()+xlab(NULL)+ylab(NULL)+\n  scale_size_continuous(range=c(1,8))+\n  scale_fill_gradientn(colours=c(\"#2381B3\",\"#F0E366\"),guide=\"legend\")+\n  theme(legend.position = \"bottom\",legend.box = \"vertical\",panel.grid.major =element_blank() )\nggsave(file=\"filtered_motifs.pdf\",height=18,width = 9)\n\n#filtered_genes.pdf，上述motif对应的转录因子\n#filtered_genes.pdf, transcription factors corresponding to the above motifs\np2<-ggplot(m5,aes(type,id,size=`-logP`))+\n  geom_point(shape=21,aes(fill=FPKM),position =position_dodge(0))+\n  theme_minimal()+xlab(NULL)+ylab(NULL)+\n  scale_size_continuous(range=c(1,8))+\n  scale_fill_gradientn(colours=c(\"#2381B3\",\"#F0E366\"),guide=\"legend\")+\n  theme(legend.position = \"bottom\",legend.box = \"vertical\",panel.grid.major =element_blank(),legend.margin=margin(t= 0, unit='cm'),legend.spacing = unit(0,\"in\"))+\n  scale_size_continuous(range=c(0,10))+\n  scale_y_discrete(labels=m5$gene)\nggsave(file=\"filtered_genes.pdf\",height=20,width = 4)\n输出的图\nOutput graphs\n查看filtered_motifs.pdf，是按照paper的描述筛选出来的motif；\n查看filtered_genes.pdf，是上述motif对应的转录因子。\n可以看出，比paper的图多出了很多转录因子。而且同一转录因子对应多个motif，paper里的只出现一个motif，作者是怎么处理的呢？\nCheck filtered_motifs.pdf, which contains motifs filtered according\nto the description in the paper;\nCheck the filtered_genes.pdf, which shows the transcription factors\ncorresponding to the aforementioned motif.\nIt can be observed that there are significantly more transcription\nfactors compared to the paper’s diagram. Additionally, the same\ntranscription factor corresponds to multiple motifs, whereas only one\nmotif is shown in the paper. How did the author address this?\npaper作者Jingyi答复：\nReply by paper author Jingyi:\n我认为你有更多motif的原因是我们使用了不同版本的motif数据库。我在2016年的论文中使用的是一个旧版本，其中包含的motif相对较少。\n如果一个基因有多个富集值，我会选择最高的富集值赋值给该基因。\nI think the reason why you have more motif is the different version\nof motif database we are using. The one I used in 2016 paper was an old\none with relatively less motif included.\nIf one gene has multiple enrichment value, I choose the highest\nenrichment value to assign to that gene.\n为了模仿出原版的效果，我们把paper里出现的转录因子对应的数据提取出来，重新画图\nTo imitate the effect of the original version, we extracted the data\ncorresponding to the transcription factors mentioned in the paper and\nredrew the graphs.\nggsave(file=\"paper_gene.pdf\",height=8.4,width = 3.2)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa5bubbles_FigureYa5bubbles",
      "title": "FigureYa5bubbles/FigureYa5bubbles.html",
      "html": "FigureYa5bubbles/FigureYa5bubbles.html",
      "text": "texts/main_FigureYa5bubbles_FigureYa5bubbles.txt",
      "folder": "FigureYa5bubbles",
      "thumb": "gallery_compress/FigureYa5bubbles.webp"
    },
    "word_count": 597,
    "lines_count": 134,
    "title": "FigureYa5 bubbles",
    "description": "Requirement description 想模仿出2016年XieWei老师那篇Nature的泡泡图。 I want to imitate the bubble chart of Nature by Professor Xie Wei in 2016.",
    "input_data_types": [
      "DNA-seq"
    ],
    "output_types": [
      "统计表格"
    ],
    "technical_methods": [
      "通路分析",
      "motif分析"
    ],
    "biology_areas": [],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "header",
      "guide",
      "width",
      "pvalue",
      "colours",
      "labels",
      "major",
      "unit",
      "box",
      "margin"
    ]
  },
  {
    "id": "main_FigureYa71ssGSEA_update_FigureYa71ssGSEA_update",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa71ssGSEA_update_FigureYa71ssGSEA_update.txt",
    "content": "FigureYa71ssGSEA_update\nFigureYa71ssGSEA_update\nRongfang Shen, Taojun Ye\n2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n输入TCGA数据，用原文的方法计算，原图复现。\nRequirement Description\nInput TCGA data and compute it using the method of the original text,\nreproduced in the original figure.\n出自\nhttps://doi.org/10.3389/fimmu.2018.01578\nfrom\nhttps://doi.org/10.3389/fimmu.2018.01578\n应用场景\n关于量化浸润免疫细胞，2018年发表在Cancer Immunol\nImmunother中的一篇综述概况了目前所用的几种方法：\nQuantifying\ntumor-infiltrating immune cells from transcriptomics data\n。\nssGSEA量化免疫细胞浸润最大的一个优点就是自己可以定制量化免疫浸润细胞种类。像MCPcounter只能量化10种免疫细胞，cibersort量化22种细胞，但是目前平台只限于用在芯片数据，虽然很多RNA-seq数据也直接用了。\nssGSEA只要你有marker\ngenes就可以量化。\n注意：\n量化出来的结果是不可以跨数据比较的，就跟转录组的批次效应一样。\n目前公认并且用的最多的免疫细胞marker就是2013年发表在Immunity上的\nSpatiotemporalDynamicsof\nIntratumoralImmuneCells Reveal the Immune Landscape in Human Cancer\n所提供的免疫细胞marker genes（Table\nS1），能提取到24种免疫细胞信息。下文用的是这24种免疫细胞。\n例文提取了27种免疫细胞，联系原作者能获得27种免疫细胞表面marker\ngenes。输入原作者提供的这些marker\ngenes来跑这套代码，结果基本同原文一致，可以很好的分为3类。\nApplication Scenarios\nWith regard to quantifying infiltrating immune cells, a 2018 review\npublished in Cancer Immunol Immunother provides an overview of several\nmethods currently used:\nQuantifying\ntumor-infiltrating immune cells from transcriptomics data\n.\nOne of the biggest advantages of ssGSEA for quantifying immune cell\ninfiltration is that one can customize the quantification of immune\ninfiltrating cell types. Like MCPcounter can only quantify 10 types of\nimmune cells, cibersort quantifies 22 types of cells, but currently the\nplatform is limited to microarray data, although many RNA-seq data are\nalso used directly.\nssGSEA can quantify as long as you have marker genes.\nNote:\nThe results from quantification are not\ncomparable across data, just like the batch effect on the\ntranscriptome.\nThe currently recognized and most used immune cell marker is\n[SpatiotemporalDynamicsof IntratumoralImmuneCells Reveal the Immune\nLandscape in Human Cancer] published in Immunity in 2013 (\nhttps://linkinghub.elsevier.com/retrieve/pii/S1074-7613(13)00437-8\n)\nThe immune cell marker genes (Table S1) provided by\nhttps://linkinghub.elsevier.com/retrieve/pii/S1074-7613(13)00437-8\n)\nwere able to extract information on 24 immune cells. These 24 immune\ncells are used in the following text.\nThe example paper extracted 27 kinds of immune cells, contacting the\noriginal author can get 27 kinds of immune cell surface marker genes.\ninput these marker genes provided by the original author to run this set\nof code, the result is basically the same as the original article, and\nit can be well categorized into 3 classes.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\n# 加载生物信息学分析所需的R包 / Load R packages for bioinformatics analysis\nlibrary(GSVA)          # 基因集变异分析 / Gene Set Variation Analysis\nlibrary(org.Hs.eg.db)\nlibrary(TCGAbiolinks)   # TCGA数据下载与处理 / TCGA data download and processing\nlibrary(ComplexHeatmap) # 复杂热图绘制 / Complex heatmap visualization\nlibrary(dplyr)         # 数据操作与转换 / Data manipulation and transformation\nlibrary(stringr)       # 字符串处理 / String manipulation\nlibrary(rtracklayer)   # 基因组数据交互 / Genomic data interoperability\nlibrary(SummarizedExperiment) # 基因组数据容器 / Genomic data container\nlibrary(clusterProfiler) # 聚类分析与可视化 / Cluster profiling and visualization\nlibrary(RColorBrewer)  # 颜色调色板 / Color palettes\nlibrary(maftools)      # MAF文件分析与可视化 / MAF file analysis and visualization\nlibrary(circlize)      # 环形可视化 / Circular visualization\nlibrary(matrixStats)   # 矩阵统计运算 / Matrix statistical operations\nlibrary(GetoptLong)    # 字符串插值 / String interpolation\nlibrary(GenomicRanges) # 基因组范围操作 / Genomic ranges manipulation\n\n# 设置系统环境参数 / Set system environment parameters\nSys.setenv(LANGUAGE = \"en\")  # 强制显示英文报错信息 / Force English error messages\noptions(stringsAsFactors = FALSE)  # 防止字符自动转为因子 / Prevent automatic conversion of strings to factors\n输入数据预处理\n用ssGSEA量化免疫浸润，需要两个输入数据：\neasy_input_immunity.rdata，24种免疫细胞marker genes的ENTREZ\nID，保存为list。来源：\n2013\nImmunity那篇文章的Table S1\n，手动整理成csv格式，并用GPL96（HG-U133A\nAffymetrix platform）按照探针得到gene\nsymbol，文章有提到这批数据是从这个芯片平台得到的。\neasy_input_expr.csv，基因表达矩阵，每行一个基因，每列一个sample。第一列基因ID跟easy_input_immunity.rdata里的基因ID一致，此处都用ENTREZ\nID。\n如果你已经准备好了这两个文件，就可以直接进入“用ssGSEA来量化浸润水平”。\n下面带你获得这两个输入文件：\nInput data preprocessing\nQuantifying immune infiltration with ssGSEA requires two input\ndata:\neasy_input_immunity.rdata, ENTREZ IDs of 24 immune cell marker\ngenes, saved as a list. source:\nTable\nS1 of the 2013 Immunity article\n, manually organized into csv format,\nand used GPL96 (HG-U133A Affymetrix platform) to get the gene symbol,\nthe article has mentioned that this batch of data was obtained from this\nchip platform.\neasy_input_expr.csv, gene expression matrix, one gene per row,\none sample per column, the first column gene ID is the same as the gene\nID in easy_input_immunity.rdata, and ENTREZ ID is used here.\nIf you have these two files ready, you can go directly to\n“Quantifying infiltration levels with ssGSEA”.\nThe following takes you to the two input files:\n免疫细胞marker genes\n这步获得的easy_input_immunity.rdata里面是各种免疫细胞marker genes\nlist，可重复使用。\nImmune cell marker genes\nThe easy_input_immunity.rdata obtained in this step contains a list\nof various immune cell marker genes that can be reused.\n# 读取免疫细胞标记基因文件 / Read immune cell marker gene file\n# 输入：包含CellType和ENTREZ_GENE_ID列的CSV文件 / Input: CSV file with CellType and ENTREZ_GENE_ID columns\nimmunity <- read.csv(\"immunitygene.csv\", header = TRUE)  # header=T表示第一行是列名 / header=T means first row contains column names\n\n# 数据清洗 - 移除非免疫细胞类型 / Data cleaning - Remove non-immune cell types\n# 排除血管、正常黏膜等非目标细胞类型 / Exclude non-target cell types like blood vessels, normal mucosa etc.\nimmunity <- immunity[!immunity$CellType %in% \n                     c(\"Blood vessels\", \"Normal mucosa\", \n                       \"SW480 cancer cells\", \"Lymph vessels\"), ]\n\n# 数据转换 - 转为细胞类型分组的基因列表 / Data transformation - Convert to cell-type grouped gene list\n# 步骤1：按CellType拆分数据框 / Step 1: Split dataframe by CellType\n# 步骤2：提取每个细胞类型的Entrez基因ID / Step 2: Extract Entrez gene IDs for each cell type\n# 注意：原始数据来自Affymetrix芯片平台，此处选用Entrez_ID保持一致性 / Note: Original data from Affymetrix platform, using Entrez_ID for consistency\nimmunity <- immunity %>% \n  split(., .$CellType) %>%  # 按CellType分组 / Group by CellType\n  lapply(., function(x)(x$ENTREZ_GENE_ID))  # 提取每组的基因ID / Extract gene IDs per group\n\n# 去除重复基因 / Remove duplicate genes\nimmunity <- lapply(immunity, unique)  # 对每个细胞类型的基因列表去重 / Deduplicate gene lists per cell type\n\n# 保存处理后的数据 / Save processed data\n# 保存为R原生格式便于快速重加载 / Save as R native format for fast reloading\nsave(immunity, file = \"easy_input_immunity.rdata\")  # 输出文件名包含\"easy_input\"提示简化后的数据 / Output filename contains \"easy_input\" indicating simplified data\n表达矩阵\nTCGA表达数据的获取方式：\n用TGCAbiolinks下载表达数据read\ncount，然后转成TPM，数据下载和转换的方法可参考FigureYa23count2TPM；第一列是ENTREZ\nID，其后每列一个sample。需要把gene_id换成gene symbol或ENTREZ\nID。GDC来源的TCGA数据用的是v22版本，从GENCODE\nhttps://www.gencodegenes.org/\n进去，点击下载v22版本gtf文件：\nftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_22/gencode.v22.annotation.gtf.gz\n或者下载所有癌症的TPM，提取感兴趣癌症的TPM，可参考FigureYa56immune_inflitrationV2。\n此处用TGCAbiolinks下载”TCGA-COAD”和”TCGA-READ”的基因表达矩阵，然后转成TPM，获得not_easy_input_expr.txt文件。\n如果你已经生成过gtf_v22.csv文件，就可以跳过下面这段。\nExpression matrix\nTCGA expression data acquisition method:\nUse TGCAbiolinks to download the expression data read count, and\nthen converted to TPM, the method of data download and conversion can be\nfound in FigureYa23count2TPM; the first column is ENTREZ ID, and each\nsubsequent column is one sample. need to replace gene_id with gene\nsymbol or ENTREZ ID. The TCGA data from the GDC source used version v22,\ngo in from GENCODE\nhttps://www.gencodegenes.org/\nand click to download the\nv22 gtf file: <\nftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_\nhuman/release_22/gencode.v22.annotation.gtf.gz>\nOr download the TPMs for all cancers and extract the TPMs for the\ncancer of interest, see FigureYa56immune_inflitrationV2.\nHere we use TGCAbiolinks to download the gene expression matrix of\n“TCGA-COAD” and “TCGA-READ”, and then convert it to TPM to get\nnot_easy_input_expr.txt file.\nIf you have already generated the gtf_v22.csv file, you can skip the\nfollowing paragraph.\n# 先获得protein_coding gene的gene_id跟gene symbol的对应关系\ngtf_v22 <- rtracklayer::import(\"gencode.v22.annotation.gtf\")\ngtf_v22 <- as.data.frame(gtf_v22)\ngtf_v22 <- dplyr::select(gtf_v22, c(\"gene_id\", \"gene_type\", \"gene_name\")) %>% \n  filter(., gene_type ==  \"protein_coding\") %>% \n  unique()\ngtf_v22 <- gtf_v22[!duplicated(gtf_v22), ]\n\n# 再加入ENTREZ ID，如果immunity.rdata里用的是gene symbol，就不需要运行下面这行\ngtf_v22 <- bitr(gtf_v22$gene_name, fromType = \"SYMBOL\", toType = \"ENTREZID\", OrgDb = \"org.Hs.eg.db\") %>%\n  merge(., gtf_v22, by.x = \"SYMBOL\", by.y = \"gene_name\") %>% \n  mutate(., gene_id = str_sub(gene_id, 1, 15))\n\n# 这步获得gtf_v22.csv文件，包含v22版本protein_coding gene的gene_id、gene symbol和ENTREZ ID的对应关系，可重复使用。\nwrite.csv(gtf_v22, \"gtf_v22.csv\", quote = F, row.names = F)\n# 读取基因表达数据矩阵，行名为基因ID，列名为样本ID\n# 参数说明:\n# \"not_easy_input_expr.csv\" - 原始表达矩阵文件，需包含基因ID作为行名\n# Read gene expression data matrix with gene IDs as row names\n# Parameter description:\n# \"not_easy_input_expr.csv\" - Original expression matrix file with gene IDs as row names\ntcga_expr <- read.csv(\"not_easy_input_expr.csv\", header = T, stringsAsFactors = F, row.names = 1)\ntcga_expr[1:3,1:3]\n# 读取之前生成的基因ID映射表(含ENTREZID和gene_id)\n# Load pre-generated gene ID mapping table (contains ENTREZID and gene_id)\ngtf_v22 <- read.csv(\"gtf_v22.csv\")\n\n# 加载data.table包用于高效数据处理\n# Load data.table package for efficient data processing\nlibrary(data.table)\n# 将原始基因ID转换为ENTREZ ID并按ENTREZ ID合并重复基因(取中位数)\n# 注意：此步骤处理时间较长，建议在高性能环境运行\n# 参数说明:\n# by.x = 2 - 使用gtf_v22的第2列(gene_id)作为连接键\n# by.y = 0 - 使用tcga_expr的行名(基因ID)作为连接键\n# aggregate(.~ENTREZID, ., median) - 按ENTREZ ID分组并计算表达值中位数\n# Convert gene IDs to ENTREZ IDs and aggregate duplicate genes by median expression\n# Note: This step is time-consuming, recommend running on high-performance environment\n# Parameter description:\n# by.x = 2 - Use 2nd column (gene_id) of gtf_v22 as join key\n# by.y = 0 - Use row names (gene IDs) of tcga_expr as join key\n# aggregate(.~ENTREZID, ., median) - Group by ENTREZ ID and compute median expression\ntcga_expr <- merge(gtf_v22[, c(\"ENTREZID\", \"gene_id\")], tcga_expr, by.x = 2, by.y = 0) %>% .[, -1] %>% \n    aggregate(.~ENTREZID, ., median)  # This step may take a while\n\n# 设置ENTREZ ID为行名并移除冗余列\n# Set ENTREZ ID as row names and remove redundant columns\nrownames(tcga_expr) <- tcga_expr$ENTREZID\ntcga_expr <- tcga_expr[, -1]\nhead(tcga_expr)\n# 保存处理后的表达矩阵到文件，保留1位小数以减小文件大小\n# Save processed expression matrix to file with 1 decimal place to reduce file size\nwrite.csv(round(tcga_expr,1), \"easy_input_expr.csv\", quote = F)\n用ssGSEA来量化浸润水平\nQuantifying infiltration levels with ssGSEA\n# 读取TCGA基因表达矩阵 / Load TCGA gene expression matrix\n# 注意：第一列作为行名（基因名） / Note: First column as row names (gene names)\ntcga_expr <- read.csv(\"easy_input_expr.csv\", row.names = 1)  \n\n# 检查数据前3行前2列 / Check first 3 rows and 2 columns\ntcga_expr[1:3, 1:2]  # 验证数据读取是否正确 / Verify data loading\n# 加载预处理的免疫基因集 / Load pre-processed immune gene sets\n(load(\"easy_input_immunity.rdata\"))  # 括号使加载结果自动打印 / Parentheses auto-print loaded objects\nimmunity[1]  # 查看第一个免疫细胞类型的基因 / View genes of first immune cell type\n# 执行ssGSEA分析 / Perform ssGSEA analysis\n# 步骤：1.转置矩阵 2.转换为矩阵格式 3.使用ssGSEA方法计算富集分数\n# Steps: 1.Transpose matrix 2.Convert to matrix 3.Calculate enrichment scores with ssGSEA\n# 将所有基因 ID 转为字符型\nimmunity <- lapply(immunity, as.character)\n\nparams <- ssgseaParam(exprData = as.matrix(tcga_expr), geneSets = immunity)\ntcga_gsva <- as.data.frame(t(gsva(params)))\n# 检查结果数据结构 / Check result structure\nstr(tcga_gsva)  # 显示数据维度及前几行 / Show dimensions and first rows\n# 保存ssGSEA结果 / Save ssGSEA results\nwrite.csv(\n  tcga_gsva, \n  \"ssGSEA_output.csv\", \n  quote = FALSE,  # 不添加引号 / No quotes around values\n  row.names = TRUE  # 保留行名（样本ID） / Keep row names (sample IDs)\n)\n\n# 可视化结果 / Visualize results\nlibrary(pheatmap)  # 加载热图绘制包 / Load heatmap package\n# 绘制标准化热图 / Draw standardized heatmap\npheatmap(\n  t(tcga_gsva),  # 需要转置使样本为列 / Transpose to show samples as columns\n  scale = \"row\",  # 行标准化（Z-score） / Row standardization (Z-score)\n  show_colnames = FALSE,  # 隐藏样本名 / Hide sample names\n  color = colorRampPalette(\n    c(\"navy\", \"white\", \"firebrick3\")  # 蓝-白-红渐变色 / Blue-white-red gradient\n  )(50))  # 生成50个颜色梯度 / Generate 50 color gradients\n如果你只想计算免疫浸润，那么到这里就结束了。\n如果你想把免疫浸润跟突变、临床信息结合起来看，复现例文的原图，就需要运行下面这部分：\nIf you just want to calculate the immune infiltration, then that’s\nthe end of it here.\nIf you want to look at the immune infiltration in conjunction with\nthe mutation and clinical information and reproduce the original graph\nof the example text, you need to run the following section:\n原图复现\n下面用TCGAbiolink从GDC下载数据，需要找个网络好点的地方。\nOriginal image reproduction\nHere’s how to download the data from GDC using TCGAbiolink, you need\nto find a place with a good network.\n下载突变信息\n变异类型归为WT和Mutant，参考\nhttps://bioconductor.org/packages/devel/bioc/vignettes/ELMER/inst/doc/pipe.html\nDownload mutation information\nMutation types are categorized as WT and Mutant, refer to\nhttps://bioconductor.org/packages/devel/bioc/vignettes/ELMER/inst/doc/pipe.html\n# 定义目标基因和突变类型 / Define target genes and mutation types\ntargetMut <- c(\"TP53\", \"KRAS\", \"BRAF\", \"EGFR\")  # 需要提取的癌基因 / Oncogenes to extract\nnonsilentmutation <- c(\"Frame_Shift_Del\", \"Frame_Shift_Ins\", \"Missense_Mutation\", \n                      \"Nonsense_Mutation\", \"Splice_Site\", \"In_Frame_Del\", \n                      \"In_Frame_Ins\", \"Translation_Start_Site\", \"Nonstop_Mutation\") \n# 注：Splice_Region突变通常影响非编码RNA / Note: Splice_Region affects ncRNA splicing\n\n# 获取TCGA突变数据 / Retrieve TCGA mutation data\n# 方法：使用varscan2流程获取COAD和READ数据 / Method: Using varscan2 pipeline for COAD and READ\n# 下载 MAF 文件（已整合多个 caller，如 varscan2、mutect2 等）\n# query <- GDCquery(\n#   project = \"TCGA-COAD\",\n#   data.category = \"Simple Nucleotide Variation\",\n#   data.type = \"Masked Somatic Mutation\",\n#   workflow.type = \"Aliquot Ensemble Somatic Variant Merging and Masking\"\n# )\n# # 下载数据\n# GDCdownload(query)\n# # 准备数据\n# coadmut <- GDCprepare(query)\n#\n# query <- GDCquery(\n#   project = \"TCGA-READ\",\n#   data.category = \"Simple Nucleotide Variation\",\n#   data.type = \"Masked Somatic Mutation\",\n#   workflow.type = \"Aliquot Ensemble Somatic Variant Merging and Masking\"\n# )\n# # 下载数据\n# GDCdownload(query)\n# # 准备数据\n# readmut <- GDCprepare(query)\n\n# coadmut <- GDCquery_Maf(tumor = \"COAD\", pipelines = \"varscan2\")  # 结肠腺癌 / Colon adenocarcinoma\n# readmut <- GDCquery_Maf(tumor = \"READ\", pipelines = \"varscan2\")  # 直肠腺癌 / Rectal adenocarcinoma\nlibrary(readr)\ncoadmut <- read_tsv(\"TCGA-COAD.somaticmutation_wxs.tsv.gz\")\nreadmut <- read_tsv(\"TCGA-READ.somaticmutation_wxs.tsv.gz\")\n# 验证并合并数据 / Validate and merge data\nall(colnames(coadmut) == colnames(readmut))  # 确认列名一致 / Confirm identical column names\ncrcmut <- rbind(coadmut, readmut)  # 合并结直肠癌数据 / Merge colorectal cancer data\n\n# 处理样本ID / Process sample IDs\n# 提取前12位作为样本ID（TCGA标准） / Extract first 12 chars as TCGA sample ID\ncrcmut <- data.frame(sample = str_sub(crcmut$Tumor_Sample_Barcode, 1, 12), crcmut)  \nall_mutSample <- unique(crcmut$sample)  # 获取所有突变样本 / Get all mutated samples\n\n# 数据过滤 - 保留非同义突变 / Data filtering - Keep nonsilent mutations\ntable(crcmut$Variant_Classification)  # 查看突变类型分布 / View mutation type distribution\ncrcmut <- crcmut[crcmut$Variant_Classification %in% nonsilentmutation, ]  # 过滤沉默突变 / Filter silent mutations\n\n# 提取目标基因突变 / Extract target gene mutations\ncrc_mut_gene <- crcmut[crcmut$Hugo_Symbol %in% targetMut, ]  # 筛选目标基因 / Filter target genes\n\n# 定义突变组和野生型组 / Define mutant and wild-type groups\n# TP53突变分析 / TP53 mutation analysis\nTP53mutSample <- unique(crc_mut_gene[crc_mut_gene$Hugo_Symbol == \"TP53\", \"sample\"])  \nTP53wildSample <- setdiff(all_mutSample, TP53mutSample)  \n# 逻辑：存在于数据但无突变的样本为野生型 / Logic: Samples in data without mutation are wild-type\n# 注：不在数据中的样本视为NA（未检测） / Note: Samples not in data are considered NA (not tested)\n\n# 其他基因相同处理 / Same processing for other genes\nKRASmutSample <- unique(crc_mut_gene[crc_mut_gene$Hugo_Symbol == \"KRAS\", \"sample\"])\nKRASwildSample <- setdiff(all_mutSample, KRASmutSample)\n\nBRAFmutSample <- unique(crc_mut_gene[crc_mut_gene$Hugo_Symbol == \"BRAF\", \"sample\"])\nBRAFwildSample <- setdiff(all_mutSample, BRAFmutSample)\n\nEGFRmutSample <- unique(crc_mut_gene[crc_mut_gene$Hugo_Symbol == \"EGFR\", \"sample\"])\nEGFRwildSample <- setdiff(all_mutSample, EGFRmutSample)\n下载msi临床信息\nDownload msi clinical information\n# # 获取TCGA-COAD项目的MSI数据 / Retrieve MSI data for TCGA-COAD project\n# msiquery1 <- GDCquery(\n#   project = \"TCGA-COAD\",       # 结肠腺癌项目 / Colon adenocarcinoma project\n#   data.category = \"Other\",     # 其他数据类型 / Other data category\n#   legacy = TRUE,               # 使用旧版数据 / Use legacy data\n#   access = \"open\",             # 公开访问数据 / Open access data\n#   data.type = \"Auxiliary test\" # 辅助测试数据类型 / Auxiliary test data type\n# )\n# \n# # 下载查询到的数据 / Download the queried data\n# GDCdownload(msiquery1)\n# \n# # 提取并整理MSI结果 / Extract and organize MSI results\n# coad_msi_results <- GDCprepare_clinic(\n#   query = msiquery1,           # 查询对象 / Query object\n#   clinical.info = \"msi\"        # 提取MSI信息 / Extract MSI information\n# )\n# \n# # 获取TCGA-READ项目的MSI数据 / Retrieve MSI data for TCGA-READ project\n# msiquery2 <- GDCquery(\n#   project = \"TCGA-READ\",       # 直肠腺癌项目 / Rectal adenocarcinoma project\n#   data.category = \"Other\",     \n#   legacy = TRUE,\n#   access = \"open\",\n#   data.type = \"Auxiliary test\"\n# )\n# \n# # 下载查询到的数据 / Download the queried data\n# GDCdownload(msiquery2)\n# \n# # 提取并整理MSI结果 / Extract and organize MSI results\n# read_msi_results <- GDCprepare_clinic(\n#   query = msiquery2,\n#   clinical.info = \"msi\"\n# )\n\nclinical_data <- read.delim(\"TCGA.COADREAD.sampleMap_COADREAD_clinicalMatrix\", \n                            stringsAsFactors = FALSE, check.names = FALSE)\nmsi_results <- data.frame(\n  sample = clinical_data[,1],\n  MSI = clinical_data$MSI_updated_Oct62011\n)\n# # 合并两个癌症类型的数据 / Merge data from both cancer types\n# msi_results <- rbind(read_msi_results, coad_msi_results) %>%  # 行合并 / Row binding\n#   .[, c(1, 3)] %>%              # 选择第1列(样本ID)和第3列(MSI状态) / Select columns 1(sample ID) and 3(MSI status)\n#   setNames(c(\"sample\", \"MSI\"))  # 重命名列 / Rename columns\n下载其他临床信息\nDownload additional clinical information\n# # 获取TCGA-COAD临床数据 / Retrieve TCGA-COAD clinical data\n# coadclinical <- GDCquery(\n#   project = \"TCGA-COAD\",        # 结肠腺癌项目 / Colon adenocarcinoma project\n#   data.category = \"Clinical\",   # 临床数据类型 / Clinical data category\n#   file.type = \"xml\"             # 文件格式为XML / XML file format\n# )\n# \n# # 下载临床数据 / Download clinical data\n# GDCdownload(coadclinical)\n# \n# # 提取并整理患者临床信息 / Extract and organize patient clinical info\n# coadclinical <- GDCprepare_clinic(\n#   query = coadclinical,         # 查询对象 / Query object\n#   clinical.info = \"patient\"     # 患者级别临床信息 / Patient-level clinical data\n# )\n# \n# # 获取TCGA-READ临床数据 / Retrieve TCGA-READ clinical data\n# readclinical <- GDCquery(\n#   project = \"TCGA-READ\",        # 直肠腺癌项目 / Rectal adenocarcinoma project\n#   data.category = \"Clinical\",\n#   file.type = \"xml\"\n# )\n# \n# # 下载临床数据 / Download clinical data\n# GDCdownload(readclinical)\n# \n# # 提取并整理患者临床信息 / Extract and organize patient clinical info\n# readclinical <- GDCprepare_clinic(\n#   query = readclinical,\n#   clinical.info = \"patient\"\n# )\n# \n# # 验证列名一致性 / Verify column name consistency\n# # 确保两个数据框结构相同 / Ensure identical dataframe structures\n# all(colnames(readclinical) == colnames(coadclinical))  \n# \n# # 合并临床数据 / Merge clinical data\n# clinical <- rbind(coadclinical, readclinical)  # 行合并 / Row binding\n组合所需要的临床信息\nClinical information required for the portfolio\n# 选择关键临床变量 / Select key clinical variables\ntargetAnno <- clinical_data[, c(\n  \"sampleID\",            # 患者ID / Patient ID\n  \"pathologic_stage\",   # 病理分期 / Pathologic stage\n  \"gender\",                        # 性别 / Gender\n  \"vital_status\",                   # 生存状态 / Vital status\n  \"anatomic_neoplasm_subdivision\",  # 肿瘤解剖位置 / Tumor anatomic location\n  \"colon_polyps_present\"           # 是否存在结肠息肉 / Presence of colon polyps\n)]\n\n# 查看肿瘤位置分布 / Check tumor location distribution\ntable(targetAnno$anatomic_neoplasm_subdivision)\n# 划分左右半结肠 / Classify left/right colon cancer\n# 右侧：盲肠至横结肠 / Right: Cecum to Transverse Colon\n# 左侧：脾曲至直肠 / Left: Splenic Flexure to Rectum\ntargetAnno$tumor_site <- targetAnno$anatomic_neoplasm_subdivision %>% \n  str_replace(., \"(Cecum|Ascending Colon|Hepatic Flexure|Transverse Colon)\", \"right\") %>%\n  str_replace(., \"(Splenic Flexure|Descending Colon|Sigmoid Colon|Rectosigmoid Junction|Rectum)\", \"left\")\n\n# 合并MSI数据 / Merge MSI data\ntargetAnno <- merge(\n  targetAnno, \n  msi_results, \n  by.x = \"sampleID\",  # 临床数据中的患者ID / Patient ID in clinical data\n  by.y = \"sample\",               # MSI数据中的样本ID / Sample ID in MSI data\n  all.x = TRUE                   # 保留所有临床样本（左连接） / Keep all clinical samples (left join)\n)\n\n# 初始化突变状态列 / Initialize mutation status columns\ntargetAnno$TP53mut <- NA  # TP53突变状态 / TP53 mutation status\ntargetAnno$KRASmut <- NA  # KRAS突变状态 / KRAS mutation status\ntargetAnno$BRAFmut <- NA  # BRAF突变状态 / BRAF mutation status\ntargetAnno$EGFRmut <- NA  # EGFR突变状态 / EGFR mutation status\n\n# 标记TP53突变状态 / Annotate TP53 mutation status\ntargetAnno[targetAnno$bcr_patient_barcode %in% TP53mutSample, \"TP53mut\"] <- \"mutant\"     # 突变型 / Mutant\ntargetAnno[targetAnno$bcr_patient_barcode %in% TP53wildSample, \"TP53mut\"] <- \"wildtype\"  # 野生型 / Wild-type\n\n# 标记KRAS突变状态 / Annotate KRAS mutation status\ntargetAnno[targetAnno$bcr_patient_barcode %in% KRASmutSample, \"KRASmut\"] <- \"mutant\"\ntargetAnno[targetAnno$bcr_patient_barcode %in% KRASwildSample, \"KRASmut\"] <- \"wildtype\"\n\n# 标记BRAF突变状态 / Annotate BRAF mutation status\ntargetAnno[targetAnno$bcr_patient_barcode %in% BRAFmutSample, \"BRAFmut\"] <- \"mutant\"\ntargetAnno[targetAnno$bcr_patient_barcode %in% BRAFwildSample, \"BRAFmut\"] <- \"wildtype\"\n\n# 标记EGFR突变状态 / Annotate EGFR mutation status\ntargetAnno[targetAnno$bcr_patient_barcode %in% EGFRmutSample, \"EGFRmut\"] <- \"mutant\"\ntargetAnno[targetAnno$bcr_patient_barcode %in% EGFRwildSample, \"EGFRmut\"] <- \"wildtype\"\n\n# 查看数据摘要 / View data summary\nsummary(targetAnno)\n融合ssGSEA和临床表达数据\nFusing ssGSEA and clinical expression data\n# 读取ssGSEA免疫浸润分析结果 / Load ssGSEA immune infiltration results\ntcga_gsva <- read.csv(\"ssGSEA_output.csv\", row.names = 1)  # 第一列为行名(样本ID) / First column as row names (sample IDs)\n\n# 处理样本ID格式 / Process sample ID format\ntcga_gsva <- data.frame(\n  sample = str_sub(rownames(tcga_gsva), 1, 12),  # 提取前12位TCGA样本ID / Extract first 12 chars of TCGA ID\n  barcode = rownames(tcga_gsva),                 # 保留完整条形码 / Keep full barcode\n  tcga_gsva                                     # 保留原始数据 / Keep original data\n) \n# 统一ID格式（替换点号为连字符） / Standardize ID format (replace dots with hyphens)\ntcga_gsva$sample <- str_replace_all(tcga_gsva$sample, \"\\\\.\", \"-\")\n\n# 合并免疫特征与临床注释数据 / Merge immune features with clinical annotations\nlibrary(data.table)  # 加载高效数据处理包 / Load efficient data processing package\nheatmapinput <- unique(merge(\n  tcga_gsva, \n  targetAnno, \n  by.x = \"sample\",                      # 免疫数据中的样本ID / Sample ID in immune data\n  by.y = \"sampleID\",         # 临床数据中的患者ID / Patient ID in clinical data\n  all.x = TRUE                          # 保留所有免疫样本（左连接） / Keep all immune samples (left join)\n))\n\n# 设置行名 / Set row names\nrownames(heatmapinput) <- heatmapinput$barcode  # 使用完整条形码作为行名 / Use full barcode as row names\n\n# 检查数据结构 / Check data structure\nsummary(heatmapinput)  # 显示各变量摘要 / Show variable summaries\n# 保存热图输入数据 / Save heatmap input data\nwrite.csv(heatmapinput, \"heatmapinput.csv\")  # CSV格式便于检查 / CSV format for inspection\n开始画图\n用complexheatmap画图。complexheatmap的参数众多，有兴趣了解的详情\nhttps://bioconductor.org/packages/release/bioc/html/ComplexHeatmap.html\nStart drawing the map\nDrawing with complexheatmap. complexheatmap has numerous parameters,\ninterested in knowing more details\nhttps://bioconductor.org/packages/release/bioc/html/ComplexHeatmap.html\n# 读取预处理的热图输入数据 / Load preprocessed heatmap input data\nheatmapinput <- read.csv(\"heatmapinput.csv\", row.names = 1)\n\n# 准备ssGSEA矩阵数据 / Prepare ssGSEA matrix data\nml <- heatmapinput[, c(3:26)]  # 选择免疫细胞浸润分数列 / Select immune infiltration score columns\nml <- as.data.frame(t(apply(ml, 2, scale)))  # 按列标准化（Z-score） / Column-wise standardization\ncolnames(ml) <- rownames(heatmapinput)  # 设置列名为样本ID / Set column names as sample IDs\n\n# 设置热图颜色映射 / Set heatmap color mapping\ncol_fun <- colorRamp2(\n  c(-5, 0, 5),  # 定义颜色断点 / Define color breaks\n  c(\"#377EB8\", \"white\", \"#E41A1C\")  # 蓝-白-红渐变 / Blue-white-red gradient\n)\n\n### 第一步：样本聚类分组 / Step 1: Sample clustering and grouping\nh1 <- Heatmap(\n  ml,\n  cluster_rows = TRUE, \n  cluster_columns = TRUE,\n  clustering_method_columns = \"ward.D2\",  # 层次聚类方法 / Hierarchical clustering method\n  show_row_names = TRUE, \n  show_column_names = FALSE,\n  clustering_distance_columns = \"euclidean\",\n  clustering_distance_rows = \"euclidean\",\n  clustering_method_rows = \"ward.D2\"\n)\n# 获取聚类树并切割 / Extract dendrogram and cut into groups\ntree <- column_dend(h1)  # 提取列聚类树 / Extract column dendrogram\nind <- cutree(as.hclust(tree), k = 2)[order.dendrogram(tree)]  # 分为2类 / Cut into 2 clusters\ntable(ind)  # 查看分组情况 / Check cluster sizes\n# 将免疫浸润分组信息添加到数据中 / Add immune infiltration groups to metadata\nheatmapinput$Immune_infiltration <- ind[heatmapinput$barcode]\nheatmapinput$Immune_infiltration <- str_replace(heatmapinput$Immune_infiltration, \"1\", \"Low infiltration\")\nheatmapinput$Immune_infiltration <- str_replace(heatmapinput$Immune_infiltration, \"2\", \"High infiltration\")\n\n### 第二步：准备临床注释数据 / Step 2: Prepare clinical annotations\nImmune_infiltration <- heatmapinput[, \"Immune_infiltration\"]\nTumor_site <- heatmapinput[, \"tumor_site\"] \nTP53_mutation <- heatmapinput[, \"TP53mut\"]\nKRAS_mutation <- heatmapinput[, \"KRASmut\"]\nBRAF_mutation <- heatmapinput[, \"BRAFmut\"]\nEGFR_mutation <- heatmapinput[, \"EGFRmut\"]\nGender <- heatmapinput[, \"gender\"]\nMSI <- heatmapinput[, \"MSI\"]\nPolyps <- heatmapinput[, \"colon_polyps_present\"]\nSurvival <- heatmapinput[, \"vital_status\"]  # 注：建议使用生存时间+状态更准确 / Note: Suggest using survival time + status\nAnatomic_location <- heatmapinput[, \"anatomic_neoplasm_subdivision\"]\nStage <- heatmapinput[, \"pathologic_stage\"]\n\n### 第三步：创建复杂热图注释 / Step 3: Create complex heatmap annotations\nha = HeatmapAnnotation(\n  # 定义所有临床注释变量 / Define all clinical annotation variables\n  Immune_infiltration = Immune_infiltration,\n  Tumor_site = Tumor_site,\n  TP53_mutation = TP53_mutation,\n  KRAS_mutation = KRAS_mutation,\n  BRAF_mutation = BRAF_mutation,\n  EGFR_mutation = EGFR_mutation,\n  Gender = Gender,\n  MSI = MSI,\n  Polyps = Polyps,\n  Survival = Survival,\n  Anatomic_location = Anatomic_location,\n  Stage = Stage,\n  \n  # 可视化参数 / Visualization parameters\n  show_annotation_name = FALSE,  # 不显示注释名称 / Hide annotation names\n  col = list(\n    Immune_infiltration = c(\"High infiltration\" = \"#3FA538\", \"Low infiltration\" = \"#9FD29BFF\"),\n    Tumor_site = c(\"left\" = \"#E00115\", \"right\" = \"#5E84B6\"),\n    TP53_mutation = c(\"mutant\" = \"black\", \"wildtype\" = \"grey\"),\n    KRAS_mutation = c(\"mutant\" = \"black\", \"wildtype\" = \"grey\"),\n    BRAF_mutation = c(\"mutant\" = \"black\", \"wildtype\" = \"grey\"),\n    EGFR_mutation = c(\"mutant\" = \"black\", \"wildtype\" = \"grey\"),\n    Gender = c(\"MALE\" = \"#C4868E\", \"FEMALE\" = \"#97A8C7\"),\n    MSI = c(\"MSI-H\" = \"#E5554D\", \"MSI-L\" = \"#C4868E\", \"MSS\" = \"#AEB6CE\", \"Indeterminate\" = \"#2B3D44\"),\n    Polyps = c(\"YES\" = \"black\", \"NO\" = \"grey\"),\n    Survival = c(\"Alive\" = \"#3FA538\", \"Dead\" = \"#E00115\"),\n    Stage = c(\"Stage I\" = \"#B0B0FFFF\", \"Stage IA\" = \"#6060FFFF\", \n              \"Stage II\" = \"#B0FFB0FF\", \"Stage IIA\" = \"#95FF95FF\",\n              \"Stage IIB\" = \"#7AFF7AFF\", \"Stage IIC\" = \"#60FF60FF\",\n              \"Stage III\" = \"#F7E897FF\", \"Stage IIIA\" = \"#F9EF64FF\",\n              \"Stage IIIB\" = \"#FCF732FF\", \"Stage IIIC\" = \"#FFFF00FF\",\n              \"Stage IV\" = \"#FF6060FF\", \"Stage IVA\" = \"#FF3030FF\",\n              \"Stage IVB\" = \"#FF0000FF\")\n  ),\n  na_col = \"white\",  # NA值显示为白色 / NA values shown in white\n  annotation_height = unit(rep(5, 12), \"mm\"),  # 注释条高度 / Annotation bar height\n  \n  # 图例参数 / Legend parameters\n  annotation_legend_param = list(\n    Immune_infiltration = list(title = \"Immune infiltration\"),\n    Tumor_site = list(title = \"Tumor site\"),\n    TP53_mutation = list(title = \"TP53 mutation\"),\n    KRAS_mutation = list(title = \"KRAS mutation\"),\n    BRAF_mutation = list(title = \"BRAF mutation\"),\n    EGFR_mutation = list(title = \"EGFR mutation\"),\n    Gender = list(title = \"Gender\"),\n    MSI = list(title = \"MSI status\"),\n    Polyps = list(title = \"Polyps present\"),\n    Survival = list(title = \"Vital status\"),\n    Anatomic_location = list(title = \"Anatomic location\"),\n    Stage = list(title = \"Pathologic stage\")\n  )\n)\n\n### 第四步：绘制最终热图 / Step 4: Draw final heatmap\nht <- Heatmap(\n  ml, \n  col = col_fun, \n  name = \"Z-score\",  # 颜色图例标题 / Color legend title\n  cluster_rows = TRUE, \n  cluster_columns = TRUE,\n  show_row_names = TRUE, \n  show_column_names = FALSE,\n  top_annotation = ha,  # 顶部临床注释 / top clinical annotations\n  column_title = qq(\"TCGA CRC samples (n = @{ncol(ml)})\"),  # 动态标题 / Dynamic title\n  clustering_method_columns = \"ward.D2\",\n  clustering_distance_columns = \"euclidean\",\n  clustering_distance_rows = \"euclidean\",\n  clustering_method_rows = \"ward.D2\",\n  column_dend_height = unit(30, \"mm\")  # 聚类树高度 / Dendrogram height\n)\n# 设置PDF输出 / Set PDF output\npdf(\"ssGSEA.pdf\", width = 16, height = 12)  # 16英寸宽，12英寸高 / 16-inch width, 12-inch height\n\n# 绘制热图并调整图例位置 / Draw heatmap with adjusted legend position\ndraw(ht, \n     annotation_legend_side = \"left\",  # 注释图例放在左侧 / Annotation legend on left\n     heatmap_legend_side = \"left\")     # 热图图例放在左侧 / Heatmap legend on left\n\n### 第一部分：添加注释标题 / Part 1: Add annotation titles\nannotation_titles <- c(\n  Immune_infiltration = \"Immune infiltration\",\n  Tumor_site = \"Tumor site\",\n  TP53_mutation = \"TP53 mutation\",\n  KRAS_mutation = \"KRAS mutation\",\n  BRAF_mutation = \"BRAF mutation\",\n  EGFR_mutation = \"EGFR mutation\",\n  Gender = \"Gender\",\n  MSI = \"MSI status\",\n  Polyps = \"Polyps\",\n  Survival = \"Vital status\",\n  Anatomic_location = \"Anatomic location\",\n  Stage = \"Pathologic stage\"\n)\n\n# 循环为每个注释添加标题 / Loop to add titles for each annotation\nfor(an in names(annotation_titles)) {\n  decorate_annotation(an, {\n    # 添加注释标题（右侧对齐） / Add annotation title (right-justified)\n    grid.text(annotation_titles[an], \n              x = unit(-2, \"mm\"),  # 左侧2mm处 / 2mm left of annotation\n              just = \"right\")       # 右对齐 / Right justification\n    # 添加边框 / Add border\n    grid.rect(gp = gpar(fill = NA, col = \"black\"))  # 透明填充黑色边框 / Transparent fill with black border\n  })\n}\n\n### 第二部分：添加分组分隔线 / Part 2: Add cluster demarcation lines\nht_drawn <- draw(ht)\ndecorate_heatmap_body(ht_drawn@ht_list[[1]]@name, {\n  # 左侧边界线 / Left border line\n  grid.lines(x = c(0, 0), y = c(0, 1), \n            gp = gpar(lty = 1, lwd = 2))  # 实线，2pt宽 / Solid line, 2pt width\n  \n  # 分组分隔线（根据聚类结果） / Cluster divider line (based on clustering)\n  grid.lines(x = c(table(ind)[[1]]/sum(table(ind)), \n                  table(ind)[[1]]/sum(table(ind))), \n            y = c(0, 1),\n            gp = gpar(lty = 2, lwd = 2))  # 虚线，2pt宽 / Dashed line, 2pt width\n  \n  # 右侧边界线 / Right border line\n  grid.lines(x = c(1, 1), y = c(0, 1), \n            gp = gpar(lty = 1, lwd = 2))\n})\n\n### 第三部分：添加分组标签 / Part 3: Add cluster labels\ndecorate_heatmap_body(ht_drawn@ht_list[[1]]@name, {\n  # 高浸润组标签 / High infiltration label\n  grid.text(\"High infiltration\", \n            x = (table(ind)[[1]]/2)/sum(table(ind)),  # 第一组水平中点 / Midpoint of first cluster\n            y = 0.1,                                  # y轴位置 / y-position\n            default.units = \"npc\",                    # 标准化单位 / Normalized parent coordinates\n            gp = gpar(fontsize = 16))                 # 字体大小 / Font size\n  \n  # 低浸润组标签 / Low infiltration label\n  grid.text(\"Low infiltration\", \n            x = (table(ind)[[1]] + table(ind)[[2]]/2)/sum(table(ind)),  # 第二组水平中点 / Midpoint of second cluster\n            y = 0.1,\n            default.units = \"npc\",\n            gp = gpar(fontsize = 16))\n})\n\n# 关闭图形设备 / Close graphics device\ndev.off()\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa71ssGSEA_update_FigureYa71ssGSEA_update",
      "title": "FigureYa71ssGSEA_update/FigureYa71ssGSEA_update.html",
      "html": "FigureYa71ssGSEA_update/FigureYa71ssGSEA_update.html",
      "text": "texts/main_FigureYa71ssGSEA_update_FigureYa71ssGSEA_update.txt",
      "folder": "FigureYa71ssGSEA_update",
      "thumb": "gallery_compress/FigureYa71ssGSEA_update.webp"
    },
    "word_count": 4007,
    "lines_count": 744,
    "title": "FigureYa71ssGSEA_update",
    "description": "输入TCGA数据，用原文的方法计算，原图复现。 Requirement Description Input TCGA data and compute it using the method of the original text,",
    "input_data_types": [
      "表达矩阵",
      "突变数据",
      "生存数据",
      "临床数据",
      "RNA-seq",
      "DNA-seq"
    ],
    "output_types": [
      "热图",
      "统计表格",
      "网络图",
      "生存曲线"
    ],
    "technical_methods": [
      "聚类分析",
      "网络分析",
      "通路分析",
      "标准化"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学"
    ],
    "complexity_level": "高级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "info",
      "clustering_distance_rows",
      "header",
      "Stage",
      "show_row_names",
      "annotation_height",
      "clustering_method_columns",
      "annotation_legend_param",
      "width"
    ]
  },
  {
    "id": "main_FigureYa122mut2expr_20230822_223122_FigureYa122mut2expr",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa122mut2expr_20230822_223122_FigureYa122mut2expr.txt",
    "content": "FigureYa122mut2expr\nFigureYa122mut2expr\nLong Zhao, Taojun Ye\n2025-5-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n虽然原文附件给出了代码，但自己看着费劲，请高手带我们理解并复现原文的Figure\n1b建模。\nRequirement description\nAlthough the original attachment provides the code, it seems\ndifficult for us to understand and reproduce the Figure 1b modeling in\nthe original text. Please help us understand and reproduce it.\n出自\nhttp://www.nature.com/articles/ncomms6901\nfrom\nhttp://www.nature.com/articles/ncomms6901\n代码在原文补充材料中有提供，里面有很多东西值得学习。同时我自己写了一些比原文精简的代码（一些数据命名尽量和原文一致，确保小伙伴跑的时候能够理解不同做法的异曲同工）。\n小丫碎碎念：\n像这种附带代码的好文章越来越多，是非常好的学习资源。\n这类文章怎么找到呢？在感兴趣的期刊主页的高级搜索里，搜code或script，同时限定research\narticle和发表年份等信息。检索结果里会有上下文，一眼扫过去，就能看到哪些文章带代码。\n怎样学习这类代码？这次就从这篇带代码的文章带你上手，以后你就可以自己去挖宝藏了。推荐路线：\n先尝试自己写，或者至少在脑子里猜测作者是用什么方法哪个包实现的\n看原文代码，边看边实践\n记笔记，思考这段代码能应用到哪些场景上，可以尝试按照FigureYa的格式来写，或者干脆写成R包（Y叔说写R包要趁早）\n用在自己的数据上，争取能用到paper里，经历了这一过程，你会有质的提升\n自己死磕一篇文章的代码是孤独的，遇到问题也没人讨论，以后有机会我们可以搞个学习小组，感兴趣的小伙伴一起讨论同一篇文章的代码。\nThe code is provided in the supplementary materials of the original\ntext, and there are many things worth learning from it. At the same\ntime, I wrote some code that was more concise than the original text\n(some data names should be as consistent as possible with the original\ntext to ensure that my friends can understand the similarities of\ndifferent approaches when running).\n**Xiaoya’s rambling: * * There are more and more good articles with\naccompanying code, which are very good learning resources.\nHow can I find such articles? Search for code or script on the\nadvanced search page of the journal, while limiting information such as\nresearch article and publication year. There will be context in the\nsearch results, and at a glance, you can see which articles have\ncode.\nHow to learn this type of code? This time campaign will take you\nthrough this article with code, so you can dig for treasure on your own\nin the future. Recommended route:\n-Try writing it yourself first, or at least guess in your mind what\nmethod and package the author used to implement it -Read the original\ncode and practice while reading -Take notes and think about which\nscenarios this code can be applied to. You can try writing it in the\nformat of FigureYa, or simply write it as an R package (Uncle Y said\nit’s better to write an R package as soon as possible) -Apply it to your\nown data and strive to use it in a paper. Through this process, you will\nhave a qualitative improvement\nIt’s lonely to tinker with the code of an article by oneself, and no\none will discuss it when encountering problems. In the future, we can\nform a study group where interested friends can discuss the code of the\nsame article together.\n应用场景\n已有genotype和转录数据，通过线性模型解析突变对基因表达的贡献，即基因表达如何响应不同的genotype，不同的突变如何影响基因表达。\n该模型的假设：\n每个突变位点只是影响特定的一些基因的表达；\n包含2种以上突变的个体，基因表达变化为两个或多个突变影响基因集合的并集；\n缺点：该模型忽略了基因间的相互调控。\n如果想要系统的研究基因之间的相互关系，就需要更多的基因样本容量，所以该线性模型方法是相对小样本量的很好的方式。\nApplication scenarios\nThere is already genotype and transcription data available, and a\nlinear model is used to analyze the contribution of mutations to gene\nexpression, that is, how gene expression responds to different genotypes\nand how different mutations affect gene expression.\nThe assumption of this model is:\nEach mutation site only affects the expression of specific\ngenes;\nIndividuals with two or more mutations whose gene expression\nchanges result in the union of gene sets affected by two or more\nmutations;\nDisadvantage: This model ignores the mutual regulation between\ngenes.\nIf you want to systematically study the interrelationships between\ngenes, you need more gene sample sizes, so this linear model method is a\ngood way for relatively small sample sizes.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\n# 加载用于读取Excel文件的包\n# Load the package for reading Excel files\nlibrary(openxlsx)\n# 加载用于芯片数据处理的包\n# Load the package for microarray data processing\nlibrary(GEOquery)\nlibrary(affy) \n# 加载用于芯片数据处理的包（GCRMA算法）\n# Load the package for microarray data processing (GCRMA algorithm)\nlibrary(gcrma) \n# 加载人类基因注释包\n# Load the human gene annotation package\nlibrary(org.Hs.eg.db)\n# 加载人类芯片(hgu133plus2)注释包\n# Load the human microarray (hgu133plus2) annotation package\nlibrary(hgu133plus2.db)\n# 加载线性模型分析包\n# Load the package for linear model analysis\nlibrary(limma)\n# 加载颜色方案包\n# Load the package for color palettes\nlibrary(RColorBrewer) \n\n# 设置环境变量，使R显示英文报错信息\n# Set environment variable to display error messages in English\nSys.setenv(LANGUAGE = \"en\") \n# 设置选项，禁止将字符串自动转换为因子类型\n# Set option to prevent automatic conversion of strings to factors\noptions(stringsAsFactors = FALSE)\n输入数据的预处理\n需要两种输入数据：表达数据和基因型数据\n表达数据：159个突变体和17个正常个体芯片数据，下载地址：<\nhttp://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE58831\n>，点击Download里的http下载（早上下载速度更快），解压缩到当前文件夹。\ngenotype和表型数据：Supplementary Data\n1—ncomms6901-s2.xlsx，其中部分个体数据缺失。\nPreprocessing of input data\nTwo types of input data are required: expression data and genotype\ndata\nExpression data: Chip data from 159 mutants and 17 normal\nindividuals, download link:<\nhttp://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE58831\n>Click on the HTTP download in Download (faster download speed in the\nmorning), and extract it to the current folder.\nGenotype and phenotype data: Supplementary Data 1-\nncomms6901-s2.xlsx, with some individual data missing.\n芯片数据处理：\n以下是芯片数据处理过程，主要用到affy，gcrma包\n下面这一步需要较长的运行时间，我把运行结果gset保存在文件里，便于再次运行时读取\nChip data processing:\nThe following is the chip data processing process, mainly using the\naffy and gcrma packages\nThe following step requires a relatively long running time. I will\nsave the running result gset in a file for easy retrieval when running\nagain\nif (!file.exists(\"gset.RData\")) {\n  cat(\"gset.RData not found. Downloading from GEO...\\n\")\n  \n  gset_list <- getGEO('GSE58831', destdir = \".\", getGPL = FALSE)\n  \n  if (length(gset_list) > 0) {\n    gset <- gset_list[[1]]\n    save(gset, file = \"gset.RData\")\n    cat(\"Downloaded and saved gset.RData successfully.\\n\")\n  } else {\n    stop(\"Failed to download or parse data from GEO for GSE58831.\")\n  }\n} else {\n  cat(\"Found existing gset.RData. Skipping download.\\n\")\n}\n# 加载基因表达数据集   Load gene expression dataset\nload(\"gset.RData\")\n\n# 处理样本名称，将格式为GSM1420467_MDS194.CEL.gz的样本名简化为GSM1420467\n# Process sample names: simplify from format like GSM1420467_MDS194.CEL.gz to GSM1420467\nsamples <- sub(\"_.+\",\"\", sampleNames(gset)) \nsampleNames(gset) <- samples\n\n# 将探针ID转换为ENTREZID（基因ID）\n# Convert probe IDs to ENTREZIDs (gene IDs)\n# 由于存在多个探针对应一个基因的情况（如1570001_at和222201_s_at均对应ENTREZID 9994），需对这些探针数据求平均值\n# Note: Multiple probes may map to the same gene (e.g., 1570001_at and 222201_s_at both map to ENTREZID 9994), averaging their expression values is required\ne <- exprs(gset)  # 提取表达矩阵  Extract expression matrix\ne[1:3,1:3] # 查看表达矩阵前几行几列  View first few rows and columns of the matrix\ntab <- select(hgu133plus2.db, keys = keys(hgu133plus2.db), columns = c(\"ENTREZID\"))   # 构建探针ID与ENTREZID的映射表  Build probe-to-gene mapping table\n上面的e里面保存了探针组的表达矩阵，需要转换成ENTREZID对应的表达矩阵，这里提供三种方式，便于理解：\n方式一：\n我自己用的code，比较繁琐，也容易理解。\n思路是：在表达数据中加入ENTREZID，然后根据ENTREZID把dataframe通过split转换成list。之后把list中第一列的PROBEID和最后一列的ENTREZID去掉，最后通过sapply得到表达数据：\nThe expression matrix of the probe group is saved in the e above,\nwhich needs to be converted into the expression matrix corresponding to\nENTREZID. Here are three ways to facilitate understanding:\n**Method 1: * * The code I use myself is quite cumbersome and easy to\nunderstand.\nThe idea is to add ENTREZID to the expression data, and then convert\nthe dataframe into a list through split based on ENTREZID. Afterwards,\nremove the PROBEID in the first column and ENTREZID in the last column\nof the list, and finally obtain the expression data through sapply:\nexpr <- as.data.frame(e)\nexpr$PROBEID <- rownames(expr)\nexpr.id <- merge(expr,tab,by=\"PROBEID\")\nlist <- split(expr.id, expr.id[,178])\nlist_new <- list\nfor (i in 1:length(list_new)){\nlist_new[[i]] <- list[[i]][,2:177] \n}\ngeneExpr <- t(sapply(list_new,colMeans))\n方式二：\n这是文章作者的代码，明显简洁许多，运行速度也快了很多，主要是在转换list这里节省了大量时间。\n作者的思路是：首先把只含有PROBEID和ENTREZID两列数据按照ENTREZID转换成list，然后通过sapply加一个function就可以了:\n**Method 2: * * This is the author’s code, which is obviously much\nsimpler and runs much faster, mainly saving a lot of time in converting\nlists.\nThe author’s idea is to first convert the data containing only two\ncolumns, PROBEID and ENTREZID, into a list according to ENTREZID, and\nthen add a function through sapply\n# 根据ENTREZID对探针分组，并计算每组探针表达值的均值，生成基因表达矩阵\n# Group probes by ENTREZID and calculate the mean expression values for each gene, generating a gene expression matrix\ngeneExpr <- t(sapply(split(tab[,1], tab[,2]), function(ids){\n                    colMeans(e[ids,,drop=FALSE])\n                }))\n方式三：\n如果以上理解有点困难，可以通过以下代码进行逐步操作，就会明白了：\n**Method 3: * * If the above understanding is a bit difficult, you\ncan gradually operate through the following code to understand:\n# 根据tab数据框的第二列对第一列进行分组，并存储为列表\n# Split the first column of the 'tab' data frame by the second column and store as a list\nlist <- split(tab[,1], tab[,2])\n\n# 定义一个函数，用于计算表达矩阵e中特定行(基因)的平均表达值\n# Define a function to calculate the average expression values of specific rows (genes) in the expression matrix 'e'\ncolmean <- function(ids){\n  colMeans(e[ids,,drop=FALSE])  \n}\n\n# 对列表中的每个元素(基因集合)应用colmean函数，计算平均表达矩阵\n# Apply the 'colmean' function to each element (gene set) in the list to calculate the average expression matrix\ngeneExpr1 <- sapply(list, colmean)\n\n# 转置基因表达矩阵，使行代表样本，列代表基因集合\n# Transpose the gene expression matrix so that rows represent samples and columns represent gene sets\ngeneExpr <- t(geneExpr1)\n这里有一个小tip就是\ne[ids,,drop=FALSE]\n，一般来讲用中括号[]来提取大于一列时，得到的是matrix，但是提取某一列的时候一般得到的数据是vector，如果加上drop=FALSE参数，即使提取一列，同样也会得到matrix。\nThere is a small tip here, which is’ e [ids, drop=FALSE] ’. Generally\nspeaking, when using parentheses [] to extract more than one column, the\nresult is a matrix. However, when extracting a certain column, the data\nobtained is usually a vector. If the drop=False parameter is added, even\nif one column is extracted, the matrix will still be obtained.\ngenotype突变信息\nGenotype mutation information\n# 从Excel文件中读取MDS数据，从第2行开始加载（跳过标题行）\n# Read MDS data from an Excel file starting from row 2 (skipping the header)\nmdsData <- read.xlsx(\"ncomms6901-s2.xlsx\", startRow = 2, check.names = F)\n\n# 查看数据前几行，了解数据结构\n# View the first few rows of the data to understand its structure\nhead(mdsData)\n# 找出数据框中PDID列包含缺失值(NA)的行索引\n# Find the row indices where the PDID column contains missing values (NA)\nnu <- which(is.na(mdsData$PDID))\n\n# 构建分析用的设计矩阵：移除PDID为NA的行（包括normal样本）\n# 选择第27到79列、第7列和第90列作为分析变量\n# Build the design matrix for analysis: remove rows with NA in PDID (including normal samples)\n# Select columns 27 to 79, column 7, and column 90 as analysis variables\ndesign <- mdsData[-nu, c(27:79, 7, 90)]\n\n# 查看设计矩阵的前3行和前3列，确认数据结构\n# View the first 3 rows and 3 columns of the design matrix to confirm data structure\ndesign[1:3, 1:3]\n把normal信息整合成起来，normal信息的所有突变基因列为0。定义年龄数据为NA：\nIntegrate the normal information and list all mutated genes in the\nnormal information as 0. Define age data as NA:\n# 从mdsData中提取Normal样本，并选择分析所需的列(27:79,7,90)\n# Extract Normal samples from mdsData and select columns for analysis (27:79,7,90)\nnormal <- mdsData[mdsData[,6]==\"Normal\", c(27:79,7,90)]\n\n# 将Normal数据中的缺失值替换为0\n# Replace missing values in Normal data with 0\nnormal[is.na(normal)] <- 0\n\n# 初始化Normal样本的age_imp列为缺失值(后续可能用于年龄插补)\n# Initialize age_imp column for Normal samples as NA (to be imputed later)\nnormal$age_imp <- NA\n\n# 将处理后的突变样本(design)与正常样本(normal)合并\n# Combine processed mutant samples (design) with normal samples (normal)\ndesign <- rbind(design, normal)\n\n# 根据基因7503的表达水平推断Normal样本的性别(表达>5为男性)\n# Infer gender of Normal samples based on expression of gene 7503 (expression >5 indicates male)\ndesign[125:141, \"Gender\"] <- geneExpr[\"7503\", as.character(mdsData[mdsData[,6]==\"Normal\", 2])] > 5\n\n# 筛选至少在5个样本中出现的特征(过滤低频特征)\n# Filter features present in at least 5 samples (remove rare features)\ndesign <- design[, colSums(design, na.rm=T) >= 5]\n\n# 添加Normal列标记样本类型(0=突变样本,1=正常样本)\n# Add Normal column to indicate sample type (0=mutant, 1=normal)\ndesign$Normal <- c(rep(0, nrow(design)-nrow(normal)), rep(1, nrow(normal)))\n\n# 添加offset列作为模型偏移项(通常设为1)\n# Add offset column for modeling purposes (typically set to 1)\ndesign$offset <- 1\n\n# 重新排列列顺序以优化分析\n# Rearrange column order for analysis\ndesign <- design[, c(20, 1:16, 19, 17:18)]\n\n# 对age_imp列进行中心化处理(减去均值)\n# Center the age_imp column (subtract mean)\ndesign$age_imp <- scale(design$age_imp, center=T, scale=F)\n\n# 设置行名为样本ID\n# Set row names to sample IDs\nrownames(design) <- c(as.character(mdsData[-nu, 2]), as.character(mdsData[mdsData[,6]==\"Normal\", 2]))\n\n# 用列均值填充缺失值(常见的数据预处理步骤)\n# Fill missing values with column means (common data preprocessing step)\nfor(j in 1:ncol(design))\n    design[is.na(design[,j]), j] <- mean(design[,j], na.rm=TRUE)\n\n# 查看处理后的设计矩阵前几行\n# View the first few rows of the processed design matrix\nhead(design)\n构建线性模型\n这里主要用到limma包，其中F.stat，是F-statistic检验，该值越大，一般p值越小，即差异显著。\nConstructing a linear model\nThe limma package is mainly used here, where F.stat is the\nF-statistical test. The larger the value, the smaller the p-value,\nindicating a significant difference.\n# 使用limma包的lmFit函数拟合线性模型，分析基因表达数据与设计矩阵的关系\n# Fit a linear model using limma's lmFit function to analyze the relationship between gene expression and design matrix\nglm <- lmFit(geneExpr[, rownames(design)], design = design)\n\n# 使用eBayes函数对线性模型的结果进行经验贝叶斯调节，提高统计检验的稳定性\n# Apply empirical Bayes moderation to the linear model results using eBayes to improve statistical testing stability\nglm <- eBayes(glm)\n\n# 计算F统计量，用于评估多个变量对基因表达的联合效应\n# F.stat包含每个基因的F统计量值，用于后续的差异表达基因筛选\n# Calculate F-statistics to evaluate the joint effect of multiple variables on gene expression\n# F.stat contains F-statistic values for each gene, used for subsequent differential expression gene screening\nF.stat <- classifyTestsF(glm[,-1], fstat.only = TRUE)\n开始画图-b\nb图里有三个小图，我们分别来画。\n定义颜色，主要定义19种颜色，每种颜色在之后会代表每一个design的列信息：\nStart drawing - b\nThere are three small pictures in Figure B, let’s draw them\nseparately.\nDefine colors, mainly 19 colors, each representing column information\nfor each design:\n# 从RColorBrewer包中创建一个包含多种颜色的向量，用于可视化不同突变类型\n# Create a color vector from RColorBrewer for visualizing different mutation types\ncolMutations <- c(brewer.pal(8, \"Set1\")[-6], rev(brewer.pal(8, \"Dark2\")), brewer.pal(7, \"Set2\"))[c(1:12, 16:19, 13:15)]\n\n# 根据颜色的色相(Hue)对颜色向量进行排序\n# Sort the color vector by hue for better visual grouping\no <- order(apply(col2rgb(colMutations), 2, rgb2hsv)[1, ])\n\n# 反转排序顺序并重新排列颜色，创建更美观的颜色循环\n# Reverse the order and reposition colors to create a visually appealing cycle\ncolMutations <- colMutations[rev(o)][(4*1:19 + 15) %% 19 + 1]\n\n# 为颜色向量命名，使其与设计矩阵中的列名(突变类型)对应\n# Name the colors to match the column names (mutation types) in the design matrix\nnames(colMutations) <- colnames(design)[-1]\n\n# 加载scales包用于颜色显示\n# Load the scales package for color visualization\nlibrary(\"scales\")\n\n# 显示颜色方案，帮助用户预览用于后续图表的颜色\n# Display the color palette for preview before using in plots\nshow_col(colMutations)\n选取Fstat最大的前1000个基因用于作图\nSelect the top 1000 genes with the highest Fstat for mapping\n# 选择F统计量最高的前1000个基因，按降序排列并提取基因名称\n# Select the top 1000 genes with the highest F-statistics, sorted in descending order, and extract gene names\nw <- names(sort(F.stat, decreasing = TRUE)[1:1000])\n\n# 从设计矩阵中移除第一列(通常是截距项)，保留突变类型相关的列\n# Remove the first column (usually the intercept term) from the design matrix, retaining mutation type columns\nz <- design[,-1]\n\n# 筛选基因表达矩阵，仅保留设计矩阵中存在的样本对应的列\n# Filter the gene expression matrix to include only columns (samples) present in the design matrix\ngeneExpr <- geneExpr[, rownames(design)]\nb中间图：\n这是另外一种画heatmap的方法，也是最让我惊艳的一部分。\n大体思路就是：首先通过hclust对数据进行聚类，之后通过rasterImage按照聚类的顺序画heatmap。\nB Middle image:\nThis is another method of drawing heatmaps, and it is also the most\nstunning part for me.\nThe general idea is to first cluster the data using HCluster, and\nthen draw a heatmap in the order of clustering using RasterImage.\n# 设置绘图参数，包括无边框、坐标轴标签位置、边距等\n# Set plot parameters including no border, axis label positions, margins, etc.\npar(bty=\"n\", mgp = c(2,.33,0), mar=rep(0,4), las=1, tcl=-.25, xpd=NA)\n\n# 创建一个空绘图区域，设置x轴为设计矩阵的列数，y轴为设计矩阵的行数\n# Create an empty plot area with x-axis set to the number of columns and y-axis to the number of rows in the design matrix\nplot(NA, NA, xlim=c(0, ncol(design)), ylim=c(0, nrow(design)), \n     xaxt=\"n\", yaxt=\"n\", xlab=\"\", ylab=\"\", xaxs=\"i\", yaxs=\"i\")\n\n# 对设计矩阵的前16列进行层次聚类，以便后续对样本进行排序\n# Perform hierarchical clustering on the first 16 columns of the design matrix to sort samples\nh <- hclust(dist(z[,1:16]))\n\n# 对设计矩阵的转置进行层次聚类，以便后续对特征进行排序\n# Perform hierarchical clustering on the transposed design matrix to sort features\nj <- hclust(dist(t(z)))\n\n# 创建热图：将突变状态(z矩阵)转换为颜色矩阵，使用聚类结果排序后绘制\n# 有突变的位置使用对应颜色，无突变位置使用白色\n# Create a heatmap: convert mutation status (z matrix) to a color matrix, sort using clustering results, and plot\n# Mutated positions use corresponding colors, non-mutated positions use white\nrasterImage(sapply(1:ncol(z), function(i) ifelse(z[,i] > 0, colMutations[i-1], \"#FFFFFF\"))[h$order, j$order], \n            0, 0, ncol(design), nrow(design), interpolate=FALSE)\n可以把画图部分分解来做:\nYou can break down the drawing part to do:\nfunc <- function(i) ifelse(z[,i]>0, colMutations[i-1], \"#FFFFFF\")\nmatrix <-sapply(1:ncol(z), func)\nmatrix_order <- matrix[h$order,j$order]\nrasterImage(matrix_order, 0, 0, ncol(design), nrow(design), interpolate=FALSE)\nb左侧图：\n首先是把基因表达的大小分成12份，然后换成11个颜色，之后组成颜色的矩阵。通过rasterImage画出来。rasterImage还有其他有意思的用法，可以参考Y叔的\nhttps://guangchuangyu.github.io/cn/2017/04/ggimage/\nLeft side image:\nFirstly, divide the size of gene expression into 12 parts, then\nreplace them with 11 colors, and then form a matrix of colors. Draw it\nthrough RasterImage. RasterImage has other interesting uses, you can\nrefer to Uncle Y’s<\nhttps://guangchuangyu.github.io/cn/2017/04/ggimage/\n>\n# 设置绘图参数，包括无边框、坐标轴标签位置、边距等\n# Set plot parameters including no border, axis label positions, margins, etc.\npar(bty=\"n\", mgp = c(2,.33,0), mar=rep(0,4), las=1, tcl=-.25, xpd=NA)\n\n# 创建一个空绘图区域，设置x轴为设计矩阵的列数，y轴为设计矩阵的行数\n# Create an empty plot area with x-axis set to the number of columns and y-axis to the number of rows in the design matrix\nplot(NA, NA, xlim=c(0, ncol(design)), ylim=c(0, nrow(design)), \n     xaxt=\"n\", yaxt=\"n\", xlab=\"\", ylab=\"\", xaxs=\"i\", yaxs=\"i\")\n\n# 对设计矩阵的前16列进行层次聚类，以便后续对样本进行排序\n# Perform hierarchical clustering on the first 16 columns of the design matrix to sort samples\nh <- hclust(dist(z[,1:16]))\n\n# 对设计矩阵的转置进行层次聚类，以便后续对特征进行排序\n# Perform hierarchical clustering on the transposed design matrix to sort features\nj <- hclust(dist(t(z)))\n\n# 创建热图：将突变状态(z矩阵)转换为颜色矩阵，使用聚类结果排序后绘制\n# 有突变的位置使用对应颜色，无突变位置使用白色\n# Create a heatmap: convert mutation status (z matrix) to a color matrix, sort using clustering results, and plot\n# Mutated positions use corresponding colors, non-mutated positions use white\nrasterImage(sapply(1:ncol(z), function(i) ifelse(z[,i] > 0, colMutations[i-1], \"#FFFFFF\"))[h$order, j$order], \n            0, 0, ncol(design), nrow(design), interpolate=FALSE)\nb右侧图：\nRight side image:\n# 设置绘图参数，包括无边框、坐标轴标签位置、边距等\n# Set plot parameters including no border, axis label positions, margins, etc.\npar(bty=\"n\", mgp = c(2,.33,0), mar=rep(0,4), las=1, tcl=-.25, xpd=NA)\n\n# 创建一个空绘图区域，设置x轴为设计矩阵的列数减1(排除第一列)，y轴为1000个基因\n# Create an empty plot area with x-axis set to number of columns in design matrix minus 1 (excluding first column), \n# y-axis set to 1000 genes\nplot(NA, NA, xlim=c(0, ncol(design)-1), ylim=c(0, 1000), \n     xaxt=\"n\", yaxt=\"n\", xlab=\"\", ylab=\"\", xaxs=\"i\", yaxs=\"i\")\n\n# 创建热图：将线性模型系数矩阵(glm$coefficients)中的前1000个基因与突变类型的关系\n# 映射到红-蓝(RdBu)颜色渐变，使用之前的聚类结果排序后绘制\n# 颜色表示基因表达与突变类型之间的关联强度(-3到3之间分为12个等级)\n# Create a heatmap: visualize the relationship between the top 1000 genes and mutation types \n# using linear model coefficients (glm$coefficients)\n# Map values to a red-blue (RdBu) color gradient, sort by previous clustering results, and plot\n# Colors represent the strength of association between gene expression and mutation types \n# (divided into 12 levels between -3 and 3)\nrasterImage(matrix(brewer.pal(11, \"RdBu\")[cut(glm$coefficients[w, -1][h$order, j$order], seq(-3, 3, length.out=12))], \n                   ncol=ncol(design)-1), \n            0, 0, ncol(design)-1, 1000, interpolate=FALSE)\nc和d\n仅用b图的heatmap回答基因表达如何响应不同的genotype以及各种不同的突变如何影响基因表达还不够完美，作者又画了c和d图。\n原文代码用baseplot画c和d图，我自己用ggplot2复现了c和d图。\nC and D\nIt is not perfect to answer how gene expression responds to different\ngenotypes and how various mutations affect gene expression using only\nthe heatmap in Figure B. The author has also drawn Figures C and D.\nThe original code used baseplot to draw c and d graphs, and I\nreproduced the c and d graphs myself using ggplot2.\n# 创建一个包含Set1和Dark2调色板颜色的向量，用于后续绘图的颜色设置\n# Create a vector of colors from Set1 and Dark2 palettes for use in subsequent plots\nset1 = c(brewer.pal(9,\"Set1\"), brewer.pal(8, \"Dark2\"))\n\n# 加载外部R脚本\"mg14.R\"，该脚本来自https://github.com/mg14/mg14仓库\n# 该脚本可能包含自定义函数或分析流程\n# Source an external R script \"mg14.R\" from https://github.com/mg14/mg14 repository\n# This script likely contains custom functions or analysis pipelines\nsource(\"mg14.R\")\n1. 构建随机的表型数据。\n方法和上面的”构建线性模型”\n是一样的，只不过随机一下表型数据，即基因型数据，从而能够展现出基因型的差异对基因表达值是有影响的。但是这部分不考虑后面的“Normal”,“Gender”,“Age”等，所以用到的是glm中2-17列（这里我认为原文的2：16是有错误的，因为这样就没有了del(20q)这一列，因为有17个突变体信息，而且仔细看看原文里面的图和补充材料里提供的图是有差别的，所以这里不用太纠结，明白代码原理最重要）\n1. Construct random phenotype data.\nThe method is the same as “building a linear model” above, except\nthat phenotype data, i.e. genotype data, is randomly selected to\ndemonstrate that genotype differences have an impact on gene expression\nvalues. But this part does not consider the later “Normal”, “Gender”,\n“Age”, etc., so columns 2-17 in glm are used (here I think the original\n2:16 is incorrect because there is no del (20q) column because there are\n17 mutant information, and carefully looking at the figures in the\noriginal text and the figures provided in the supplementary materials\nare different, so there is no need to worry too much here, understanding\nthe code principle is the most important)\n# 重新计算F统计量，仅考虑线性模型中第2到17列的变量（通常是突变类型相关变量）\n# Recompute F-statistics considering only variables in columns 2 to 17 of the linear model \n# (typically mutation type-related variables)\nF.stat <- classifyTestsF(glm[,2:17], fstat.only=TRUE)\n\n# 设置随机数种子以确保结果可重现\n# Set random seed for reproducibility\nset.seed(42)\n\n# 构建随机化对照模型：对设计矩阵的每一列进行随机重排，破坏变量与样本的真实关联\n# 然后拟合线性模型并进行经验贝叶斯调节\n# Build a randomized control model: randomly permute each column of the design matrix to disrupt \n# the true association between variables and samples, then fit a linear model and apply empirical Bayes\nrlm <- lmFit(geneExpr[, rownames(design)], apply(design, 2, sample))\nrlm <- eBayes(rlm)\n\n# 计算随机化模型的F统计量，用于评估观察到的F统计量的显著性\n# Compute F-statistics for the randomized model to assess the significance of observed F-statistics\nR.stat <- classifyTestsF(rlm[,2:17], fstat.only=T)\n到这里为止，我们有两个\nt-statistics数值，分别为F.stat和R.stat，分别代表真实的基因型对基因表达的影响和随机出来的基因型对表达的影响。F.stat的官方解释是：For\neach gene, classify a series of related t-statistics as significantly up\nor down using nested\nF-tests。也就是说，对于一个基因来说，F.stat越大，不同的基因型之间表达差异越明显，so基因型是对这个基因是决定因素的可能性越大。\nSo far, we have two t-statistics values, F.stat and R.stat,\nrepresenting the impact of real genotypes on gene expression and the\nimpact of randomly selected genotypes on expression, respectively. F.\nThe official explanation of stat is: For each gene, classify a series of\nrelated t-statistics as significantly up or down using nested F-tests。\nThat is to say, for a gene, the larger the F.stat, the more significant\nthe expression differences between different genotypes, and the greater\nthe possibility that genotype is the determining factor for this\ngene.\n2. 计算基因型差异和表达差异之间的R平方。\n实话实说作者的计算公式没太理解。一般来讲计算R平方R2=SSR/SST=1-SSE/SST，其中：SST=SSR+SSE，SST(total\nsum of squares)为总平方和，SSR(regression sum of\nsquares)为回归平方和，SSE(error sum of squares)\n为残差平方和。这里的代码是：\n2. Calculate the R-squared between genotype differences and\nexpression differences.\nTo be honest, the author didn’t quite understand the calculation\nformula. Generally speaking, calculating R-squared R2=SSR/SST=1-SSE/SST,\nwhere SST=SSR+SSE, SST (total sum of squares) is the total sum of\nsquares, SSR (regression sum of squares) is the regression sum of\nsquares, and SSE (error sum of squares) is the residual sum of squares.\nThe code here is:\n# 基于F统计量计算遗传效应的R²值（解释方差比例）\n# 使用公式 R² = 1 - 1/(1 + F·df1/df2)，其中df1=15（突变类型数），df2=n-p（样本数-参数数）\n# Calculate R-squared values (proportion of variance explained) for genetic effects based on F-statistics\n# Using the formula R² = 1 - 1/(1 + F·df1/df2), where df1=15 (number of mutation types), df2=n-p (number of samples minus number of parameters)\nRgenetics = 1 - 1/(1 + F.stat * 15/(nrow(design)-ncol(design)))\n\n# 基于随机化模型的F统计量计算零分布下的R²值\n# 用于评估观察到的Rgenetics的显著性\n# Calculate R-squared values under the null distribution using F-statistics from the randomized model\n# Used to assess the significance of observed Rgenetics values\nPgenetics = 1 - 1/(1 + R.stat * 15/(nrow(design)-ncol(design)))\n\n# 为R²值向量命名，使其与基因表达矩阵的行名(基因ID)对应\n# Name the R-squared vectors to match the row names (gene IDs) of the gene expression matrix\nnames(Rgenetics) <- names(Pgenetics) <- rownames(geneExpr)\nRgenetics正式基因型数据；Pgenetics随机基因型数据。\n3. 寻找adjust.p值小于0.05的基因（相关性最强的基因）\nRegenetics official genotype data; Pgenetics random genotype\ndata.\n3. Search for genes with an adjust.P value less than 0.05 (the genes\nwith the strongest correlation)\n# 从F统计量对象中提取分子自由度和分母自由度\n# 这两个参数用于后续的F检验和p值计算\n# Extract degrees of freedom (numerator and denominator) from the F-statistic object\n# These parameters are used for subsequent F-tests and p-value calculations\ndf1 <- attr(F.stat, \"df1\")\ndf2 <- attr(F.stat, \"df2\")\n\n# 基于F统计量计算p值，使用卡方分布近似（F统计量乘以分子自由度近似服从卡方分布）\n# Calculate p-values based on F-statistics using a chi-squared distribution approximation \n# (F-statistic multiplied by numerator degrees of freedom approximates a chi-squared distribution)\nF.p.value <- pchisq(df1 * F.stat, df1, lower.tail = FALSE)\n\n# 计算多重检验校正后的q值（使用Benjamini-Hochberg方法控制FDR）\n# 筛选q值小于0.05的显著基因，并找出其中最小的Rgenetics值\n# 该值作为后续分析中\"显著可解释方差\"的阈值\n# Calculate q-values using Benjamini-Hochberg method to control FDR\n# Select significant genes with q-value < 0.05 and find the minimum Rgenetics value among them\n# This value serves as the threshold for \"significantly explained variance\" in subsequent analyses\nr <- min(Rgenetics[p.adjust(F.p.value, \"BH\") < 0.05])\n前三步为计算p值。r：adjust.p\n<0.05的最小的Rgenetics(相关系数)的值.我们认为Rgenetics大于r的基因都是和突变有相关性的基因。\nThe first three steps are to calculate the p-value. r: The minimum\nvalue of Rgenetics (correlation coefficient) with adjustment. p<0.05\nWe believe that genes with Rgenetics greater than r are genes associated\nwith mutations.\n4. 原文画c图的代码\n4. The code for drawing a C diagram in the original text\n# 设置绘图参数，包括无边框、坐标轴标签位置、边距等\n# Set plot parameters including no border, axis label positions, margins, etc.\npar(bty=\"n\", mgp = c(2,.33,0), mar=c(3,2.5,1,1)+.1, las=1, tcl=-.25, xpd=NA)\n\n# 计算随机模型解释方差(Pgenetics)的密度分布\n# Compute the density distribution of explained variance from the randomized model (Pgenetics)\nd <- density(Pgenetics, bw=1e-3)\n\n# 定义缩放因子(原文中由nrow(gexpr)/512得到)\n# Define scaling factor (derived from nrow(gexpr)/512 in the original code)\nf <- 1\n\n# 绘制随机模型的密度曲线(灰色)，x轴为解释方差(R²)，y轴为密度\n# Plot the density curve of the randomized model (grey), x-axis is explained variance (R²), y-axis is density\nplot(d$x, d$y * f, col='grey', xlab=expression(paste(\"Explained variance per gene \", R^2)), \n     main=\"\", lwd=2, type=\"l\", ylab=\"\", xlim=c(0,0.7))\ntitle(ylab=\"Density\", line=1.5)  # 添加y轴标签\n\n# 计算实际模型解释方差(Rgenetics)的密度分布\n# Compute the density distribution of explained variance from the actual model (Rgenetics)\nd <- density(Rgenetics, bw=1e-3)\n\n# 找出密度曲线中解释方差大于阈值r的部分\n# Find the part of the density curve where explained variance exceeds the threshold r\nx0 <- which(d$x > r)\n\n# 填充实际模型中超过阈值r的区域(使用半透明红色)\n# Shade the area under the density curve where Rgenetics exceeds the threshold r (using translucent red)\npolygon(d$x[c(x0[1], x0)], c(0, d$y[x0]) * f, col=paste(set1[1], \"44\", sep=\"\"), border=NA)\n\n# 绘制实际模型的密度曲线(红色)\n# Plot the density curve of the actual model (red)\nlines(d$x, d$y * f, col=set1[1], lwd=2)\n\n# 添加文本标注：显示超过阈值r的基因数量\n# Add text annotation: number of genes with Rgenetics exceeding threshold r\ntext(d$x[x0[1]], d$y[x0[1]] * f, pos=4, paste(sum(Rgenetics > r), \"genes q < 0.05\"))\n\n# 添加箭头指向ENTREZID为22的基因(ABCB7)\n# Add an arrow pointing to the gene with ENTREZID 22 (ABCB7)\narrows(Rgenetics[\"22\"], par(\"usr\")[4]/7, Rgenetics[\"22\"], par(\"usr\")[4]/50, length=0.05)\n\n# 找出解释方差最高的基因并显示前几个\n# Find genes with the highest explained variance and display the top ones\nM_Rgenetics <- sort(Rgenetics, decreasing=T)\nhead(M_Rgenetics)\n# 标注ABCB7基因(ENTREZID 22)及其解释方差值\n# Label the ABCB7 gene (ENTREZID 22) and its explained variance value\ntext(Rgenetics[\"22\"], par(\"usr\")[4]/8, \"ABCB7\", font=3, pos=3)\n\n# 添加图例说明不同曲线的含义\n# Add legend to explain different curves\nlegend(\"topright\", bty=\"n\", col=c(set1[1], \"grey\"), lty=1, c(\"Observed\", \"Random\"), lwd=2)\n这张图只要能说明：\n突变体确实和基因表达相关，因为随机出来的random突变信息和表达像相关性要小于真实的（灰线和红线）。\n4049个基因和这16中突变类型是有比较强的相关性（浅红色填充部分）。\nABCB7基因，和突变类型相关性最强（所以下一张图在详细展示ABCB7）。\nThis picture only needs to illustrate:\nMutants are indeed related to gene expression, as the correlation\nbetween randomly generated mutation information and expression patterns\nis smaller than that of the real ones (gray and red lines). There is a\nstrong correlation between 4049 genes and these 16 mutation types\n(highlighted in light red). The ABCB7 gene has the strongest correlation\nwith mutation types (so the next figure will show ABCB7 in detail).\n5. 原文画d图的代码\n首先通过上面得到的线性模型预测一下基因表达水平。首先是预测所有的基因和突变的关系。这里涉及到一个“%\n%”，这个代表矩阵相乘的含义。矩阵相乘是第一个矩阵的row\n第二个矩阵column的和。\n5. The code for drawing a diagram in the original text\nFirstly, predict the gene expression level using the linear model\nobtained above. The first step is to predict the relationship between\nall genes and mutations. This involves a ’% *%’, which represents the\nmeaning of matrix multiplication. Matrix multiplication is the sum of\nthe row of the first matrix and the column of the second matrix.\n# 基于线性模型系数和设计矩阵预测所有基因的表达值\n# 矩阵乘法结果：基因数×样本数，每行代表一个基因在所有样本中的预测表达\n# Predict gene expression values using linear model coefficients and design matrix\n# Result of matrix multiplication: number of genes × number of samples\nglmPrediction <- glm$coefficients %*% t(design)\n\n# 设置绘图参数，包括无边框、坐标轴标签位置、边距等\n# Set plot parameters including no border, axis label positions, margins, etc.\npar(bty=\"n\", mgp = c(1.5,.33,0), mar=c(2.5,2.5,1,1)+.1, las=1, tcl=-.25)\n\n# 绘制ABCB7基因(ENTREZID 22)的预测表达值与实际表达值的散点图\n# 横坐标：预测表达值，纵坐标：实际表达值，共有141个样本点\n# Scatter plot of predicted vs. observed expression values for ABCB7 gene (ENTREZID 22)\n# X-axis: predicted expression, Y-axis: observed expression, 141 samples in total\nplot(glmPrediction[\"22\",], geneExpr[\"22\", rownames(design)], \n     ylab=expression(paste(\"Observed \", italic(\"ABCB7\"), \" expression\")), \n     xlab=expression(paste(\"Predicted \", italic(\"ABCB7\"), \" expression\")), \n     pch=16, cex=.8)\n\n# 添加y=x参考线，表示预测完全准确的情况\n# Add y=x reference line indicating perfect prediction\nabline(0,1)\n\n# 准备在主图右下方添加小图：展示ABCB7基因与各基因型的相关性分布\n# Prepare to add an inset plot showing correlation distribution between ABCB7 and genotypes\ny <- glm$coefficients[\"22\", -1] + glm$coefficients[\"22\", 1]  # 获取ABCB7与各基因型的关联系数\nu <- par(\"usr\")  # 获取当前绘图区域坐标\npar(xpd=NA)  # 允许图形元素超出绘图区域\n\n# 计算小图中各点的位置坐标\n# Calculate coordinates for points in the inset plot\nx0 <- rep(u[3] + 1, ncol(design) - 1)  # x坐标固定在主图左侧\ny0 <- u[4] + 0.05 * (u[4] - u[3]) - rank(-y) / length(y) * (u[4] - u[3]) / 1.2  # y坐标按系数排序\n\n# 计算ABCB7与各基因型关联系数的密度分布\n# Compute density distribution of correlation coefficients between ABCB7 and genotypes\nd <- density(y)\n\n# 绘制关联系数的密度分布轮廓(类似小提琴图)\n# Draw density distribution outline (similar to violin plot)\nlines(d$x, d$y/5 + 1 + u[3], col=\"grey\")\nlines(d$x, -d$y/5 + 1 + u[3], col=\"grey\")\n\n# 在密度分布区域内绘制各基因型的关联系数点，使用不同颜色区分基因型\n# Plot correlation coefficients for each genotype with different colors\npoints(x = y, y = x0 + violinJitter(y, magnitude = 0.25)$y, col = colMutations, pch = 16)\n\n# 添加标题：模型系数\n# Add title: Model coefficients\ntext(x = glm$coefficients[\"22\", 1], y = 1.5 + u[3], \"Model coefficients\", cex = 0.8)\n\n# 找出与ABCB7最相关的基因型(p值<0.01)\n# Identify genotypes most significantly associated with ABCB7 (p-value < 0.01)\nw <- glm$p.value[\"22\", -1] < 0.01\n\n# 为显著相关的基因型添加旋转标签\n# Add rotated labels for significantly associated genotypes\nrotatedLabel(y[w], x0[w] + 0.1, labels = colnames(design)[-1][w], \n             font = ifelse(grepl(\"[[:lower:]]\", colnames(design)[-1]), 1, 3)[w], \n             cex = .66, pos = 1, col = colMutations[w])\n\n# 添加x轴刻度，显示相对于截距的系数值\n# Add x-axis ticks showing coefficient values relative to the intercept\naxis(at = -1:1 + glm$coefficients[\"22\", 1], labels = -1:1, side = 1, \n     cex.axis = .8, line = -1, mgp = c(1.5, .05, 0), tcl = -.15)\n\n# 在图的右上角添加R²值，表示模型对ABCB7表达的解释程度\n# Add R² value in the top-right corner, indicating the proportion of variance explained\ntext(u[1], u[4], substitute(paste(R^2 == r), list(r = round(Rgenetics[\"22\"], 2))), pos = 4)\n6. 用ggplot2画c和d图\n构建数据\n6. Use ggplot2 to draw graphs c and d\nBuilding data\n# 加载ggplot2包，用于创建高质量统计图形\n# Load the ggplot2 package for creating high-quality statistical graphics\nlibrary(ggplot2)\n\n# 创建数据框，包含观察到的解释方差(Rgenetics)和随机模型的解释方差(Pgenetics)\n# Create a data frame containing observed explained variance (Rgenetics) and \n# explained variance from the random model (Pgenetics)\ngenetics <- data.frame(Observed = Rgenetics, Random = Pgenetics)\n\n# 根据阈值r标记显著基因和非显著基因\n# Label significant and non-significant genes based on threshold r\nfor (i in 1:nrow(genetics)) {\n  if (genetics[i, 1] > r) {\n    genetics[i, 3] <- \"sign\"  \n  } else {\n    genetics[i, 3] <- \"nc\"   \n  }\n}\n画图\nplot\n# 使用ggplot2创建解释方差密度图，比较观察值与随机模型的分布差异\n# Create a density plot of explained variance using ggplot2 to compare observed vs. random distributions\nggplot(genetics) +\n  \n  # 绘制随机模型解释方差的密度曲线(灰色)\n  # Plot density curve for explained variance from the random model (grey)\n  geom_density(aes(Random, stat(count)), col=\"grey\", adjust=0.01, size=1) +\n  \n  # 绘制观察到的解释方差的密度曲线(红色)，并按显著性分组填充颜色\n  # Plot density curve for observed explained variance (red) with color fill by significance\n  geom_density(aes(Observed, stat(count), fill=V3), col=\"red\", adjust=0.01, size=1, alpha=0.3) +\n  \n  # 添加文本标注，显示显著基因数量(q<0.05)\n  # Add text annotation showing the number of significant genes (q<0.05)\n  geom_text(aes(r+0.2, 530000), label= paste(sum(Rgenetics > r), \"genes q < 0.05\"), size=5) +\n  \n  # 添加箭头指向ABCB7基因的解释方差值\n  # Add an arrow pointing to the explained variance value of ABCB7 gene\n  geom_segment(aes(x=Rgenetics[\"22\"], xend=Rgenetics[\"22\"], y=250000, yend=1), \n               size=1.5, arrow=arrow(length=unit(0.3, \"cm\"))) +\n  \n  # 添加ABCB7基因标签\n  # Add label for ABCB7 gene\n  geom_text(aes(Rgenetics[\"22\"], 300000), label=\"ABCB7\", size=5, fontface=\"italic\") +\n  \n  # 手动设置显著性分组的填充颜色(非显著=白色，显著=红色)\n  # Manually set fill colors for significance groups (non-significant=white, significant=red)\n  scale_fill_manual(values=c(\"white\", \"red\")) +\n  \n  # 设置x轴标签为解释方差(R²)\n  # Set x-axis label to explained variance (R²)\n  labs(x=expression(paste(\"Explained variance per gene \", R^2))) +\n  \n  # 使用黑白主题并设置基础字体大小\n  # Use black-and-white theme with specified base font size\n  theme_bw(base_size=16) +\n  \n  # 移除网格线并隐藏图例\n  # Remove grid lines and hide legend\n  theme(panel.grid=element_blank(), legend.position=\"none\") +\n  \n  # 设置x轴显示范围为0到0.7\n  # Set x-axis limits from 0 to 0.7\n  coord_cartesian(xlim=c(0, 0.7))\n# 创建数据框，包含ABCB7基因的预测表达值和实际观测值\n# Create a data frame containing predicted and observed expression values for ABCB7 gene\nexpr <- data.frame(Predict = glmPrediction[\"22\",], Observed = geneExpr[\"22\", rownames(design)])\n\n# 创建小提琴图所需的数据框，包含ABCB7与各基因型的关联系数\n# Create data frame for violin plot containing association coefficients between ABCB7 and genotypes\nvio_data <- as.data.frame(glm$coefficients[\"22\", -1])\ncolnames(vio_data) <- \"coefficients\"\nvio_data$color <- rownames(vio_data)\n\n# 创建预测值与观测值的散点图\n# Create scatter plot of predicted vs. observed expression values\np1 <- ggplot(expr, aes(Predict, Observed)) +\n  geom_point(size=2) +  \n  geom_segment(aes(x=6, xend=10, y=6, yend=10), size=1) +  \n  labs(x=expression(paste(\"Predicted \", italic(\"ABCB7\"), \" expression\")),\n       y=expression(paste(\"Observed \", italic(\"ABCB7\"), \" expression\"))) +  \n  geom_text(aes(6.5, 9.8, label=\"R^2 = 0.6\"), size=8) +  \n  theme_bw(base_size=16) +  \n  theme(panel.grid=element_blank(), legend.position=\"none\")  \n\n# 为小提琴图数据添加颜色标签（基因型名称）\n# Add color labels (genotype names) to violin plot data\nvio_data$color <- rownames(vio_data)\n\n# 创建关联系数的小提琴图\n# Create violin plot of association coefficients\np2 <- ggplot(vio_data, aes(x=1, y=coefficients)) +\n  geom_violin(bw=0.1) +  \n  geom_jitter(aes(color=color), size=4) +  \n  geom_text(aes(1.2, -1.5), label=\"SF3B1\", size=5, col=colMutations[\"SF3B1\"]) +  \n  geom_text(aes(1.2, -1), label=\"del(5q)\", size=5, col=colMutations[\"del(5q)\"]) +  \n  coord_flip() + \n  scale_color_manual(values=colMutations) + \n  theme_classic(base_size=16) +  \n  theme(panel.grid=element_blank(), legend.position=\"none\", \n        axis.title.y=element_blank(), \n        axis.text.y=element_blank(),  \n        axis.ticks.y=element_blank(), \n        axis.line.y=element_blank())  \n\n# 使用cowplot包将两个图组合在一起\n# Combine the two plots using cowplot package\nlibrary(cowplot)\np1 +\n  annotation_custom(ggplotGrob(p2),  \n                    xmin=7, ymin=4.9, xmax=10, ymax=6.5)\nsessionInfo()",
    "chapter_info": {},
    "word_count": 4717,
    "lines_count": 855,
    "title": "FigureYa122mut2expr",
    "description": "虽然原文附件给出了代码，但自己看着费劲，请高手带我们理解并复现原文的Figure 1b建模。 Requirement description",
    "input_data_types": [
      "临床数据",
      "表达矩阵",
      "突变数据"
    ],
    "output_types": [
      "火山图",
      "热图",
      "统计表格",
      "箱线图",
      "散点图"
    ],
    "technical_methods": [
      "聚类分析",
      "质量控制",
      "差异表达分析"
    ],
    "biology_areas": [],
    "complexity_level": "高级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "非显著",
      "SST",
      "xmax",
      "set1",
      "df2",
      "0",
      "r",
      "significant"
    ]
  },
  {
    "id": "main_FigureYa234panImmune_FigureYa234panImmune",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa234panImmune_FigureYa234panImmune.txt",
    "content": "FigureYa234panImmune\nFigureYa234panImmune\nHoushi Xu\n2025-5-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n实现利用USCS上的pan-cancer数据分别通过EPIC和Cibersort算法，计算各个肿瘤的免疫细胞浸润信息，并输出结果，同时计算某个指定基因在各个肿瘤中分别与免疫细胞的相关性，并分别输出相关性热图和相关性信息的excel表\n例文只使用了一种方法，我想用多种方法来证明相关性\nRequirement Description\nUse the pan-cancer data on USCS to calculate the immune cell\ninfiltration information of each tumor through the EPIC and Cibersort\nalgorithms, and output the results, and at the same time calculate the\ncorrelation between a specified gene and immune cells in each tumor, and\noutput the correlation heat map and correlation information in the excel\nsheet.\nThe example uses only one method, and I want to use multiple methods\nto prove correlation\n出自\nhttps://www.frontiersin.org/articles/10.3389/fonc.2021.634617/full\nfrom\nhttps://www.frontiersin.org/articles/10.3389/fonc.2021.634617/full\nFIGURE 7 | Associations of CD96 expression to tumor purity and immune\ninfiltration. (B) The correlations of CD96 expression and immune\ninfiltration in cancers.\nBesides, we employed\nTIMER2.0\nto exhibit the\nlandscape of CD96 correlating with various immune infiltrates in human\ncancers (Figure 7B). # 应用场景\n分别用TIMER、EPIC、Cibersort计算各个肿瘤的免疫细胞浸润信息。\n热图可用于展示目的基因在泛癌中与免疫浸润之间的关系。\n下面分别展示TIMER、EPIC、Cibersort这三种计算方法并画图（例文用的是TIMER2.0）。三种方法的细胞不同，可相互参照，结合研究兴趣，讨论自己的结果。\nApplication Scenarios\nTIMER, EPIC, and Cibersort were used to calculate the immune cell\ninfiltration information of each tumor.\nHeatmaps can be used to demonstrate the relationship between genes of\ninterest and immune invasion in pan-cancer.\nThe following three calculation methods are shown and plotted\nrespectively (TIMER 2.0 is used in the example). The cells of the three\nmethods are different, and they can be cross-referenced, combined with\nresearch interests, and discuss their own results.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nlibrary(ggplot2)\nlibrary(ggpubr)\nlibrary(patchwork)\nlibrary(showtext)\nlibrary(EPIC)\nlibrary(IOBR)\nshowtext.auto(enable = TRUE)\nfont.add('arial', 'arial.ttf') #设置字体，windows用户  # Set fonts for Windows users\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 #error messages are displayed in English\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # chr is not allowed to be converted to factor\nTIMER\n从TIMER下载数据\nMethods: Tumor IMmune Estimation Resource 2.0 (TIMER2.0;\nhttp://timer.cistrome.org/\n) web server is a\ncomprehensive resource forsystematical analysis of immune infiltrates\nacross diverse cancertypes. At first, we used it to study the\ndifferential expressionof CD96 between tumor and adjacent normal tissues\nacross all TCGA cohorts.\nWe then explored the association between CD96 expression and immune\ninfiltration based on several immune deconvolution algorithms\n进入\nTIMER2.0\n或者\nTIMER2.0\n(comp-genomics.org)\n，按一下步骤获得分析结果文件：\n点击Immune\n在\nGene Expression\n里选择\nCD96\n在\nImmune Infiltrates\n里每次选一种免疫细胞\n点击\nSubmit\n点击\nTable\n下载分析结果\n重复以上操作，直到获得所有免疫细胞的分析结果，放到data文件夹下。（虽然一次可以选择多个细胞，但网站对数量有限制，所以我们还是一次只选一种细胞。\n!!!Querying 115 interested features exceeds the limited amount (n=20).\nPlease reduce the number. ）\nTIMER\nDownload data from TIMER\nMethods: Tumor IMmune Estimation Resource 2.0 (TIMER2.0;\nhttp://timer.cistrome.org/\n) web server is a\ncomprehensive resource forsystematical analysis of immune infiltrates\nacross diverse cancertypes. At first, we used it to study the\ndifferential expressionof CD96 between tumor and adjacent normal tissues\nacross all TCGA cohorts.\nWe then explored the association between CD96 expression and immune\ninfiltration based on several immune deconvolution algorithms\nGo to\nTIMER2.0\nor\nTIMER2.0 (comp-genomics.org)\nand follow the steps below to obtain the analysis result file:\nClick Immune\nSelect ‘CD96’ in ‘Gene Expression’\nSelect one type of immune cell at a time in ‘Immune\nInfiltrates’\nClick ‘Submit’\nClick ‘Table’ to download the analysis results\nRepeat the above until you have the results of the analysis of all\nimmune cells and put them in the data folder. (Although you can select\nmore than one cell at a time, the website has a limit on the number, so\nwe still only select one cell at a time.) !! Querying 115 interested\nfeatures exceeds the limited amount (n=20). Please reduce the number.\n）\n批量读入TIMER结果\nBatch reading TIMER results\ndata文件夹里除了从TIMER下载的Table表以外，不要放其他任何文件。 Do not\nput any files in the data folder except for the table table downloaded\nfrom the TIMER.\nsetwd(\"./data\")\nfile <- dir()\ndata <- list()\nfor (i in (1:length(file))) {\n  data[[i]] <- read.csv(file[i],header = T)\n}\n画图前的数据预处理\nTIMER的免疫细胞分类细致，有19类，例文给每一类画成一个小热图，排成了两行，因此画图时麻烦些。\nPre-processing of data before drawing\nThere are 19 types of immune cells in TIMER, and each type is drawn\ninto a small heat map arranged in two rows, so it is more troublesome to\ndraw the picture.\n# y轴排列顺序\n# Y-axis sort order\nname <- c(\"UVM (n=80)\", \"UCS (n=57)\", \"UCEC (n=545)\", \"THYM (n=120)\", \n        \"THCA (n=509)\", \"TGCT (n=150)\", \"STAD (n=415)\", \"SKCM (n=471)\", \n        \"SKCM-Primary (n=103)\", \"SKCM-Metastasis (n=368)\", \"SARC (n=260)\", \n        \"READ (n=166)\", \"PRAD (n=498)\", \"PCPG (n=181)\", \"PAAD (n=179)\", \n        \"OV (n=303)\", \"MESO (n=87)\", \"LUSC (n=501)\", \"LUAD (n=515)\", \n        \"LIHC (n=371)\", \"LGG (n=516)\", \"KIRP (n=290)\", \"KIRC (n=533)\", \n        \"KICH (n=66)\", \"HNSC (n=522)\", \"HNSC-HPV +  (n=98)\", \"HNSC-HPV- (n=422)\", \n        \"GBM (n=153)\", \"ESCA (n=185)\", \"DLBC (n=48)\", \"COAD (n=458)\", \n        \"CHOL (n=36)\", \"CESC (n=306)\", \"BRCA (n=1100)\", \"BRCA-LumB (n=219)\", \n        \"BRCA-LumA (n=568)\", \"BRCA-Her2 (n=82)\", \"BRCA-Basal (n=191)\", \n        \"BLCA (n=408)\", \"ACC (n=79)\")\n\n# 定义函数画heatmap\n# Define the function to draw a heatmap\nplot_tme <- function(x){\n  x$pvalue = ifelse(x$adj.p >= 0.05, \"p≥0.05\", \"p<0.05\")\n  x$cancer = factor(x$cancer, levels = name) \n  \n  ggplot(x, aes(infiltrates, cancer, \n                shape = pvalue, \n                color = rho)) +\n    geom_point(size = 3) + \n    scale_shape_manual(values = c(15, 7)) + \n    scale_color_gradient2(low = \"#2b8cbe\",mid = \"white\",high = \"#e41a1c\") + \n    #scale_x_discrete(position = \"top\") + \n    theme_bw() + \n    theme(axis.title.y = element_blank(),\n          axis.title.x = element_blank(),\n          axis.text.x = element_text(angle = 90,hjust = 0,vjust = 0),\n          axis.text.x.bottom = element_text(family = \"arial\"))\n}\n\n# 画出19个热图\n# Draw 19 heat maps\ndd <- lapply(data, plot_tme)\n#dd[[1]] # 可以这样查看每一个heatmap # You can view each heatmap like this\n画图\nDrawing\n# 设置和下半部分分割的位置\n# Set the position of the division with the lower half\nbreakpoint <- 8 # 上面画8个热图，下面画19-8=11个 # Draw 8 heat maps on the top and 19-8=11 on the bottom\n\n## 先画上半部分\n# 画第1个热图（第1个热图左侧带label，其余不带）\n## Draw the top half first\n# Draw the first heatmap (the left side of the first heatmap has a label, and the rest is not)\nup <- dd[[1]] + \n  scale_x_discrete(position = \"top\") + \n  guides(color=FALSE) + guides(shape=FALSE) # 不画图例 # No legend\n# 加上第2-8个热图\n# Plus the 2nd-8th heatmap\nfor (i in 2:(breakpoint)) {\n  up <- up + dd[[i]] + \n    scale_x_discrete(position = \"top\") + \n    theme(axis.text.y = element_blank()) + # 不画y轴label # Don't draw the y-axis label\n    guides(color = FALSE) + guides(shape = FALSE) # 不画图例 # No legend\n}\n\n# 按照x轴来调整图片组合宽度\n# Adjust the width of the image combination according to the x-axis\nwidth_up <- NULL\nfor (i in 1:breakpoint) {\n  width_up <- c(width_up,length(unique(data[[i]]$infiltrates)))\n}\n\n# 画完上半部分\n# Finish the first half\nup + plot_layout(guides = 'collect',widths = width_up)\n# 保存到文件\n# Save to file\nggsave(\"TIMER.pdf\", \n       height=15, width=10)\n# 输出的PDF文件是矢量图，可以用illustrator等矢量图编辑器打开，进一步调整图形、文字\n# The output PDF file is a vector image, which can be opened with a vector editor such as illustrator to further adjust the graphics and text\nEPIC\n免疫浸润算法强烈推荐IOBR（\nGitHub - IOBR/IOBR: IOBR is an R\npackage to perform comprehensive analysis of tumor microenvironment and\nsignatures for immuno-oncology.\n）\nEPIC\nIOBR is highly recommended for immunoinfiltration algorithms （\nGitHub - IOBR/IOBR: IOBR is an R\npackage to perform comprehensive analysis of tumor microenvironment and\nsignatures for immuno-oncology.\n）\n输入数据\npancancer_mRNA_exprSet.Rdata，表达矩阵和癌症名type\nexpr_pancancer.Rda，表达矩阵，取自pancancer_mRNA_exprSet.Rdata。\n数据来源于UCSC xena\nPan-cancer，从数据下载到获得以上两个文件的过程见\nTCGA_pan.R\n（位于当前文件夹）\nEnter data\npancancer_mRNA_exprSet.Rdata, expression matrix and cancer name\ntype\nexpr_pancancer. Rda, Expression Matrix, taken from\npancancer_mRNA_exprSet.Rdata.\nThe data is from UCSC xena Pan-cancer, and the process from data\ndownload to obtaining the above two files is described in ‘TCGA_pan. R’\n(located in the current folder).\n# 载入数据\n# Load data\n(load(\"expr_pancancer.Rda\"))\nexpr[1:5,1:5]\ndim(expr)\n(load(\"pancancer_mRNA_exprSet.Rdata\"))\nmRNA_exprSet[1:5,1:5]\ndim(mRNA_exprSet)\n运行EPIC\nRun EPIC\n#epic <- deconvo_tme(eset = expr, \n#                    method = \"epic\", \n#                    arrays = FALSE)\n# save(epic,file = \"epic.Rda\")\n\nload(\"epic.Rda\")\ndim(epic)\n#epic[1:5,]\nepic$ID <- gsub(\"\\\\.\",\"-\",epic$ID)\ndata <- merge(epic, \n              mRNA_exprSet, \n              by.x = \"ID\", by.y = \"sample\")\n#data[1:5,]\ndim(data)\n计算相关性\nCalculate relevance\n# 自定义计算相关性的函数\n# Customize the function to calculate the relevance\ncorr <- function(gene){\n  y <- as.numeric(data[, gene])\n  colnames <- colnames(epic[, 2:9])\n  do.call(rbind,lapply(colnames, function(x){\n    dd <- cor.test(as.numeric(data[, x]), y, type = \"spearman\")\n    data.frame(gene = gene, immune_cells = x,\n               cor = dd$estimate, p.value = dd$p.value )\n  }))\n}\n# 计算相关性\n# Calculate relevance\ncorr(\"CD96\")\ngene <- \"CD96\"\ncancertype <- unique(data$type)\nres <- data.frame(type=NULL,\n                  gene=NULL,\n                  immune_cells=NULL,\n                  cor=NULL,\n                  p.value=NULL)\n\nfor (i in cancertype){\n  data2 <- data %>% filter(type==i)\n  y <- as.numeric(data2[,gene])\n  colnames <- colnames(epic[,2:9])\n  dd2 <- do.call(rbind,lapply(colnames, function(x){\n    dd <- cor.test(as.numeric(data2[,x]),y,type = \"spearman\")\n    data.frame(type = i,\n               gene = gene,\n               immune_cells = x,\n               cor = dd$estimate,\n               p.value = dd$p.value )\n             }))\n  res <- rbind(res,dd2)\n}\nres$pvalue <- ifelse(res$p.value >= 0.05,\"p≥0.05\",\"p<0.05\")\nhead(res)\nwrite.csv(res,\"output_res.EPIC.csv\")\n画图\nEPIC只有8种细胞，画在一起就可以了。\n保持跟上面TIMER组合图的风格一致。\nDrawing\nEPIC has only 8 types of cells, and it is enough to draw them\ntogether.\nKeep the same style as the TIMER combo chart above.\nggplot(res, aes(immune_cells,\n               type,\n               shape = pvalue,\n               color = cor)) +  \ngeom_point(size = 3) + \nscale_shape_manual(values = c(15,7)) + \nscale_color_gradient2(low = \"#2b8cbe\",\n                      mid = \"white\",\n                     high = \"#e41a1c\",\n                   limits = c(-1, 1)) + \ntheme_bw() + \ntheme(axis.title.y = element_blank(),\n      axis.title.x = element_blank(),\n      axis.text.x = element_text(angle = 90,\n                                 hjust = 1,\n                                 vjust = 0,\n                                family = \"arial\"))\nggsave(\"EPIC.pdf\", width = 4, height = 7)\nCibersort\n输入数据同“EPIC”的输入数据\n运行Cibersort\nCibersort\nThe input data is the same as the input data of “EPIC”.\nRun Cibersort\n# 用IOBR包计算\n# Calculated using IOBR packets\n#cibersort <- deconvo_tme(eset = expr, \n#                      method = \"cibersort\", \n#                      arrays = FALSE, \n#                      perm = 200 )\n\n# pancancer的免疫细胞浸润信息可以用IOBR计算，也可以直接导入官方数据 [CIBERSORT immune fractions](https://gdc.cancer.gov/about-data/publications/panimmune)\n# 这里直接导入官方数据\n# The immune cell infiltration information of pancancer can be calculated using IOBR or directly imported into the official data [CIBERSORT immune fractions](https://gdc.cancer.gov/about-data/publications/panimmune)\n# Import official data directly here\ncibersort <- read.table(\"TCGA.Kallisto.fullIDs.cibersort.relative.tsv\", header = T)\n\ncibersort$SampleID <- substring(cibersort$SampleID,1,15)\ncibersort$SampleID <- gsub(\"\\\\.\",\"-\",cibersort$SampleID)\n\ncibersort <- merge(cibersort,\n                   mRNA_exprSet,\n                   by.x = \"SampleID\",\n                   by.y = \"sample\")\n计算相关性\nCalculate relevance\ngene <- \"CD96\"\nres <- data.frame(type=NULL,\n                  gene=NULL,\n                  immune_cells=NULL,\n                  cor=NULL,\n                  p.value=NULL)\n\nfor (i in cancertype){\n  data2 <- cibersort %>% filter(type==i)\n  y <- as.numeric(data2[,gene])\n  colnames <- colnames(cibersort[,3:24])\n  dd2 <- do.call(rbind,lapply(colnames, function(x){\n    dd <- cor.test(as.numeric(data2[,x]),y,type = \"spearman\")\n    data.frame(type = i,\n               gene = gene,\n               immune_cells = x,\n               cor = dd$estimate,\n               p.value = dd$p.value )\n  }))\n  res <- rbind(res,dd2)\n}\nres$pvalue <- ifelse(res$p.value >= 0.05,\"p≥0.05\",\"p<0.05\")\nhead(res)\nwrite.csv(res, \"output_res.Cibersort.csv\")\n画图\nCibersort有22种细胞，也可以画在一起。并保持跟以上两种方法的画图风格一致。\nDrawing\nCibersort has 22 types of cells, which can also be drawn together.\nAnd keep the drawing style consistent with the above two methods.\nggplot(res, aes(immune_cells,\n            type,\n            shape = pvalue,\n            color = cor)) +  \n  geom_point(size = 3) + \n  scale_shape_manual(values = c(15,7)) + \n  scale_color_gradient2(limits = c(-1, 1),\n                        low = \"#2b8cbe\",\n                        mid = \"white\",\n                        high = \"#e41a1c\") + \n  theme_bw() + \n  theme(axis.title.y= element_blank(),\n        axis.title.x = element_blank(),\n        axis.text.x = element_text(angle = 90,\n                                   hjust = 1,\n                                   vjust = 0,\n                                   family = \"arial\"))\nggsave(\"Cibersort.pdf\", width = 5, height = 7)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa234panImmune_FigureYa234panImmune",
      "title": "FigureYa234panImmune/FigureYa234panImmune.html",
      "html": "FigureYa234panImmune/FigureYa234panImmune.html",
      "text": "texts/main_FigureYa234panImmune_FigureYa234panImmune.txt",
      "folder": "FigureYa234panImmune",
      "thumb": "gallery_compress/FigureYa234panImmune.webp"
    },
    "word_count": 1667,
    "lines_count": 408,
    "title": "FigureYa234panImmune",
    "description": "实现利用USCS上的pan-cancer数据分别通过EPIC和Cibersort算法，计算各个肿瘤的免疫细胞浸润信息，并输出结果，同时计算某个指定基因在各个肿瘤中分别与免疫细胞的相关性，并分别输出相关性热图和相关性信息的excel表 例文只使用了一种方法，我想用多种方法来证明相关性 Requirement Description",
    "input_data_types": [
      "表达矩阵"
    ],
    "output_types": [
      "散点图",
      "热图",
      "统计表格"
    ],
    "technical_methods": [
      "差异表达分析"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "gene",
      "values",
      "header",
      "width",
      "n",
      "8",
      "pvalue",
      "vjust",
      "guides"
    ]
  },
  {
    "id": "main_FigureYa143survCor_FigureYa143survCor",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa143survCor_FigureYa143survCor.txt",
    "content": "FigureYa143survCor\nFigureYa143survCor\nAuthor(s)\n: Xiaofan Lu\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n绘制较复杂的相关性图，包括计算每个表达值下的logrank\nscore；以肠癌MSS和MSI样本为例。 Draw a more complex correlation graph,\nincluding calculating the logrank score for each expression value; take\ncolorectal cancer MSS and MSI samples as an example.\n出自\nhttps://www.jci.org/articles/view/127046\nFrom\nhttps://www.jci.org/articles/view/127046\nFigure 1. Comparison of TME stratification based on CD8A and CD274\ngene expression between TCGA melanoma and CRC. Scatter plots of\nlog2-transformed CD8A and CD274\ngene expression\nvalues\nare shown (A and C) for melanoma (n = 459) and CRC (n = 599),\nrespectively. A linear regression line is plotted with the\ngray\nshaded region showing the 95% confidence interval\n. Pearson’s\ncorrelation coefficient r and P values are given at the bottom.\nMSI (black triangles) and MSS (gray circles) statuses\nare labeled for CRC samples.\nMedian values of CD8A and CD274\nexpression are indicated with dashed gray lines\n. log-rank\nstatistics were applied to identify the optimal cut-off for transforming\nthe continuous variable of gene expression into categorical high- and\nlow-expression groups in a survfit model. The test score at each\ncandidate cut-off across the log-transformed gene expression values was\nplotted.\nThe highest test score (indicated with a blue arrow)\nwas applied for best separating patients into 4 different risk groups\n(using solid blue lines; named groups I to IV)\n. To compare risk\ngroups between melanoma and CRC, we also applied a secondary peak of\ntest scores (red arrow with an asterisk, which revealed a reverse\npattern of survival in CRC as shown in Supplemental Figure 2) for CD274\nstratification (indicated with a solid red line instead of a blue line;\nnamed groups I, II, III* and IV*). Each stratified risk group is labeled\nwith its population fraction in percentages.\nStatistics\n. CD8A and PD-L1 gene expression were\nchosen for investigation from the 20 correlated genes (Bedognetti et\nal.; ref. 12). We used\nlog-rank statistics\nto identify\nthe\noptimal expression cut-off\nfor each gene with\nregard to the associated hazard of death or relapse events in a survfit\nmodel (63), using the cutp function of the\nR package\nsurvMisc\n(version 0.5.5;\nhttps://CRAN.R-project.org/package=survMisc\n). The\ncut-off with the\nhighest log-rank test score was selected for\nbest separating patients into high- and low-expression groups with\ndifferent risks\n. Upon observing a bimodal distribution of\nmarginal log-rank statistics for CRC, but not melanoma, CD274 expression\nvalue at a secondary mode was used to identify a second set of high-risk\nsubjects.\n应用场景\nApplication scenarios\n用log-rank statistics找最佳分组cut-off。 Use log-rank statistics to\nfind the best grouping cut-off.\n用复杂相关性图同时展示基因表达相关性、MSI/MSS状态、最佳cut-off、分组等信息。\nUse complex correlation graphs to simultaneously display gene expression\ncorrelation, MSI/MSS status, best cut-off, grouping and other\ninformation.\n如果只想计算并展示相关性，画出类似的图，可参考FigureYa92immune_gene。\nIf you only want to calculate and display the correlation and draw a\nsimilar graph, refer to FigureYa92immune_gene.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nlibrary(TCGAbiolinks) # Download data\nlibrary(survival) # Calculate survdiff\nlibrary(survMisc) # Calculate cutoff\nlibrary(shape) # Draw a slightly more beautiful arrow\n\nSys.setenv(LANGUAGE = \"en\") #Display English error message\noptions(stringsAsFactors = FALSE) #Disable conversion of chr to factor\n输入文件\nInput file\neasy_input_expr.txt，基因表达矩阵。第一列是样本ID，二、三列分别是CD274和CD8A的TPM。每行一个样本。TPM的获得可参考FigureYa23count2TPM或FigureYa56immune_inflitration。或者直接用FigureYa34count2FPKM下载FPKM值。\neasy_input_expr.txt, gene expression matrix. The first column is the\nsample ID, and the second and third columns are the TPM of CD274 and\nCD8A respectively. One sample per row. For TPM, refer to\nFigureYa23count2TPM or FigureYa56immune_inflitration. Or directly use\nFigureYa34count2FPKM to download the FPKM value.\neasy_input_survival.txt，生存信息，跟表达矩阵的样本ID对应。\neasy_input_survival.txt, survival information, corresponding to the\nsample ID of the expression matrix.\nmsi_results.rda，下载的MSI信息保存在这里，以便重复使用。\nmsi_results.rda, the downloaded MSI information is saved here for\nreuse.\n# 表达矩阵\n# Expression matrix\nexpr <- read.table(\"easy_input_expr.txt\",sep = \"\\t\",check.names = F,stringsAsFactors = F,header = T,row.names = 1)\nhead(expr)\n# 生存信息\n# Survival information\nsurv <- read.table(\"easy_input_survival.txt\",sep = \"\\t\",check.names = F,stringsAsFactors = F,header = T,row.names = 1)\nhead(surv)\n下载MSI信息： Download MSI information:\n下载过程完成后存储为当前文件夹下的msi_results.rda文件，便于重复使用。\nAfter the download process is completed, it is stored as the\nmsi_results.rda file in the current folder for easy reuse.\n# COAD结肠癌\n# COAD colon cancer\nmsiquery1 <- GDCquery(project = \"TCGA-COAD\",\n                      data.category = \"Other\",\n                      legacy = TRUE,\n                      access = \"open\",\n                      data.type = \"Auxiliary test\")\nGDCdownload(msiquery1)\ncoad_msi_results <- GDCprepare_clinic(msiquery1, \"msi\")\ncoad_msi_results <- coad_msi_results[,c(1,3)]\nrownames(coad_msi_results) <- paste0(\"COAD-\",substr(coad_msi_results$bcr_patient_barcode,9,12),\"-01A\") #zhi 修改样本名匹配表达谱和临床数据\n#zhi Modify sample name to match expression spectrum and clinical data\ncolnames(coad_msi_results) <- c(\"sample\", \"MSI\")\n\n# READ直肠癌\n# READ rectal cancer\nmsiquery2 <- GDCquery(project = \"TCGA-READ\",\n                      data.category = \"Other\",\n                      legacy = TRUE,\n                      access = \"open\",\n                      data.type = \"Auxiliary test\")\nGDCdownload(msiquery2)\nread_msi_results <- GDCprepare_clinic(msiquery2, \"msi\")\nread_msi_results <- read_msi_results[,c(1,3)]\nrownames(read_msi_results) <- paste0(\"READ-\",substr(read_msi_results$bcr_patient_barcode,9,12),\"-01A\") # 修改样本名匹配表达谱和临床数据\n# Modify sample name to match expression spectrum and clinical data\ncolnames(read_msi_results) <- c(\"sample\", \"MSI\")\n\n# 合并MSI信息\n# Merge MSI information\nmsi_results <- rbind.data.frame(coad_msi_results, read_msi_results)\n\n# 存储MSI信息\n# Store MSI information\nsave(msi_results,file = \"msi_results.rda\")\n读取MSI信息： Read MSI information:\n(load(\"msi_results.rda\"))\ntable(msi_results$MSI)\nmss.sam <- rownames(msi_results[which(msi_results$MSI %in% c(\"MSS\",\"MSI-L\")),])\nmsi.sam <- rownames(msi_results[which(msi_results$MSI %in% c(\"MSI-H\")),])\n挑选表达矩阵、生存信息、包含明确MSI信息的共有样本： Select expression\nmatrix, survival information, and common samples containing clear MSI\ninformation:\ncom_sam <- intersect(intersect(rownames(expr),rownames(surv)),c(mss.sam, msi.sam))\nexpr <- round(log2(expr[com_sam,] + 1),2) # 表达谱对数转化\nsurv <- surv[com_sam,]\n计算logrank score和相关性\nCalculate logrank score and correlation\n#-------------------#\n# 计算logrank score #\n#-------------------#\n#-------------------#\n# Calculate logrank score #\n#-------------------#\n\nexprsurv <- cbind.data.frame(surv,expr) # 新建包含表达和生存的数据框 # Create a new data frame containing expression and survival\nexprsurv$sampleID <- rownames(exprsurv) # 生成样名 # Generate sample names\n\n# CD274\ncox.CD274 <- coxph(Surv(OS.time, OS) ~ CD274, data=exprsurv) # cox回归 # cox regression\nlogrank.CD274 <- as.data.frame(print(cutp(cox.CD274))) # cut连续变量产生logrank score # Cut continuous variables to generate\ncolnames(logrank.CD274)[1] <- \"CD274\"\nlogrank.CD274 <- logrank.CD274[order(logrank.CD274$CD274),]\npeak.CD274 <- logrank.CD274[which.min(logrank.CD274$CD274.p),1] # 得到p值最小(logrank score 峰值)下对应的表达值 # Get the expression value corresponding to the minimum p value \npeak.CD274.score <- logrank.CD274[which.min(logrank.CD274$CD274.p),2] # 找到logrank score 峰值 # Find the logrank score peak value\n\n# CD8A\ncox.CD8A <- coxph(Surv(OS.time, OS) ~ CD8A, data=exprsurv)\nlogrank.CD8A <- as.data.frame(print(cutp(cox.CD8A)))\ncolnames(logrank.CD8A)[1] <- \"CD8A\"\nlogrank.CD8A <- logrank.CD8A[order(logrank.CD8A$CD8A),]\npeak.CD8A <- logrank.CD8A[which.min(logrank.CD8A$CD8A.p),1]\npeak.CD8A.score <- logrank.CD8A[which.min(logrank.CD8A$CD8A.p),2]\n\n# 计算各区域的样本 (注意边际上的样本重复问题)\n# Calculate the samples in each region (note the problem of sample duplication on the margin)\nlefttop <- expr[which(expr$CD274 < peak.CD274 & expr$CD8A > peak.CD8A),]\nleftbottom <- expr[which(expr$CD274 <= peak.CD274 & expr$CD8A <= peak.CD8A),]\nrighttop <- expr[which(expr$CD274 >= peak.CD274 & expr$CD8A >= peak.CD8A),]\nrightbottom <- expr[which(expr$CD274 > peak.CD274 & expr$CD8A < peak.CD8A),]\n\nlefttop.pct <- paste0(\"III (\",round(nrow(lefttop)/nrow(expr),2)*100,\"%)\")\nleftbottom.pct <- paste0(\"I (\",round(nrow(leftbottom)/nrow(expr),2)*100,\"%)\")\nrighttop.pct <- paste0(\"IV (\",round(nrow(righttop)/nrow(expr),2)*100,\"%)\")\nrightbottom.pct <- paste0(\"II (\",round(nrow(rightbottom)/nrow(expr),2)*100,\"%)\")\n\n#------------#\n# 计算相关性 #\n#------------#\n#----------------#\n# Calculate correlation #\n#----------------#\n\ncor <- cor.test(expr$CD274,expr$CD8A,method = \"pearson\") # 皮尔森相关性检验\nr <- round(cor$estimate,2)\np <- ifelse(cor$p.value < 0.001,\" < 0.001\", paste0(\" = \",round(cor$p.value))) # p值显示为文本\n\n#------------------------#\n# 计算线性回归以及置信域 #\n#------------------------#\n#------------------------#\n# Calculate linear regression and confidence region #\n#------------------------#\nreg <- lm(CD8A~CD274,data=expr[order(expr$CD274),]) # 注意要按照x轴排序  # Note that the order should be sorted according to the x-axis\nci <- as.data.frame(predict(reg, newdata = expr[order(expr$CD274),], interval = 'confidence')) # 计算置信域 # Calculate confidence region\n开始画图\nStart drawing\n# 设置颜色\n# Set color\nblue <- \"#4F81BD\"\nred <- \"#E53435\"\nlblue <- \"#5bc0eb\"\ndblue <- \"#1d00ff\"\npink <- \"#FF7FBF\"\n\n# 计算边界\n# Calculate the boundary\nylim <- range(expr$CD8A) # 计算y轴边界 # Calculate the y-axis boundary\nxlim <- range(expr$CD274) # 计算x轴边界 # Calculate the x-axis boundary\n\n# 保存pdf图像 # Save pdf image\npdf(\"complex correlation with logrank score.pdf\",width = 6,height = 6)\n\n# 设置画面布局，相同数字代表同一区块，数字越多代表该区块所占面积越大\n# Set the screen layout, the same number represents the same block, the more numbers represent the larger area of the block\nlayout(matrix(c(1,1,1,1,2,\n                3,3,3,3,4,\n                3,3,3,3,4,\n                3,3,3,3,4,\n                3,3,3,3,4),\n              byrow = T,nrow = 5))\n\n#--------------------------------------------#\n# 画布区域1：添加x轴相关的logrank test score #\n#--------------------------------------------#\n#--------------------------------------------#\n# Canvas area 1: Add x-axis related logrank test score #\n#--------------------------------------------#\n\npar(bty=\"n\", mgp = c(2,0.5,0), mar = c(0.6,4.1,2.1,0),tcl=-.25,xpd = T) # 注意mar参数要和其他区域匹配，分别显示图像为下，左，上，右预留的位置；xpd允许箭头超出图像范围\n# Note that the mar parameter must match other regions, and the image is displayed as the reserved position for the bottom, left, top, and right respectively; xpd allows the arrow to exceed the image range\nplot(NULL, NULL,\n     xlim = xlim,ylim = c(0,max(logrank.CD274$CD274.U) + 5), # y轴额外空余一些距离放箭头\n     xaxt = \"n\",yaxt = \"n\",ann=FALSE) # 不显示坐标轴\n\n# 这里不能使用barplot原因在于x轴的间隔并不固定，其实barplot本身本身是rect函数的一种wrapper，所以这里用rect函数绘制条形图\n# The reason why barplot cannot be used here is that the interval of the x-axis is not fixed. In fact, barplot itself is a wrapper of the rect function, so the rect function is used here to draw a bar chart\nrect(xleft=logrank.CD274[order(logrank.CD274$CD274),\"CD274\"]-0.01, \n     ybottom=0, \n     xright=logrank.CD274[order(logrank.CD274$CD274),\"CD274\"]+0.01, \n     ytop=logrank.CD274[order(logrank.CD274$CD274),\"CD274.U\"],col = \"black\")\n\n# 在peak处添加箭头\n# Add arrows at peak\nArrows(peak.CD274,peak.CD274.score + 5,\n       peak.CD274,peak.CD274.score + 3,\n       arr.length = 0.2,\n       lwd = 2,col = blue,arr.type = \"triangle\")\n\n#------------------------#\n# 画布区域2：填充空白画布#\n#------------------------#\n#------------------------#\n# Canvas area 2: Fill the blank canvas#\n#------------------------#\n\npar(bty=\"n\", mgp = c(2,0.5,0), mar = c(4.1,4.1,0,0),tcl=-.25)\nplot(0,0,col = \"white\",xaxt = \"n\",yaxt = \"n\",xlab = \"\",ylab = \"\")\n\n#----------------------#\n# 画布区域3：相关性主图#\n#----------------------#\n#----------------------#\n# Canvas area 3: Correlation main graph#\n#----------------------#\n\npar(bty=\"o\", mgp = c(2,0.5,0), mar = c(4.1,4.1,0,0),tcl = -.25,font.axis = 2,las = 1) # 注意坐标轴刻度均水平 # Note that the axis scale is horizontal\npar(xpd=F)\n\n# 画MSS4\n# Draw MSS\nplot(expr[mss.sam,\"CD274\"], expr[mss.sam,\"CD8A\"],ylim = ylim,xlim = xlim,\n     xlab = expression(italic(CD274)~\"(PD-L1) Gene Expression\"), # 注意斜体 # Note the italics\n     ylab = expression(italic(CD8A)~\" Gene Expression\"),main = \"\", # 注意斜体 # Note the italics\n     cex.lab = 1.8, # 坐标轴文字大小 # Axis text size\n     cex.axis = 1.4, # 坐标轴刻度大小 # Axis scale size\n     col=\"grey40\",\n     cex = 1.2,\n     type = \"p\",pch = 19) # 圆形为MSS # Circle is MSS\n\n\n# 添加MSI # Add MSI\npoints(expr[msi.sam,\"CD274\"], expr[msi.sam,\"CD8A\"],\n       ylim = ylim,xlim = xlim,\n       col=\"black\",\n       cex = 2, # 三角形稍大 # The triangle is slightly larger\n       pch = 17) # 三角形为MSI # The triangle is MSI\n \n# 添加中位数 # Add median\nabline(h = median(expr$CD8A),lty = 2,col = \"grey60\",lwd = 2)\nabline(v = median(expr$CD274),lty = 2,col = \"grey60\",lwd = 2)\n\n# 添加logrank peak对应的表达值\n# Add the expression value \nabline(v = peak.CD274,lty = 2,col = blue,lwd = 2)\nabline(h = peak.CD8A,lty = 2,col = blue,lwd = 2)\n\n# 添加相关性\n# 添加回归线 (由于例文并未布满整个画布，所以这里不使用abline)\n# Add correlation\n# Add regression line (since the example does not fill the entire canvas, abline is not used here)\nlines(x = xlim,y = xlim*reg$coefficients[2] + reg$coefficients[1], lwd = 2)\n\n# 添加置信带\n# Add confidence band\npolygon(round(c(sort(expr$CD274),rev(sort(expr$CD274))),2),\n        round(c(ci$lwr,rev(ci$upr)),2),\n        col=ggplot2::alpha(\"grey70\",0.6),\n        border=NA)\n\n# 添加相关性文本\n# Add correlation text\ntext(2,0,adj = 0,bquote(~italic(r)~\" = \"~.(r)~\", \"~italic(P)~.(p)),cex = 1.6) # 注意斜体\n\n# 添加样本百分比\n# Add sample percentage\ntext(0.5,6.5,bquote(bold(.(lefttop.pct))),cex = 1.6,col = dblue)\ntext(4,6.5,bquote(bold(.(righttop.pct))),cex = 1.6,col = red)\ntext(0.5,0.5,bquote(bold(.(leftbottom.pct))),cex = 1.6,col = lblue)\ntext(4,0.5,bquote(bold(.(rightbottom.pct))),cex = 1.6,col = pink)\n\n# 添加图例\n# 确定图片边界\n# Add legend\n# Determine the image boundary\nxmin <- par(\"usr\")[1]\nxmax <- par(\"usr\")[2]\nymin <- par(\"usr\")[3]\nymax <- par(\"usr\")[4]\n\n# 确定图例大小\n# Determine the legend size\nlgd <- legend(x = mean(c(xmin,xmax)), y =  mean(c(ymin,ymax)), \n              legend = c(\"MSI\",\"MSS\"), \n              col = c(\"black\",\"grey40\"),\n              pch = c(17,19),\n              cex = 1.5, \n              border = NA, \n              title = expression(bold(\"MSI Status\")),\n              y.intersp = 1, x.intersp = 0.8,\n              bty = \"o\",\n              plot = F)\n\n# 定位图例悬浮在右下角（不同于bottomright）\n# Position the legend to float in the lower right corner (different from bottomright)\nlegend(x = xmax - lgd$rect$w - 0.1, y =  ymin + lgd$rect$h + 0.1,\n       legend = c(\"MSI\",\"MSS\"), \n       col = c(\"black\",\"grey40\"),\n       pch = c(17,19),\n       cex = 1.5, \n       border = NA, \n       title = expression(bold(\"MSI Status\")),\n       y.intersp = 1, x.intersp = 0.8,\n       bty = \"o\",\n       plot = T)\n       \n#--------------------------------------------#\n# 画布区域4：添加y轴相关的logrank test score #\n#--------------------------------------------#\n#--------------------------------------------#\n# Canvas area 4: Add y-axis related logrank test score #\n#--------------------------------------------#\n\npar(bty=\"n\", mgp = c(2,0.5,0), mar = c(4.1,0.6,0,2.1),tcl=-.25,xpd = T)\nplot(NULL, NULL,\n     xlim = c(0,max(logrank.CD8A$CD8A.U) + 5),ylim = ylim,\n     xaxt = \"n\",yaxt = \"n\",ann=FALSE)\n\nrect(xleft=0, \n     ybottom=logrank.CD8A[order(logrank.CD8A$CD8A),\"CD8A\"]-0.01, \n     xright=logrank.CD8A[order(logrank.CD8A$CD8A),\"CD8A.U\"], \n     ytop=logrank.CD8A[order(logrank.CD8A$CD8A),\"CD8A\"]+0.01,col = \"black\")\n\nArrows(peak.CD8A.score + 5,peak.CD8A,\n       peak.CD8A.score + 3,peak.CD8A,\n       arr.length = 0.2,\n       lwd = 2,col = blue,arr.type = \"triangle\")\n\n# 关闭图形句柄\n#Close graphics handle\ninvisible(dev.off())\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa143survCor_FigureYa143survCor",
      "title": "FigureYa143survCor/FigureYa143survCor.html",
      "html": "FigureYa143survCor/FigureYa143survCor.html",
      "text": "texts/main_FigureYa143survCor_FigureYa143survCor.txt",
      "folder": "FigureYa143survCor",
      "thumb": "gallery_compress/FigureYa143survCor.webp"
    },
    "word_count": 1892,
    "lines_count": 419,
    "title": "FigureYa143survCor",
    "description": "Requirement description 绘制较复杂的相关性图，包括计算每个表达值下的logrank score；以肠癌MSS和MSI样本为例。 Draw a more complex correlation graph,",
    "input_data_types": [
      "临床数据",
      "表达矩阵",
      "生存数据"
    ],
    "output_types": [
      "散点图",
      "统计表格",
      "生存曲线"
    ],
    "technical_methods": [
      "生存分析"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学"
    ],
    "complexity_level": "高级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "intersp",
      "header",
      "lwd",
      "width",
      "newdata",
      "ylim",
      "n",
      "xlim",
      "nrow"
    ]
  },
  {
    "id": "main_FigureYa300pancanCor_FigureYa300pancanCor",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa300pancanCor_FigureYa300pancanCor.txt",
    "content": "FigureYa300pancanCor\nFigureYa300pancanCor\nAuthor(s)\n: Xiaofan Lu; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-05-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nDemand description\n输入数据是Table S4中基因名称，使用z-score打分画出Figure\n5中在不同癌症中与表型的相关性。\nInput data are gene names from Table S4, using z-score values to plot\nFigure 5 showing correlations with phenotypes across different cancer\ntypes.\n出自：\nhttps://jitc.bmj.com/content/10/6/e004210\n图5 中性粒细胞胞外诱捕网（NETs）评分与肿瘤多种恶性特征高度相关\nSource:\nhttps://jitc.bmj.com/content/10/6/e004210\nFigure 5 The neutrophil extracellular traps score was highly\ncorrelated with many malignant features of the tumor.\n应用场景\nApplication scenarios\n在泛癌中计算某感兴趣得分并计算该得分与几种致癌通路的相关性。\n相关性展示的8种情况\nhttps://mp.weixin.qq.com/s/D9wheY5QdnOh4JrjIc8-Cg\n，相关FigureYa看这里\n可以用FigureYa实现例文多个Figure，例如：\nFigure 1A，可参考FigureYa31lasso\nFigure 2，FigureYa291PancanProgSigature\n已复现。泛癌中计算某感兴趣得分并计算该得分与预后的相关性；绘制得分分布于预后散点图。\nFigure 2CDE、3、6BCDE，可参考FigureYa35batch_bestSeparation\nFigure 4AB，可参考FigureYa30\nFigure 4C，可参考FigureYa85timeROC\nFigure 4D，可参考FigureYa33DCA\nCalculate a score of interest across pan-cancer and assess its\ncorrelation with several oncogenic pathways.\nEight scenarios for correlation visualization:\nhttps://mp.weixin.qq.com/s/D9wheY5QdnOh4JrjIc8-Cg\n.\nRelated FigureYa examples available here:\nFigureYa can be used to create multiple figures as shown in the\nexample article, such as:\nFigure 1A, refer to FigureYa31lasso:\nFigure 2, reproduced in FigureYa291PancanProgSignature: . Calculate\na score of interest across pan-cancer and evaluate its correlation with\nprognosis; plot score distribution and prognostic scatter plots.\nFigures 2CDE, 3, and 6BCDE, refer to\nFigureYa35batch_bestSeparation:\nFigures 4AB, refer to FigureYa30:\nFigure 4C, refer to FigureYa85timeROC:\nFigure 4D, refer to FigureYa33DCA:\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(ggplot2)\nlibrary(data.table)\nlibrary(cowplot)\nlibrary(ggpubr)\nlibrary(GSVA)\nlibrary(SimDesign)\nlibrary(tidyr)\n\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n自定义函数将gmt文件读取为list\nCustom function to read a GMT file as a list\ngmt2list <- function(annofile){\n  if (!file.exists(annofile)) {\n    stop(\"There is no such gmt file.\")\n  }\n  \n  if (tools::file_ext(annofile) == \"xz\") {\n    annofile <- xzfile(annofile)\n    x <- scan(annofile, what=\"\", sep=\"\\n\", quiet=TRUE)\n    close(annofile)\n  } else if (tools::file_ext(annofile) == \"gmt\") {\n    x <- scan(annofile, what=\"\", sep=\"\\n\", quiet=TRUE)\n  } else {\n    stop (\"Only gmt and gmt.xz are accepted for gmt2list\")\n  }\n  \n  y <- strsplit(x, \"\\t\")\n  names(y) <- sapply(y, `[[`, 1)\n  \n  annoList <- lapply(y, `[`, c(-1,-2))\n}\n输入文件\nInput Files\n跟FigureYa291PancanProgSigature的输入文件相同，不用重复下载。\ntable s6 risk\ncoefficients.txt，风险基因以及对应系数，来自原文补充材料表格Table\nS6。\nmerged_sample_quality_annotations.tsv，肿瘤注释文件。下载自\nhttps://gdc.cancer.gov/about-data/publications/pancanatlas\n，下载地址\nhttp://api.gdc.cancer.gov/data/1a7d7be8-675d-4e60-a105-19d4121bdebf\n。\nEBPlusPlusAdjustPANCAN_IlluminaHiSeq_RNASeqV2.geneExp.tsv，表达矩阵，第一列是基因，之后是其在每个样本中的表达量。下载自\nhttp://api.gdc.cancer.gov/data/3586c0da-64d0-4b74-a449-5ff4d9136611\n。\nSurvival_SupplementalTable_S1_20171025_xena_sp，生存数据。来自\nhttps://xenabrowser.net/datapages/?dataset=Survival_SupplementalTable_S1_20171025_xena_sp&host=https%3A%2F%2Fpancanatlas.xenahubs.net&removeHub=https%3A%2F%2Fxena.treehouse.gi.ucsc.edu%3A443\n.\nThe input files are the same as those used in\nFigureYa291PancanProgSignature , so there is no need to download them\nagain.\ntable s6 risk coefficients.txt: Risk genes and their corresponding\ncoefficients, sourced from the supplementary table Table S6 of the\noriginal paper.\nmerged_sample_quality_annotations.tsv: Tumor annotation file.\nDownloaded from\nhttps://gdc.cancer.gov/about-data/publications/pancanatlas\n(direct download link:\nhttp://api.gdc.cancer.gov/data/1a7d7be8-675d-4e60-a105-19d4121bdebf\n).\nEBPlusPlusAdjustPANCAN_IlluminaHiSeq_RNASeqV2.geneExp.tsv: Expression\nmatrix, where the first column contains gene names and subsequent\ncolumns contain expression values for each sample. Downloaded from\nhttp://api.gdc.cancer.gov/data/3586c0da-64d0-4b74-a449-5ff4d9136611\n.\nSurvival_SupplementalTable_S1_20171025_xena_sp: Survival data.\nObtained from\nhttps://xenabrowser.net/datapages/?dataset=Survival_SupplementalTable_S1_20171025_xena_sp&host=https%3A%2F%2Fpancanatlas.xenahubs.net&removeHub=https%3A%2F%2Fxena.treehouse.gi.ucsc.edu%3A443\n.\n# 读取风险基因以及对应系数（来自原文补充材料表格Table S6）\n# Read risk genes and their corresponding coefficients (from supplementary Table S6 of the original paper)\nrisk.coeff <- read.table(\"table s6 risk coefficients.txt\",sep = \"\\t\", row.names = NULL,check.names = F,stringsAsFactors = F,header = T)\n\n# 读取肿瘤注释文件\n# Read tumor annotation file\nrawAnno <- read.delim(\"merged_sample_quality_annotations.tsv\",sep = \"\\t\",row.names = NULL,check.names = F,stringsAsFactors = F,header = T)\nrawAnno$simple_barcode <- substr(rawAnno$aliquot_barcode,1,15)\nsamAnno <- rawAnno[!duplicated(rawAnno$simple_barcode),c(\"cancer type\", \"simple_barcode\")]\nsamAnno <- samAnno[which(samAnno$`cancer type` != \"\"),]\nwrite.table(samAnno,\"output_simple_sample_annotation.txt\",sep = \"\\t\",row.names = F,col.names = T,quote = F)\n\n# 快速读取表达谱数据并做数据预处理\n# Quickly read expression profile data and perform preprocessing\nexpr <- fread(\"EBPlusPlusAdjustPANCAN_IlluminaHiSeq_RNASeqV2.geneExp.tsv\",sep = \"\\t\",stringsAsFactors = F,check.names = F,header = T)\nexpr <- as.data.frame(expr); rownames(expr) <- expr[,1]; expr <- expr[,-1]\ngene <- sapply(strsplit(rownames(expr),\"|\",fixed = T), \"[\",1)\nexpr$gene <- gene\nexpr <- expr[!duplicated(expr$gene),]\nrownames(expr) <- expr$gene; expr <- expr[,-ncol(expr)]\n\n# 对于这份泛癌数据，将略小于0的数值拉到0，否则不能取log（其他途径下载的泛癌数据可能不需要此操作）\n# For this pan-cancer dataset, adjust slightly negative values to 0 to enable log transformation (may not be necessary for other pan-cancer datasets)\nexpr[expr < 0] <- 0 \n\ncolnames(expr) <- substr(colnames(expr),1,15)\ngc()\n# 去掉对于风险基因存在NA值的样本\n# Remove samples with NA values for risk genes\nexpr.sub <- expr[risk.coeff$Gene, ] \nexpr.sub <- as.data.frame(t(na.omit(t(expr.sub)))) \nkeepSam <- colnames(expr.sub)\nexpr <- expr[,keepSam] \n\n# 读取生存数据(虽然在本代码中没有用到，但是原文使用的样本是具有生存数据的)\n# Read survival data (though not used in this code, the original study only included samples with survival data)\nsurv <- read.delim(\"Survival_SupplementalTable_S1_20171025_xena_sp\", sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T) \n\n# 确定肿瘤样本以及对应肿瘤类型\n# Identify tumor samples and their corresponding cancer types\nsam <- samAnno[which(samAnno$`cancer type` != \"LAML\"),\"simple_barcode\"] \ncomsam <- intersect(intersect(colnames(expr), sam), rownames(surv)) #\ntumsam <- comsam[substr(comsam,14,14) == \"0\"] \ntumAnno <- samAnno[which(samAnno$simple_barcode %in% tumsam),] \ntumAnno <- tumAnno[order(tumAnno$`cancer type`),] \ntumors <- unique(tumAnno$`cancer type`)\n计算NETs得分\nCalculate NETs Score\noncogenic.gmt，将原文补充材料S4以及S6的基因制作成的gmt文件。Table S4:\nGene sets related to angiogenesis, cell proliferation, and epithelial to\nmesenchymal transition. Table S6: 19-gene NETs-characteristic signature\nwith the risk coefficients\noncogenic.gmt - A GMT file created from genes in Supplementary Tables\nS4 and S6 of the original paper. Table S4: Gene sets related to\nangiogenesis, cell proliferation, and epithelial-to-mesenchymal\ntransition. Table S6: 19-gene NETs-characteristic signature with risk\ncoefficients.\n# 在所有样本中计算NETs得分(在本代码中仅仅是为了确定根据cox-based nets score确定肿瘤的level)\n# Calculate NETs score across all samples (used here only to determine tumor levels based on Cox-based NETs score) \nnets.score <- list() \nnets.mean <- c() \noutTab <- NULL\nfor (i in tumors) {\n  \n  # 提取当前肿瘤类型的肿瘤样本\n  # Extract tumor samples of current cancer type\n  sam <- tumAnno[which(tumAnno$`cancer type` == i),\"simple_barcode\"] \n  \n  # 提取表达谱子集并进行log2转化\n  # Extract expression subset and apply log2 transformation\n  expr.sub <- log2(expr[risk.coeff$Gene,sam] + 1) \n  \n  # 计算经过z-score的NETs得分\n  # Calculate z-score normalized NETs score  \n  nets <- scale(apply(expr.sub,2,function(x) {x %*% risk.coeff$Coefficient})) \n  nets.score[[i]] <- nets\n  nets.mean <- c(nets.mean, mean(nets))\n  outTab <- rbind.data.frame(outTab, \n                             data.frame(tumor = i, \n                                        NETs = as.numeric(nets), \n                                        row.names = sam,\n                                        stringsAsFactors = F),\n                             stringsAsFactors = F)\n}\nsapply(nets.score, range)\nwrite.table(outTab, file = \"output_nets score of all tumor sample across 32 tumor types.txt\",sep = \"\\t\",row.names = T,col.names = F,quote = F)\nnames(nets.mean) <- tumors\n\n# 根据均值对肿瘤进行排序\n# Sort tumors by mean score \nnets.mean <- sort(nets.mean, decreasing = T) \n\n# 将排序结果作为肿瘤因子的等级\n# Use sorted order as tumor factor levels\ntumor.level <- names(nets.mean) \n\n# 在所有样本中通过z-score计算致癌通路以及NETs得分（注意：此时NETs得分不再是由cox系数计算，而是由zscore算法下的单样本富集得到）\n# Calculate oncogenic pathway and NETs scores via z-score across all samples (Note: NETs score here is not Cox-based but derived from single-sample enrichment using z-score)  \n\n # 将原文补充材料S4以及S6的基因制作成gmt文件，并将gmt文件读取为list\n# Convert genes from Supplementary Tables S4 & S6 into GMT format and read as list \noncosig <- gmt2list(\"oncogenic.gmt\")\n\n# 去掉list中的空值\n# Remove empty entries \noncosig <- sapply(oncosig, function(x) setdiff(x,\"\")) \nzscore.list <- list()\noutSig <- NULL\nfor (i in tumors) {\n  message(i)\n  sam <- tumAnno[which(tumAnno$`cancer type` == i), \"simple_barcode\"]\n  expr.sub <- log2(expr[, sam] + 1)\n  \n  param <- zscoreParam(\n    exprData = as.matrix(expr.sub),\n    geneSets = oncosig,\n    minSize = 1,\n    maxSize = Inf\n  )\n  \n  zscore.list[[i]] <- quiet(gsva(param))\n  \n  outSig <- rbind.data.frame(\n    outSig,\n    cbind.data.frame(\n      tumor = i,\n      as.data.frame(t(zscore.list[[i]]))\n    ),\n    stringsAsFactors = F\n  )\n}\nwrite.table(outSig, file = \"output_oncogenic and nets score of all tumor sample across 32 tumor types.txt\",sep = \"\\t\",row.names = T,col.names = F,quote = F)\n开始画图\nPlotting\n# 设置颜色\n# Set color palette\nmycol <- c(\"#A6CEE3\",\n           \"#1F78B4\",\n           \"#B2DF8A\",\n           \"#33A02C\",\n           \"#FB9A99\",\n           \"#E31A1C\",\n           \"#FDBF6F\",\n           \"#FF7F00\",\n           \"#CAB2D6\",\n           \"#6A3D9A\",\n           \"#B15928\",\n           \"#8DD3C7\",\n           \"#BEBADA\",\n           \"#FB8072\",\n           \"#80B1D3\",\n           \"#FDB462\",\n           \"#B3DE69\",\n           \"#FCCDE5\",\n           \"#D9D9D9\",\n           \"#BC80BD\",\n           \"#CCEBC5\",\n           \"#FFED6F\",\n           \"#8C510A\",\n           \"#BF812D\",\n           \"#DFC27D\",\n           \"#F6E8C3\",\n           \"#80CDC1\",\n           \"#35978F\",\n           \"#01665E\",\n           \"#003C30\",\n           \"#8E0152\",\n           \"#C51B7D\")\n\n# 制作绘图数据并绘图\n# Prepare plot data and generate plots\nplotdata <- outSig\nplotdata <- gather(plotdata, oncogenic, zscore, Angiogenesis:`Cell cycle`, factor_key=TRUE)\nplotdata$tumor <- factor(plotdata$tumor, levels = tumor.level)\n\n# 泛癌相关性散点图\n# Pan-cancer correlation scatter plot\np1 <- ggplot(data = plotdata, aes(x = zscore, y = NETs)) + \n  geom_point(aes(color=tumor),size=1.5,alpha = 0.5) +\n  scale_color_manual(values = mycol) + \n  geom_smooth(method = \"lm\", se = FALSE) +\n  geom_ribbon(stat = \"smooth\",method = \"lm\",se = TRUE,alpha = 0,linetype = \"dashed\") + \n  xlab(\"Oncogenic (z-score)\") + ylab(\"NETs (z-score)\") + \n  stat_cor(method = \"pearson\", label.x = -40, label.y = 10) + \n  facet_wrap(.~oncogenic, nrow = 1) + \n  theme_bw() + \n  theme(axis.text.x = element_text(vjust = 0.5, size = 12, color = \"black\"),\n        axis.ticks = element_line(size=0.2, color=\"black\"),\n        axis.ticks.length = unit(0.2, \"cm\"),\n        legend.position = \"right\",\n        axis.title = element_text(size = 12),\n        axis.text = element_text(size = 12))\nggsave(filename = \"correlation scatter plot of zscored oncogenic and NETs in pancancer.pdf\", width = 15,height = 5)\ntmp1 <- plotdata[which(plotdata$oncogenic == \"Angiogenesis\"),]\np2 <- ggplot(data = tmp1, aes(x = zscore, y = NETs)) + \n  geom_point(aes(color=tumor),size=1.2,alpha = 0.5) +\n  scale_color_manual(values = mycol) + \n  geom_smooth(method = \"lm\", se = FALSE) +\n  geom_ribbon(stat = \"smooth\",method = \"lm\",se = TRUE,alpha = 0,linetype = \"dashed\") + \n  stat_cor(method = \"pearson\", label.x = -40, label.y = 10) + \n  xlab(\"Angiogenesis (z-score)\") + ylab(\"NETs (z-score)\") + \n  facet_wrap(.~tumor, ncol = 8) + \n  theme_bw() + \n  theme(axis.text.x = element_text(vjust = 0.5, size = 12, color = \"black\"),\n        axis.ticks = element_line(size=0.2, color=\"black\"),\n        axis.ticks.length = unit(0.2, \"cm\"),\n        legend.position = \"none\",\n        axis.title = element_text(size = 12),\n        axis.text = element_text(size = 12))\nggsave(filename = \"correlation scatter plot of zscored Angiogenesis and NETs in pancancer.pdf\", width = 15,height = 8)\ntmp2 <- plotdata[which(plotdata$oncogenic == \"EMT\"),]\np3 <- ggplot(data = tmp2, aes(x = zscore, y = NETs)) + \n  geom_point(aes(color=tumor),size=1.2,alpha = 0.5) +\n  scale_color_manual(values = mycol) + \n  geom_smooth(method = \"lm\", se = FALSE) +\n  geom_ribbon(stat = \"smooth\",method = \"lm\",se = TRUE,alpha = 0,linetype = \"dashed\") + \n  stat_cor(method = \"pearson\", label.x = -40, label.y = 10) + \n  xlab(\"EMT (z-score)\") + ylab(\"NETs (z-score)\") + \n  facet_wrap(.~tumor, ncol = 8) + \n  theme_bw() + \n  theme(axis.text.x = element_text(vjust = 0.5, size = 12, color = \"black\"),\n        axis.ticks = element_line(size=0.2, color=\"black\"),\n        axis.ticks.length = unit(0.2, \"cm\"),\n        legend.position = \"none\",\n        axis.title = element_text(size = 12),\n        axis.text = element_text(size = 12))\nggsave(filename = \"correlation scatter plot of zscored EMT and NETs in pancancer.pdf\", width = 15,height = 8)\np <- plot_grid(p1,p2,p3, align = \"v\", ncol = 1)\nggsave(filename = \"combined correlation scatter plot of zscored oncogenic and NETs in pancancer.pdf\", width = 15,height = 18)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa300pancanCor_FigureYa300pancanCor",
      "title": "FigureYa300pancanCor/FigureYa300pancanCor.html",
      "html": "FigureYa300pancanCor/FigureYa300pancanCor.html",
      "text": "texts/main_FigureYa300pancanCor_FigureYa300pancanCor.txt",
      "folder": "FigureYa300pancanCor",
      "thumb": "gallery_compress/FigureYa300pancanCor.webp"
    },
    "word_count": 1517,
    "lines_count": 369,
    "title": "FigureYa300pancanCor",
    "description": "Demand description 输入数据是Table S4中基因名称，使用z-score打分画出Figure 5中在不同癌症中与表型的相关性。",
    "input_data_types": [
      "临床数据",
      "表达矩阵",
      "生存数据"
    ],
    "output_types": [
      "散点图",
      "统计表格",
      "生存曲线"
    ],
    "technical_methods": [
      "通路分析",
      "生存分析",
      "质量控制"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "ticks",
      "values",
      "header",
      "width",
      "nrow",
      "vjust",
      "factor_key",
      "NETs",
      "method"
    ]
  },
  {
    "id": "main_FigureYa163twoVarCor_update_FigureYa163twoVarCor_update",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa163twoVarCor_update_FigureYa163twoVarCor_update.txt",
    "content": "FigureYa163twoVarCor_update\nFigureYa163twoVarCor_update\nAuthor(s)\n: Xiaofan Lu\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement Description\n需求一：\n绘制多组数据在两个变量上的相关性散点图。\nRequirement 1:\nPlot a scatter plot of the correlations\nbetween multiple data sets on two variables.\nFig. 1 Correlations between DNAm age and chronological age and other\nmolecular characteristics of DNAm age groups. a DNAm age of 200 mixed\nnormal cervical samples predicts chronological age with a decent\ncorrelation coefficient, whereas such correlation was much weaker in 252\ntumour samples from TCGA.\n图的解读\nInterpretation of the\nFigure\n不同于普通相关性散点图，这里添加了更丰富的信息，类似的有FigureYa143survCor：\nUnlike ordinary correlation scatter plots, this one adds richer\ninformation, similar to FigureYa143survCor:\n用点的大小展示横纵坐标的差异，类似于FigureYa59vocano用点的大小体现差异倍数和pvalue；\n用了两种颜色，使得两组数据可以画一起，还可用更多颜色展示更多组。\nThe size of the dot indicates the difference between the horizontal\nand vertical axes, similar to FigureYa59vocano, which uses the size of\nthe dot to indicate the fold difference and p-value;\nTwo colors are used to allow the two data sets to be plotted\ntogether, and more colors can be used to display more groups.\n需求二：\n审稿人要求我比较两个相关性大小有没有统计学差异，我想知道老师这篇文章里Fisher’s\nr-to-z transformation是怎么计算的？\nRequirement 2:\nThe\nreviewer asked me to compare the two correlations to see if they are\nstatistically significant. I would like to know how Fisher’s r-to-z\ntransformation is calculated in this paper.\n出自\nhttps://clinicalepigeneticsjournal.biomedcentral.com/articles/10.1186/s13148-020-0822-y\nFrom\nhttps://clinicalepigeneticsjournal.biomedcentral.com/articles/10.1186/s13148-020-0822-y\n应用场景\nApplication Scenarios\n展示两个基因/性状之间的相关性，2组/3组/多组都可以画一起。 Show the\ncorrelation between two genes/traits. Two, three, or more groups can be\nplotted together.\n这里用颜色区分每个分组，如果太多怕区分不开，可参考FigureYa125Fishertest、FigureYa76corrgram或FigureYa97correlationV3，再多的话可以用FigureYa73batchCorrelation做批量相关性分析和画图。\nHere, each group is distinguished by color. If there are too many\ngroups to distinguish, refer to FigureYa125 Fishertest, FigureYa76\ncorrgram, or FigureYa97 correlationV3. For even more, use FigureYa73\nbatchCorrelation for batch correlation analysis and plotting.\n这里要求两组数据的横纵坐标一致，如果你的两组数据横纵坐标不一致，可参考FigureYa62twoAxis和FigureYa96R2的画法\nThis requires the two data sets to have consistent horizontal and\nvertical coordinates. If your two data sets do not, refer to\nFigureYa62twoAxis and FigureYa96R2 for more information.\n环境设置\nEnvironment Settings\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 #Display English error messages\noptions(stringsAsFactors = FALSE) #禁止chr转成factor #Disable conversion of chr to factor\n自定义函数，用于比较不同组相关性是否有统计学差异 Custom function used\nto compare statistical differences in correlations between different\ngroups\ntest2cor = function(x1, x2, y1, y2, method = \"pearson\") {\n  \n  # x1：第一组相关性分析的变量1\n  # x2：第一组相关性分析的变量2\n  # y1：第二组相关性分析的变量1\n  # y2：第二组相关性分析的变量2\n  # method：相关性分析方法，默认为皮尔斯相关性\n  # x1: Variable 1 for the first correlation analysis\n  # x2: Variable 2 for the first correlation analysis\n  # y1: Variable 1 for the second correlation analysis\n  # y2: Variable 2 for the second correlation analysis\n  # method: Correlation analysis method, default is Pierce correlation\n  \n  # 统计定义： Fisher’s r-to-z transformation was used to calculate a value of z that was applied to assess the significance of the difference between two correlation coefficients. \n  # Statistical Definition: Fisher’s r-to-z transformation was used to calculate the value of z that was applied to assess the significance of the difference between two correlation coefficients. \n\n  cor1 = cor.test(x1, x2, method = method)\n  cor2 = cor.test(y1, y2, method = method)\n  \n  r1 = cor1$estimate\n  r2 = cor2$estimate\n  n1 = sum(complete.cases(x1, x2))\n  n2 = sum(complete.cases(y1, y2))\n  fisher = ((0.5*log((1+r1)/(1-r1)))-(0.5*log((1+r2)/(1-r2))))/((1/(n1-3))+(1/(n2-3)))^0.5\n  \n  p.value = (2*(1-pnorm(abs(fisher))))\n  \n  result= list(\n    \"cor1\" = list(\n      \"estimate\" = as.numeric(cor1$estimate),\n      \"p.value\" = cor1$p.value,\n      \"n\" = n1\n    ),\n    \"cor2\" = list(\n      \"estimate\" = as.numeric(cor2$estimate),\n      \"p.value\" = cor2$p.value,\n      \"n\" = n2\n    ),\n    \"p.value.twosided\" = as.numeric(p.value), # 双侧检验p值 # Two-sided test p-value\n    \"p.value.onesided\" = as.numeric(p.value) / 2 # 单侧检验p值，根据相关性大小自行判断是“greater”还是“less” # One-sided test p-value, judge whether it is \"greater\" or \"less\" based on the size of the correlation\n  )\n  cat(paste(sep=\"\",\n            \"cor1: r=\", format(result$cor1$estimate, digits=3), \", p=\", format(result$cor1$p.value, digits=3), \", n=\", result$cor1$n, \"\\n\",\n            \"cor2: r=\", format(result$cor2$estimate, digits=3), \", p=\", format(result$cor2$p.value, digits=3), \", n=\", result$cor2$n, \"\\n\",\n            \"diffence: p(one-sided)=\", format(result$p.value.onesided, digits=3), \", p(two-sided)=\", format(result$p.value.twosided, digits=3), \"\\n\"\n  ))\n  return(result);\n}\n输入文件\nInput file\neasy_input.csv，第一列和第二列是连续变量，分别对应图上的横纵坐标，第三列是分组。\neasy_input.csv, the first and second columns are continuous variables,\ncorresponding to the horizontal and vertical coordinates on the graph,\nrespectively. The third column is the grouping.\ncor.data <- read.csv(\"easy_input.csv\", row.names = NULL, check.names = F, header = T, stringsAsFactors = F)\nhead(cor.data)\ndim(cor.data)\ntable(cor.data$class)\n分别计算不同组的相关性\nCalculate correlations for different groups separately\n# 第一组 # First group\nt.cor <- cor.test(cor.data[which(cor.data$class == \"T\"), \"age\"], cor.data[which(cor.data$class == \"T\"), \"dnamage\"])\nt.cor\n# 第二组 # Second group\nn.cor <- cor.test(cor.data[which(cor.data$class == \"N\"), \"age\"], cor.data[which(cor.data$class == \"N\"), \"dnamage\"])\nn.cor\n比较不同组相关性是否有统计学差异\n直接在屏幕上打印两次相关性的差异显著性\nCompare the correlations between different groups to see if they are\nstatistically significant.\nPrint the significance of the difference between the two correlations\ndirectly to the screen.\ncor.diff <- test2cor(x1 = cor.data[which(cor.data$class == \"T\"), \"age\"], \n                     x2 = cor.data[which(cor.data$class == \"T\"),\"dnamage\"],\n                     y1 = cor.data[which(cor.data$class == \"N\"), \"age\"], \n                     y2 = cor.data[which(cor.data$class == \"N\"), \"dnamage\"])\n开始画图\nStart plotting\n先计算画图时需要的额外变量 First, calculate the additional variables\nneeded for plotting.\n# 计算散点图里点的大小，根据自己的数据来调整公式\n# Calculate the size of the points in the scatter plot and adjust the formula based on your own data.\ncor.data$diff <- abs(cor.data$dnamage - cor.data$age) # 计算甲基化加速年龄 # Calculate the age of methylation acceleration.\ncor.data$size <- log10(cor.data$diff + 1) # 根据加速程度计算散点大小 # Calculate the size of scattered points based on the acceleration\n\n# 计算图例里点的大小\n# Calculate the size of points in the legend\ncor.data$range <- cut(cor.data$size, breaks = quantile(cor.data$size), include.lowest = T) # 分配散点大小区间 # Assign scattered point size intervals\ncor.data$range2 <- as.numeric(gsub(\"]\", \"\", sapply(strsplit(as.character(cor.data$range),\",\"), \"[\",2), fixed = T)) # 取区间的后半部分，用于绘制图例 # Take the second half of the interval to draw the legend\nhead(cor.data)\n# 计算图例里需要绘制多少圆圈\n# Calculate the number of circles to draw in the legend\nnum <- length(unique(cor.data$range2)) \nnum\n# 计算坐标轴的范围\n# Calculate the axis ranges\nylim <- range(cor.data$dnamage) # y轴范围 # y-axis range\nxlim <- range(cor.data$age) # x轴范围 # x-axis range\n画图 Drawing\npdf(\"TwoVarCor.pdf\", width = 7, height = 6.5)\npar(bty=\"o\", mgp = c(2,0.5,0), mar = c(4.1,4.1,2.1,4.1), tcl=-.25, font.main=3) # 画布基本设置 # Basic canvas settings\npar(xpd=F) # 禁止显示超过画布的部分 # Disable display of parts exceeding the canvas\nplot(NULL, NULL, ylim = ylim, xlim = xlim, # 先绘制一个空的画布，仅有边框和坐标名 # First draw an empty canvas with only borders and coordinate names\n     xlab = \"Chronological age \", ylab = \"DNA methylation age\",col=\"white\",\n     main = \"\")\nrect(par(\"usr\")[1], # 给画布设置背景色，掩盖边框 # Set the background color of the canvas to cover the border\n     par(\"usr\")[3],\n     par(\"usr\")[2],\n     par(\"usr\")[4],\n     col = \"#EAE9E9\",\n     border = F)\ngrid(col = \"white\", lty = 1, lwd = 1.5) # 添加网格 # Add a grid\n\n## 画散点和回归线\n# 在画布中添加一组（肿瘤组）的散点\n## Draw scatter plots and regression line\n# Add one set of scatter plots (tumor group) to the canvas\ntmp1 <- cor.data[which(cor.data$class == \"T\"),]\nreg1 <- lm(dnamage~age, data=tmp1) # 计算回归线 # Calculate the regression line\npoints(tmp1$age, tmp1$dnamage,\n       pch = 19,\n       col = ggplot2::alpha(\"#E51718\",0.8), # 重叠散点透明化 # Make overlapping scatter plots transparent\n       cex = tmp1$size)\nabline(reg1, lwd = 2, col = \"#E51718\") # 添加回归线 # Add the regression line\n\n# 在画布中添加另一组（正常组）的散点\n# Add another set of scatter plots (normal group) to the canvas\ntmp2 <- cor.data[which(cor.data$class == \"N\"),]\nreg2 <- lm(dnamage~age, data=tmp2)\npoints(tmp2$age, tmp2$dnamage,\n       pch = 19,\n       col = ggplot2::alpha(\"#1D2D60\",0.8),\n       cex = tmp2$size)\nabline(reg2, lwd = 2, col = \"#1D2D60\")\n\n# 如果有更多组，就按照以上格式依次添加。\n# If there are more groups, add them one by one according to the above format.\n\n## 画顶部和右侧地毯线\n# 添加边际地毯线显示数据分布情况\n## Draw the top and right rug lines\n# Add marginal rug lines to show data distribution\nrug(cor.data$age, col=\"black\", lwd=1, side=3)\nrug(cor.data$dnamage, col=\"black\", lwd=1, side=4)\n\n## 添加相关性结果\n# 本人不太会用expression和paste的组合，所以是直接写进去的\n# 手动把\"~rho~\" = 后面的数值修改为t.cor和n.cor的数值\n## Add correlation results\n# I'm not very good at using expression and paste, so I just typed it in directly.\n# Manually change the value after \"~rho~\" = to the values of t.cor and n.cor\ntext(20,150, # 根据自己的数据调整位置 # Adjust the position according to your data\n     adj = 0,expression(\"Tumour: N = 252; \"~rho~\" = 0.30; \"~italic(P)~\" < 0.001\"), col = c(\"#E51718\"), cex=1)\ntext(20,140, # 根据自己的数据调整位置 # Adjust the position according to your data\n     adj = 0,expression(\"Normal: N = 200; \"~rho~\" = 0.82; \"~italic(P)~\" < 0.001\"), col = c(\"#1D2D60\"), cex=1)\n\n# 允许绘制超过画布的部分（用于添加图例）\n# Allow drawing beyond the canvas (for adding legends)\npar(xpd = T)\n\n## 画图例\n## Draw legend\n# 做散点的圆圈\n# Make scattered circles\npoints(x = rep(par(\"usr\")[2] + 2.2, num), \n       y = seq(80,60, # 根据自己的数据调整位置 # Adjust the position according to your own data\n               length.out = num),\n       pch = 19,\n       bty = \"n\",\n       cex = sort(unique(cor.data$range2)),\n       col = \"black\")\n\n# 做散点图例的文字\n# Make the text of the scatter plot legend\ntext(x = rep(par(\"usr\")[2] + 3.8, num + 1), y = c(95, seq(80,60,length.out = num)),\n     labels = c(\"Absolute\\nVertical\\nShift\",\n                round(10^(sort(unique(cor.data$range2))) - 1,0)), # 还原对数转化 # Restore logarithmic transformation\n     adj = 0,cex = 0.8)\n\n# 做分组的圆圈（肿瘤和正常）\n# Make grouped circles (tumor and normal)\npoints(x = rep(par(\"usr\")[2] + 2.2, 2), y = c(130, 120),\n       pch = 19,\n       bty = \"n\",\n       cex = 1.8,\n       col = c(\"#E51718\",\"#1D2D60\"))\n\n# 做分组图图例的文字\n# Make legend text for grouped graph\ntext(x = rep(par(\"usr\")[2] + 3.8, num + 1), y = c(130, 120),\n     labels = c(\"Tumour\",\"Normal\"),\n     adj = 0,cex = 0.8)\n\n# 添加画布的边框\n# Add canvas border\npar(new = T, bty=\"o\")\nplot(-1, -1,\n     col = \"white\",\n     xlim = xlim, ylim = ylim,\n     xlab = \"\", ylab = \"\",\n     xaxt = \"n\", yaxt = \"n\")\ninvisible(dev.off())\n# 最终图可在AI里稍加修饰\n# Final plot can be slightly modified in AI\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa163twoVarCor_update_FigureYa163twoVarCor_update",
      "title": "FigureYa163twoVarCor_update/FigureYa163twoVarCor_update.html",
      "html": "FigureYa163twoVarCor_update/FigureYa163twoVarCor_update.html",
      "text": "texts/main_FigureYa163twoVarCor_update_FigureYa163twoVarCor_update.txt",
      "folder": "FigureYa163twoVarCor_update",
      "thumb": "gallery_compress/FigureYa163twoVarCor_update.webp"
    },
    "word_count": 1487,
    "lines_count": 279,
    "title": "FigureYa163twoVarCor_update",
    "description": "Requirement Description 需求一： 绘制多组数据在两个变量上的相关性散点图。",
    "input_data_types": [],
    "output_types": [
      "散点图",
      "统计表格"
    ],
    "technical_methods": [],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "cor1",
      "header",
      "lwd",
      "width",
      "r2",
      "ylim",
      "new",
      "xlim",
      "side"
    ]
  },
  {
    "id": "main_FigureYa245VarDecompose_FigureYa245VarDecompose",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa245VarDecompose_FigureYa245VarDecompose.txt",
    "content": "FigureYa245VarDecompose\nFigureYa245VarDecompose\nAuthor(s)\n: Jianing Gao\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n我想实现这篇文献的Fig.2b，使用RNA-seq来衡量基因的表达保守性。\n基因在物种之间表达量的保守性，想用来分析非编码RNA在不同物种之间的表达保守性。\nRequirement Description\nI would like to draw Fig.2b of this article, using RNA-seq to measure\nthe conserved expression of genes.\nThe conservation of gene expression between species was intended to\nanalyze the expression conservation of non-coding RNAs between\nspecies.\n出自\nhttps://www.nature.com/articles/nature13992\nfrom\nhttps://www.nature.com/articles/nature13992\nFigure 2: Comparative analysis of the gene expression programs in\nhuman and mouse samples.\nb, Gene expression variance decomposition (see Methods) estimates the\nrelative contribution of tissue and species to the observed variance in\ngene expression for each orthologous human–mouse gene pair. Green dots\nindicate genes with\nhigher between-tissue contribution\nand red dots genes with\nhigher between-species\ncontributions\n.\nOur initial analyses revealed that gene expression patterns tended to\ncluster more by species rather than by tissue (Fig. 2a). To resolve the\nsets of genes contributing to different components in the clustering, we\nemployed variance decomposition (see Methods) to estimate, for each\northologous human–mouse gene pair, the proportion of the variance in\nexpression that is contributed by tissue and by species (Fig. 2b). This\nanalysis revealed the sets of genes\nwhose expression varies more\nacross tissues than between species\n, and those\nwhose\nexpression varies more between species than across tissues\n. As\nexpected,\nthe clustering of the RNA-seq samples is dominated\neither by species or tissues\n, depending on the gene set\nemployed (Extended Data Fig. 1a, b). Furthermore, removal of the ~4,800\ngenes that drive the species-specific clustering (see ref. 47,\nSupplementary Fig. 1d therein) or normalization methods that reduce the\nspecies effects reveal tissue-specific patterns of expression in the\nsame samples (Extended Data Fig. 1c).\n作者通过对人和鼠10个不同的组织的转录组数据通过PCA（Fig.2a，画法可参考FigureYa101PCA）评估了基因表达在人鼠之间的保守性，发现样本主要按照物种而不是组织分开，这表明人鼠之间的基因表达差异大于组织之间的差异。随后作者通过方差分解（线性混合模型）计算了组织和物种对基因表达方差的贡献，鉴定出了人鼠表达保守和人鼠表达差异的基因（Fig.2b）。在剔除了人鼠表达差异的基因后，PCA的结果表明样本按照组织而不是物种分布（Extend\nFig.1c）。\nThe authors evaluated the conservation of gene expression between\nhumans and mice by PCA (Fig.2a, see FigureYa101PCA) on transcriptome\ndata from 10 different tissues of humans and mice, and found that the\nsamples were mainly separated by species rather than tissues, indicating\nthat the differences in gene expression between humans and mice were\ngreater than the differences between tissues. The authors then\ncalculated the contribution of tissues and species to the variance of\ngene expression by variance decomposition (linear mixed model) and\nidentified genes with conservative human-mouse expression and\ndifferential human-mouse expression (Fig.2b). After culling the\ndifferentially expressed genes in humans and mice, the results of PCA\nshowed that the samples were distributed by tissue rather than species\n(Extend Fig.1c).\n应用场景\nFig.2b的方法具有普适性，对于研究某基因在物种之间表达的保守性有指导意义。如果某基因的表达水平在人鼠之间不保守，可能提示着该基因突变造成的效应在人鼠之间有差异。此时运用小鼠作为模式生物得到的结论泛化到人上时，需要特别谨慎。\nApplication Scenarios\nFig.2b’s method is universal and has guiding significance for\nstudying the conserved expression of a gene between species. If the\nexpression level of a gene is not conserved between humans and mice, it\nmay indicate that the effects of the gene mutation are different between\nhumans and mice. At this point, special caution is required when\ngeneralizing conclusions from mice as model organisms to humans.\noriginal text：Categorizing orthologous gene pairs into these groups\nshould enable more informative translation of research results between\nmouse and human. In particular, for\ngene pairs whose variance in\nexpression is largest between tissues (and less between species), mouse\nshould be a particularly informative model for human biology\n.\nIn contrast, interpretation of studies involving\ngenes whose\nvariance in expression is larger between species needs to take into\naccount the species variation\n. The relative contributions of\nspecies-specific and tissue-specific factors to each gene’s expression\nare further explored in two associated papers37,47.\n本脚本主要实现了以下功能：\n按照直系同源关系（one2one orthologs）合并人鼠转录组\n数据重构，使之方便应用线性混合模型\n利用并行计算批量对每个基因构建线性混合模型，并计算物种和组织两个随机效应分别对基因表达方差的贡献\n绘图，复现Fig.2b\nThis script implements the following functions:\nMerge the human and mouse transcriptomes according to the\northologous relationship (one2one orthologs).\nData reconstruction to facilitate the application of linear hybrid\nmodels\nParallel computational batches were used to construct a linear mixed\nmodel for each gene, and the contribution of two random effects, species\nand tissue, to the variance of gene expression was calculated\nDrawing, reproduction Fig.2b\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nsuppressPackageStartupMessages({\n  library(tidyverse)\n  library(lme4) # 用于实现linear mixed model (LMM) # Used to implement linear mixed model (LMM)\n})\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # error messages are displayed in English\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # chr is not allowed to be converted to factor\n输入文件\nhuman.tissue.fpkm.rds和mouse.tissue.fpkm.rds，人和鼠各器官的表达矩阵。\nhuman2mouse.ortholog.txt，人和鼠同源基因的对应关系。\nInput files\nhuman.tissue.fpkm.rds and mouse.tissue.fpkm.rds, expression matrices\nof human and mouse organs.\nhuman2mouse.ortholog.txt, correspondence between human and mouse\nhomologous genes.\n# 加载表达矩阵\n# Load the Expression Matrix\nhuman <- readRDS(\"human.tissue.fpkm.rds\")\n#如果你的数据是csv格式，可以这样读取\n# If your data is in csv format, you can read it like this\n#human <- read.csv(\"human.tissue.fpkm.csv\")\nmouse <- readRDS(\"mouse.tissue.fpkm.rds\")\n\n# 加载同源基因对应关系\n# Load homologous gene correspondence\northologs <- read_tsv(\"human2mouse.ortholog.txt\")\nFilter genes:\nGenes with a maximum RPKM greater than 0.1 in each dataset were\nkept.\nkept.rows <- apply(human[, -c(1,2)], 1, max) > 0.1\ntable(kept.rows)\nhuman <- human[kept.rows, ]\nkept.rows <- apply(mouse[, -c(1,2)], 1, max) > 0.1\ntable(kept.rows)\nmouse <- mouse[kept.rows, ]\n1) 按照直系同源关系(one2one orthologs)合并人鼠转录组\n1) Merge human-mouse transcriptomes according to orthologous\nrelationships (one2one orthologs).\nin.human <- orthologs$`Gene stable ID` %in% human$Gene.ID\nin.mouse <- orthologs$`Mouse gene stable ID` %in% mouse$Gene.ID\n# 取人鼠的转录组都检测到的one2one.orthologs\n# Take the transcriptomes of human mice that are detected by one2one.orthologs\northologs <- orthologs[in.human & in.mouse, ]\nhuman <- human %>% filter(Gene.ID %in% orthologs$`Gene stable ID`)\nmouse <- mouse %>% filter(Gene.ID %in% orthologs$`Mouse gene stable ID`)\n\nall(dim(human) == dim(mouse)) # should be TRUE\ncolnames(human) <- paste0(\"Human_\", colnames(human))\ncolnames(mouse) <- paste0(\"Mouse_\", colnames(mouse))\n\n# Order by orthologs\nrownames(human) <- human$Human_Gene.ID\nrownames(mouse) <- mouse$Mouse_Gene.ID\nhuman <- human[orthologs$`Gene stable ID`, ] %>% as_tibble()\nmouse <- mouse[orthologs$`Mouse gene stable ID`, ] %>% as_tibble()\ndata <- cbind(human, mouse)\n2) 数据重构，使之方便应用线性混合模型\n2) Data reconstruction to facilitate the application of linear\nhybrid models\ndata <- data %>% \n  mutate(GenePairs = paste(Human_Gene.Name, Mouse_Gene.Name, sep = \"_\"), .before = 1) %>% \n  select(-contains(\"Gene.\")) %>% \n  pivot_longer(-GenePairs,\n               names_to = c(\"Species\", \"Tissue\"), \n               names_sep = \"_\", \n               values_to = c(\"FPKM\"))\nWe used log10 (RPKM) to normalize the data and a pseudocount of 0.01\nto deal with zero expression values.\ndata$lgFPKM <- log10(data$FPKM + 0.01)\ndata$Tissue <- factor(data$Tissue) # Tissue should be factor for LMM model\ndata$Species <- factor(data$Species) # Species should be factor for LMM model \nhead(data)\n3)\n批量对每个基因构建线性混合模型(LMM)，并计算物种和组织两个随机效应分别对基因表达方差的贡献\n3) Construct a linear mixed model (LMM) for each gene in batches,\nand calculate the contribution of two random effects of species and\ntissue to gene expression variance, respectively\nGene expression was modeled as a function of tissue and the species\n(considered as random factors).\nThe LMM was implemented in the R package lme4 (ref).\nThe restricted maximum likelihood (REML) estimators for the random\neffects of\ntissue, species and residual\nvariance were\nnormalized by their sum to give the variance components (Fig. 2b).\n根据原文描述，LMM模型应该如下: According to the original description,\nthe LMM model should look like this:\nlogFPKM ~ 1 + (1|Tissue) + (1|Species)\n|Dependent variable| |Random Effects (Intercept)| |Random Effects 2\n(Intercept)|\n这里提供两种计算方式，“串行计算”慢，推荐找个服务器运行“并行运算”。\nThere are two computing methods here, “serial computing” is slow, it is\nrecommended to find a server to run “parallel computing”.\n串行计算：大约15min\nSerial calculation: about 15min\ngene.pairs <- unique(data$GenePairs)\n\nlmm.var.dcp <- pbapply::pblapply(gene.pairs, function(xx) {\n  model <- lmer(lgFPKM~1+(1|Tissue)+(1|Species), data = subset(data, GenePairs == xx), REML = TRUE, verbose = FALSE)\n  results <- as.data.frame(VarCorr(model))\n  res <- results$vcov / sum(results$vcov) # normalized by their sum to give the variance components\n  data.frame(\n    GenePairs = xx,\n    frac.of.var.tissue = res[1],\n    frac.of.var.species = res[2],\n    frac.of.var.residual = res[3]\n  )\n}) %>% do.call(rbind, .)\n并行计算(推荐)\nParallel Computing (Recommended)\nrequire(doParallel)\n\n## ==== do parallel start ====\n## apply for 20 workers\n# 设定CPU数量，例如20，取决于你用的服务器 # Set the number of CPUs, e.g. 20, depending on the server you are using\ncl <- makeCluster(20) \nregisterDoParallel(cl)\ngene.pairs <- unique(data$GenePairs)\n\nlmm.var.dcp <- foreach(\n  xx = gene.pairs, \n  .combine = \"rbind\", \n  .packages = c(\"lme4\"),\n  .export = c(\"data\")) %dopar% {\n    model <- lmer(lgFPKM~1+(1|Tissue)+(1|Species), data = subset(data, GenePairs == xx), REML = TRUE, verbose = FALSE)\n    results <- as.data.frame(VarCorr(model))\n    res <- results$vcov / sum(results$vcov)\n    data.frame(\n      GenePairs = xx,\n      frac.of.var.tissue = res[1],\n      frac.of.var.species = res[2],\n      frac.of.var.residual = res[3]\n    )\n  }\n\nhead(lmm.var.dcp)\n开始画图 - Fig.2b\nStart Drawing - Fig.2b\nlmm.var.dcp <- readRDS(\"lmm.var.dcp.rds\")\n\n(top.quantile.tissue <-  quantile(lmm.var.dcp$frac.of.var.tissue)[4])\n(top.quantile.species <- quantile(lmm.var.dcp$frac.of.var.species)[4])\nlmm.var.dcp %>% \n  mutate(group = ifelse(\n    frac.of.var.tissue > top.quantile.tissue & \n      frac.of.var.tissue > frac.of.var.species, \"High across tissues\", \n    ifelse(\n      frac.of.var.species > top.quantile.species & \n        frac.of.var.species > frac.of.var.tissue, \"High across species\", \"None\")\n  )) %>% \n  ggplot(aes(frac.of.var.tissue, frac.of.var.species, color = group)) + \n  geom_point(size = 0.5) + \n  guides(color = guide_legend(override.aes = list(size = 3))) + \n  theme_bw(base_size = 15) + \n  labs(x = \"Fraction of variance across tissues\", \n       y = \"Fraction of variance\\nacross species\") + \n  theme(\n    panel.grid = element_blank(),\n    legend.title = element_blank(),\n    legend.position = c(0.7, 0.85),\n    legend.background = element_blank(),\n    axis.text = element_text(color = \"black\")\n  )\nggsave(\"VarDecompose.pdf\")\n顺便看两个同源基因\n分别画图看一下人鼠之间基因表达水平相对保守/有差异的基因\n在人鼠之间基因表达水平相对保守的基因\nBy the way, look at the two homologous genes\nDraw separate graphs to see genes with relatively\nconserved/differential gene expression levels between humans and\nmice\nGenes with relatively conserved gene expression levels between\nhumans and mice\nExample of genes with higher between-tissue contribution\nsubset(lmm.var.dcp, GenePairs==\"LRRIQ3_Lrriq3\")\ndata %>% filter(GenePairs==\"LRRIQ3_Lrriq3\") %>% \n  ggplot(aes(Tissue, lgFPKM, color=Species)) + \n  geom_point() + \n  geom_text(aes(label=Tissue))\n在人鼠之间基因表达水平有差异的基因\nGenes with differential gene expression levels between humans and\nmice\nExample of genes with higher between-species contribution\nsubset(lmm.var.dcp, GenePairs==\"EMC10_Emc10\")\ndata %>% filter(GenePairs==\"EMC10_Emc10\") %>% \n  ggplot(aes(Tissue, lgFPKM, color=Species)) + \n  geom_point() + \n  geom_text(aes(label=Tissue))\n效果还挺明显 The effect is quite obvious\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa245VarDecompose_FigureYa245VarDecompose",
      "title": "FigureYa245VarDecompose/FigureYa245VarDecompose.html",
      "html": "FigureYa245VarDecompose/FigureYa245VarDecompose.html",
      "text": "texts/main_FigureYa245VarDecompose_FigureYa245VarDecompose.txt",
      "folder": "FigureYa245VarDecompose",
      "thumb": "gallery_compress/FigureYa245VarDecompose.webp"
    },
    "word_count": 1514,
    "lines_count": 304,
    "title": "FigureYa245VarDecompose",
    "description": "我想实现这篇文献的Fig.2b，使用RNA-seq来衡量基因的表达保守性。 基因在物种之间表达量的保守性，想用来分析非编码RNA在不同物种之间的表达保守性。 Requirement Description",
    "input_data_types": [
      "突变数据",
      "临床数据",
      "表达矩阵",
      "RNA-seq"
    ],
    "output_types": [
      "统计表格"
    ],
    "technical_methods": [
      "聚类分析",
      "标准化"
    ],
    "biology_areas": [],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "grid",
      "tissue",
      "REML",
      "before",
      "values_to",
      "group",
      "verbose",
      "GenePairs"
    ]
  },
  {
    "id": "main_FigureYa105GDSC_FigureYa105GDSC",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa105GDSC_FigureYa105GDSC.txt",
    "content": "FigureYa105GDSC\nFigureYa105GDSC\nXiaofan Lu, Taojun Ye\n2025-5-20\n需求描述\n利用pRRophetic算法，根据GDSC<www.cancerrxgene.org/>细胞系表达谱和TCGA基因表达谱构建岭回归模型预测药物IC50（使用原文数据，复现原图）\n提示：pRRophetic的示例可参考：\nhttps://github.com/paulgeeleher/pRRophetic/blob/master/vignetteOutline.pdf\n##Requirement description\nUsing the pRRophetic algorithm, a ridge regression model was\nconstructed based on the expression profiles of\nGDSC<www.cancerrxgene. org/>cell lines and TCGA gene expression\nprofiles to predict drug IC50 (using the original data and reproducing\nthe original image)\nTip: For an example of pRRophetic, please refer to:\nhttps://github.com/paulgeeleher/pRRophetic/blob/master/vignetteOutline.pdf\n出自\nhttps://www.sciencedirect.com/science/article/pii/S1476558619301307\nfrom\nhttps://www.sciencedirect.com/science/article/pii/S1476558619301307\n注意：\n由于包含原文数据，若涉及到注释文件亚型及其他相关数据的使用，请引用：\nLu X, Jiang L, Zhang L, et al. Immune Signature-Based Subtypes of\nCervical Squamous Cell Carcinoma Tightly Associated with Human\nPapillomavirus Type 16 Expression, Molecular Features, and Clinical\nOutcome[J]. Neoplasia, 2019, 21(6): 591-601.\n**Note: * * Due to the inclusion of original data, if it involves the\nuse of annotation file subtypes and other related data, please cite: Lu\nX, Jiang L, Zhang L, et al. Immune Signature-Based Subtypes of Cervical\nSquamous Cell Carcinoma Tightly Associated with Human Papillomavirus\nType 16 Expression, Molecular Features, and Clinical Outcome[J].\nNeoplasia, 2019, 21(6): 591-601.\n应用场景\n预测病人对药物的IC50，画box plot图对比不同分组。\n还可以通过批量计算，筛选出组间差异显著的药物。\n##Application scenarios\nPredict the IC50 of the patient for the drug and draw a box plot to\ncompare different groups.\nIt is also possible to screen drugs with significant differences\nbetween groups through batch calculations.\n环境设置\n使用国内镜像安装包\n##Environment settings\nUse domestic image installation package\noptions(\"repos\"= c(CRAN=\"https://mirrors.tuna.tsinghua.edu.cn/CRAN/\"))\noptions(BioC_mirror=\"http://mirrors.ustc.edu.cn/bioc/\")\nBiocManager::install(c(\"car\", \"ridge\", \"preprocessCore\", \"genefilter\", \"sva\"))\nGDSC数据库里的内容可以用R包pRRophetic来访问和计算。\n上述链接的R包有误，有问题，如要用pRRophetic包请用果子公众号更新维护版本\nhttps://github.com/ixxmu/mp_duty/issues/2691\n#The R package of the above link is incorrect. If you want to use the\npRRophic package, please update the maintenance version with the fruit\nofficial account<\nhttps://github.com/ixxmu/mp_duty/issues/2691\n>\n加载包\nThe content in the GDSC database can be accessed and calculated using\nthe R package pRRophetic.\nClick on the link to download pRRophetic_0.5.tar.gz:<\nhttps://osf.io/dwzce/?action=download\n>Then install\nit locally.\nLoad Package\ninstall.packages(\"./pRRophetic 2/resource/pRRophetic_Guozi/\", repos = NULL,type = \"source\")\n# 加载pRRophetic包，用于药物反应预测和分析\n# Load the pRRophetic package for drug response prediction and analysis\nlibrary(pRRophetic)\n# 加载ggplot2包，用于创建优雅的统计图形\n# Load the ggplot2 package for creating elegant statistical graphics\nlibrary(ggplot2)\n\n# 加载cowplot包，用于组合和排列ggplot图形\n# Load the cowplot package for combining and arranging ggplot graphics\nlibrary(cowplot)\n\n# 设置环境语言为英文，使报错信息以英文显示\n# Set the environment language to English to display error messages in English\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止字符串自动转换为因子，保持数据原始格式\n# Disable automatic conversion of strings to factors to maintain original data format\noptions(stringsAsFactors = FALSE)\n输入文件\n需要三个文件：表达数据、分组信息和药物名字，前两个文件的sample\nID必须一致。\neasy_input_expr.txt，基因表达矩阵。\neasy_input_anno.txt，分组信息。示例数据里的C1和C2分别对应”HPV16-IMM”和”HPV16-KRT”。也可以是按某个基因的突变类型分组、或按某个基因表达量高低分组。\ndrug.txt，要计算和画图的药物的名字，药物名必须存在与GDSC数据库中。\n具体选哪个药物呢？\n可以基于背景知识来选择合适的药物，就像例文那样；也可以批量筛选组间差异显著的药物做深入研究。\ngetCGPinfo函数内部是2016版药物的名字，共251种；GDSC数据库的网站上2019版的药物名字有266种：\nhttps://www.cancerrxgene.org/translation/Drug#t-all\n；然而pRRopheticPredict函数的drug参数the\nname of the drug for which you would like to predict sensitivity, one\nof…，其中的药物名字只有138个，下面就对这138种药物进行计算和画图。把pRRopheticPredict函数的drug参数中的药物整理后保存在drug.txt文件中。\n##Input file\nThree files are required: expression data, grouping information, and\ndrug names. The sample IDs of the first two files must be\nconsistent.\neasy_input_expr.txt， Gene expression matrix.\neasy_input_anno.txt， Grouping information. C1 and C2 in the example\ndata correspond to “HPV16-IMM” and “HPV16-KRT”, respectively. It can\nalso be grouped according to the mutation type of a certain gene, or\naccording to the high or low expression level of a certain gene.\ndrug.txt， To calculate and plot the names of drugs, the drug names\nmust exist in the GDSC database.\nWhich medication should be\nchosen specifically?\nSuitable drugs can be selected based on\nbackground knowledge, as in the example text; It is also possible to\nconduct in-depth research by batch screening drugs with significant\ndifferences between groups.\nThe getCGPinfo function contains the names of 251 drugs from the 2016\nversion; On the website of GDSC database, there are 266 drug names in\nthe 2019 version:<\nhttps://www.cancerrxgene.org/translation/Drug#t\n-all>； However, the drug parameter of the pRRopheticRedis function\nthe name of the drug for which you would like to predict sensitivity,\none of…， There are only 138 drug names among them. Below, we will\ncalculate and plot these 138 drugs. Sort and save the drugs in the drug\nparameter of the pRRopheticRedis function in the drug.exe file.\n# 读取表达矩阵数据，假设文件格式为制表符分隔，第一列作为行名，第一行为列名\n# Read expression matrix data, assuming tab-separated format with row names in first column and column names in first row\ndat <- read.table(\"easy_input_expr.txt\",sep = \"\\t\",row.names = 1,header = T,stringsAsFactors = F,check.names = F)\n\n# 查看表达矩阵前3行和前3列，用于数据质量检查\n# View the first 3 rows and 3 columns of the expression matrix for data quality check\ndat[1:3, 1:3]\n# 读取样本分组信息，假设文件格式为制表符分隔，第一列作为行名，第一行为列名\n# Read sample annotation data, assuming tab-separated format with row names in first column and column names in first row\nann <- read.table(\"easy_input_anno.txt\",sep = \"\\t\",row.names = 1,header = T,stringsAsFactors = F,check.names = F)\n\n# 查看分组信息的前几行，了解数据结构\n# View the first few rows of annotation data to understand its structure\nhead(ann)\n# 统计每个免疫聚类(ImmClust)的样本数量，了解样本分布\n# Count the number of samples in each immune cluster (ImmClust) to understand sample distribution\ntable(ann$ImmClust)\n# 读取待分析的药物名称列表\n# Read the list of drug names to be analyzed\nGCP.drug <- read.table(\"drug.txt\") # 如果要使用例文中的两种药物，可替换为drug_eg.txt\n\n# 提取药物名称所在列的数据\n# Extract drug names from the first column of the data frame\nGCP.drug <- GCP.drug$V1\n\n# 选择前12种药物进行分析，可根据需要调整\n# Select the first 12 drugs for analysis, adjust as needed\nGCP.drug <- GCP.drug[1:12]\n药物敏感性预测和画图\n##Drug sensitivity prediction and plotting\n# 自定义足够多的box颜色，颜色数量至少等于分组数量\n# Customize enough colors for the boxplots, the number of colors should be at least equal to the number of groups\njco <- c(\"#EABF00\", \"#2874C5\", \"red\")\n\n### 药物敏感性预测 ###\n# Initialize lists to store results and plots\nGCPinfo <- GCP.IC50 <- GCP.expr <- cvOut <- predictedPtype <- predictedBoxdat <- list()\nplotp <- list()\n\nfor (drug in GCP.drug) {\n  # 设置随机种子，确保结果可重复\n  # Set random seed for reproducibility, especially for the 10-fold cross-validation in prediction\n  set.seed(1248103) \n  \n  # 提示当前药物分析开始\n  # Print message indicating start of analysis for current drug\n  cat(drug,\" starts!\\n\") \n  \n  # 预测IC50值，使用pRRophetic包的默认参数\n  # Predict IC50 values using pRRophetic with default parameters\n  testMatrix <- as.matrix(dat[,rownames(ann)])\n  predictedPtype[[drug]] <- pRRopheticPredict(testMatrix = testMatrix,\n                                              drug = drug,\n                                              tissueType = \"allSolidTumors\",\n                                              selection = 1) # 1表示若有重复基因取均值处理\n                                              # 1 indicates averaging duplicate genes if present\n  \n  # 检查预测结果与样本注释的名称是否匹配\n  # Check if the names in prediction results match the annotation data\n  if(!all(names(predictedPtype[[drug]])==rownames(ann))) {stop(\"Name mismatched!\\n\")}\n  \n  # 准备用于绘制箱线图的数据框\n  # Prepare data frame for boxplot visualization\n  predictedBoxdat[[drug]] <- data.frame(\"est.ic50\"=predictedPtype[[drug]],\n                                        \"ImmClust\"=ifelse(ann$ImmClust == \"C1\",\"HPV16-IMM\",\"HPV16-KRT\"), \n                                        row.names = names(predictedPtype[[drug]])) \n  \n  # 将免疫聚类转换为有序因子变量\n  # Convert ImmClust to an ordered factor for proper plotting\n  predictedBoxdat[[drug]]$ImmClust <- factor(predictedBoxdat[[drug]]$ImmClust,\n                                            levels = c(\"HPV16-IMM\",\"HPV16-KRT\"),\n                                            ordered = T)\n  \n  # 使用ggplot2绘制箱线图\n  # Create boxplot using ggplot2\n  p <- ggplot(data = predictedBoxdat[[drug]], aes(x=ImmClust, y=est.ic50))\n  p <- p + geom_boxplot(aes(fill = ImmClust)) + \n    scale_fill_manual(values = jco[1:length(unique(ann$ImmClust))]) + # 自定义box的配色\n                                                       # Customize box colors\n    theme(legend.position=\"none\") + # 不显示图例\n                                   # Remove legend\n    theme(axis.text.x = element_text(angle = 45, hjust = 1,size = 12), # 倾斜x轴标签\n                                                                 # Rotate x-axis labels\n          plot.title = element_text(size = 12, hjust = 0.5)) +  # 居中标题\n                                                                 # Center plot title\n    xlab(\"\") + ylab(\"Estimated IC50\") +  # 设置坐标轴标签\n                                         # Set axis labels\n    ggtitle(drug) # 添加药物名称作为标题\n                  # Add drug name as title\n  \n  # 保存每个药物的箱线图到列表\n  # Save each plot to a list for later combination\n  plotp[[drug]] <- p\n  \n  # 提示当前药物分析完成\n  # Print message indicating completion of analysis for current drug\n  cat(drug,\" has been finished!\\n\")\n}\n# 合并图片 - 适合展示两种药物\n# Combine plots - suitable for displaying two drugs\np1 <- plot_grid(plotp[[1]],plotp[[2]],labels = c(\"A\",\"B\"),nrow = 1) \nggsave(\"boxplot of predicted IC50.pdf\", width = 6, height = 5)\n\n# 适合展示多种药物\n# Combine plots - suitable for displaying multiple drugs\np2 <- plot_grid(plotlist=plotp, ncol=6)\nggsave(\"boxplot of predicted IC50_multiple.pdf\", width = 12, height = 6)\n检验组间差异\n##Test group differences\n# 初始化向量存储每种药物的Wilcoxon检验p值（中文注释）\n# Initialize vector to store Wilcoxon test p-values for each drug (English comment)\np <- vector()\n\n# 对每种药物进行Wilcoxon秩和检验，比较HPV16-IMM和HPV16-KRT免疫聚类组的估计IC50值（中文注释）\n# Perform Wilcoxon rank-sum test for each drug to compare estimated IC50 values between \n# HPV16-IMM and HPV16-KRT immune clusters (English comment)\nfor (drug in GCP.drug) {\n  # 提取HPV16-IMM免疫聚类组的估计IC50值（中文注释）\n  # Extract estimated IC50 values for HPV16-IMM immune cluster (English comment)\n  group1 <- as.numeric(predictedBoxdat[[drug]][which(predictedBoxdat[[drug]]$ImmClust %in% \"HPV16-IMM\"), \"est.ic50\"])\n  \n  # 提取HPV16-KRT免疫聚类组的估计IC50值（中文注释）\n  # Extract estimated IC50 values for HPV16-KRT immune cluster (English comment)\n  group2 <- as.numeric(predictedBoxdat[[drug]][which(predictedBoxdat[[drug]]$ImmClust %in% \"HPV16-KRT\"), \"est.ic50\"])\n  \n  # 执行单侧Wilcoxon秩和检验，检验假设：HPV16-IMM组的IC50值低于HPV16-KRT组（中文注释）\n  # Perform one-sided Wilcoxon rank-sum test with the hypothesis that \n  # the IC50 values of HPV16-IMM group are lower than those of HPV16-KRT group (English comment)\n  tmp <- wilcox.test(group1, group2, alternative = \"less\")$p.value\n  \n  # 将p值添加到结果向量中（中文注释）\n  # Append the p-value to the result vector (English comment)\n  p <- append(p, tmp)\n}\n\n# 为结果向量添加药物名称作为标签（中文注释）\n# Add drug names as labels to the result vector (English comment)\nnames(p) <- GCP.drug\n\n# 打印所有药物的p值（中文注释）\n# Print p-values for all drugs (English comment)\nprint(p)\n# 注释：由于存在不显著的结果，此处未将p值添加到箱线图上（中文注释）\n# Note: Since there are non-significant results, p-values are not added to the boxplot here (English comment)\n# 可根据需要将p值添加到ggplot的标题中，或参考FigureYa12box函数直接绘制在图上（中文注释）\n# They can be added to the title of a ggplot or directly plotted on the figure \n# by referring to the FigureYa12box function if needed (English comment)\n\n# 将p值保存到文本文件（中文注释）\n# Save p-values to a text file (English comment)\nwrite.table(p, \"output_pvalue.txt\", quote = F, sep = \"\\t\")\n打开output_pvalue.txt文件，从中挑选合适的药物，把名字写在”drug.txt”文件里，就可以只对这些药物计算和画图了。\nOpen the output _pvalue. txt file, select the appropriate medication\nfrom it, write the name in the “drug. txt” file, and you can calculate\nand draw only for these medications.\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa105GDSC_FigureYa105GDSC",
      "title": "FigureYa105GDSC/FigureYa105GDSC.html",
      "html": "FigureYa105GDSC/FigureYa105GDSC.html",
      "text": "texts/main_FigureYa105GDSC_FigureYa105GDSC.txt",
      "folder": "FigureYa105GDSC",
      "thumb": "gallery_compress/FigureYa105GDSC.webp"
    },
    "word_count": 1409,
    "lines_count": 277,
    "title": "FigureYa105GDSC",
    "description": "利用pRRophetic算法，根据GDSC<www.cancerrxgene.org/>细胞系表达谱和TCGA基因表达谱构建岭回归模型预测药物IC50（使用原文数据，复现原图） 提示：pRRophetic的示例可参考： https://github.com/paulgeeleher/pRRophetic/blob/master/vignetteOutline.pdf",
    "input_data_types": [
      "临床数据",
      "表达矩阵",
      "突变数据"
    ],
    "output_types": [
      "箱线图",
      "统计表格"
    ],
    "technical_methods": [
      "聚类分析",
      "生存分析",
      "质量控制"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学",
      "药物研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "drug",
      "values",
      "header",
      "repos",
      "width",
      "pvalue",
      "nrow",
      "labels",
      "ordered"
    ]
  },
  {
    "id": "main_FigureYa283vennyPvalue_FigureYa283vennyPvalue",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa283vennyPvalue_FigureYa283vennyPvalue.txt",
    "content": "FigureYa283vennyPvalue\nFigureYa283vennyPvalue\nAuthor(s)\n: Xiaofan Lu; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirements Description\n主要是不知道这个韦恩图的p值是怎么实现的（exact test of multiset\nintersections）。\nThe P value below the Venn diagram is associated with the\nintersection (exact test of multiset intersections).\n出自\nhttps://www.nature.com/articles/s41588-022-01047-6\n图1 | 体内外三阴性乳腺癌中基底态持久细胞群的鉴定。\nd. 图展示了三种PDX模型持久细胞中激活通路的交集情况（左），数据来源于MSicDB数据库的c2_curated（乳腺/乳房相关通路）和c7_Hallmark（特征基因集）两个分类。维恩图下方的P值代表该交集具有统计学显著性（基于多重集交集的精确检验）。条形图（右）显示了持久细胞中激活程度最高的五个通路（每个分类各选前五），横坐标对应PDX_95模型的-log10\nq值。\nSource:\nhttps://www.nature.com/articles/s41588-022-01047-6\nFig. 1 | identification of a pool of basal persister cells in TNBC in\nvivo and in vitro. d, Venn diagram displaying the intersection of\npathways activated in persister cells from the three PDX models, among\nMSigDB c2_curated Breast/Mammary and c7_Hallmark pathways (left). The P\nvalue below the Venn diagram is associated with the intersection (exact\ntest of multiset intersections). Barplot displaying the top five\npathways (for each category) activated in persister cells (right). The x\naxis corresponds to –log10 q-values for the model PDX_95.\n应用场景\nApplication Scenario\n韦恩图及p值计算（基于多个数据集交集精确检验，Exact test of multiset\nintersect）\nVenn diagram and p-value calculation (exact test of multiset\nintersections)\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\n# 加载韦恩图画图软件包“VennDiagram”\n# For drawing Venn diagrams\nlibrary(VennDiagram)\n# 加载可求多个交集精确检验P值的软件包\n# For calculating exact p-values of multiset intersections\nlibrary(SuperExactTest)\n# 显示英文报错信息\n# Display English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character conversion to factor\noptions(stringsAsFactors = FALSE)\n输入文件\nInput Files\neasy_input.txt，每个数据集为一列。这里以3个为例，可以有更多个数据集。\neasy_input.txt, each dataset as a column. Here we use 3 as example,\ncan have more datasets.\n# 读入测试数据 (这里为了简单演示，由26个英文字母生成三个数据集)\n# Read test data (here using 26 letters to generate 3 datasets for demonstration)\ndat <- read.table(\"easy_input.txt\",sep = \"\\t\", header = T, stringsAsFactors = F,check.names = F) \n\n# 转化为列表数据类型\n# Convert to list data type\ndat <- as.list(dat) \nn.bk <- length(unique(unlist(dat)))\n计算p value\nCalculate p-value\n输出多个数据集重叠显著P值，基于软件包“SuperExactTest”中MSET函数:\nCalculate FE and significance of intersection among multiple sets.\n参考文献 Wang, M., Zhao, Y., & Zhang, B. (2015). Efficient test\nand visualization of multi-set intersections. Scientific reports, 5(1),\n1-12.\nCalculate p-value for multiple dataset overlaps using MSET function\nfrom “SuperExactTest” package.\nReference: Wang, M., Zhao, Y., & Zhang, B. (2015). Efficient test\nand visualization of multi-set intersections. Scientific reports, 5(1),\n1-12.\n# x为定义的列表数据。n为背景群体数量，如基因总数，或这里的总的英文字母数26。lower.tail=FALSE表示计算上侧拖尾P值(统计量大于一个观察到的值概率)，即这里要计算的多个数据集重叠显著P值。\n# x is the defined list data. n is the background population size, such as total number of genes, or here the total number of English letters (26). lower.tail=FALSE means calculating the upper tail p-value (probability that the statistic is greater than an observed value), which is the significant overlap p-value we want to calculate for multiple datasets.\nmset.res <- MSET(x = dat, \n                 n = 26, \n                 lower.tail = FALSE) \np.value <- mset.res$p.value\n\n# 打印pvalue\n# Print p-value\np.value\n画venn图\nDraw Venn diagram\n个人比较推荐采用在线工具绘制scale后的韦恩图，方便快捷可编辑，可尝试以下链接：\nhttp://bioinformatics.psb.ugent.be/webtools/Venn/\nhttp://bioinfogp.cnb.csic.es/tools/venny/index.html\n这里用R画，用的是VennDiagram包。\n还可以用ggVennDiagram包，标注各区域百分比，并且按百分比填充颜色，可参考FigureYa112Plus_venn。\n如果有>=5个数据集，可尝试eulerr\nhttps://cran.r-project.org/web/packages/eulerr/vignettes/venn-diagrams.html\n或nVennR包\nhttps://cran.r-project.org/web/packages/nVennR/vignettes/nVennR.html\nPersonally recommend using online tools for scaled Venn diagrams,\neasy and editable:\nhttp://bioinformatics.psb.ugent.be/webtools/Venn/\nhttp://bioinfogp.cnb.csic.es/tools/venny/index.html\nHere we use R with VennDiagram package. Can also use ggVennDiagram\npackage to show percentages and color by percentage, see\nFigureYa112Plus_venn. For >=5 datasets, try eulerr\nhttps://cran.r-project.org/web/packages/eulerr/vignettes/venn-diagrams.html\nor nVennR\nhttps://cran.r-project.org/web/packages/nVennR/vignettes/nVennR.html\n# 创建韦恩图对象\n# Create Venn diagram object \nvenn <- venn.diagram(x = dat, \n                     filename = NULL, \n                     fill = c('red','steelblue','yellow'))\n\n# 初始化新图形页面\n# Initialize new graphics page \ngrid.newpage()\n\n# 渲染韦恩图\n# Render the Venn diagram  \ngrid.draw(venn)\n# 导出PDF文件（5x5英寸）\n# Export to PDF (5x5 inches) \ndev.copy2pdf(file = \"venny.pdf\", width = 5, height = 5)\n会话信息\nSession Info\n# 显示会话信息\n# Show session information\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa283vennyPvalue_FigureYa283vennyPvalue",
      "title": "FigureYa283vennyPvalue/FigureYa283vennyPvalue.html",
      "html": "FigureYa283vennyPvalue/FigureYa283vennyPvalue.html",
      "text": "texts/main_FigureYa283vennyPvalue_FigureYa283vennyPvalue.txt",
      "folder": "FigureYa283vennyPvalue",
      "thumb": "gallery_compress/FigureYa283vennyPvalue.webp"
    },
    "word_count": 565,
    "lines_count": 135,
    "title": "FigureYa283vennyPvalue",
    "description": "Requirements Description 主要是不知道这个韦恩图的p值是怎么实现的（exact test of multiset intersections）。",
    "input_data_types": [],
    "output_types": [
      "统计表格"
    ],
    "technical_methods": [
      "通路分析"
    ],
    "biology_areas": [],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "LANGUAGE",
      "stringsAsFactors",
      "x",
      "tail",
      "header",
      "width",
      "n",
      "pvalue",
      "names"
    ]
  },
  {
    "id": "main_FigureYa28color_FigureYa28color",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa28color_FigureYa28color.txt",
    "content": "FigureYa28 color\nFigureYa28 color\nYing Ge; Yijing Chen\n2025-5-20\n需求描述\nrequirement description\n虽然有那么多调色板：\nhttps://www.nceas.ucsb.edu/~frazier/RSpatialGuides/colorPaletteCheatsheet.pdf\n还有那么多配色方案：\nhttps://cran.r-project.org/web/packages/ggsci/vignettes/ggsci.html\n当我为paper结果图选颜色时，还是会对自己的审美不自信。\n那就模仿你（或者你老板）心仪的paper的配色方案吧！\nAlthough there are so many palettes:\nhttps://www.nceas.ucsb.edu/~frazier/RSpatialGuides/colorPaletteCheatsheet.pdf\nAnd so many color schemes:\nhttps://cran.r-project.org/web/packages/ggsci/vignettes/ggsci.html\nI still get unsure of my own aesthetic when it comes to picking\ncolors for the paper results chart.\nThen mimic the color scheme of your (or your boss’s) preferred\npaper!\n应用场景\napplication scenario\n本套代码要做的就是从你心仪的paper里提取它的配色方案。\n如果你需要大量的颜色，那就选一篇颜色丰富的paper。\nWhat this code is going to do is extract its color scheme from your\npreferred paper.\nIf you need a lot of colors, then pick a colorful paper.\n环境设置\nenvironment setting\n用到Y叔推荐的\nrPlotter\n包\nhttps://mp.weixin.qq.com/s/ZrS8IQOMSwx9R3006HYryA\n，先安装它\nUse the\nrPlotter\npackage recommended by Uncle Y\nhttps://mp.weixin.qq.com/s/ZrS8IQOMSwx9R3006HYryA\n,\ninstall it first\n#使用国内镜像安装包\n#use the domestic mirror installation package\n#options(\"repos\"= c(CRAN=\"https://mirrors.tuna.tsinghua.edu.cn/CRAN/\"))\n#options(BioC_mirror=\"http://mirrors.ustc.edu.cn/bioc/\")\n\ninstall.packages(c(\"ggplot2\", \"stringr\", \"reshape2\", \"dichromat\"))\ninstall(\"EBImage\")\n\nlibrary(devtools)\ninstall_github(\"ramnathv/rblocks\")\ninstall_github(\"woobe/rPlotter\")\nlibrary(rPlotter)\nlibrary(scales)\n\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 display English error messages\noptions(stringsAsFactors = FALSE) #禁止chr转成factor prohibit the conversion of chr to factor\n提取颜色\nExtract color\n提取Figure 2的颜色\nExtract the color of Figure 2\n此处以\nhttps://www.nature.com/articles/nature22973\n这篇paper为例，提取正文Figure的颜色\n同一篇paper里的图通常会使用同一套配色方案，这样全文看起来才协调。\n因此，通常挑选其中最具代表性的1个Figure提取颜色就够了，例文的Figure\n2最为典型。\nUse this paper\nhttps://www.nature.com/articles/nature22973\nas an\nexample to extract the colors of the figure in the main text.\nFigures in the same paper usually use the same color scheme, so that\nthe whole text looks coherent.\nTherefore, it is usually enough to select one of the most\nrepresentative Figure to extract the color, Figure 2 of the example\npaper is the most typical.\n#其中`num_col =`参数默认值是5，此处设置为30，提取30种颜色\n#the default value of the `num_col =` parameter is 5, which is set to 30 to extract 30 colors\nmycol<-extract_colours(\"nature22973-f2.jpg\", num_col = 30) \nmycol\n#展示颜色\n#show colors\nlibrary(\"scales\")\nshow_col(mycol)\n#保存颜色和代码到PDF文件，制作配色卡\n#save colors and codes to PDF files to make color cards\npdf(\"Fig2.pdf\")\nshow_col(mycol)\ndev.off()\n#保存颜色代码到文本文件\n#save color codes to a text file\nwrite.table(mycol,\"Fig2.txt\",row.names = F,col.names = F)\n提取\nFigure 2 - 6\n的颜色\nExtract the colors of\nFigure 2 - 6\n如果你不满足于一个图的颜色，还可以一步提取全文所有图的颜色。\nPaper里的Figure地址都是有规律可循的，拿到一个Figure的地址，就能推测出其他Figure的地址。\n找到地址的规律，就可以用\nfor\n循环提取所有Figure的颜色。\nIf you are not satisfied with the color of one figure, you can also\nextract the color of all the figures in the full text in one step.\nThe addresses of the Figures in Paper are regular, and by getting the\naddress of one Figure, you can infer the addresses of other Figures.\nFinding the pattern of addresses, you can use\nfor\nloop\nto extract the colors of all Figures.\nallcol<-list()\nfor (i in 1:6){\n  #fig<-paste0(\"https://media.nature.com/lw926/nature-assets/nature/journal/v547/n7663/images/nature22973-f\",i,\".jpg\")\n  #如果网速慢，或者没有在线打开的权限，就提前把图片保存在当前目录\n  #从当前目录读取图片文件\n  #If you have a slow internet connection or don't have access to open it online, save the image in the current directory in advance\n  #Read the image file from the current directory\n  fig<-paste0(\"nature22973-f\",i,\".jpg\") \n  allcol<-append(allcol,extract_colours(fig, num_col = 30))\n}\n\n#去除重复出现的颜色\n#remove recurring colors\nallcol<-base::unique(unlist(allcol))  \n\n#颜色排序\n#color Sorting\nallcol<-allcol[order(allcol)]\n\n#展示颜色\n#show colors\nshow_col(allcol)\n颜色多了，用一维展示看起来乱，用三维展示，需要复制到Console里运行才能看到\n玩得开心！\nThere are so many colors that it looks messy with a one-dimensional\ndisplay, and with a three-dimensional display, you need to copy it and\nrun it in Console to see it\nHave fun!\n#转换为RGB\n#convert to RGB\nallcol_rgb<-data.frame(t(col2rgb(allcol)))\nallcol_rgb$col<-allcol\n\n#install.packages(\"rgl\")\nlibrary(rgl)\nplot3d(allcol_rgb$red,allcol_rgb$green,allcol_rgb$blue,\n       xlab = \"red\",ylab = \"green\",zlab = \"blue\",\n       col = allcol_rgb$col,\n       type = \"s\",\n       size = 0.75,\n       lit = F)\n\n#保存颜色\n#save colors\nwrite.table(allcol,\"allcol.txt\",row.names = F,col.names = F)\n增减颜色\nadd or subtract colors\n增加过渡色。为了产生同一色系，让画图效果更协调，有时会在几种颜色中间添加过渡色。\nAdd transition colors. In order to produce a homogeneous color\nscheme and to make the drawing more coherent, transition colors are\nsometimes added between several colors.\n#例如，想用mycol的前4个颜色：\n#For example, you want to use the first 4 colors of mycol:\nshow_col(mycol[1:4])\n#需要扩展成8种颜色\n#need to expand to 8 colors\nmycol_plus<-colorRampPalette(mycol[1:4],alpha=TRUE)(8)\nshow_col(mycol_plus)\n#保存颜色\n#save colors\nwrite.table(mycol_plus,\"Fig2_plus.txt\",row.names = F,col.names = F)\n缩减颜色。如果只想要其中一部分颜色，可以手动编辑”allcol.txt”文件，还可以用上面的方法抽取部分颜色。\nSubtract colors. If you only want some of the colors, you can\nmanually edit the “allcol.txt” file, or you can extract some of the\ncolors using the method above.\n#例如，allcol颜色太多，只抽取50个颜色\n#For example, allcol has too many colors and only 50 colors are extracted\nallcol_minus<-colorRampPalette(allcol,alpha=TRUE)(50)\nshow_col(allcol_minus)\n#保存颜色\n#save colors\nwrite.table(allcol_minus,\"allcol_minus.txt\",row.names = F,col.names = F)\n颜色的用法\nColor usage\n上面获得的\nmycol\n就可以用到其他的画图代码中\nThe\nmycol\nobtained above can be used in other drawing\ncode.\n用法一\nUsage one\n替换代码中的自定义颜色，例如\nFigureYa3 genomeView\n、\nFigureYa24 ROC\n，\nFigureYa25 Sankey\n，\nFigureYa26 circos_R\n，\nFigureYa27 t-SNE\n。\n在画图代码中找到\nmycol<-\n那一行，在\nFigureYa3 genomeView\n里是\ncolpal<-\n，在\nFigureYa26 circos_R\n里是\nbgcol<-\n。用下面这三行替换它：\nReplace custom colors in code such as\nFigureYa3 genomeView\n,\nFigureYa24 ROC\n,\nFigureYa25 Sankey\n,\nFigureYa26 circos_R\n,\nFigureYa27 t-SNE\n.\nFind the line\nmycol<-\nin the drawing code,\ncolpal<-\nin\nFigureYa3 genomeView\n, and\nbgcol<-\nin\nFigureYa26 circos_R\n. Replace it\nwith the following three lines:\nmycol <- read.table(\"Fig2.txt\")#此处使用Figure 2的颜色 the colors from Figure 2 are used here\nmycol <- as.character(mycol$V1)\nmycol\n用法二\nUsage two\n定义单个颜色，例如\nFigureYa1 survivalCurve\n、\nFigureYa9 heatmap\n、\nFigureYa5 bubbles\n在画图代码中找到类似下面这样的语句：\nDefine individual color, e.g.\nFigureYa1 survivalCurve\n,\nFigureYa9 heatmap\n,\nFigureYa5 bubbles\n.\nFind a statement like the following in the drawing code:\npalette <- c(\"red\",\"blue\")\n#或者\n#or\ncolours <- c(\"#2381B3\",\"#F0E366\")\n#或者\n#or\nmycol <- c(\"#223D6C\",\"#D20A13\",\"#088247\",\"#FFD121\",\"#11AA4D\",\"#58CDD9\",\"#7A142C\",\"#5D90BA\",\"#431A3D\",\"#91612D\",\"#6E568C\",\"#E0367A\",\"#D8D155\",\"#64495D\",\"#7CC767\")\n用你喜欢的颜色代码替换括号里的颜色代码。\nReplace the color code in the parentheses with your preferred color\ncode.\n用法三\nUsage three\n有几套代码的颜色写在输入文件中，修改输入文件中的颜色，例如\nFigureYa8 RadarChart\n、\nFigureYa10 chromosome\n、\nFigureYa26 circos_R\n。\n打开输入文件，找到颜色列，用你喜欢的颜色代码替换原来的颜色，注意去掉\n#\n符号\nThere are several sets of codes with colors written in the input\nfile, modify the colors in the input file, for example\nFigureYa8 RadarChart\n,\nFigureYa10 chromosome\n,\nFigureYa26 circos_R\n.\nOpen the input file, find the color column and replace the original\ncolor with your preferred color code, taking care to remove the\n#\nsymbol.\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa28color_FigureYa28color",
      "title": "FigureYa28color/FigureYa28color.html",
      "html": "FigureYa28color/FigureYa28color.html",
      "text": "texts/main_FigureYa28color_FigureYa28color.txt",
      "folder": "FigureYa28color",
      "thumb": "gallery_compress/FigureYa28color.webp"
    },
    "word_count": 878,
    "lines_count": 292,
    "title": "FigureYa28 color",
    "description": "requirement description 虽然有那么多调色板： https://www.nceas.ucsb.edu/~frazier/RSpatialGuides/colorPaletteCheatsheet.pdf",
    "input_data_types": [
      "生存数据"
    ],
    "output_types": [
      "热图",
      "统计表格",
      "生存曲线"
    ],
    "technical_methods": [],
    "biology_areas": [],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "zlab",
      "LANGUAGE",
      "",
      "stringsAsFactors",
      "col",
      "CRAN",
      "ylab",
      "size",
      "lit",
      "BioC_mirror"
    ]
  },
  {
    "id": "main_FigureYa114ternaryCluster_FigureYa114ternaryCluster",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa114ternaryCluster_FigureYa114ternaryCluster.txt",
    "content": "FigureYa114ternaryCluster\nFigureYa114ternaryCluster\nAuthor(s)\n: Xiaofan Lu, Taojun Ye\nReviewer(s)\n: Ying Ge\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n仅对某感兴趣通路做聚类分析，同时纳入正常样本表达水平的考虑，来挖掘癌症样本异质性。大神丢的文章能解决我的问题，想画下面这个图\nRequirement description\nPerform cluster analysis only on a specific pathway of interest,\nwhile considering the expression level of normal samples, to explore\ncancer sample heterogeneity. The article lost by the great god can solve\nmy problem. I would like to draw the following image\n出自\nhttps://www.gastrojournal.org/article/S0016-5085(17)36144-9/abstract\nFrom\nhttps://www.gastrojournal.org/article/S0016-5085(17)36144-9/abstract\n应用场景\n在一组样本中某个geneset表达谱变异很大时，展示这个geneset的所有基因表达异质性。\n同时还能根据这个geneset的基因表达谱对样本进行分组。分组结果可尝试用于解释样本的另一个性状或临床指标（如预后）的差异，最终证明该geneset与样本性状或临床指标的关联。\nApplication scenarios\nWhen there is significant variation in the expression profile of a\ncertain gene set in a set of samples, display all gene expression\nheterogeneity of this gene set.\nAt the same time, samples can be grouped based on the gene expression\nprofile of this geneset. The grouping results can be attempted to\nexplain the differences in another trait or clinical indicator (such as\nprognosis) of the sample, ultimately proving the association between the\ngeneset and the sample trait or clinical indicator.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nlibrary(GSVA)\nlibrary(pheatmap)\nlibrary(gplots)\n# 设置英文报错信息\n# Set error messages to English\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr自动转换为factor\n# Disable automatic conversion of character to factor\noptions(stringsAsFactors = FALSE)\n参数设置\nParameter settings\n# 表达矩阵前多少列来自肿瘤样本\n# Number of columns in the expression matrix from tumor samples\ntumornumber <- 147 \n\n# 表达矩阵后多少列来自正常样本\n# Number of columns in the expression matrix from normal samples\nnormalnumber <- 50 \n\n# 特征名称（如信号通路名称）\n# Name of the signature (e.g., pathway name)\nsignaturename <- \"TGFB\" \n\n# 设置基因分类阈值，用于判断基因的表达状态\n# Threshold for gene classification to determine expression status\nhalfwidth <- 0.025\n\n# 样本分类个数\n# Number of sample clusters\nClusterNumber <- 4\n\n# 样本类对应颜色\n# Colors corresponding to each sample cluster\nClusterColor = c(\"#B31E22\",\"#529B40\",\"#020105\",\"#383D8E\")\n读取输入文件\n需要两个输入文件：基因表达矩阵和感兴趣的基因通路\neasy_input_expr.csv，文章作者提供的32189*197基因表达矩阵(FPKM)，前147列来自肿瘤样本，后面是50个正常对照的表达谱。\neasy_input_signatures.csv，某一通路基因列表，此处是TGFbeta。\nRead input file\nTwo input files are required: gene expression matrix and gene pathway\nof interest\neasy_input_expr.csv， The 32189 * 197 gene expression matrix (FPKM)\nprovided by the author of the article consists of the first 147 columns\nfrom tumor samples, followed by the expression profiles of 50 normal\ncontrols.\neasy_input_signatures.csv， A list of genes for a certain pathway,\nhere TGFbeta.\n# 读取表达矩阵数据，设置首行为行名，禁止自动转换列名\n# Read expression matrix data, set first column as row names, disable automatic conversion of column names\nexpr <- read.csv(\"easy_input_expr.csv\", check.names = F, row.names = 1)\n\n# 查看数据前几行几列的结构\n# View the structure of the first few rows and columns of the data\nexpr[1:3,1:3]\n# 读取基因集签名数据，仅保留第一列\n# Read gene set signature data, keep only the first column\nsignature <- read.csv(\"easy_input_signatures.csv\")[,1]\n\n# 显示读取的基因集签名内容\n# Display the content of the read gene signatures\nsignature\n估计GSVA富集分数，后面用于检验富集分数在k个类的差异\nEstimate the GSVA enrichment score, which will be used later to test\nthe differences in enrichment scores among k classes\n# 创建空列表用于存储基因集签名\n# Create an empty list to store gene signatures\nsiglist <- list()\n\n# 将指定基因集签名加入列表，键名为签名名称\n# Add the specified gene signature to the list with signature name as key\nsiglist[[signaturename]] <- signature\n\n# 对肿瘤样本进行GSVA富集分析\n# Perform GSVA enrichment analysis on tumor samples\n# 参数说明:\n# - as.matrix(expr[,1:tumornumber]): 提取前tumornumber列的表达矩阵作为肿瘤样本\n# - siglist: 包含基因集签名的列表\ngsva_params <- gsvaParam(exprData = as.matrix(expr[,1:tumornumber]),\n                         geneSets = siglist)\nsignature.gsva <- gsva(gsva_params)\n根据正常样本signature基因表达将肿瘤样本基因表达状态分成3类：高标达、低表达、不变\nAccording to the normal sample signature gene expression, the gene\nexpression status of tumor samples can be divided into three categories:\nhigh standard, low expression, and unchanged\n# 提取signature基因表达矩阵，筛选样本间有差异的基因\n# Extract expression matrix of signature genes and filter genes with inter-sample variability\nrowids <- intersect(rownames(expr), signature)  # 获取表达矩阵和基因集共有基因\nlogdata <- log2(expr[rowids, ] + 0.5)  # 对数转换表达值，加0.5避免log(0)\ntumordata <- logdata[, 1:tumornumber]  # 提取肿瘤样本数据\nvar <- apply(tumordata, 1, sd, na.rm=T)  # 计算每个基因在肿瘤样本中的标准差\nselvar <- var[var>0]  # 筛选有表达差异的基因(标准差>0)\ntumordata <- tumordata[names(selvar), ]  # 仅保留有差异的基因\nnormaldata <- logdata[names(selvar), (tumornumber+1):(tumornumber+normalnumber)]  # 提取正常样本对应基因表达\n\n# 根据文献方法提供的标准，判断各个基因相对于正常样本高表达或者低表达的状态\n# Determine gene expression status (up/down) relative to normal samples based on literature criteria\n\n# 首先设置基因分类阈值，计算各个基因在正常样本中高表达或者低表达阈值\n# First, set thresholds for gene classification and calculate expression cutoffs from normal samples\nhalfwidth <- 0.025  # 分位数阈值(2.5%)\nnormaldown <- apply(normaldata, 1, function(x) quantile(x, probs=halfwidth, na.rm=T) )  # 低表达阈值(2.5%分位数)\nnormalup <- apply(normaldata, 1, function(x) quantile(x, probs=1-halfwidth, na.rm=T) )  # 高表达阈值(97.5%分位数)\n\n# 根据判断表达状态，得到的状态矩阵用于聚类和绘图\n# Determine expression status matrix for clustering and visualization\nfor (k in 1:nrow(tumordata)) {\n  rowk <- as.numeric(tumordata[k, ])  # 获取当前基因在所有肿瘤样本中的表达值\n  out <- rep(0, times=ncol(tumordata))  # 初始化表达状态为0(无变化)\n  out[rowk>normalup[k]] <- 1  # 高于正常样本97.5%分位数标记为高表达(1)\n  out[rowk<normaldown[k]] <- -1  # 低于正常样本2.5%分位数标记为低表达(-1)\n  tumordata[k, ] <- out  # 更新表达状态矩阵\n}\n\n# 输出结果，不用于绘图\n# Output results (not for plotting)\noutdata <- tumordata  # 复制表达状态矩阵\noutdata[outdata==1] <- \"UP\"  # 高表达标记为UP\noutdata[outdata==-1] <- \"DOWN\"  # 低表达标记为DOWN\noutdata[outdata==0] <- \"NOCHANGE\"  # 无变化标记为NOCHANGE\nwrite.csv(outdata,\"Ternary.csv\",row.names = T,col.names = NA)  # 保存为CSV文件\n聚类并绘图\nCluster and plot\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa114ternaryCluster_FigureYa114ternaryCluster",
      "title": "FigureYa114ternaryCluster/FigureYa114ternaryCluster.html",
      "html": "FigureYa114ternaryCluster/FigureYa114ternaryCluster.html",
      "text": "texts/main_FigureYa114ternaryCluster_FigureYa114ternaryCluster.txt",
      "folder": "FigureYa114ternaryCluster",
      "thumb": "gallery_compress/FigureYa114ternaryCluster.webp"
    },
    "word_count": 763,
    "lines_count": 166,
    "title": "FigureYa114ternaryCluster",
    "description": "仅对某感兴趣通路做聚类分析，同时纳入正常样本表达水平的考虑，来挖掘癌症样本异质性。大神丢的文章能解决我的问题，想画下面这个图 Requirement description Perform cluster analysis only on a specific pathway of interest,",
    "input_data_types": [
      "临床数据",
      "表达矩阵"
    ],
    "output_types": [
      "热图"
    ],
    "technical_methods": [
      "聚类分析",
      "通路分析"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "LANGUAGE",
      "probs",
      "stringsAsFactors",
      "times",
      "threshold",
      "geneSets",
      "rm",
      "exprData",
      "names"
    ]
  },
  {
    "id": "main_FigureYa261circGene_FigureYa261circGene",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa261circGene_FigureYa261circGene.txt",
    "content": "FigureYa261circGene\nFigureYa261circGene\nAuthor(s)\n: Shuwen Cheng; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-10-04\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\nTo cite package ‘RCircos’ in publications use:\nHongen Zhang, Paul Meltzer and Sean Davis (2013), RCircos: an R\npackage for Circos 2D track plots, BMC Bioinformatics 14:244\n需求描述\nDemand description\n绘制基因位置的环形图。\nDrawing a circular diagram of gene locations.\n出自：\nhttps://molecular-cancer.biomedcentral.com/articles/10.1186/s12943-020-01170-0\n图1 胃癌中m6A调控因子的遗传及表达变异全景 d\n基于GSE62717队列的m6A调控因子在23条染色体上的拷贝数变异（CNV）位置分布\nSource:\nhttps://molecular-cancer.biomedcentral.com/articles/10.1186/s12943-020-01170-0\nFig. 1 Landscape of genetic and expression variation of m6A\nregulators in gastric cancer. d The location of CNV alteration of m6A\nregulators on 23 chromosomes using GSE62717 cohort.\n应用场景\nApplication scenarios\n把几个感兴趣的基因标注在基因组上，可以像这篇例文画成圆的。\n如果基因太多，可以画成直的，可参考FigureYa10chromosome，可以同时展示基因表达量/变化倍数、分类等信息。\nMark the genes of interest on the genome, which can be drawn in a\ncircular layout like the example provided.\nIf there are too many genes, a linear layout can be used (refer to\nFigureYa10chromosome), which can simultaneously display gene expression\nlevels/fold changes, classifications, and other information.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(RCircos)      # 用于绘制环形基因组图，主图形绘制功能\nlibrary(magrittr)     # 提供 %>% 管道操作符，简化数据处理流程\nlibrary(tidyverse)    # 数据处理与可视化工具集，主要用于数据筛选、变换（如 dplyr、readr）\nlibrary(rtracklayer)  # 用于读取和处理基因组注释文件（如 GTF），提取基因位置信息\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n目标基因位置的获取\nObtaining Target Gene Locations\n如果你已经获得了very_easy_input.txt，就可以跳过这步，直接进入“开始画图”。\neasy_input_gene.txt，根据需要定义一个基因集，后面将把基因名标在画成环状的染色体上。\ngencode.v39.annotation.gtf，基因组上所有基因所在位置，从中提取出目标基因的位置。可以从\ngencode\n下载\nhttps://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_39/gencode.v39.annotation.gtf.gz\n。\nIf you already have very_easy_input.txt, you can skip this step and\nproceed directly to “Start Plotting.”\neasy_input_gene.txt: Define a gene set as needed. These gene names\nwill later be labeled on the circular chromosome plot.\ngencode.v39.annotation.gtf: Contains the genomic coordinates of all\ngenes. Extract the positions of your target genes from this file. You\ncan download the gencode.v39.annotation.gtf file from\ngencode\nat:\nhttps://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_39/gencode.v39.annotation.gtf.gz\n.\n# 根据需要定义一个基因集，可以从文件读入\n# Define a gene set as needed and it can be read from a file\ngenes <- read.table(\"easy_input_gene.txt\", header = T)$SYMBOL\n\n# 也可以直接在这里写入：\n# Or can be directly specified here: \n#genes <- c(\"METTL3\", \"METTL14\", \"FTO\", \"ALKBH5\",\"IGF2BP3\",\n#           \"YTHDF1\", \"YTHDF2\", \"YTHDF3\", \"IGF2BP1\", \"IGF2BP2\", )\n\n# 根据基因集提取出目的基因所在位置\n# Extract genomic positions of target genes\ngene_pos <- import(\"gencode.v39.annotation.gtf\") %>% # 载入gtf文件\n  as.data.frame %>% \n  \n  # 仅选择基因，去除转录本等等\n  # Select only gene entries, filtering out transcripts etc.\n  filter(source == \"HAVANA\", type == \"gene\") %>%  \n  \n  # 保留基因位置和名称\n  # Keep genomic coordinates and gene names\n  dplyr::select(seqnames, start, end, gene_name) %>% \n  \n  # 挑选目的基因\n  # Filter for target genes\n  filter(gene_name %in% genes)\nhead(gene_pos)\n\n# 原文没说内圈散点图代表什么特征，我们这里随机生成一列数值\n# Since the original text didn't specify what the inner scatter points represent, we'll randomly generate a numeric column here\ngene_pos$gene_dot <- rnorm(nrow(gene_pos), 0, 2)\n\n# 保存到文件，便于套用格式\n# Save to file for easy format reuse\nwrite.csv(gene_pos,\"very_easy_input.csv\", row.names = F, quote = F)\n开始画图\nPlotting\nvery_easy_input.csv，基因、基因在染色体上的位置、基因的某一特征数值。\nvery_easy_input.csv contains gene names, their chromosomal positions,\nand a numerical feature value for each gene.\n# 加载基因所在的位置和数值\n# Load gene positions and associated numerical values \ngene_pos <- read.csv(\"very_easy_input.csv\", header = T)\n\n# 加载染色体Ideogram\n# Load chromosome ideogram data \n(data(\"UCSC.HG38.Human.CytoBandIdeogram\"))\n# 创建PDF输出文件（5x5英寸）\n# Create PDF output file (5x5 inches)\npdf(file=\"circGene.pdf\", height=5, width=5)\n\n# 初始化RCircos核心组件（基于hg38人类细胞遗传图谱）\n# Initialize RCircos core components (based on hg38 human cytoband)\nRCircos.Set.Core.Components(UCSC.HG38.Human.CytoBandIdeogram,\n                            chr.exclude = NULL,\n                            tracks.inside = 3, \n                            tracks.outside = 0)\nRCircos.Set.Plot.Area()\n\n# 绘制染色体\n# Draw chromosome ideograms\nRCircos.Chromosome.Ideogram.Plot()\n\n# 在第一圈用散点在基因所在的位置标注数值\n# 调整配色\n# Plot scatter points in Track 1 to show numerical values at gene positions\n# Adjust color scheme\nparam <- RCircos.Get.Plot.Parameters()\nparam$track.background <- \"grey\" \nRCircos.Reset.Plot.Parameters(param)\n\n# 第一轨道：散点图显示基因数值\n# Track 1: Scatter plot for gene values\nRCircos.Scatter.Plot(gene_pos,\n                     data.col = 5, \n                     by.fold = 1, \n                     track.num = 1,\n                     side = \"in\")\n\n# 第二轨道：基因连接线（标记基因位置）\n# Track 2: Gene connectors (mark gene positions)\nRCircos.Gene.Connector.Plot(genomic.data = gene_pos, \n                            track.num = 2, \n                            side = \"in\")\n\n# 第三轨道：基因名称标签\n# Track 3: Gene name labels\nRCircos.Gene.Name.Plot(gene_pos, \n                       name.col = 4,\n                       track.num = 3, \n                       side = \"in\")\n\n# 关闭图形设备（完成PDF输出）\n# Close graphics device (finish PDF output)\ndev.off()\n后期处理\nPost-processing\n输出到pdf文件为矢量图，可以用Adobe\nIllustrator等软件打开，编辑图形和文字。例如为避免基因名文字重叠，手动微调文字位置，和修改连线形状。\nThe plot is exported as a vector graphic in PDF format, which can be\nopened and edited in software like Adobe Illustrator. For example, you\nmay manually adjust text positions to prevent gene name overlaps and\nmodify connector shapes.\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa261circGene_FigureYa261circGene",
      "title": "FigureYa261circGene/FigureYa261circGene.html",
      "html": "FigureYa261circGene/FigureYa261circGene.html",
      "text": "texts/main_FigureYa261circGene_FigureYa261circGene.txt",
      "folder": "FigureYa261circGene",
      "thumb": "gallery_compress/FigureYa261circGene.webp"
    },
    "word_count": 675,
    "lines_count": 178,
    "title": "FigureYa261circGene",
    "description": "Demand description 绘制基因位置的环形图。 Drawing a circular diagram of gene locations.",
    "input_data_types": [
      "DNA-seq"
    ],
    "output_types": [
      "散点图",
      "统计表格"
    ],
    "technical_methods": [],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "LANGUAGE",
      "quote",
      "stringsAsFactors",
      "col",
      "num",
      "exclude",
      "data",
      "header",
      "width"
    ]
  },
  {
    "id": "main_FigureYa295ClassDiscovery_FigureYa295ClassDiscovery",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa295ClassDiscovery_FigureYa295ClassDiscovery.txt",
    "content": "FigureYa295ClassDiscovery\nFigureYa295ClassDiscovery\nAuthor(s)\n: Xiaofan Lu; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-05-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nDemand description\n想实现一个聚类分析的方法，主要是重现本文的方法，然后在自己的数据中进行分组，方法可能比较麻烦，但是个人感觉这种聚类的方法更加的新颖，可以适用于更多的疾病。最主要的是在第一篇文章的基础上衍生出的第二篇文章的分组（C1，C2A，C2B）。\nWe want a clustering analysis method, mainly to reproduce the\napproach described in this paper, and then apply it to group my own\ndata. The method might be a bit complex, but I personally feel this\nclustering approach is more innovative and can be applied to a wider\nrange of diseases. The most important aspect is the grouping (C1, C2A,\nC2B) derived from the second article, which builds upon the foundation\nof the first article.\n出自\nhttps://europepmc.org/article/med/19061838\n图1. 通过表达谱分析鉴定肝母细胞瘤的两个亚型。 (A)\n方法流程图：用于识别稳健样本聚类（包括两个肿瘤亚群 rC1 和 rC2\n以及一个非肿瘤组 NL），并采用六种不同算法（CCP、LDA、1NN、3NN、NC 和\nSVM）结合留一法交叉验证对肝母细胞瘤（HB）样本进行分类。 (B) 上：25 例 HB\n样本的分子分型及 CTNNB1 基因状态。黑色和灰色方块分别表示 CTNNB1 和 AXIN1\n基因突变。下：代表性 C1 和 C2 病例的 β-catenin 免疫组化分析。比例尺 = 50\nμm。 (C) HB 亚型与非肿瘤肝组织（NT）中 Wnt 通路相关基因及 β-catenin\n靶基因的表达情况（p < 0.005）。水平线表示平均值。\nSource:\nhttps://europepmc.org/article/med/19061838\nFigure 1. Identification of Two Hepatoblas- toma Subclasses by\nExpression Profiling. (A) Schematic overview of the approach used to\nidentify robust clusters of samples, including two tumor clusters (rC1\nand rC2) and one nontumor cluster (NL), and to classify hepatoblastoma\n(HB) samples using six different algorithms (CCP, LDA, 1NN, 3NN, NC, and\nSVM) and leave-one- out cross-validation. (B) Top: molecular\nclassification of 25 HB samples and CTNNB1 gene status. Black and gray\nsquares indicate mutations of the CTNNB1 and AXIN1 genes. Bottom:\nimmunohistochemical analysis of b-catenin for representative C1 and C2\ncases. Scale bars = 50 mm. (C) Expression of representative Wnt-related\nand b-catenin target genes (p < 0.005) in HB sub- classes and\nnontumor livers (NT). Horizontal bars indicate mean values.\n应用场景\nApplication scenarios\n类似一种共识聚类吧，只是太复杂了。算法流程写在\nReadme.md\n文件里，这是我和一个计算机专业的师弟写的，非常偏统计+计算机。\nIt’s somewhat like consensus clustering, just overly complex. The\nalgorithmic workflow is documented in the\nReadme.txt\nfile—this was written by me and a computer science junior student,\nheavily leaning toward statistics + computing.\n环境设置\nRequirements Description\nsource(\"install_dependencies.R\")\nsource(\"classPredict.R\") # from classpredict package, an R version of BRB ArrayTools software\n\nlibrary(cluster)\nlibrary(phangorn)\nlibrary(ape)\nlibrary(reshape2)\nlibrary(ComplexHeatmap)\nlibrary(limma)\nlibrary(classpredict)\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n输入文件\nInput Files\nHB-29samples-RMA-renormData19k.txt，表达矩阵。放在InputData文件夹里。\nHB-29samples-RMA-renormData19k.txt, expression matrix. Place in the\nInputData folder.\nwork.path <- \".\"\n\n# 输入文件所在文件夹\n# Input data folder path\ndata.path <- file.path(work.path, \"InputData\") \n\n# 结果文件所在文件夹\n# Results output folder path\nres.path <- file.path(work.path, \"Results\") \n\ninvisible(lapply(ls()[grep(\"path\", ls())], function(x){\n  if (!dir.exists(get(x))) dir.create(get(x))\n}))\n\n# 加载表达矩阵\n# Load expression matrix\nmtx <- read.table(file.path(data.path, \"HB-29samples-RMA-renormData19k.txt\"), \n                  header = T, row.names = 1, sep = \"\\t\")\nmtx <- mtx[-1, ]\ntmp <- rownames(mtx)\nmtx <- data.frame(lapply(mtx, as.numeric))\nrownames(mtx) <- tmp\nmtx <- as.matrix(mtx)\n聚类分析\nprobe.stat <- list()\nprobe.stat$probe <- rownames(mtx)\nnsample <- ncol(mtx)\n\n## 1: 方差检验\n## 1: Variance test  \n## -----------------------------------------------------------------\n\n# 计算每个探针的方差\n# calculate variance for each probe\nprobe.stat$var <- apply(mtx, 1, var) \n\n# 计算卡方统计量\n# calculate chi statistic\nprobe.stat$statistic <- (nsample-1)*probe.stat$var/median(probe.stat$var) \n\n# 计算单尾p值\n# calculate single tail p value\nprobe.stat$pvalue <- 1-pchisq(probe.stat$statistic, df = nsample-1) \n\n### 稳健变异系数(rCV)\n### Robust coefficient of variation (rCV)\nprobe.stat$rCV <- apply(mtx, 1, function(x){\n  x = sort(x)\n  x = x[2:(ncol(mtx)-1)]\n  sd(x)/mean(x)\n})\n\n### 无监督探针集筛选\n### Unsupervised probe sets selection \nthresholds <- c(0.6, 0.7, 0.8, 0.9, 0.95, 0.975, 0.99, 0.995)\n\n# 按阈值筛选探针集\n# filter probe set for each threshold\nprobe.stat$sets <- lapply(thresholds, function(threshold){ \n  probe.stat$probe[probe.stat$pvalue < 0.01 & \n                     probe.stat$rCV < 10 & \n                     probe.stat$rCV > quantile(probe.stat$rCV, threshold)]\n})\nnames(probe.stat$sets) <- thresholds\n\n# 列出探针集数量\n# list the number of probe set\nunlist(lapply(probe.stat$sets, length))\n# 探针集p值总结\n# summary the pvalue of the probe set\nlapply(probe.stat$sets, function(x) summary(probe.stat$pvalue[x]))\n# 探针集rCV总结\n# summary the rCV of the probe set\nlapply(probe.stat$sets, function(x) summary(probe.stat$rCV[x]))\npdf(file.path(res.path, \"Dendrograms.pdf\"))\nlapply(Dends, plot)\ninvisible(dev.off())\n\n## 3: 稳定性评估\n## 3: Stability assessment\n## -----------------------------------------------------------------\n\n### 内在稳定性\n### intrinsic stability \n\n#### 扰动\n#### perturbation\nnoise <- matrix(rnorm(n = nrow(mtx)*ncol(mtx), mean = 0, sd = sqrt(1.5 * median(probe.stat$var))),\n                nrow = nrow(mtx), ncol = ncol(mtx))\n\n#### 重采样\n#### resampleing\nnewsample <- sample(1:ncol(mtx), size = 5, replace = T)\nnewsample <- (mtx + noise)[, newsample]\ncolnames(newsample) <- paste0(\"test\", 1:ncol(newsample))\n# mtx <- cbind(mtx, newsample)\n\n### 树状图间相似性评分\n### Similarity Score between dendrograms\n\n#### 树分割距离(又称对称差异度量或Robinson-Foulds距离)\n#### tree partition distance (also called symmetric difference metric and Robinson-Foulds distance)\nphylos <- lapply(Dends, as.phylo) \nclass(phylos) <- \"multiPhylo\"\nRF.dist(phylos)\ninvisible(dev.off())\n\n#### 设置k=3\n#### 用h=24-22切割树状图\n#### 识别在24个分区中至少有22次共分类的样本对组\n#### set k as 3\n#### cut the dendrogrom using h=24-22\n#### identified groups in which any pair of samples was co-classified in at least 22 of the 24 partitions\nk = \"3\"; \nsampleInfo <- data.frame(\"Sample\" = colnames(mtx))\nmat = mat.list[[k]]\nhcl = hclust(as.dist(24-mat))\ngp <- cutree(tree = hcl, h = 24-22)\nsampleInfo$PrimaryCluster = as.factor(gp[match(sampleInfo$Sample, names(gp))])\n\n#### 合并平均共分类分数大于20的聚类\n#### 用h=24-18切割hcl2\n#### merge clusters whose mean co-classification score is more than 20\n#### cut the hcl2 using h=24-18\nnum.gps = length(levels(sampleInfo$PrimaryCluster))\ngps.coc.mat <- matrix(nrow = num.gps, ncol = num.gps)\nrownames(gps.coc.mat) = colnames(gps.coc.mat) = levels(sampleInfo$PrimaryCluster)\nfor (i in levels(sampleInfo$PrimaryCluster)){\n  for (j in 1:num.gps){\n    sampleA = names(gp)[gp == i]\n    sampleB = names(gp)[gp == j]\n    \n    # 计算每对组的平均共分类分数\n    # compute mean co-classification score for each group pair\n    gps.coc.mat[i, j] = mean(mat[sampleA, sampleB]) \n  }\n}\nhcl2 <- hclust(as.dist(gps.coc.mat))\ngp2 <- cutree(hclust(as.dist(24-gps.coc.mat)), h = 24-18)\n\n#### 将PrimaryCluster标签转为最终标签\n#### switch the PrimaryCluster label to final label\nsampleInfo$FinalCluster <- plyr::mapvalues(x = sampleInfo$PrimaryCluster,\n                                           from = names(gp2),\n                                           to = gp2)\ntable(sampleInfo$FinalCluster)\nsplit(sampleInfo$Sample, sampleInfo$FinalCluster)\nwrite.table(sampleInfo, file.path(res.path, \"output_sampleInfo.txt\"), \n            row.names = F, col.names = T, quote = F, sep = \"\\t\")\n\n\n## 5: 16基因特征\n## 5: 16 gene signature  \n## -----------------------------------------------------------------\n\n### 使用limma寻找特征基因\n### 以文献中的分组标签为例\n### use limma to find signature\n### take the group label from article as example\n\ngroup <- setNames(object = c(rep(\"rC1\", 8), rep(\"rC2\", 5)), \n                  nm = c(\"HB83\", \"HB81\", \"HB5\", \"HB75\", \"HB59\", \"HB69\", \"HB74F\", \"HB49\",\n                         \"HB80\", \"HB74e\", \"HB86\", \"HB72\", \"HB73\"))\ndesign <- model.matrix(~0+factor(group))\ncolnames(design) = levels(factor(group))\nrownames(design) = names(group)\ndesign\ncontrast.matrix <- makeContrasts(paste0(unique(group),collapse = \"-\"), levels = design)\nfit <- lmFit(mtx[, names(group)], design)\nfit2 <- contrasts.fit(fit, contrast.matrix)\nfit2 <- eBayes(fit2) \nDEGs = topTable(fit2, coef=1, n=Inf)\nsig = rownames(DEGs)[DEGs$adj.P.Val<1e-3]\n\n## 16基因分类器\n## 16 gene classifier\n\n### 使用classpredict (R版BRB ArrayTools软件)\n### use classpredict (an R version of BRB ArrayTools software)\n\n## 6: 聚类预测\n## 6: cluster prediction \n## -----------------------------------------------------------------\n\nall.data <- mtx[sig, ]\n\n# 训练集\n# train set\ntrain.data <- all.data[, names(group)] \n\n# 训练集标签\n# label of train set\ntrain.label <- as.factor(group) \n\n# train.data$Group <- as.factor(group)\n\ntest.data <- all.data[, setdiff(colnames(all.data), names(group))] # test set\ngeneId <- data.frame(\"UniqueID\" = rownames(train.data))\n\nresList <- classPredict(exprTrain = train.data, exprTest = test.data, isPaired = FALSE,\n                        pairVar.train = NULL, pairVar.test = NULL, geneId = geneId, \n                        cls = as.character(train.label), projectPath = res.path,\n                        pmethod = c(\"ccp\", \"bcc\", \"dlda\", \"knn\", \"nc\", \"svm\"),\n                        geneSelect = \"igenes.univAlpha\",\n                        univAlpha = 0.001, univMcr = 0, foldDiff = 0, rvm = TRUE,\n                        filter = rep(1, length(geneId)), ngenePairs = 25, nfrvm = 10, cvMethod = 1,\n                        kfoldValue = 10, bccPrior = 1, bccThresh = 0.8, nperm = 0,\n                        svmCost = 1, svmWeight =1, fixseed = 1, prevalence = NULL, \n                        outputName = \"ClassPrediction\", generateHTML = T)\nView(resList$predNewSamples)\nView(resList$performClass)\nwrite.table(resList$predNewSamples, file.path(res.path, \"output_ClassPrediction.txt\"),\n            row.names = F, col.names = T, sep = \"\\t\", quote = F)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa295ClassDiscovery_FigureYa295ClassDiscovery",
      "title": "FigureYa295ClassDiscovery/FigureYa295ClassDiscovery.html",
      "html": "FigureYa295ClassDiscovery/FigureYa295ClassDiscovery.html",
      "text": "texts/main_FigureYa295ClassDiscovery_FigureYa295ClassDiscovery.txt",
      "folder": "FigureYa295ClassDiscovery",
      "thumb": "gallery_compress/FigureYa295ClassDiscovery.webp"
    },
    "word_count": 1173,
    "lines_count": 298,
    "title": "FigureYa295ClassDiscovery",
    "description": "Demand description 想实现一个聚类分析的方法，主要是重现本文的方法，然后在自己的数据中进行分组，方法可能比较麻烦，但是个人感觉这种聚类的方法更加的新颖，可以适用于更多的疾病。最主要的是在第一篇文章的基础上衍生出的第二篇文章的分组（C1，C2A，C2B）。 We want a clustering analysis method, mainly to reproduce the",
    "input_data_types": [
      "临床数据",
      "表达矩阵",
      "突变数据"
    ],
    "output_types": [
      "热图",
      "统计表格"
    ],
    "technical_methods": [
      "聚类分析",
      "通路分析",
      "差异表达分析"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学"
    ],
    "complexity_level": "高级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "to",
      "nfrvm",
      "pmethod",
      "nperm",
      "outputName",
      "cls",
      "header",
      "用h",
      "coef"
    ]
  },
  {
    "id": "main_FigureYa31lasso_update_FigureYa31lasso_update",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa31lasso_update_FigureYa31lasso_update.txt",
    "content": "FIgureYa31lasso_update\nFIgureYa31lasso_update\nAuthor(s)\n: Ya Zhang, Ying Ge; Yijing Chen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n画出paper中的lasso回归图，给出图中线所对应的基因顺序。\n将纳入signature的变量拟合成一个变量，作为nomogram的输入。\nDraw the lasso regression plot from the paper, giving the order of\nthe genes corresponding to the lines in the plot.\nFit the variables that are included in the signature to a variable\nthat is used as input to the nomogram.\n出自\nhttps://linkinghub.elsevier.com/retrieve/pii/S1470-2045(13)70491-1\nlasso结果怎么解读？看这篇：\nhttps://mp.weixin.qq.com/s/Odf3zYOu77DvN-ph4gHPJQ\nfrom\nhttps://linkinghub.elsevier.com/retrieve/pii/S1470-2045(13)70491-1\nHow to interpret lasso results? Read this:\nhttps://mp.weixin.qq.com/s/Odf3zYOu77DvN-ph4gHPJQ\n应用场景\nApplication scenario\n筛选差异基因之后，进一步筛选有预后意义的基因，组成基因表达signature。\nLASSO对于高维度、强相关、小样本的生存资料数据较为适用。\nAfter screening for differential genes, genes with prognostic\nsignificance are further screened to compose the gene expression\nsignature.\nLASSO is more suitable for high-dimensional, strongly correlated, and\nsmall-sample survival data.\n环境设置\nEnvironment setting\n采用R包\nglmnet\n，它是目前最好用的拟合广义线性模型的R包，由\nLASSO\n回归的发明人，斯坦福统计学家 Trevor Hastie 领衔开发。\nThe R package\nglmnet\nis used, which is the best R\npackage available for fitting generalized linear models, lead by Trevor\nHastie, the Stanford statistician who invented\nLASSO\nregression.\nsource(\"install_dependencies.R\")\n#install.packages(\"glmnet\")\n#install.packages(\"survival\")\nlibrary(\"glmnet\")\nlibrary(\"survival\")\nsource(\"nonzeroCoef.R\")\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 display English error messages\noptions(stringsAsFactors = FALSE) #禁止chr转成factor prohibit the conversion of chr to factor\n输入数据\nInput data\n输入文件有两个，一个是生存信息\neasy_input_suv.csv\n，一个是基因表达矩阵\neasy_input_exp.csv\n。\neasy_input_suv.csv\n，生存信息，至少包含三列，分别为patient\nIDs、follow up time、life status\neasy_input_exp.csv\n，基因表达矩阵，每行一个基因，每列一个patient，跟\nsuv.csv\n里的\npatient ID\n一致。\nThere are two input files: one is the survival information file\neasy_input_suv.csv\n, and the other is the gene expression\nmatrix file\neasy_input_exp.csv\n.\neasy_input_suv.csv\n, the survival information, contains\nat least three columns for patient IDs, follow up time, life status\neasy_input_exp.csv\n, gene expression matrix, one gene per\nrow, one patient per column, consistent with the\npatient ID\nin\nsuv.csv\n.\nmyexpr <- read.csv(\"easy_input_exp.csv\", header = T,row.names = 1)\nmyexpr[1:3,1:4]\nmysurv <- read.csv(\"easy_input_suv.csv\", header = T,row.names = 1)\nhead(mysurv)\n#检查样品信息跟表达量矩阵的样品是否一致\n#check that the sample information is consistent with the samples in the expression matrix\nif (all(colnames(myexpr) %in% rownames(mysurv))){\n  warning(\"两个文件的patient ID是一致的\")\n} else{\n  warning(\"两个文件的patient ID不一致\")\n}\n开始画图\nStart drawing\n算出lambda值\nCalculate the lambda value\ncvfit = cv.glmnet(t(myexpr), Surv(mysurv$months,mysurv$status), \n                  #10倍交叉验证，非必须限定条件，这篇文献有，其他文献大多没提\n                  #10-fold cross-validation, non-required qualification, available in this paper, mostly unmentioned in others\n                  #nfold=10,\n                  family = \"cox\"\n                  ) \nplot(cvfit)\n#两个lambda值均可采用，具体lambda选值要根据自己实验设计而定。\n#此处使用`lambda min`\n#Both lambda values can be used, the exact lambda selection depends on your own experimental design.\n#Here we use `lambda min`.\ncvfit$lambda.min #最佳lambda值 best lambda value\ncvfit$lambda.1se #一倍SE内的更简洁的模型 a more concise model in double SE\nfit <- glmnet(t(myexpr), Surv(mysurv$months,mysurv$status), \n               family = \"cox\") \n\n#用包自带的函数画图\n#use the built-in functions of the package to plot the graph\nplot(fit, label = TRUE)\n修改画图函数\nModify the plotting function\n原函数打印序号，需要修改画图函数，改为打印基因名\n如果基因太多，打印基因名也看不清。在右侧列出图例，这样看起来更清晰。\nThe original function prints the serial number, you need to modify\nthe plotting function to print the gene name instead.\nIf there are too many genes, it is hard to see the gene names. List\nthe legend on the right side, so that it looks clearer.\n#自定义颜色\n#custom colors\nmycol <- rep(c(\"#223D6C\",\"#D20A13\",\"#FFD121\",\"#088247\",\"#11AA4D\",\"#58CDD9\",\"#7A142C\",\"#5D90BA\",\"#431A3D\",\"#91612D\",\"#6E568C\",\"#E0367A\",\"#D8D155\",\"#64495D\",\"#7CC767\"),2)\n\n#设置x轴最大值\n#set the x-axis maximum value\nxmax <- 3.6\n\nplotCoef_plus <- function (beta, norm, lambda, df, dev, label = FALSE, legend = FALSE, xvar = c(\"norm\", \n    \"lambda\", \"dev\"), xlab = iname, ylab = \"Coefficients\", ...) \n{\n    which = nonzeroCoef(beta)\n    nwhich = length(which)\n    switch(nwhich + 1, `0` = {\n        warning(\"No plot produced since all coefficients zero\")\n        return()\n    }, `1` = warning(\"1 or less nonzero coefficients; glmnet plot is not meaningful\"))\n    beta = as.matrix(beta[which, , drop = FALSE])\n    xvar = match.arg(xvar)\n    switch(xvar, norm = {\n        index = if (missing(norm)) apply(abs(beta), 2, sum) else norm\n        iname = \"L1 Norm\"\n        approx.f = 1\n    }, lambda = {\n        index = log(lambda)\n        iname = \"Log Lambda\"\n        approx.f = 0\n    }, dev = {\n        index = dev\n        iname = \"Fraction Deviance Explained\"\n        approx.f = 1\n    })\n    dotlist = list(...)\n    type = dotlist$type\n    \n    if (legend){\n      #在右侧留出画图例的地方\n      #leave space on the right hand side for drawing the legend\n      par(xpd = T, mar = par()$mar + c(0,0,0,6))\n    }\n    \n    #修改bty，换个更好看的边框，还可以改成，o / n / 7 / l / c / u / ]\n    #modify the bty for a better looking border and also change it to, o / n / 7 / l / c / u / ]\n    if (is.null(type)) \n        matplot(index, t(beta), lty = 1, lwd = 2,\n                xlab = xlab, ylab = ylab, \n                xlim = c(0, xmax), #设置x轴最大值 set the x-axis maximum value\n                col = mycol,#线的颜色 color of the line\n                type = \"l\", cex.lab=1.2, cex.axis=1,\n                bty=\"n\", ...)#不画右边框 no right-hand border\n    else matplot(index, t(beta), lty = 1, lwd = 2,\n                 xlab = xlab, ylab = ylab, \n                 xlim = c(0, xmax), \n                 col = mycol,\n                 type = \"l\", cex.lab=1.2, cex.axis=1,\n                 bty=\"n\", ...)\n    atdf = pretty(index)\n    prettydf = approx(x = index, y = df, xout = atdf, rule = 2, \n        method = \"constant\", f = approx.f)$y\n    axis(3, at = atdf, labels = prettydf, tcl = NA)\n    \n    if (label) {\n        nnz = length(which)\n        xpos = max(index)\n        pos = 4\n        if (xvar == \"lambda\") {\n            xpos = min(index)\n            pos = 2\n        }\n        xpos = rep(xpos, nnz)\n        ypos = beta[, ncol(beta)]\n        \n        #原函数打印序号，修改为打印基因名\n        #the original function prints the serial number, modified to print the gene name\n        text(xpos, ypos, paste(rownames(myexpr)[which]),\n             cex = 0.8, #基因名字体大小 gene name font size\n             #基因名的颜色跟线一样\n             #gene names are the same color as the lines\n             col = mycol,\n             #如果你不想要彩色的字，就用下面这行\n             #if you don't want colored words, use the following line\n             #col = \"black\",\n             pos = pos)\n    }\n    if (legend) {\n      #画图例\n      #draw legend\n      legend(\"topright\",\n           inset=c(-0.12,0),#图例画到图外面 legend drawn outside the figure\n           legend = rownames(myexpr), #图例文字 legend text\n           col = mycol, #图例线的颜色，与文字对应 color of the legend line, corresponding to the text \n           lwd = 3, #图例中线的粗细 thickness of lines in the legend\n           cex = 1, #图例字体大小 legend font size\n           bty = \"n\") #不显示图例边框 legend border not displayed\n    }\n    par(xpd=FALSE)\n}\n\nplot.glmnet_plus <- function (x, xvar = c(\"norm\", \"lambda\", \"dev\"), label = FALSE, legend = FALSE,\n    ...) \n{\n    xvar = match.arg(xvar)\n    plotCoef_plus(x$beta, lambda = x$lambda, df = x$df, dev = x$dev.ratio, \n        label = label, legend = legend, xvar = xvar, ...)\n}\n在线的旁边显示基因名\nDisplay the gene name next to the line\n用修改后的函数画图\nDraw a graph with the modified function\npdf(\"lasso_name.pdf\",width = 10,height = 8)\nplot.glmnet_plus(fit, label = TRUE, #打印基因名 print gene name\n                 legend = FALSE) #不显示图例 legend not displayed\n\n#在图上画虚线\n#你想用哪个cutoff，就在“v = ”写上相应的数字\n#此处以lambda.min作为cutoff\n#draw dotted lines on the graph\n#write the corresponding number in “v =” for whichever cutoff you want to use\n#use lambda.min as the cutoff\nabline(v = cvfit$lambda.min, lty = 3, #线的类型，可以改成0, 1, 2, 3, 4, 5, 6 type of line, can be changed to 0, 1, 2, 3, 4, 5, 6\n       lwd = 2, #线的粗细 thickness of line\n       col = \"black\") #线的颜色 color of line\ndev.off()\n以图例的形式展示基因名\nShow gene names in legend form\n如果筛出来的基因太多，图上太挤，就把基因名用图例的形式标注。\nIf there are too many genes screened out and the graph is too\ncrowded, label the gene names with a legend.\npdf(\"lasso_legend.pdf\",width = 10,height = 8)\nplot.glmnet_plus(fit, label = FALSE, #不打印基因名 do not print gene names\n                 legend = TRUE) #显示图例 show legend\nabline(v = cvfit$lambda.min, lty=3, \n       lwd = 2, \n       col = \"black\")\ndev.off()\n输出选中的基因\nOutput selected genes\n输出选中的基因及其coefficient，这个coefficient跟lasso图中的纵坐标是一致的\nOutput the selected genes and their coefficient, which is the same as\nthe vertical coordinate in the lasso plot\n#在参数“s =”后面写cutoff\n#此处选用lambda.min\n#write cutoff after the parameter \"s =\"\n#here, lambda.min is used\ncoef.min = coef(cvfit, s = \"lambda.min\") \ncoef.min\n#提取选中的基因名\n#extract selected gene names\nactive.min = which(coef.min != 0)\ngeneids <- rownames(myexpr)[active.min]\ngeneids\n#提取选中的基因对应的coefficient\n#extract the coefficient corresponding to the selected genes\nindex.min = coef.min[active.min]\nindex.min\n#输出到文件\n#output to file\ncombine <- cbind(geneids, index.min)\nwrite.csv(combine,\"gene_index.csv\")\n输出用于nomogram作图的文件\nOutput files for nomogram graphing\n将纳入signature的变量拟合成一个变量，可作为nomogram的输入，对接FigureYa30nomogram，作为easy_input.txt文件的一列。\nFit the variables to be included in the signature into a single\nvariable, which can serve as an input for the nomogram, interfacing with\nFigureYa30nomogram, as a column in the easy_input.txt file.\nsignature <- as.matrix(t(myexpr[geneids,])) %*% as.matrix(index.min) \nsummary(signature)\ncolnames(signature)[1] <- \"lasso\"\nrow.names = row.names(myexpr)\nwrite.table(signature,\"lasso_output.txt\",row.names = T, quote = F)\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa31lasso_update_FigureYa31lasso_update",
      "title": "FigureYa31lasso_update/FigureYa31lasso_update.html",
      "html": "FigureYa31lasso_update/FigureYa31lasso_update.html",
      "text": "texts/main_FigureYa31lasso_update_FigureYa31lasso_update.txt",
      "folder": "FigureYa31lasso_update",
      "thumb": "gallery_compress/FigureYa31lasso_update.webp"
    },
    "word_count": 1292,
    "lines_count": 305,
    "title": "FIgureYa31lasso_update",
    "description": "Requirement description 画出paper中的lasso回归图，给出图中线所对应的基因顺序。 将纳入signature的变量拟合成一个变量，作为nomogram的输入。",
    "input_data_types": [
      "临床数据",
      "表达矩阵",
      "生存数据"
    ],
    "output_types": [
      "统计表格",
      "生存曲线"
    ],
    "technical_methods": [
      "生存分析"
    ],
    "biology_areas": [],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "pos",
      "iname",
      "min",
      "header",
      "lwd",
      "width",
      "xlim",
      "df"
    ]
  },
  {
    "id": "main_FigureYa258SNF_FigureYa258SNF",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa258SNF_FigureYa258SNF.txt",
    "content": "FigureYa258SNF\nFigureYa258SNF\nAuthor(s)\n: Xiaofan Lu; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-09-30\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nDemand description\n用多组学数据，比如DNA甲基化和基因表达数据，一起识别疾病亚组，像这篇文章用相似网络融合\n(SNF)这种方法。\nUsing multi-omics data, such as DNA methylation and gene expression\ndata, to jointly identify disease subgroups, as demonstrated in this\narticle using methods like Similarity Network Fusion (SNF).\n出自：\nhttps://www.sciencedirect.com/science/article/pii/S1535610817302015?via%3Dihub\nSource:\nhttps://www.sciencedirect.com/science/article/pii/S1535610817302015?via%3Dihub\n应用场景\nApplication scenarios\n使用相似性网络融合算法（Similarity network fusion,\nSNF）对多组学数据进行联合聚类。\nFigureYa69cancerSubtype用到了SNFCC方法，是对同一个数据集的聚类，这次是对多组学数据聚类。\nUsing the Similarity Network Fusion (SNF) algorithm for joint\nclustering of multi-omics data.\nFigureYa69cancerSubtype employed the SNFCC method for clustering the\nsame dataset, whereas this time, it is applied to multi-omics data\nclustering.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(SNFtool)\nlibrary(data.table)\nlibrary(pheatmap)\nlibrary(NMF)\n# 自定义函数\n# Custom function\nnormalize <- function(X) X/rowSums(X)\n\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n输入文件\nInput Files\neasy_input_expr.txt: 表达谱矩阵。/ Expression profile matrix.\neasy_input_beta.txt: 甲基化数据，beta值。/ Methylation data (beta\nvalues).\n# 加载表达谱和甲基化（beta值）\n# 注意：原文提到，SNF算法本身不要求数据进行任何预筛选，因此使用了全部表达谱和甲基化谱，这里只是为了示例，因此仅采用了mRNA和位于启动子的甲基化数据\n# 原文：The SNF method does not require any prior feature selection so we used the full matrix of gene expression (21,641 genes) and the full matrix of methylation data (logitB values, 321,174 probes).\n# Loading expression profiles and methylation (beta values)\n# Note: The original paper states that the SNF algorithm itself does not require any pre-filtering of data, hence the full expression and methylation profiles were used. For this demonstration, we only used mRNA and promoter-region methylation data.\n# Original text: \"The SNF method does not require any prior feature selection so we used the full matrix of gene expression (21,641 genes) and the full matrix of methylation data (logitB values, 321,174 probes).\"\n\nexpr <- fread(\"easy_input_expr.txt\",sep = \"\\t\",check.names = F,stringsAsFactors = F,header = T,data.table = F)\nrownames(expr) <- expr[,1]; expr <- expr[,-1]\nexpr <- expr[rowSums(expr) > 0,]\nexpr <- as.data.frame(t(scale(t(log2(expr + 1)))))\n\nbeta <- fread(\"easy_input_beta.txt\",sep = \"\\t\",check.names = F,stringsAsFactors = F,header = T,data.table = F)\nrownames(beta) <- beta[,1]; beta <- beta[,-1]\nbeta <- as.data.frame(na.omit(beta))\n进行SNF分析\nPerforming SNF analysis\n# 根据例文所述对甲基化beta值进行转化，得到M值\n# Convert methylation beta values to M-values as described in the example paper\nmvalue <- as.data.frame(wateRmelon::Beta2M(beta))\n# 获取同样的样本以及处理过的多组学数据（可以添加更多的组学数据到列表中）\n# Obtain common samples and prepare processed multi-omics data (additional omics data can be added to the list)\ncomsam <- intersect(colnames(expr),colnames(mvalue))\nmoic.list <- list(mrna = as.matrix(expr[,comsam]),\n                  meth = as.matrix(mvalue[,comsam]))\n\n# 进行SNF分析并使用原文参数\n# 原文：We used the SNFtool R package (v2.2.0) with the parameters K = 50, alpha = 0.6, T = 50. Spectral clustering implemented in the SNFtool package was run on the SNF fused similarity matrix to obtain the groups corresponding to k=2 to 20.\n# Perform SNF analysis using parameters from the original paper\n# Original text: \"We used the SNFtool R package (v2.2.0) with the parameters K = 50, alpha = 0.6, T = 50. Spectral clustering implemented in the SNFtool package was run on the SNF fused similarity matrix to obtain the groups corresponding to k=2 to 20.\"\npara.K = 50\npara.alpha = 0.6\npara.T = 50\n\nW.list <- list()\nfor (m in 1:length(moic.list)) { \n  message(\"--dealing with the omics data of \",m,\"...\")\n  W.list[[m]] <- affinityMatrix(as.matrix(dist(t(moic.list[[m]]))), K = para.K, sigma = para.alpha)\n}\n# 对相似性矩阵列表进行融合\n# Fuse the similarity matrices\nW <- SNF(W.list, K = para.K, t = para.T)\n# 使用谱聚类对融合的相似性矩阵进行聚类\n# Perform spectral clustering on the fused similarity matrix \nn.clust <- 2:5\nfor (n in n.clust) {\n  message(\"--generating heatmap with cluster number of \",n,\"...\")\n  clust <- spectralClustering(W, K = n)\n  ind <- sort(as.vector(clust), index.return = TRUE)\n  ind <- ind$ix\n  diag(W) <- median(as.vector(W))\n  indata <- normalize(W)\n  indata <- indata + t(indata)\n  hm <- pheatmap(indata[ind, ind],\n                 color = NMF:::ccRamp(c(\"white\",\"red\"),64),\n                 border_color = NA,\n                 cluster_cols = F,\n                 cluster_rows = F,\n                 show_rownames = FALSE,\n                 show_colnames = FALSE,\n                 name = \"SNF\",\n                 filename = paste0(\"snf heatmap with cluster number of \",n,\".pdf\"))\n}\n查看热图决定哪次聚类得到了最清晰的热图。\n原文最后选用k=4。\n随后单独对每个subgroup进行SNF聚类，根据自己数据的具体情况套用以上代码即可。\n原文：For each of these four subgroups we then ran the SNF method\nindependently with the following parameters and clustered the resulting\nfused similarity matrix with spectral clustering using k=2 to 8.\n参数: WNT: K = 10, alpha = 0.6, T = 50 SHH: K = 40, alpha = 0.6, T =\n50 Group 3: K = 40, alpha = 0.6, T = 50 Group 4: K = 60, alpha = 0.6, T\n= 50 Group 3 and Group 4: K = 80, alpha = 0.6, T = 50\nDetermine optimal cluster number by examining heatmap clarity.\nThe original paper ultimately selected k=4 based on visual\ninspection.\nApply SNF clustering independently to each subgroup using the\nfollowing parameters.\nOriginal text: For each of these four subgroups we then ran the SNF\nmethod independently with the following parameters and clustered the\nresulting fused similarity matrix with spectral clustering using k=2 to\n8.\nParameters: WNT: K = 10, alpha = 0.6, T = 50 SHH: K = 40, alpha =\n0.6, T = 50 Group 3: K = 40, alpha = 0.6, T = 50 Group 4: K = 60, alpha\n= 0.6, T = 50 Group 3 and Group 4: K = 80, alpha = 0.6, T = 50\n后期结果展示\nPost-analysis visualization\n例文用热图展示subgroup、subtype的关系。\n按指定的样本顺序画热图，可参考FigureYa91cluster_heatmap。\n以下代码可顺利对接其中的“7. 从文件导入样本顺序”\nThe example paper uses heatmaps to display subgroup/subtype\nrelationships.\nTo plot heatmaps with specified sample order, refer to\nFigureYa91cluster_heatmap.\nThe following code can directly interface with “7. Import sample\norder from file”\n#按照原文选用k=4\n# Using k=4 as specified in the original paper\nn <- 4 \nclust <- spectralClustering(W, K = n)\nind <- sort(as.vector(clust), index.return = TRUE)\nind <- ind$ix\ndiag(W) <- median(as.vector(W))\nindata <- normalize(W)\nindata <- indata + t(indata)\n\n# 把样本顺序保存到sam_order\n# Save sample order to sam_order\nsam_order <- row.names(indata[ind, ind])\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa258SNF_FigureYa258SNF",
      "title": "FigureYa258SNF/FigureYa258SNF.html",
      "html": "FigureYa258SNF/FigureYa258SNF.html",
      "text": "texts/main_FigureYa258SNF_FigureYa258SNF.txt",
      "folder": "FigureYa258SNF",
      "thumb": "gallery_compress/FigureYa258SNF.webp"
    },
    "word_count": 947,
    "lines_count": 169,
    "title": "FigureYa258SNF",
    "description": "Demand description 用多组学数据，比如DNA甲基化和基因表达数据，一起识别疾病亚组，像这篇文章用相似网络融合 (SNF)这种方法。",
    "input_data_types": [
      "临床数据"
    ],
    "output_types": [
      "热图",
      "统计表格",
      "网络图"
    ],
    "technical_methods": [
      "聚类分析",
      "网络分析"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "header",
      "cluster_cols",
      "原文最后选用k",
      "sigma",
      "name",
      "k",
      "K",
      "mrna",
      "LANGUAGE"
    ]
  },
  {
    "id": "main_FigureYa309cell2location_03_cell2location_mapping",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa309cell2location_03_cell2location_mapping.txt",
    "content": "03_cell2location_mapping\nIn [1]:\nimport\nscanpy\nas\nsc\nimport\nnumpy\nas\nnp\nimport\npandas\nas\npd\nimport\nmatplotlib.pyplot\nas\nplt\nimport\nmatplotlib\nas\nmpl\nimport\ncell2location\nfrom\nmatplotlib\nimport\nrcParams\nrcParams\n[\n'pdf.fonttype'\n]\n=\n42\n# enables correct plotting of text for PDFs\nIn [2]:\nresults_folder\n=\n'./results/'\n# create paths and names to results folders for reference regression and cell2location models\nref_run_name\n=\nf\n'\n{\nresults_folder\n}\n/reference_signatures'\nrun_name\n=\nf\n'\n{\nresults_folder\n}\n/cell2location_map'\nLoad datasets\n¶\nIn [3]:\n# Read data\nadata_vis\n=\nsc\n.\nread\n(\n\"data/visium_merge_inter_upload.h5ad\"\n)\nIn [4]:\nadata_vis\nOut[4]:\nimportant\n注意adata_vis的数据结构：\n切片图像保存于\nadata_vis.uns['spatial']\n在cell2location中，切片转录组默认使用\nadata_vis.obs['sample']\n用于区分不同切片的数据\n修改\nadata_vis.uns['spatial']\n的key值使之和\nadata_vis.obs['sample']\n保持一致，这样才能使用\nselect_slide\n函数subset切片\nIn [5]:\nfor\nk\nin\nlist\n(\nadata_vis\n.\nuns\n[\n'spatial'\n]\n.\nkeys\n()):\nadata_vis\n.\nuns\n[\n'spatial'\n][\nk\n.\nsplit\n(\n'_'\n)[\n3\n]]\n=\nadata_vis\n.\nuns\n[\n'spatial'\n]\n.\npop\n(\nk\n)\nIn [6]:\nlist\n(\nadata_vis\n.\nuns\n[\n'spatial'\n]\n.\nkeys\n())\nOut[6]:\nIn [7]:\nadata_vis\n.\nobs\n[[\n'sample'\n,\n'donor_id'\n]]\n.\nvalue_counts\n()\nOut[7]:\n导入上一步的结果：reference signature\nIn [8]:\ninf_aver\n=\npd\n.\nread_csv\n(\nf\n\"\n{\nref_run_name\n}\n/inf_aver.csv\"\n,\nindex_col\n=\n0\n)\ninf_aver\n.\nhead\n()\nOut[8]:\nACKR+_EC\nActivated KRT+ NK\nActivated NK\nActivated_B-AREG\nActivated_B-RHOB\nCCL5+_EC\nCD\nCD4+T_Act-CCL5\nCD4+T_Act-CH25H\nCD4+T_Act-CXCR4\n...\nTR Mac.3\nType A intercalated cell\nType B intercalated cell\ncDC1\ncDC2\ncir_NK-PTGDS\ncir_NK-S100B\ngdT_Vd1\ngdT_Vd2\npDC\nFO538757.2\n0.095478\n0.090512\n0.110985\n0.055967\n0.075919\n0.074606\n0.149572\n0.084705\n0.095956\n0.096498\n...\n0.128304\n0.104031\n0.250288\n0.090729\n0.136187\n0.130000\n0.084518\n0.122680\n0.083116\n0.134055\nNOC2L\n0.138662\n0.127062\n0.117580\n0.117451\n0.114746\n0.082101\n0.170084\n0.105224\n0.101670\n0.108131\n...\n0.028709\n0.076386\n0.117015\n0.069693\n0.090842\n0.123789\n0.110760\n0.140441\n0.105666\n0.130683\nPERM1\n0.002008\n0.000344\n0.000227\n0.001351\n0.002163\n0.003590\n0.025246\n0.001045\n0.008251\n0.000158\n...\n0.003109\n0.005901\n0.482280\n0.000646\n0.001460\n0.000493\n0.003901\n0.001227\n0.000922\n0.001944\nHES4\n0.011849\n0.006743\n0.051286\n0.004431\n0.004672\n0.239193\n0.127295\n0.005886\n0.009522\n0.002642\n...\n0.009600\n0.007545\n0.044294\n0.013336\n0.001851\n0.074820\n0.109686\n0.005783\n0.001141\n0.012366\nISG15\n0.412864\n0.386006\n0.502053\n0.174437\n0.136781\n0.391983\n0.042844\n0.363116\n0.340214\n0.340523\n...\n0.354593\n0.026318\n0.085551\n0.235624\n0.197040\n0.441866\n0.612398\n0.588833\n0.357066\n0.088883\n5 rows × 103 columns\n对参考数据和空转数据中基因取交集\nIn [9]:\nadata_vis\n.\nvar\n.\nhead\n()\nOut[9]:\nfeature_types\ngenome\nSYMBOL\nmt\nn_cells_by_counts-6800STDY12499406\nmean_counts-6800STDY12499406\nlog1p_mean_counts-6800STDY12499406\npct_dropout_by_counts-6800STDY12499406\ntotal_counts-6800STDY12499406\nlog1p_total_counts-6800STDY12499406\n...\nlog1p_mean_counts-6800STDY12499508\npct_dropout_by_counts-6800STDY12499508\ntotal_counts-6800STDY12499508\nlog1p_total_counts-6800STDY12499508\nn_cells_by_counts-6800STDY12499509\nmean_counts-6800STDY12499509\nlog1p_mean_counts-6800STDY12499509\npct_dropout_by_counts-6800STDY12499509\ntotal_counts-6800STDY12499509\nlog1p_total_counts-6800STDY12499509\nENSEMBL\nENSG00000243485\nGene Expression\nGRCh38\nMIR1302-2HG\nFalse\n0\n0.000000\n0.000000\n100.000000\n0.0\n0.000000\n...\n0.000353\n99.964677\n1.0\n0.693147\n0\n0.000000\n0.000000\n100.000000\n0.0\n0.000000\nENSG00000237613\nGene Expression\nGRCh38\nFAM138A\nFalse\n0\n0.000000\n0.000000\n100.000000\n0.0\n0.000000\n...\n0.000000\n100.000000\n0.0\n0.000000\n0\n0.000000\n0.000000\n100.000000\n0.0\n0.000000\nENSG00000186092\nGene Expression\nGRCh38\nOR4F5\nFalse\n0\n0.000000\n0.000000\n100.000000\n0.0\n0.000000\n...\n0.000000\n100.000000\n0.0\n0.000000\n0\n0.000000\n0.000000\n100.000000\n0.0\n0.000000\nENSG00000238009\nGene Expression\nGRCh38\nAL627309.1\nFalse\n4\n0.001193\n0.001193\n99.880668\n4.0\n1.609438\n...\n0.002822\n99.717414\n8.0\n2.197225\n1\n0.000356\n0.000356\n99.964425\n1.0\n0.693147\nENSG00000239945\nGene Expression\nGRCh38\nAL627309.3\nFalse\n0\n0.000000\n0.000000\n100.000000\n0.0\n0.000000\n...\n0.000000\n100.000000\n0.0\n0.000000\n0\n0.000000\n0.000000\n100.000000\n0.0\n0.000000\n5 rows × 100 columns\nIn [10]:\nis_dup\n=\nadata_vis\n.\nvar\n[\n\"SYMBOL\"\n]\n.\nduplicated\n()\n.\ntolist\n()\nsymbol\n=\nadata_vis\n.\nvar\n[\n\"SYMBOL\"\n]\n.\ntolist\n()\nensembl\n=\nadata_vis\n.\nvar\n.\nindex\n.\ntolist\n()\nuni_symbol\n=\n[(\nsymbol\n[\ni\n]\n+\n\"_\"\n+\nensembl\n[\ni\n])\nif\nis_dup\n[\ni\n]\nelse\nsymbol\n[\ni\n]\nfor\ni\nin\nrange\n(\nlen\n(\nis_dup\n))]\nIn [11]:\nadata_vis\n.\nvar_names\n=\nuni_symbol\nIn [12]:\nadata_vis\n.\nvar\n.\nhead\n()\nOut[12]:\nfeature_types\ngenome\nSYMBOL\nmt\nn_cells_by_counts-6800STDY12499406\nmean_counts-6800STDY12499406\nlog1p_mean_counts-6800STDY12499406\npct_dropout_by_counts-6800STDY12499406\ntotal_counts-6800STDY12499406\nlog1p_total_counts-6800STDY12499406\n...\nlog1p_mean_counts-6800STDY12499508\npct_dropout_by_counts-6800STDY12499508\ntotal_counts-6800STDY12499508\nlog1p_total_counts-6800STDY12499508\nn_cells_by_counts-6800STDY12499509\nmean_counts-6800STDY12499509\nlog1p_mean_counts-6800STDY12499509\npct_dropout_by_counts-6800STDY12499509\ntotal_counts-6800STDY12499509\nlog1p_total_counts-6800STDY12499509\nMIR1302-2HG\nGene Expression\nGRCh38\nMIR1302-2HG\nFalse\n0\n0.000000\n0.000000\n100.000000\n0.0\n0.000000\n...\n0.000353\n99.964677\n1.0\n0.693147\n0\n0.000000\n0.000000\n100.000000\n0.0\n0.000000\nFAM138A\nGene Expression\nGRCh38\nFAM138A\nFalse\n0\n0.000000\n0.000000\n100.000000\n0.0\n0.000000\n...\n0.000000\n100.000000\n0.0\n0.000000\n0\n0.000000\n0.000000\n100.000000\n0.0\n0.000000\nOR4F5\nGene Expression\nGRCh38\nOR4F5\nFalse\n0\n0.000000\n0.000000\n100.000000\n0.0\n0.000000\n...\n0.000000\n100.000000\n0.0\n0.000000\n0\n0.000000\n0.000000\n100.000000\n0.0\n0.000000\nAL627309.1\nGene Expression\nGRCh38\nAL627309.1\nFalse\n4\n0.001193\n0.001193\n99.880668\n4.0\n1.609438\n...\n0.002822\n99.717414\n8.0\n2.197225\n1\n0.000356\n0.000356\n99.964425\n1.0\n0.693147\nAL627309.3\nGene Expression\nGRCh38\nAL627309.3\nFalse\n0\n0.000000\n0.000000\n100.000000\n0.0\n0.000000\n...\n0.000000\n100.000000\n0.0\n0.000000\n0\n0.000000\n0.000000\n100.000000\n0.0\n0.000000\n5 rows × 100 columns\nIn [13]:\n# find shared genes and subset both anndata and reference signatures\nintersect\n=\nnp\n.\nintersect1d\n(\nadata_vis\n.\nvar_names\n,\ninf_aver\n.\nindex\n)\nadata_vis\n=\nadata_vis\n[:,\nintersect\n]\n.\ncopy\n()\ninf_aver\n=\ninf_aver\n.\nloc\n[\nintersect\n,\n:]\n.\ncopy\n()\nIn [14]:\nadata_vis\n.\nshape\n,\ninf_aver\n.\nshape\nOut[14]:\nThe reference signature model was further used by cell2location to estimate spatial abundance of cell\ntypes. We kept genes that were shared with scRNA-seq and estimated the abundance of cell types in tumor core and interface\ngroups respectively. In this step, cell2location was used with the following parameter settings:\ntraining iterations: 20,000,\nnumber of cells per location N = 20,\n‘detection_alpha’ = 200\nIn [15]:\n# prepare anndata for cell2location model\ncell2location\n.\nmodels\n.\nCell2location\n.\nsetup_anndata\n(\nadata\n=\nadata_vis\n,\nbatch_key\n=\n\"sample\"\n)\nIn [16]:\n# create and train the model\nmod\n=\ncell2location\n.\nmodels\n.\nCell2location\n(\nadata_vis\n,\ncell_state_df\n=\ninf_aver\n,\n# the expected average cell abundance: tissue-dependent\n# hyper-prior which can be estimated from paired histology:\nN_cells_per_location\n=\n20\n,\n# hyperparameter controlling normalisation of\n# within-experiment variation in RNA detection:\ndetection_alpha\n=\n200\n)\nmod\n.\nview_anndata_setup\n()\n这里我们使用一个较小的迭代次数，减小模型训练时间\nIn [ ]:\n## 使用GPU训练\n# import torch\n# if torch.cuda.is_available():\n#     mod.train(max_epochs=10000, batch_size=None, train_size=1, use_gpu=True)\nIn [17]:\nmod\n.\ntrain\n(\nmax_epochs\n=\n10000\n,\n# train using full data (batch_size=None)\nbatch_size\n=\nNone\n,\n# use all data points in training because\n# we need to estimate cell abundance at all locations\ntrain_size\n=\n1\n,\nuse_gpu\n=\nFalse\n,\n)\n# plot ELBO loss history during training, removing first 100 epochs from the plot\nmod\n.\nplot_history\n(\n1000\n)\nplt\n.\nlegend\n(\nlabels\n=\n[\n'full data training'\n]);\ncell2location最终的结果是输出一个后验概率，用来表示spot中不同细胞类型的丰度。\n最终的结果存储在\nadata_vis.obsm\n中。\n注意： cell2location给出的每种细胞在每个spot中的后验概率其实是一个分布。export_posterior函数输出的是这个分布的均值，5%分位数，95%分位数来代表这个分布。\nIn [18]:\n# In this section, we export the estimated cell abundance (summary of the posterior distribution).\nadata_vis\n=\nmod\n.\nexport_posterior\n(\nadata_vis\n,\nsample_kwargs\n=\n{\n'num_samples'\n:\n1000\n,\n'batch_size'\n:\nmod\n.\nadata\n.\nn_obs\n,\n'use_gpu'\n:\nFalse\n}\n)\n# Save model\nmod\n.\nsave\n(\nf\n\"\n{\nrun_name\n}\n\"\n,\noverwrite\n=\nTrue\n)\n# mod = cell2location.models.Cell2location.load(f\"{run_name}\", adata_vis)\n# Save anndata object with results\nadata_file\n=\nf\n\"\n{\nrun_name\n}\n/sp.h5ad\"\nadata_vis\n.\nwrite\n(\nadata_file\n)\nadata_file\nOut[18]:\n散点图具有正相关的趋势说明模型可以用来解释数据\nIn [19]:\nmod\n.\nplot_QC\n()",
    "chapter_info": {
      "id": "main_FigureYa309cell2location_03_cell2location_mapping",
      "title": "FigureYa309cell2location/03_cell2location_mapping.html",
      "html": "FigureYa309cell2location/03_cell2location_mapping.html",
      "text": "texts/main_FigureYa309cell2location_03_cell2location_mapping.txt",
      "folder": "FigureYa309cell2location",
      "thumb": "gallery_compress/FigureYa309cell2location.webp"
    },
    "word_count": 1137,
    "lines_count": 889,
    "title": "In [1]:",
    "description": "暂无描述",
    "input_data_types": [
      "RNA-seq"
    ],
    "output_types": [
      "散点图"
    ],
    "technical_methods": [],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "adata_vis",
      "overwrite",
      "detection_alpha",
      "train_size",
      "inf_aver",
      "index_col",
      "is_dup",
      "use_gpu",
      "ensembl",
      "batch_key"
    ]
  },
  {
    "id": "main_FigureYa218Elasticnet_FigureYa218Elasticnet",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa218Elasticnet_FigureYa218Elasticnet.txt",
    "content": "FigureYa218Elasticnet\nFigureYa218Elasticnet\nAuthor(s)\n: Xiaofan Lu; Ying Ge, Yijing Chen\nDate\n: 2025-09-30\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n我想实现弹性网络筛选和分类的数据分析。根据表达矩阵，绘制figure2的A,B,C筛选和系数图，再根据结果绘制分类效果E图，得到准确率。\nI would like to try data analysis for resilient network screening and\nclassification. Based on the expression matrix, I will generate the\nscreening and coefficient plots for groups A, B, and C as shown in\nFigure 2. Subsequently, I will plot the classification performance\ndiagram E based on the results to determine the accuracy rate.\n出自\nhttps://www.frontiersin.org/articles/10.3389/fgene.2020.00857/full\nFIGURE 2 | The screening and validation of 15 genes conducted by the\ndiagnostic classifier. (A,B) Binomial deviance as a function of the\nregularization parameter lambda for leave-one-study-out cross-validation\non the training datasets. Points correspond to the means, and error bars\ncorrespond to the standard deviations. Coefficients of 15 genes were\nselected by the lambda with the minimum binomial deviance marked by the\nblue dashed line (lambda = 0.025, ln(lambda) = −3.692). (C) Coefficient\nvalues for each of the fifteen selected genes. A positive coefficient\nfor a gene signature within its class indicates that elevated expression\nof this gene increases the probability of a specimen belonging to its\ntissue type. (D) Heatmap for describing the expression levels of\nselected genes in the binomial classifier erected by training datasets.\nEach row is a gene with its Entrez Gene ID in parentheses; each column\nis a sample. (E) Estimated probabilities for samples in testing datasets\n(GSE101685 and ICGC). For each sample, there are two points,\ncorresponding to the probability that the sample belongs to the\nrespective class. Within each dataset and class, samples are sorted by\nthe probability of the true class. For most samples, the probability of\nthe true subtype is near 1, indicating an unambiguous\nclassification.\nfrom\nhttps://www.frontiersin.org/articles/10.3389/fgene.2020.00857/full\nFIGURE 2 | The screening and validation of 15 genes conducted by the\ndiagnostic classifier. (A,B) Binomial deviance as a function of the\nregularization parameter lambda for leave-one-study-out cross-validation\non the training datasets. Points correspond to the means, and error bars\ncorrespond to the standard deviations. Coefficients of 15 genes were\nselected by the lambda with the minimum binomial deviance marked by the\nblue dashed line (lambda = 0.025, ln(lambda) = −3.692). (C) Coefficient\nvalues for each of the fifteen selected genes. A positive coefficient\nfor a gene signature within its class indicates that elevated expression\nof this gene increases the probability of a specimen belonging to its\ntissue type. (D) Heatmap for describing the expression levels of\nselected genes in the binomial classifier erected by training datasets.\nEach row is a gene with its Entrez Gene ID in parentheses; each column\nis a sample. (E) Estimated probabilities for samples in testing datasets\n(GSE101685 and ICGC). For each sample, there are two points,\ncorresponding to the probability that the sample belongs to the\nrespective class. Within each dataset and class, samples are sorted by\nthe probability of the true class. For most samples, the probability of\nthe true subtype is near 1, indicating an unambiguous\nclassification.\n应用场景\nApplication scenario\n根据弹性网络筛选变量构建分类模型，生成筛选和系数图，以及分类效果图。\nConstruct a classification model by selecting variables based on the\nelastic net, generate screening and coefficient diagrams, as well as\nclassification effect diagrams.\n环境设置\nEnvironment setting\nsource(\"install_dependencies.R\")\nlibrary(data.table)\nlibrary(glmnet)\nlibrary(limma)\nlibrary(ggplot2)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 display English error messages\noptions(stringsAsFactors = FALSE) #禁止chr转成factor prohibit the conversion of chr to factor\n输入文件的获得\nAcquisition of input files\n提取感兴趣的肿瘤及对照组织的表达数据。如果你已经准备好，就跳过这步，直接进入“输入文件”。\n这里用TCGA的肿瘤，用GTEX的正常组织作为对照。从UCSC xena\nhttps://xenabrowser.net/datapages/\n下载经过TOIL流程统一处理的TCGA和GTEx的TPM值，free\nof computational batch effects。从中提取肝癌和肝脏数据。\nTCGA与GTEX合并的表达数据：\nhttps://xenabrowser.net/datapages/?dataset=TcgaTargetGtex_rsem_gene_tpm&host=https%3A%2F%2Ftoil.xenahubs.net&removeHub=https%3A%2F%2Fxena.treehouse.gi.ucsc.edu%3A443\n样本注释信息：\nhttps://xenabrowser.net/datapages/?dataset=TcgaTargetGTEX_phenotype.txt&host=https%3A%2F%2Ftoil.xenahubs.net&removeHub=https%3A%2F%2Fxena.treehouse.gi.ucsc.edu%3A443\n我们在FigureYa55panCancer_violin有过类似的操作。\nExtract expression data for tumours and control tissues of interest.\nIf you have already prepared these, skip this step and proceed directly\nto “Input Files”.\nHere, we utilise TCGA tumours with GTEX normal tissues as controls.\nDownload the TPM values for TCGA and GTEx, processed uniformly via the\nTOIL workflow and free of computational batch effects, from UCSC xena\nhttps://xenabrowser.net/datapages/\n. Extract data for\nhepatocellular carcinoma and liver tissue.\nCombined TCGA and GTEX expression data:\nhttps://xenabrowser.net/datapages/?dataset=TcgaTargetGtex_rsem_gene_tpm&host=https%3A%2F%2Ftoil.xenahubs.net&removeHub=https%3A%2F%2Fxena.treehouse.gi.ucsc.edu%3A443\nSample annotation information:\nhttps://xenabrowser.net/datapages/?dataset=TcgaTargetGTEX_phenotype.txt&host=https%3A%2F%2Ftoil.xenahubs.net&removeHub=https%3A%2F%2Fxena.treehouse.gi.ucsc.edu%3A443\nWe have performed similar operations on\nFigureYa55panCancer_violin.\n# 加载基因注释文件XENA网站\n# Load gene annotation file XENA website\nGinfo <- read.table(\"overlapTable27.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\n\nphenotype <- read.table(\"TcgaTargetGTEX_phenotype.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\nphenotype <- phenotype[which(phenotype$`_study` %in% c(\"TCGA\",\"GTEX\")),] # 仅筛选TCGA和GETX，移除TARGET filter out TCGA and GETX only, remove TARGET\nphenotype <- phenotype[which(phenotype$`_primary_site` != \"\"),] # 删除值为空的位点 remove site with empty value\n\n# 以下数据（9个G）提取过程需要内存较大的电脑（纯R，不受操作系统限制）\n# 或者用cut命令提取（需Linux或MAC），可参考FigureYa56immune_inflitration\n# The extraction process for the following data (9 GB) requires a computer with substantial memory (pure R, not restricted by operating system)\n# Alternatively, use the cut command for extraction (requires Linux or MAC), refer to FigureYa56immune_inflitration\ntpm <- fread(\"TcgaTargetGtex_rsem_gene_tpm\",sep = \"\\t\",header = T,check.names = F,stringsAsFactors = F)\ntpm.df <- as.data.frame(tpm)\nensembl <- sapply(strsplit(tpm$sample,\".\",fixed = T),\"[\",1) # 取出有效的Ensembl ID Retrieve valid Ensembl IDs\n\n# 过滤出感兴趣的数据集\n# Filter out the datasets of interest\nsites <- unique(phenotype$`_primary_site`) # 提出所有有效的位点 Identify all valid sites\nsites # 查看位点 View sites\ntissue <- \"Liver\" # 设置位点（必须为有效位点） Set site (must be a valid site)\nif(!is.element(tissue, sites)) { # 如不存在则报错 If it does not exist, report an error\n  stop(\"incorrect tissue, should be one of the primary_site column in phenotype.txt file.\")\n}\n\nphenotype_tissue <- phenotype[which(phenotype$`_primary_site` == tissue),]\nif(length(unique(phenotype_tissue$`_study`)) == 2) { # 必须同时含有TCGA和GETX数据 Must contain both TCGA and GTEx data\n  tcga.barcode <- intersect(rownames(phenotype_tissue[which(phenotype_tissue$`_study` == \"TCGA\"),]), colnames(tpm.df)) # 获取TCGA样本 get TCGA samples\n  gtex.barcode <- intersect(rownames(phenotype_tissue[which(phenotype_tissue$`_study` == \"GTEX\"),]), colnames(tpm.df)) # 获取GTEX样本 get GTEX samples\n \n  combined.tpm <- tpm.df[,c(tcga.barcode,gtex.barcode)]  \n  combined.tpm <- 2^(combined.tpm) - 0.001 # 官网数据为log2(x+0.001)转换的，这里转回来 The official website data has been converted to log2(x+0.001), and here it is converted back\n  combined.tpm[combined.tpm < 0] <- 0 # 由于原数据是+0.001来的，所以这里所有<0的数据均为最小值，拉为0 As the original data was +0.001, all values <0 here represent the minimum value and are adjusted to 0\n  combined.tpm <- log2(combined.tpm + 1) # 重新对数化，保证0还是0 Re-logarithmisation ensures zero remains zero\n  rownames(combined.tpm) <- ensembl # 添上行名 Add the row name\n  \n  comgene <- intersect(rownames(combined.tpm), rownames(Ginfo)) # 取出和注释文件一致的基因 Extract the genes corresponding to the annotated files\n  \n  # 将Ensembl ID转为symbol\n  # Convert Ensembl ID to symbol\n  combined.tpm <- combined.tpm[comgene,]\n  combined.tpm$genename <- Ginfo[comgene,\"genename\"]\n  combined.tpm <- combined.tpm[!duplicated(combined.tpm$genename),] # 去除重复基因 Remove duplicate genes\n  rownames(combined.tpm) <- combined.tpm$genename \n  combined.tpm <- combined.tpm[,-ncol(combined.tpm)]\n} else {\n  stop(\"this tissue has only one of TCGA or GTEX data, please switch to another tissue.\") # 若缺少任何一个数据库，则报错 If any database is missing, an error will be reported\n}\n# 保存数据\n# Save data\nwrite.table(combined.tpm,paste0(\"tpms_\",tissue,\"_TCGAGTEX.txt\"),sep = \"\\t\",row.names = T,col.names = NA,quote = F)\n输入文件\nInput Files\n训练集：\ntpms_Liver_TCGAGTEX.txt，TCGA（肝癌）和GTEX（正常组织）表达矩阵。\nlihc_sinfo.txt，TCGA肝癌临床信息\n测试集（GEO数据的下载及数据预处理可参考FigureYa203ComBat）\ngse101685.expr.txt，表达矩阵\ngse101685.sinfo.txt，样本信息\n加载数据，构建训练集和测试集，并定义早期肝癌与正常组织。\nTraining set:\ntpms_Liver_TCGAGTEX.txt, TCGA (liver cancer) and GTEX (normal\ntissue) expression matrices.\nlihc_sinfo.txt, TCGA liver cancer clinical information\nTest set (GEO data download and preprocessing can be referenced to\nFigureYa203ComBat)\ngse101685.expr.txt, expression matrix\ngse101685.sinfo.txt, sample information\nLoad data, construct training and test sets, and define early-stage\nhepatocellular carcinoma versus normal tissue.\ngse101685.expr$Gene <- sapply(strsplit(rownames(gse101685.expr),\" /// \",fixed = T),\"[\",1)\ngse101685.expr <- apply(gse101685.expr[,setdiff(colnames(gse101685.expr), \"Gene\")], 2, function(x) tapply(x, INDEX=factor(gse101685.expr$Gene), FUN=median, na.rm=TRUE))\ngse101685.expr <- as.data.frame(round(gse101685.expr,2))\nwrite.csv(gse101685.expr, \"easy_input_GSE101685.csv\", quote = F)\n#rownames(gse101685.expr) <- gsub(\"-\",\"_\",rownames(gse101685.expr),fixed = T)\n\ngse101685.sinfo <- read.delim(\"gse101685.sinfo.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\ngse.tumsam <- intersect(rownames(gse101685.sinfo[which(gse101685.sinfo$`1:TISSUE` == \"Hepatocellular carcinoma\" & gse101685.sinfo$`1:STAGE` == \"T1\"),]),colnames(gse101685.expr)) # 取出肝癌且早期的样本 Retrieve samples of early-stage liver cancer\ngse.norsam <- intersect(rownames(gse101685.sinfo[which(gse101685.sinfo$`1:TISSUE` == \"Normal liver\"),]),colnames(gse101685.expr)) # 取出正常样本 Retrieve the normal sample\n\n# 构建GSE最终表达谱以及样本信息\n# Construct the final expression profile and sample information for GSE\ngse.expr <- gse101685.expr[,c(gse.tumsam,gse.norsam)]\ngse.sinfo <- data.frame(samID = c(gse.tumsam,gse.norsam),\n                        tissue = rep(c(\"Tumor\",\"Normal\"),c(length(gse.tumsam),length(gse.norsam))),\n                        row.names = c(gse.tumsam,gse.norsam),\n                        stringsAsFactors = F)\n构建弹性网络预测模型，查看效果\nConstruct an elastic net prediction model and check the effect\n根据弹性网络筛选变量构建分类模型。\n在训练集构建弹性网络预测模型，分别查看模型在训练集和测试集的效果。\nBuild a classification model by selecting variables based on the\nelastic net.\nBuild an elastic net predictive model on the training set and examine\nthe effectiveness on both the training set and the test set.\n# 选取共同基因\n# Select common genes\ncomgene <- intersect(rownames(tcga.expr),rownames(gse.expr))\n\n# 先挑选一部分差异表达基因来构建模型\n# First, select a subset of differentially expressed genes to construct the model\npd <- data.frame(Samples = tcga.sinfo$samID,\n                 Group = tcga.sinfo$tissue,\n                 stringsAsFactors = FALSE)\ndesign <-model.matrix(~ -1 + factor(pd$Group, levels = c(\"Tumor\",\"Normal\")))\ncolnames(design) <- c(\"Tumor\",\"Normal\")\ngset <- tcga.expr[comgene,pd$Samples]\nfit <- limma::lmFit(gset, design = design);\ncontrastsMatrix <- limma::makeContrasts(Tumor - Normal, levels = c(\"Tumor\", \"Normal\"))\nfit2 <- limma::contrasts.fit(fit, contrasts = contrastsMatrix)\nfit2 <- limma::eBayes(fit2, 0.01)\nresData <- limma::topTable(fit2, adjust = \"fdr\", sort.by = \"B\", number = 100000)\nresData <- as.data.frame(subset(resData, select=c(\"logFC\",\"t\",\"B\",\"P.Value\",\"adj.P.Val\")))\nresData$id <- rownames(resData)\ncolnames(resData) <- c(\"log2fc\",\"t\",\"B\",\"pvalue\",\"padj\",\"id\")\nresData$fc <- 2^resData$log2fc\nresData <- resData[order(resData$padj),c(\"id\",\"fc\",\"log2fc\",\"pvalue\",\"padj\")]\nwrite.table(resData,\"limma results between early liver cancer and normal tissues.txt\",sep = \"\\t\",row.names = F,col.names = T,quote = F)\n\n# 训练弹性网络\n# Train elastic networks\ndegs <- resData[which(abs(resData$log2fc) > log2(1.5) & resData$padj < 0.05),] # 取出差异表达基因 Extract differentially expressed genes\nx <- scale(t(tcga.expr[rownames(degs),rownames(tcga.sinfo)])) # 数据标准化 Data standardisation\ny <- as.factor(ifelse(tcga.sinfo$tissue == \"Tumor\",1,0))\nset.seed(20201104) # 设置种子使得结果可重复 Set the seed to ensure reproducible results\ncvfit <- cv.glmnet(x, y, \n                   nfolds = nrow(x), # 余一交叉验证 Leave-one-out cross-validation\n                   family = \"binomial\", # 二分类模型 Binary classification model\n                   grouped = FALSE, # 在余一交叉验证的时候设置为FALSE Set it to FALSE during leave-one-out cross-validation\n                   alpha = 0.9, # 原文参数（alpha=0为岭回归；=1为lasso；=0~1为弹性网络） Original text parameters (alpha=0 for ridge regression; alpha=1 for lasso; alpha between 0 and 1 for elastic net)\n                   type.measure = \"deviance\") # 原文参数 Original text parameters\n\n# 取出系数不为0的变量\n# Extract variables with non-zero coefficients\nmyCoefs <- coef(cvfit, s=\"lambda.min\");\nlasso_fea <- rownames(coef(cvfit, s = 'lambda.min'))[coef(cvfit, s = 'lambda.min')[,1]!= 0]\nif(is.element(\"(Intercept)\", lasso_fea)) {\n  lasso_fea <- lasso_fea[-1] # 去掉截距项 Remove the intercept term\n}\n\n# 查看模型在训练集的效果\n# Examine the performance of the model on the training set\npred_train <- data.frame(prob = round(predict(cvfit, newx = x,type=\"response\"),4)[,1],\n                         tissue = tcga.sinfo$tissue)\n\n# 查看模型在测试集的效果\n# Examine the performance of the model on the test set\nx <- as.matrix(as.data.frame(scale(t(gse.expr[rownames(degs),gse.sinfo$samID]))))\npred_test <- data.frame(prob = round(predict(cvfit, newx = x,type=\"response\"),4)[,1],\n                        tissue = gse.sinfo$tissue)\n开始画图\nStart drawing\n生成筛选和系数图，以及分类效果图。\nGenerate screening and coefficient plots, along with classification\nperformance diagrams.\n# Figure 2A\npdf(\"Figure2A.pdf\",width = 4.5,height = 4)\npar(bty=\"o\", mgp = c(2,0.5,0), mar = c(3.1,3.1,2.1,2.1),tcl=-.25,las = 1)\nplot(cvfit)\ndev.off()\n# Figure 2B\npdf(\"Figure2B.pdf\",width = 4.5,height = 4)\npar(bty=\"o\", mgp = c(2,0.5,0), mar = c(3.1,3.1,2.1,2.1),tcl=-.25,las = 1)\nplot(cvfit$glmnet.fit, \"lambda\", label=FALSE)\ndev.off()\n# Figure 2C\ncoeff <- myCoefs@x[-1]; names(coeff) <- lasso_fea\ncoeff <- sort(coeff,decreasing = F)\ncoeff.dt <- data.frame(gene = rep(names(coeff),2),\n                    coeff = c(as.numeric(coeff),-as.numeric(coeff)),\n                    tissue = rep(c(\"Tumor\",\"Normal\"),c(length(coeff),length(coeff))))\ncoeff.dt$gene <- factor(coeff.dt$gene, levels = names(coeff))\np <- ggplot(data=coeff.dt, aes(x=gene, y=coeff,fill = tissue)) +\n  geom_bar(stat=\"identity\") + \n  scale_fill_manual(values = c(\"#E4191B\",\"#357EB8\")) + \n  coord_flip() + \n  facet_grid( ~ tissue) +\n  theme_bw() +\n  ylab(\"Coefficient\") + xlab(\"\") +\n  theme(legend.position = \"none\",\n        axis.title = element_text(size = 12,color = \"black\"),\n        axis.text = element_text(color = \"black\"))\np\nggsave(file = \"Figure2C.pdf\",width = 8,height = 6)\n\n# Figure 2E\ntmp1 <- pred_test[which(pred_test$tissue == \"Tumor\"),]\ntmp2 <- pred_test[which(pred_test$tissue == \"Normal\"),]\ntmp1 <- tmp1[order(tmp1$prob,decreasing = T),] # 肿瘤概率降序 Tumor probability in descending order\ntmp2 <- tmp2[order(tmp2$prob,decreasing = F),] # 正常概率升序 Normal probability in ascending order\n\npred.dt <- rbind.data.frame(tmp1,tmp2)\npred.dt$Pred.Tumor <- pred.dt$prob\npred.dt$Pred.Normal <- 1-pred.dt$prob\npred.dt$sample <- c(1:length(gse.tumsam), 1:length(gse.norsam))\nlong <- melt(setDT(pred.dt[,2:5]), id.vars = c(\"tissue\",\"sample\"), variable.name = \"pred\")\n\np <- ggplot(data=long, aes(x=sample, y=value,color = pred)) +\n  geom_point(stat=\"identity\") + \n  scale_color_manual(values = c(\"#E4191B\",\"#357EB8\")) + \n  facet_grid( ~ tissue) +\n  theme_bw() +\n  ylab(\"Probability\") + xlab(\"Sample\") +\n  theme(legend.position = \"bottom\",\n        legend.title = element_blank(),\n        axis.text = element_text(colour = \"black\"),\n        axis.title = element_text(size = 12,color = \"black\"))\np\nggsave(file = \"Figure2E.pdf\",width = 6,height = 4)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa218Elasticnet_FigureYa218Elasticnet",
      "title": "FigureYa218Elasticnet/FigureYa218Elasticnet.html",
      "html": "FigureYa218Elasticnet/FigureYa218Elasticnet.html",
      "text": "texts/main_FigureYa218Elasticnet_FigureYa218Elasticnet.txt",
      "folder": "FigureYa218Elasticnet",
      "thumb": "gallery_compress/FigureYa218Elasticnet.webp"
    },
    "word_count": 1847,
    "lines_count": 318,
    "title": "FigureYa218Elasticnet",
    "description": "Requirement description 我想实现弹性网络筛选和分类的数据分析。根据表达矩阵，绘制figure2的A,B,C筛选和系数图，再根据结果绘制分类效果E图，得到准确率。 I would like to try data analysis for resilient network screening and",
    "input_data_types": [
      "临床数据",
      "表达矩阵"
    ],
    "output_types": [
      "火山图",
      "热图",
      "统计表格",
      "箱线图",
      "网络图"
    ],
    "technical_methods": [
      "网络分析",
      "标准化",
      "差异表达分析"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "measure",
      "label",
      "gene",
      "coeff",
      "values",
      "colour",
      "header",
      "width",
      "prob"
    ]
  },
  {
    "id": "main_FigureYa211multiCohortImmSubtype_FigureYa211multiCohortImmSubtype",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa211multiCohortImmSubtype_FigureYa211multiCohortImmSubtype.txt",
    "content": "FigureYa211multiCohortImmSubtype\nFigureYa211multiCohortImmSubtype\nXiaofan Lu\n2025-5-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n以往的分子分型都是基于基因表达来做的，这有一个是基于多数据集免疫细胞的，输出Fig.1\nA和B。\nRequirement Description\nIn the past, molecular typing was based on gene expression, but one\nof them is based on multiple datasets of immune cell. Outputs Fig.1 A\nand B.\n出自\nhttps://www.cell.com/molecular-therapy-family/nucleic-acids/fulltext/S2162-2531(20)30259-6\nfrom\nhttps://www.cell.com/molecular-therapy-family/nucleic-acids/fulltext/S2162-2531(20)30259-6\nFigure 1. The Landscape of Immuno-cell Infiltration in the TME of\nHNSC (A) Unsupervised clustering of tumor-infiltrating immune cells in\nfive independent HNSC cohorts. Rows represent tumor-infiltrating immune\ncells, and columns represent samples. (B) Kaplan-Meier curves for\noverall survival (OS) of all HNSC patients with immune cell-infiltrating\nclasses. Log rank test showed an overall p = 0.018.\n跟FigureYa201ClusterCorrelation、FigureYa203ComBat、FigureYa204PCAscore出自同一篇文章。\nIt’s from the same article as FigureYa201ClusterCorrelation,\nFigureYa203ComBat, and FigureYa204PCAscore.\n应用场景\n不同平台的表达谱，去除批次效应后，计算免疫富集，并进行分子分型与生存分析。\n原文：We performed the CIBERSORT and ESTIMATE algorithms to quantify\nthe activity or enrichment levels of immune cells in HNSC tumor\ntissues.\nApplication Scenarios\nExpression profiles of different platforms, after removing batch\neffects, immune enrichment was calculated, and molecular typing and\nsurvival analysis were performed.\nOriginal: We performed the CIBERSORT and ESTIMATE algorithms to\nquantify the activity or enrichment levels of immune cells in HNSC tumor\ntissues.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nlibrary(sva)\nlibrary(ConsensusClusterPlus)\nlibrary(survminer)\nlibrary(survival)\nlibrary(estimate)\nlibrary(pheatmap)\nsource(\"CIBERSORT.R\")\n\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # error messages are displayed in English\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # chr is not allowed to be converted to factor\n自定义函数，用于数据标准化并截断极端值 Custom functions for data\nnormalization and truncation of extreme values\nstandarize.fun <- function(indata=NULL, halfwidth=NULL, centerFlag=T, scaleFlag=T) {  \n  outdata=t(scale(t(indata), center=centerFlag, scale=scaleFlag))\n  if (!is.null(halfwidth)) {\n    outdata[outdata>halfwidth]=halfwidth\n    outdata[outdata<(-halfwidth)]= -halfwidth\n  }\n  return(outdata)\n}\n输入文件\n表达矩阵文件，数据下载和预处理可参考FigureYa203ComBat。\nTCGA\nhnsc的表达数据和生存信息：tcga_hnsc.expr.txt和tcga_hnsc.surv.txt。可以用TCGAbiolinks下载，或从\nxena\n下载。\n来自GEO的芯片数据和生存信息：gse41613.expr.txt和gse41613.surv.txt，gse65858.expr.txt和gse65858.surv.txt\nInput files\nThe expression matrix file, the data download and preprocessing can\nbe found in FigureYa203ComBat.\nExpression data and survival information :tcga_hnsc.expr.txt and\ntcga_hnsc.surv.txt of TCGA hnsc. It can be downloaded with TCGAbiolinks,\nor from\nxena\nChip data and survival information from\nGEO:gse41613.expr.txt\nand\ngse41613.surv.txt, gse65858.expr.txt and gse65858.surv.txt\n加载不同平台的表达谱、去除批次效应\nLoad expression profiles from different platforms to remove batch\neffects\n# 加载预处理过的表达谱\n# Load the pre-treated expression spectrum\ntcga.expr <- read.csv(\"tcga_hnsc.expr.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\ngse41613.expr <- read.table(\"gse41613.expr.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\ngse65858.expr <- read.table(\"gse65858.expr.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\n\n# 检查数据量级\n# Check the amount of data\nrange(tcga.expr) # 量级很大取对数 # The magnitude is very large and logarithm\ntcga.expr <- log2(tcga.expr + 1)\nrange(tcga.expr) # 量级在0-20 # On the magnitude of 0-20\nrange(gse41613.expr) # 量级在0-20 # On the magnitude of 0-20\nrange(gse65858.expr) # 量级在0-20 # On the magnitude of 0-20\n# 合并数据集检查批次效应\n# Merge datasets to check batch effect\ncomgene <- intersect(intersect(rownames(tcga.expr), rownames(gse41613.expr)), rownames(gse65858.expr))\ncombined.expr <- cbind.data.frame(tcga.expr[comgene,],\n                                  gse41613.expr[comgene,],\n                                  gse65858.expr[comgene,])\n\n# combat去除批次再次检查\n# combat remove the batch and check it again\nbatch <- data.frame(batch = rep(c(\"TCGA\",\"GSE41613\",\"GSE65858\"), times = c(ncol(tcga.expr),ncol(gse41613.expr),ncol(gse65858.expr))))\nmodcombat = model.matrix(~1, data = batch)\ncombined.expr.combat <- as.data.frame(ComBat(dat=as.matrix(combined.expr), batch=batch$batch, mod=modcombat))\n# 保存到txt格式的文件\n# Save to a file in txt format\nwrite.table(combined.expr.combat,\"output_combined_expr.txt\",sep = \"\\t\",row.names = T,col.names = NA,quote = F)\n加载生存数据，用于生存分析\nLoad survival data for survival analysis\ntcga.surv <- read.table(\"tcga_hnsc.surv.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\ntcga.surv <- as.data.frame(na.omit(tcga.surv)) # 去除空值 # Remove null values\nrownames(tcga.surv) <- paste0(rownames(tcga.surv),\"-01\")\ngse41613.surv <- read.table(\"gse41613.surv.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\ngse65858.surv <- read.table(\"gse65858.surv.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\n\n# 根据数据将时间转化为月份\n# Convert time to months based on data\ntcga.surv$OS.time <- tcga.surv$OS.time/30.5\ngse65858.surv$OS.time <- gse65858.surv$OS.time/30.5\n\n# 合并生存时间\n# Merge time-to-live\ntcga.surv$Project <- \"TCGA\"\ngse41613.surv$Project <- \"GSE41613\"\ngse65858.surv$Project <- \"GSE65858\"\ncombined.surv <- rbind.data.frame(tcga.surv[,c(\"OS\",\"OS.time\",\"Project\")],\n                                  gse41613.surv[,c(\"OS\",\"OS.time\",\"Project\")],\n                                  gse65858.surv[,c(\"OS\",\"OS.time\",\"Project\")])\n计算ESTIMATE得分\noutput_combined_expr.csv，上一步整合好的表达矩阵和生存信息。\nCalculate the ESTIMATE score\noutput_combined_expr.csv, the previous step integrates the expression\nmatrix and survival information.\nfilterCommonGenes(input.f = \"output_combined_expr.txt\", output.f = \"output_combined_expr.gct\", id = \"GeneSymbol\")\nestimateScore(\"output_combined_expr.gct\", \"output_combined_expr_estimate_score.txt\", platform=\"affymetrix\")\n运行CIBERSORT\n原文：Infiltration levels for distinct immune cells in HNSC were\nquantified by using “CIBERSORT” R package and employing the LM22\nsignature and 1,000 permutations.\n使用CIBERSORT前，请先注册\nhttps://cibersort.stanford.edu\n，查看教程\nhttp://cibersort.stanford.edu/tutorial.php\nLM22.txt，注册后即可下载。\nRun CIBERSORT\noriginal paper:Infiltration levels for distinct immune cells in HNSC\nwere quantified by using “CIBERSORT” R package and employing the LM22\nsignature and 1,000 permutations.\nbefore use CIBERSORT Please register for\nhttps://cibersort.stanford.edu\nfirst to view the\ntutorial\nhttp://cibersort.stanford.edu/tutorial.php\nLM22.txt, you can download it after registration.\noutput_combined_expr.txt，上一步整合好的表达矩阵和生存信息。\noutput_combined_expr.txt, the previous step integrates the\nexpression matrix and survival information.\n#这步运行时间较长\n# This step takes a long time to run\nciber.res <- CIBERSORT(sig_matrix = \"LM22.txt\",\n                       mixture_file = \"output_combined_expr.txt\",\n                       perm = 100,\n                       QN = TRUE)\n# 保存到文件\n# Save to file\nwrite.table(ciber.res,\"CIBERSORT result.txt\",sep = \"\\t\",row.names = T,col.names = NA,quote = F)\n共识PAM聚类\n原文：The unsupervised clustering “Pam” method based on Euclidean and\nWard’s linkage was used in this analysis, executed by using the\n“ConsensuClusterPlus” R package,23 and repeated 1,000 times to ensure\nthe classification stability.\nConsensus PAM clustering\noriginal paper: The unsupervised clustering “Pam” method based on\nEuclidean and Ward’s linkage was used in this analysis, executed by\nusing the “ConsensuClusterPlus” R package,23 and repeated 1,000 times to\nensure the classification stability.\nest <- read.table(\"output_combined_expr_estimate_score.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\nest <- est[,-1]; colnames(est) <- est[1,]; est <- est[-1,]\ncolnames(est) <- colnames(combined.expr.combat)\n\nciber.res <- read.table(\"CIBERSORT result.txt\", sep = \"\\t\", row.names = 1, header = T, check.names = F)\nhead(ciber.res)\n# 合并ESTIMATE获得的activity of immune cells(est)和CIBERSORT获得的enrichment levels of immune cells(ciber.res)\n# Merge the activity of immune cells (est) obtained from ESTIMATE and the enrichment levels of immune cells obtained by CIBERSORT (ciber.res)\nciber.res <- ciber.res[,1:22]\nciber.res <- ciber.res[,colSums(ciber.res) > 0] # 去除丰度均为0的细胞 # Remove cells with 0 abundance\ninput_data <- cbind.data.frame(ciber.res, \n                               ImmuneScore = as.numeric(est[\"ImmuneScore\",rownames(ciber.res)]), # 添加免疫富集 # Add immune enrichment\n                               StromalScore = as.numeric(est[\"StromalScore\",rownames(ciber.res)])) # 添加基质富集 # Add matrix enrichment\n\nindata <- t(scale(input_data))\n\n# 这一步，我运行了 < 10 min\n# For this step, I ran < for 10 min\ncc <- ConsensusClusterPlus(d = indata, \n                           maxK = 3, # 三类 # Three categories\n                           reps = 1000, # 重抽样次数，可修改 # Number of resamples, modifiable\n                           pItem = 0.8, # 列维度抽样概率，可修改 # Column dimension sampling probability, modifiable\n                           pFeature = 1, # 行维度抽样概率，可修改 # Row dimension sampling probability, modifiable \n                           clusterAlg = \"pam\", # 聚类算法，可修改 # Clustering algorithm, modifiable\n                           innerLinkage = \"ward.D\", # 内部链接函数，可修改 # Internal link function, modifiable\n                           finalLinkage = \"ward.D\", # 最终链接函数，可修改 # Last-link function, modifiable\n                           distance = \"euclidean\", # 距离测度，可修改 # Distance measurement, modifiable\n                           seed = 19991018,\n                           title = \"ConsensusCluster\",\n                           plot = \"pdf\")\nICIcluster <- cc[[3]]$consensusClass\n\n# 为生存分析作准备\n# Prepare for survival analysis\ncomsam <- intersect(rownames(combined.surv),colnames(indata))\ncombined.surv[comsam,\"ICIcluster\"] <- ifelse(ICIcluster[comsam] == 1, \"A\", # 这里把有生存信息的数据的ICIcluster补上以便后面进行生存分析 # # Here we add the ICIcluster with survival information for survival analysis later\n                                             ifelse(ICIcluster[comsam] == 2, \"B\", \"C\"))\n开始画图\n热图\nStart drawing\nHeatmap\n# 设置颜色\n# Set the color\n\nblue <- \"#2874C5\"\nyellow <- \"#EABF00\"\ngreen <- \"#008B8A\"\nred <- \"#E21F26\"\n\n# 生成热图\n# Generate a heatmap\nannCol <- data.frame(ICIcluster = ifelse(ICIcluster == 1,\"A\", ifelse(ICIcluster == 2, \"B\", \"C\")),\n                     Project = rep(c(\"TCGA\",\"GSE41613\",\"GSE65858\"),c(ncol(tcga.expr),ncol(gse41613.expr),ncol(gse65858.expr))),\n                     stringsAsFactors = F)\nannCol <- annCol[order(annCol$ICIcluster,annCol$Project),] # 这里对每个ICIcluster内部的cohort进行排序，使得相同cohort的样本彼此靠近 # Here the cohorts inside each ICIcluster are sorted so that the samples of the same cohort are close to each other\n\nannColors <- list()\nannColors[[\"ICIcluster\"]] <- c(\"A\" = red,\n                               \"B\" = blue,\n                               \"C\" = yellow)\n\nannColors[[\"Project\"]] <- c(\"TCGA\" = red,\n                            \"GSE41613\" = blue,\n                            \"GSE65858\" = yellow)\n\nplotdata <- standarize.fun(indata,halfwidth = 2) # 数据标准化并截断极端值 # Data is normalized and truncated to extreme values\npheatmap(plotdata[,rownames(annCol)],\n         cluster_cols = F,\n         color = NMF:::ccRamp(c(\"#282B71\",\"white\",\"#CF2221\"),64),\n         show_rownames = T,\n         show_colnames = F,\n         annotation_col = annCol[,c(\"ICIcluster\",\"Project\"),drop = F],\n         annotation_colors = annColors,\n         treeheight_col = 0,\n         treeheight_row = 0,\n         filename = \"ICIcluster.pdf\")\n生存分析\nSurvival Analysis\nfitd <- survdiff(Surv(OS.time, OS) ~ ICIcluster,\n                 data      = combined.surv,\n                 na.action = na.exclude)\np.val <- 1 - pchisq(fitd$chisq, length(fitd$n) - 1)\nfit <- survfit(Surv(OS.time, OS)~ ICIcluster,\n               data      = combined.surv,\n               type      = \"kaplan-meier\",\n               error     = \"greenwood\",\n               conf.type = \"plain\",\n               na.action = na.exclude)\n\n# hack strata for better survival curve\nnames(fit$strata) <- gsub(\"ICIcluster=\", \"\", names(fit$strata))\n\n# kaplan-meier curve\np <- ggsurvplot(fit               = fit,\n                conf.int          = FALSE,\n                risk.table        = TRUE,\n                risk.table.col    = \"strata\",\n                palette           = c(red, blue, yellow),\n                data              = combined.surv,\n                size              = 1,\n                xlim              = c(0,120),\n                break.time.by     = 20,\n                legend.title      = \"\",\n                pval              = FALSE, # 不计算p值，改为手动添加 # The p-value is not calculated, and is added manually\n                surv.median.line  = \"hv\",\n                xlab              = \"Time (month)\",\n                ylab              = \"Survival probability\",\n                risk.table.y.text = FALSE)\np.lab <- paste0(\"Log rank test P\", # p值文本 # P-value text\n                ifelse(p.val < 0.001, \" < 0.001\",\n                       paste0(\" = \",round(p.val, 3))))\n\np$plot <- p$plot + annotate(\"text\", # 手动添加例文样式的p值 # Manually add the p-value of the example style\n                            x = 70, \n                            y = 0.55,\n                            hjust = 0,\n                            fontface = 4,\n                            label = p.lab)\np$plot\npdf.options(reset = TRUE, onefile = FALSE)\npdf(\"km curve of ICIcluster.pdf\", width = 5, height = 6)\nprint(p)\ndev.off()\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa211multiCohortImmSubtype_FigureYa211multiCohortImmSubtype",
      "title": "FigureYa211multiCohortImmSubtype/FigureYa211multiCohortImmSubtype.html",
      "html": "FigureYa211multiCohortImmSubtype/FigureYa211multiCohortImmSubtype.html",
      "text": "texts/main_FigureYa211multiCohortImmSubtype_FigureYa211multiCohortImmSubtype.txt",
      "folder": "FigureYa211multiCohortImmSubtype",
      "thumb": "gallery_compress/FigureYa211multiCohortImmSubtype.webp"
    },
    "word_count": 1433,
    "lines_count": 309,
    "title": "FigureYa211multiCohortImmSubtype",
    "description": "以往的分子分型都是基于基因表达来做的，这有一个是基于多数据集免疫细胞的，输出Fig.1 A和B。 Requirement Description",
    "input_data_types": [
      "生存数据",
      "临床数据",
      "表达矩阵",
      "突变数据"
    ],
    "output_types": [
      "散点图",
      "热图",
      "统计表格",
      "生存曲线"
    ],
    "technical_methods": [
      "聚类分析",
      "通路分析",
      "生存分析",
      "标准化"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "seed",
      "annotation_col",
      "innerLinkage",
      "fit",
      "pval",
      "reset",
      "centerFlag",
      "mixture_file"
    ]
  },
  {
    "id": "main_FigureYa238corRiskMut_FigureYa238corRiskMut",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa238corRiskMut_FigureYa238corRiskMut.txt",
    "content": "FigureYa238corRiskMut\nFigureYa238corRiskMut\nXiaofan Lu\n2025-5-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n想实现下FigA-C，预后模型建立后寻找高低风险组中突变最显著的基因，并计算riskscore与有义和错义突变的相关性，谢谢啦\nRequirement Description\nI want to crowdsource FigA-C, find the most significant mutations in\nthe high and low risk groups after the prognostic model is established,\nand calculate the correlation between riskscore and sense and missense\nmutations, thank you\n出自\nhttps://www.nature.com/articles/s41388-021-01853-y\nfrom\nhttps://www.nature.com/articles/s41388-021-01853-y\nFig. 5 TMErisk was related to tumor mutation status. A Association\nbetween synonymous mutation counts, non-synonymous mutation counts, all\nmutation counts, and TMErisk score and their distribution in the low-\nand the high-TMErisk groups. B Forest plot of genes mutating\ndifferentially in patients of the low- and the high-TMErisk groups. C\nInteraction effect of genes mutating differentially in patients in the\nlow- and the high-TMErisk groups.\nMutation status in LUAD patients in the high- and the\nlow-TMErisk groups\nTo investigate\nTMErisk-related mechanisms\nin LUAD,\nsomatic mutations from the TCGA database were also analyzed. When\ncomparing the mutant frequency between samples of the low- and the\nhigh-TMErisk groups,\nmore somatic mutations were observed in the\nhigh-TMErisk group\n, including non-synonymous and synonymous\nmutations (Fig. 5A). Meanwhile, maftools analysis results showed that 19\ngenes mutated more frequently in LUAD patients in the high- TMErisk\ngroup, including TP53, ASTN1, RYR2, XIRP2, LRP1B, CSMD1, RYR3, PCDH15,\nTTN, KEAP1, ADAMTS12, ERICH3, DMD, CDH10, SI, SYNE1, NRXN1, CACNA1E, and\nCOL11A1 (Fig. 5B). Among these genes, eight were expressed\ndifferentially between the wild type and the mutant type (Fig. S8). The\nfrequency of mutations in these genes was also shown in Fig. 4.\nMoreover, significant co-occurrences were observed among mutations of\nthese genes (Fig. 5C).\n应用场景\n看到免疫浸润跟预后风险的关系，想进一步探究机制，例文作者从突变数据入手。\n文章里有多个图可以用我们的FigureYa实现：\nFigure 2B\n森林图，可参考FigureYa47HRtable和FigureYa193RiskTable；\nFigure 2C Time-dependent AUC，可参考FigureYa85timeROC；\nFigure 4 Landscape of immune and stromal cell\ninfiltrations，可参考FigureYa230immunelandscape\nFigure 5D 对比的饼图，可参考FigureYa196PanPie\nApplication Scenarios\nSeeing the relationship between immune infiltration and prognostic\nrisk, and wanting to further explore the mechanism, the author of the\nexample article started with mutation data.\nThere are several diagrams in the article that can be implemented\nwith our FigureYa:\nFigure 2B Forest Chart, see FigureYa47HRtable and\nFigureYa193RiskTable;\nFigure 2C Time-dependent AUC, see FigureYa85timeROC;\nFigure 4 Landscape of immune and stromal cell infiltrations, see\nFigureYa230immunelandscape\nFor a pie chart compared to Figure 5D, see FigureYa196PanPie\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nlibrary(data.table)\nlibrary(maftools)\nlibrary(tidyverse)\nlibrary(magrittr)\nlibrary(readxl)\nlibrary(stringr)\nlibrary(forcats)\nlibrary(ggplot2)\nlibrary(ggpubr)\nlibrary(cowplot)\nlibrary(patchwork)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # error messages are displayed in English\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # chr is not allowed to be converted to factor\n输入文件\n表达数据：TCGA-LUAD.htseq_fpkm.tsv.gz，gene expression RNAseq -\nHTSeq - FPKM，下载自\nXENA\nGDC\nTCGA Lung Adenocarcinoma (LUAD) (15 datasets)\n，\n突变数据：data_mutations_extended.txt，下载自\ncBioPortal\n，下载luad_tcga_pan_can_atlas_2018.tar.gz文件，解压缩把其中的data_mutations_extended.txt文件移到当前文件夹。\nInput files\nExpression data :TCGA-LUAD.htseq_fpkm.tsv.gz, gene expression\nRNAseq - HTSeq - FPKM, downloaded from\nXENA\nGDC\nTCGA Lung Adenocarcinoma (LUAD) (15 datasets)\n，\n:data_mutations_extended.txt mutation data, download it from\ncBioPortal\n, download the\nluad_tcga_pan_can_atlas_2018.tar.gz file, unzip it, and put the\ndata_mutations_ extended.txt move the file to the current\nfolder.\n# 读取表达谱\n# Read the expression spectrum\nfpkm <- fread(\"TCGA-LUAD.htseq_fpkm.tsv.gz\",sep = \"\\t\",check.names = F,stringsAsFactors = F,header = T,data.table = F)\nrownames(fpkm) <- fpkm[,1]; fpkm <- fpkm[,-1]\n\n# 加载基因表达注释文件\n# Load the gene expression annotation file\nGinfo <- read.table(\"gencode.v22.annotation.gene.probeMap\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\n\n# 将FPKM的ENSEMBL ID转为Gene Symbol并去重\n# Convert the ENSEMBL ID of the FPKM to Gene Symbol and remove the duplication\nidentical(rownames(Ginfo),rownames(fpkm))\ncomgene <- intersect(rownames(fpkm),rownames(Ginfo))\nfpkm <- fpkm[comgene,]; Ginfo <- Ginfo[comgene,]\nfpkm$Gene <- as.character(Ginfo$gene)\nfpkm <- fpkm[!duplicated(fpkm$Gene),] # 重复基因去重 # Duplicate gene deduplication\nrownames(fpkm) <- fpkm$Gene; fpkm <- fpkm[,-ncol(fpkm)]\nfpkm <- as.data.frame(round(fpkm,3)) # 取表达的小数点后3位数 # Take 3 decimal places\n\n# 取出肿瘤样本\n# Tumor sample extraction\ntumsam <- colnames(fpkm[,substr(colnames(fpkm),14,16) == \"01A\"])\n# 读取突变数据，并提取出和表达数据相同的样本\n# Read the mutation data and extract the same sample as the expression data\nlabel <- c(\"Tumor_Sample_Barcode\",\n           \"Hugo_Symbol\",\n           \"Chromosome\",\n           \"Start_Position\",\n           \"End_Position\",\n           \"Variant_Classification\",\n           \"Variant_Type\",\n           \"Reference_Allele\",\n           \"Tumor_Seq_Allele1\",\n           \"Tumor_Seq_Allele2\")\nmaf <- read_tsv(\"data_mutations_extended.txt\", comment = \"#\")\nmaf$Tumor_Sample_Barcode <- paste0(maf$Tumor_Sample_Barcode,\"A\") # 添加\"A\"后缀以匹配突变 # Add the \"A\" suffix to match the mutation\ncomsam <- intersect(tumsam,unique(maf$Tumor_Sample_Barcode)) # 取出和表达相同的样本 # Extract samples with the same expression\nmaf <- maf[which(maf$Tumor_Sample_Barcode %in% comsam),label] # 取出样本和列子集 # Take out a subset of samples and columns\nwrite.table(maf,\"data_mutations_extended_modified.txt\",sep = \"\\t\",row.names = F,col.names = T,quote = F) # 输出文件\n# Output file\n计算TMEscore并分为高低两组\nThe TMEscore is calculated and divided into two groups: high and\nlow\nindata <- fpkm[names(coeff),tumsam]\nindata <- apply(indata, 1, function(x) ifelse(x > median(x), 1, 0)) # 原文将表达转换为二元变量 # The original text converts the expression into a binary variable\nTME <- apply(indata,1,function(x) {x %*% as.numeric(coeff)}) # 根据lasso系数计算TME得分 # TME score is calculated based on the lasso coefficient\nTMErisk <- data.frame(TME = TME,\n                      risk = ifelse(TME > median(TME),\"High\",\"Low\"),\n                      row.names = names(TME),\n                      stringsAsFactors = F)\n\n## 分组，low- and the high-TMErisk groups\n## grouping, low- and the high-TMErisk groups\nhsam <- rownames(TMErisk[which(TMErisk$risk == \"High\"),])\nlsam <- rownames(TMErisk[which(TMErisk$risk == \"Low\"),])\n突变按non-synonymous and synonymous mutations分类\nMutations are classified as non-synonymous and synonymous\nmutations\n# 提取low- and the high-TMErisk groups的MAF数据\n# Extract MAF data from low- and the high-TMErisk groups\nmaf.high <- maf[which(maf$Tumor_Sample_Barcode %in% intersect(comsam,hsam)),] # 取出High-TME的MAF数据 # Retrieve the MAF data of High-TME\nmaf.low <- maf[which(maf$Tumor_Sample_Barcode %in% intersect(comsam,lsam)),] # 取出Low-TME的MAF数据 # Retrieve the MAF data of the Low-TME\nwrite.table(maf.high,\"data_mutations_extended_HRisk_modified.txt\",sep = \"\\t\",row.names = F,col.names = T,quote = F)\nwrite.table(maf.low,\"data_mutations_extended_LRisk_modified.txt\",sep = \"\\t\",row.names = F,col.names = T,quote = F)\n\n# 突变按non-synonymous and synonymous mutations分类\n# 再次读取maf文件提取突变类型\n# Mutations are classified as non-synonymous and synonymous mutations\n# Read the maf file again to extract the mutation type\nmaf <- read.maf(\"data_mutations_extended_modified.txt\") # 重新读取子集 # Re-read the subset\nsynMut <- as.character(unique(maf@maf.silent$Variant_Classification)) # 利用maftool的功能取出定义的沉默突变类型 # Use the function of maftool to get out the defined mutation type of silence\nnsynMut <- as.character(unique(maf@data$Variant_Classification)) # 取出maftool定义的非沉默突变类型 # Take out the non-silencing mutation types defined by maftool\nallMut <- c(synMut,nsynMut) # 合并得到全部突变类型 # Merge to get all mutation types\n\n# 重新读取MAF对象\n# Re-read the MAF object\nsynMut.ob <- read.maf(\"data_mutations_extended_modified.txt\",\n                      vc_nonSyn = synMut, # 将非沉默类型定义为“沉默突变”，这样返回的对象在“非沉默突变”里记载的就是“沉默突变”，因此会计算沉默突变的TMB # Define the non-silent type as \"silent mutation\", so that the returned object is recorded in the \"non-silent mutation\" as \"silent mutation\", so the TMB of the silent mutation will be calculated\n                      removeDuplicatedVariants = F)\nnsynMut.ob <- read.maf(\"data_mutations_extended_modified.txt\",\n                       vc_nonSyn = nsynMut, # 同理 # Same\n                       removeDuplicatedVariants = F)\nallMut.ob <- read.maf(\"data_mutations_extended_modified.txt\",\n                      vc_nonSyn = allMut, # 同理 # Same\n                      removeDuplicatedVariants = F)\nsynMut.TMB <- as.data.frame(synMut.ob@variants.per.sample); rownames(synMut.TMB) <- synMut.TMB$Tumor_Sample_Barcode; synMut.TMB <- synMut.TMB[comsam,]\nnsynMut.TMB <- as.data.frame(nsynMut.ob@variants.per.sample); rownames(nsynMut.TMB) <- nsynMut.TMB$Tumor_Sample_Barcode; nsynMut.TMB <- nsynMut.TMB[comsam,]\nallMut.TMB <- as.data.frame(allMut.ob@variants.per.sample); rownames(allMut.TMB) <- allMut.TMB$Tumor_Sample_Barcode; allMut.TMB <- allMut.TMB[comsam,]\n\n# 合并突变信息、高低风险\n# Combined mutation information, high and low risk\nsynMut.TMB <- cbind.data.frame(synMut.TMB,TMErisk[rownames(synMut.TMB),c(\"risk\",\"TME\")]); synMut.TMB$risk <- factor(synMut.TMB$risk, levels = c(\"Low\",\"High\"))\nhead(synMut.TMB)\nnsynMut.TMB <- cbind.data.frame(nsynMut.TMB,TMErisk[rownames(nsynMut.TMB),c(\"risk\",\"TME\")]); nsynMut.TMB$risk <- factor(nsynMut.TMB$risk, levels = c(\"Low\",\"High\"))\nallMut.TMB <- cbind.data.frame(allMut.TMB,TMErisk[rownames(allMut.TMB),c(\"risk\",\"TME\")]); allMut.TMB$risk <- factor(allMut.TMB$risk, levels = c(\"Low\",\"High\"))\n图A\n该图分左中右三个图，每个图包含左侧相关性散点图和右侧箱型图。\nFigure A\nThe graph is divided into three plots, left, middle and right, each\nof which contains a correlation scatter plot on the left and a box plot\non the right.\nAssociation between\nsynonymous mutation counts,\nnon-synonymous mutation counts, all mutation counts\n, and\nTMErisk score and their distribution\nin the\nlow- and the high-TMErisk groups\n.\n# 左图 - 所有突变all mutation counts\n# 相关性散点图\n# Left panel - all mutation counts\n# Correlation scatter plot\np1 <- ggscatter(allMut.TMB, \n          x = \"TME\", y = \"Variants\",\n          color = \"risk\",\n          palette = c(Low = \"#3C6FAC\",High = \"grey60\"),\n          add = \"reg.line\",  \n          add.params = list(color = \"red\", fill = \"grey50\"), \n          conf.int = TRUE) + \n  stat_cor(method = \"pearson\", label.x = min(na.omit(allMut.TMB$TME)), label.y = max(na.omit(allMut.TMB$Variants))) +\n  theme_bw() + \n  ylab(\"All mutation counts\") +\n  xlab(\"TMErisk\") + \n  theme(axis.text.x = element_text(hjust = 0.5, size = 10, color = \"black\"),\n        axis.text.y = element_text(size = 10, color = \"black\"),\n        axis.ticks = element_line(size=0.2, color=\"black\"),\n        axis.ticks.length = unit(0.2, \"cm\"),\n        legend.position = \"none\",\n        panel.background = element_blank(),\n        axis.title = element_text(size = 10),\n        axis.text = element_text(size = 10))\n# 箱型图\n# boxplot\np2 <- ggplot(na.omit(allMut.TMB), aes(x = risk, y = Variants, fill = risk)) + \n  geom_boxplot(aes(col = risk)) + \n  scale_fill_manual(values = alpha(c(\"#3C6FAC\",\"grey50\"),0.8)) + \n  scale_color_manual(values = c(\"#3C6FAC\",\"grey50\")) + \n  xlab(\"\") + ylab(\"\") + \n  theme_bw() +\n  theme(legend.position = \"none\",\n        legend.title = element_blank(),\n        axis.text.x = element_blank(),\n        axis.text.y = element_blank(),\n        axis.ticks = element_blank(),\n        panel.border = element_blank(),\n        panel.grid = element_blank(),\n        panel.background = element_blank(),\n        axis.title = element_text(size = 10),\n        axis.text = element_text(size = 10)) + \n  stat_compare_means(method = \"wilcox.test\", label = \"p.signif\", label.y = max(na.omit(allMut.TMB$Variants)) * 0.95, label.x = 1.5, size = 8)\n\n# 合并图像\n# Merge images\nplot_grid(p1, p2,\n          labels = c(\"\",\"\",\"\"), # 无图例 # No legend\n          rel_widths = c(0.8,0.2), # 左边散点图大一些，右边小一些 # The scatter plot on the left is larger, and the right is smaller\n          axis = \"tblr\", # 四周对齐 # Align all sides\n          align = 'h', # 水平摆放 # Horizontally\n          ncol = 2, # 两列 # Two columns\n          scale = c(1,1), greedy = T)\nggsave(filename = \"scatter and boxplot for all mutation counts.pdf\", width = 5,height = 4)\n\n# 中间的图 - 沉默突变synonymous mutation counts\n# 相关性散点图\n# Graph in the middle - Silent mutation synonymous mutation counts\n# Correlation scatter plot\np1 <- ggscatter(synMut.TMB, \n                x = \"TME\", y = \"Variants\",\n                color = \"risk\",\n                palette = c(Low = \"#3C6FAC\",High = \"grey60\"),\n                add = \"reg.line\",  \n                add.params = list(color = \"red\", fill = \"grey50\"), \n                conf.int = TRUE) + \n  stat_cor(method = \"pearson\", label.x = min(na.omit(synMut.TMB$TME)), label.y = max(na.omit(synMut.TMB$Variants))) +\n  theme_bw() + \n  ylab(\"Synonymous mutation counts\") +\n  xlab(\"TMErisk\") + \n  theme(axis.text.x = element_text(hjust = 0.5, size = 10, color = \"black\"),\n        axis.text.y = element_text(size = 10, color = \"black\"),\n        axis.ticks = element_line(size=0.2, color=\"black\"),\n        axis.ticks.length = unit(0.2, \"cm\"),\n        legend.position = \"none\",\n        panel.background = element_blank(),\n        axis.title = element_text(size = 10),\n        axis.text = element_text(size = 10))\n\n# 箱型图\n# boxplot\np2 <- ggplot(na.omit(synMut.TMB), aes(x = risk, y = Variants, fill = risk)) + \n  geom_boxplot(aes(col = risk)) + \n  scale_fill_manual(values = alpha(c(\"#3C6FAC\",\"grey50\"),0.8)) + \n  scale_color_manual(values = c(\"#3C6FAC\",\"grey50\")) + \n  xlab(\"\") + ylab(\"\") + \n  theme_bw() +\n  theme(legend.position = \"none\",\n        legend.title = element_blank(),\n        axis.text.x = element_blank(),\n        axis.text.y = element_blank(),\n        axis.ticks = element_blank(),\n        panel.border = element_blank(),\n        panel.grid = element_blank(),\n        panel.background = element_blank(),\n        axis.title = element_text(size = 10),\n        axis.text = element_text(size = 10)) + \n  stat_compare_means(method = \"wilcox.test\", label = \"p.signif\", label.y = max(na.omit(synMut.TMB$Variants)) * 0.95, label.x = 1.5, size = 8)\n\n# 合并图像\n# Merge images\nplot_grid(p1, p2,\n          labels = c(\"\",\"\",\"\"),\n          rel_widths = c(0.8,0.2),\n          axis = \"tblr\",\n          align = 'h',ncol = 2,scale = c(1,1), greedy = T)\nggsave(filename = \"scatter and boxplot for synonymous mutation counts.pdf\", width = 5,height = 4)\n\n# 右图 - 非沉默突变 non-synonymous mutation counts\n# 相关性散点图\n# Right panel - non-synonymous mutation counts\n# Correlation scatter plot\np1 <- ggscatter(nsynMut.TMB, \n                x = \"TME\", y = \"Variants\",\n                color = \"risk\",\n                palette = c(Low = \"#3C6FAC\",High = \"grey60\"),\n                add = \"reg.line\",  \n                add.params = list(color = \"red\", fill = \"grey50\"), \n                conf.int = TRUE) + \n  stat_cor(method = \"pearson\", label.x = min(na.omit(nsynMut.TMB$TME)), label.y = max(na.omit(nsynMut.TMB$Variants))) +\n  theme_bw() + \n  ylab(\"Non-synonymous mutation counts\") +\n  xlab(\"TMErisk\") + \n  theme(axis.text.x = element_text(hjust = 0.5, size = 10, color = \"black\"),\n        axis.text.y = element_text(size = 10, color = \"black\"),\n        axis.ticks = element_line(size=0.2, color=\"black\"),\n        axis.ticks.length = unit(0.2, \"cm\"),\n        legend.position = \"none\",\n        panel.background = element_blank(),\n        axis.title = element_text(size = 10),\n        axis.text = element_text(size = 10))\n\n# 箱型图\n# boxplot\np2 <- ggplot(na.omit(nsynMut.TMB), aes(x = risk, y = Variants, fill = risk)) + \n  geom_boxplot(aes(col = risk)) + \n  scale_fill_manual(values = alpha(c(\"#3C6FAC\",\"grey50\"),0.8)) + \n  scale_color_manual(values = c(\"#3C6FAC\",\"grey50\")) + \n  xlab(\"\") + ylab(\"\") + \n  theme_bw() +\n  theme(legend.position = \"none\",\n        legend.title = element_blank(),\n        axis.text.x = element_blank(),\n        axis.text.y = element_blank(),\n        axis.ticks = element_blank(),\n        panel.border = element_blank(),\n        panel.grid = element_blank(),\n        panel.background = element_blank(),\n        axis.title = element_text(size = 10),\n        axis.text = element_text(size = 10)) + \n  stat_compare_means(method = \"wilcox.test\", label = \"p.signif\", label.y = max(na.omit(nsynMut.TMB$Variants)) * 0.95, label.x = 1.5, size = 8)\n\n# 合并图像\n# Merge images\nplot_grid(p1, p2,\n          labels = c(\"\",\"\",\"\"),\n          rel_widths = c(0.8,0.2),\n          axis = \"tblr\",\n          align = 'h',ncol = 2,scale = c(1,1), greedy = T)\nggsave(filename = \"scatter and boxplot for non-synonymous mutation counts.pdf\", width = 5,height = 4)\n图B\nImage B\nForest plot of genes mutating differentially in patients of the low-\nand the high-TMErisk groups.\nallMut.hrisk.ob <- read.maf(\"data_mutations_extended_HRisk_modified.txt\", # 重新读取High TME的MAF文件 # Re-read the MAF file of High TME\n                            vc_nonSyn = nsynMut, # 按照原文的结果应该是用的非沉默突变 # According to the original result, it should be used with non-silencing mutations\n                            removeDuplicatedVariants = F)\nallMut.lrisk.ob <- read.maf(\"data_mutations_extended_LRisk_modified.txt\",\n                            vc_nonSyn = nsynMut,\n                            removeDuplicatedVariants = F)\nh.vs.l <- mafCompare(m1 = allMut.lrisk.ob, \n                     m2 = allMut.hrisk.ob, \n                     m1Name = 'Low TMErisk', \n                     m2Name = 'High TMErisk', \n                     minMut = 30) # 按照原文的图，最少突变应该不少于30个 # According to the original diagram, there should be at least 30 mutations\nwrite.table(as.data.frame(h.vs.l$results),file = \"fisher test regarding non-synonymous mutations of TME risk group.txt\",sep = \"\\t\",row.names = F,col.names = T,quote = F)\npdf(\"forestplot.pdf\", width = 8,height = 6)\nforestPlot(mafCompareRes = h.vs.l, pVal = 0.05) # 保留检验显著的结果 # Retain the results of the test\ninvisible(dev.off())\n图C\nImage C\nInteraction effect of genes mutating differentially in patients in\nthe low- and the high-TMErisk groups.\ntmp <- as.data.frame(h.vs.l$results)\npdf(\"mutual exclusivity plot.pdf\", width = 6,height = 6)\nres <- somaticInteractions(maf = nsynMut.ob, \n                           genes = as.character(tmp[tmp$pval < 0.05,\"Hugo_Symbol\"]),# 取出上面分析得到的显著基因 # substract the salient genes from the above analysis\n                           showCounts = FALSE, # 不展示OR值 # The OR value is not displayed\n                           showSum = FALSE, # 不展示突变综述 # Mutation reviews are not shown\n                           pvalue = c(0.05, 0.01), # p值的区间（原文这里也有问题，P<0.05显著的是.，但是这个函数好像没有修改的参数） # The interval of the p-value (there is also a problem here in the original text, P<0.05 is significant, but this function does not seem to have modified the parameters)\n                           colPal = \"PiYG\") # 选择原文配色 # Select the color scheme of the original text\ninvisible(dev.off())\nwrite.table(as.data.frame(res),file = \"mutual exclusivity test regarding non-synonymous mutations.txt\",sep = \"\\t\",row.names = F,col.names = T,quote = F)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa238corRiskMut_FigureYa238corRiskMut",
      "title": "FigureYa238corRiskMut/FigureYa238corRiskMut.html",
      "html": "FigureYa238corRiskMut/FigureYa238corRiskMut.html",
      "text": "texts/main_FigureYa238corRiskMut_FigureYa238corRiskMut.txt",
      "folder": "FigureYa238corRiskMut",
      "thumb": "gallery_compress/FigureYa238corRiskMut.webp"
    },
    "word_count": 2210,
    "lines_count": 412,
    "title": "FigureYa238corRiskMut",
    "description": "想实现下FigA-C，预后模型建立后寻找高低风险组中突变最显著的基因，并计算riskscore与有义和错义突变的相关性，谢谢啦 Requirement Description I want to crowdsource FigA-C, find the most significant mutations in",
    "input_data_types": [
      "临床数据",
      "突变数据"
    ],
    "output_types": [
      "散点图",
      "箱线图",
      "统计表格"
    ],
    "technical_methods": [
      "生存分析"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学"
    ],
    "complexity_level": "高级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "add",
      "label",
      "ticks",
      "values",
      "rel_widths",
      "header",
      "vc_nonSyn",
      "width",
      "grid"
    ]
  },
  {
    "id": "main_FigureYa307CNVHeatmap_FigureYa307CNVHeatmap",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa307CNVHeatmap_FigureYa307CNVHeatmap.txt",
    "content": "FigureYa307CNVHeatmap\nFigureYa307CNVHeatmap\nAuthor(s)\n: Xiaofan Lu; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-10-04\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\nIf you use circlize in published research, please cite:\nGu, Z. circlize implements and enhances circular visualization in R.\nBioinformatics 2014.\n需求描述\nDemand description\n希望画出拷贝数变异的图。\nI want to plot copy number variation (CNV) profiles.​\n出自：\nhttps://www.nature.com/articles/s41467-021-22465-w\n图2：非肌层浸润性膀胱癌(NMIBC)的拷贝数变异情况。 a. 按基因组类别(GC\n1-3)分层的473个肿瘤的全基因组拷贝数景观图。增益(增益+高平衡增益)和缺失(缺失+高平衡缺失)汇总显示在染色体条带面板左侧。EORTC\n- 欧洲癌症研究与治疗组织，EAU - 欧洲泌尿外科协会，MIBC -\n肌层浸润性膀胱癌\nSuorce:\nhttps://www.nature.com/articles/s41467-021-22465-w\nFig. 2: Copy number alterations in NMIBC. a. Genome-wide copy number\nlandscape of 473 tumors stratified by genomic class (GC) 1–3. Gains\n(gain + high balanced gain) and losses (loss + high balanced loss) are\nsummarized to the left of the chromosome band panel. EORTC European\nOrganisation for Research and Treatment of Cancer, EAU European\nAssociation of Urology, MIBC muscle-invasive bladder cancer.\n应用场景\nApplication scenarios\n利用GISTIC算法的输出文件，绘制拷贝数热图（不包含底部饼图）。\n我们实现过一些突变相关以及富集分析的图，可灵活运用，画出文中的图：\nFigure 1ah共识聚类及热图，可参考FigureYa202consensusGene\nFigure 1b桑基图，画法可参考FigureYa25sankey\nFigure\n1cd、2bcd、3c、4e、5c、多亚型生存分析，可参考FigureYa284pairwiseLogrank或FigureYa1survivalCurve\nFigure\n2a，本文档将带你实现。只画左侧频率对比图，可参考FigureYa79CNV\nFigure 3e突变综合热图，可参考FigureYa248MutLandscape\nFigure 5a森林图，可参考FigureYa90subgroup\nCopy Number Heatmap Generation Using GISTIC Output Files (Excluding\nBottom Pie Chart).\nWe have several mutation-related and enrichment analysis plots, which\ncan be flexibly adapted to reproduce the figures in this study:\nFigure 1a&h: Consensus clustering and heatmap, refer to\nFigureYa202consensusGene\nFigure 1b: Sankey diagram, refer to FigureYa25sankey\nFigures 1c-d, 2b-d, 3c, 4e, 5c: Multi-subtype survival analysis,\nrefer to FigureYa284pairwiseLogrank or FigureYa1survivalCurve\nFigure 2a: This document will guide you through its implementation.\nFor the left-side frequency comparison plot only, refer to\nFigureYa79CNV\nFigure 3e: Integrated mutation heatmap, refer to\nFigureYa248MutLandscape\nFigure 5a: Forest plot, refer to FigureYa90subgroup\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(ComplexHeatmap)\n# 如果是用hg38的基因组请加载:\n# Load if using hg38 genome reference:\n#library(TxDb.Hsapiens.UCSC.hg38.knownGene) \n\n# 如果是用hg38的基因组请加载:\n# Load if using hg38 genome reference:\nlibrary(TxDb.Hsapiens.UCSC.hg19.knownGene)\n# 用于获取基因位点信息\n# For gene locus information\nlibrary(trackViewer) \n\nlibrary(org.Hs.eg.db)\nlibrary(ggplot2)\n\n# 用于获取TCGA数据的分子亚型信息\n# For TCGA molecular subtype data\nlibrary(TCGAbiolinks) \n\nlibrary(dplyr)\nlibrary(RColorBrewer)\nlibrary(circlize)\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n自定义函数，用于获取基因位点\nCustom function for retrieving gene loci\ngetGeneLocation <- function(symbol, txdb, org){\n  # 获取基因位置\n  # trackViewer::getLocation的改进版，避免报错，增加GeneSymbol列\n  # Get gene locations\n  # Improved version of trackViewer::getLocation with error handling and added GeneSymbol column\n  dbPrefix <- sub(\".db\", \"\", org)\n  eg <- mget(symbol, get(paste0(dbPrefix, \"SYMBOL2EG\")), ifnotfound = NA)\n  eg <- lapply(eg, `[`, i = 1)\n  eg <- unlist(eg, use.names = TRUE)\n  eg <- eg[!is.na(eg)]\n  if (length(eg) < 1) {\n    return(NULL)\n  }\n  genes <- genes(txdb)\n  eg <- eg[eg%in%genes$gene_id]\n  gr <- genes[eg]\n  gr$symbol <- names(eg)\n  seqlevelsStyle(gr) <- \"UCSC\"\n  seqlevels(gr) <- seqlevels(gr)[seqlevels(gr) %in% as.character(seqnames(gr))]\n  if (length(seqinfo(gr)) > 0) {\n    seqinfo(gr) <- seqinfo(gr)[seqlevels(gr)]\n  }\n  return(gr)\n}\n输入文件\nInput files\n这里以TCGA数据为例。TCGA_BLCA.all_thresholded.by_genes.txt，该文件为GISTIC算法的输出文件之一，也可在\nhttp://firebrowse.org/\n中获取已经分析好的GISTIC结果。\nUsing TCGA data as example. TCGA_BLCA.all_thresholded.by_genes.txt is\none of the output files from GISTIC algorithm. Pre-analyzed GISTIC\nresults can also be obtained from\nhttp://firebrowse.org/\ncnv <- read.table(\"TCGA_BLCA.all_thresholded.by_genes.txt\", sep = \"\\t\", row.names = 1, header = T, check.names = F)\n\n## 构建基因*样本矩阵\n## Construct gene × sample matrix\ncnv$`Locus ID` = cnv$Cytoband = NULL\ncolnames(cnv) <- substr(colnames(cnv)[4:ncol(cnv)], 1, 12)\n准备绘图数据\nPrepare plotting data\ngeneLocation$seqnames <- as.character(geneLocation$seqnames)\ngeneLocation <- geneLocation[which(geneLocation$seqnames %in% c(\"chr1\",\"chr2\",\"chr3\",\"chr4\",\"chr5\",\"chr6\",\"chr7\",\"chr8\",\"chr9\",\"chr10\",\"chr11\",\n                                                                \"chr12\",\"chr13\",\"chr14\",\"chr15\",\"chr16\",\"chr17\",\"chr18\",\"chr19\",\"chr20\",\"chr21\",\"chr22\")),]\ngeneLocation <- arrange(geneLocation, geneLocation$seqnames, geneLocation$start)\ngeneLocation$seqnames <- factor(geneLocation$seqnames, levels = c(\"chr1\",\"chr2\",\"chr3\",\"chr4\",\"chr5\",\"chr6\",\"chr7\",\"chr8\",\"chr9\",\"chr10\",\"chr11\",\n                                                                  \"chr12\",\"chr13\",\"chr14\",\"chr15\",\"chr16\",\"chr17\",\"chr18\",\"chr19\",\"chr20\",\"chr21\",\"chr22\"))\n\n## 获取分子亚型信息\n## Get molecular subtype information\nclassVar <- \"Mutation.process.cluster\"\nsampleInfo <- data.frame(TCGAquery_subtype(tumor = \"blca\"))\nsampleInfo <- sampleInfo[sampleInfo$patient %in% colnames(cnv), ]\nsampleInfo <- arrange(sampleInfo, sampleInfo[[classVar]])\nsampleInfo <- sampleInfo[sampleInfo[[classVar]] != \"NA\", ]\n\n## 整理需要用来画图的样本信息(plot.sampleInfo)\n## Prepare sample information for plotting (plot.sampleInfo)\ncnv <- cnv[geneLocation$symbol, sampleInfo$patient]\nplot.sampleInfo <- sampleInfo[, c(\"Noninvasive.bladder.history\", \"AJCC.pathologic.tumor.stage\", \"Number.of.LNs.examined\")]\ncolnames(plot.sampleInfo) <- c(\"Noninvasive\",\"AJCC.stage\",\"Nb.LNs.examined\")\nplot.sampleInfo$Nb.LNs.examined <- as.numeric(plot.sampleInfo$Nb.LNs.examined)\n开始画图\nPlotting\nstr(plot.sampleInfo)\nhm\npdf(\"CNVheatmap.pdf\", width = 10,height = 10)\ndraw(hm, heatmap_legend_side = \"right\", annotation_legend_side = \"right\", merge_legend = TRUE)\ninvisible(dev.off())\n后期处理\nPost-processing\n底部饼图画法可参考FigureYa196PanPie\n前面生成的PDF文件是矢量图文件，可以用Adobe\nIllustrator等矢量图编辑器打开编辑。\nFor bottom pie chart creation, refer to FigureYa196PanPie:\nThe previously generated PDF files are vector graphics that can be\nedited with vector editors like Adobe Illustrator.\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa307CNVHeatmap_FigureYa307CNVHeatmap",
      "title": "FigureYa307CNVHeatmap/FigureYa307CNVHeatmap.html",
      "html": "FigureYa307CNVHeatmap/FigureYa307CNVHeatmap.html",
      "text": "texts/main_FigureYa307CNVHeatmap_FigureYa307CNVHeatmap.txt",
      "folder": "FigureYa307CNVHeatmap",
      "thumb": "gallery_compress/FigureYa307CNVHeatmap.webp"
    },
    "word_count": 644,
    "lines_count": 176,
    "title": "FigureYa307CNVHeatmap",
    "description": "Demand description 希望画出拷贝数变异的图。 I want to plot copy number variation (CNV) profiles.​",
    "input_data_types": [
      "生存数据",
      "临床数据",
      "DNA-seq",
      "突变数据"
    ],
    "output_types": [
      "热图",
      "统计表格",
      "生存曲线"
    ],
    "technical_methods": [
      "聚类分析",
      "通路分析",
      "生存分析"
    ],
    "biology_areas": [
      "癌症研究",
      "药物研究"
    ],
    "complexity_level": "高级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "LANGUAGE",
      "annotation_legend_side",
      "stringsAsFactors",
      "levels",
      "heatmap_legend_side",
      "header",
      "ifnotfound",
      "merge_legend",
      "i"
    ]
  },
  {
    "id": "main_FigureYa244PCAPlot_FigureYa244PCAPlot",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa244PCAPlot_FigureYa244PCAPlot.txt",
    "content": "FigureYa244PCAPlot\nFigureYa244PCAPlot\nAuthor(s)\n: Jianing Gao\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n基因聚类，然后在图上标注出来。不用说要跟原文一个数据吧，只要输入数据得出类似的图就行。\nRequirement Description\nGenes are clustered and then annotated on the graph. Needless to say,\nyou need to have the same data as the original text, as long as you\nenter the data to get a similar graph.\n出自\nhttps://www.sciencedirect.com/science/article/pii/S2352396421003340?via%3Dihub\nfrom\nhttps://www.sciencedirect.com/science/article/pii/S2352396421003340?via%3Dihub\nFig. 1. Prognostic stratification of PDAC through their GT gene\nexpression profile (a, b) and clinical features of patients with their\nPDAC molecular profiles (c, d). (a) Biplot of the HCPC analysis result\nbased on RNA-seq data of 74 PDAC and 169 GT genes.\n应用场景\n看这里\nhttps://mp.weixin.qq.com/s/kNHM5teMRtL2dSZXzm4m8w\n，带你看透文章里的PCA图的小心机。\nApplication Scenarios\nTake a look at the\nhttps://mp.weixin.qq.com/s/kNHM5teMRtL2dSZXzm4m8w\nhere\nto take you to understand the PCA diagram in the article\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nsource(\"geom_convexhull.R\") # from ggConvexHull package\nlibrary(tidyverse)\nlibrary(factoextra)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # error messages are displayed in English\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # chr is not allowed to be converted to factor\n输入文件\neasy_input.csv，表达矩阵，每行一个基因，每列一个sample。\nInput files\neasy_input.csv, the expression matrix, one gene per row, one sample\nper column.\ndata2 <- read.csv(\"easy_input.csv\", header = T, row.names = 1)\ndata2[1:2,]\n开始画图\n方法一: 调用factoextra包\nStart drawing\nMethod 1: Call the factoextra package\np <- fviz_pca_ind(\n  X = pca, \n  repel = T, \n  geom = c(\"point\", \"text\"), # 如果不想要文字标记,去掉text即可 # If you don't want the text tag, just remove the text\n  habillage = k2$cluster, # 添加分组信息 # Add group information\n  legend.title = \"cluster\", # 图例标题 # Legend title\n  mean.point = FALSE, # 是否添加聚类中心 # Whether to add a cluster center\n  palette = c(\"red\",\"blue\"), # change color, map to col.ind\n  pointsize = 2.5, # 点的大小 # The size of the dot\n  addEllipses = TRUE, # 添加外边框 # Add an outer border\n  ellipse.type = \"convex\", # 外边框类型, 凸多边形\"convex\" # Outer Border Type, Convex Polygon \"Convex\"\n  axes.linetype = \"blank\", # hide zerolines\n  ggtheme = theme_classic(base_size = 15) # ggplot主题 # ggplot theme\n)\n# remove text legend\np <- p + guides(color = guide_legend(override.aes = aes(label = \"\")))\n# theme\np + theme(\n  legend.position = \"top\",\n  plot.title = element_blank(),\n  axis.text = element_text(color = \"black\")\n)\nggsave(\"PCA_factoextra.pdf\")\n方法二: ggplot\n准备数据\nMethod 2: ggplot\nPrepare the data\ndata.use <- as.data.frame(pca$x[, c(\"PC1\", \"PC2\")])\ndata.use$cluster <- factor(k2$cluster)\ndata.use$name <- rownames(data.use)\n\nvars.percent <- pca$sdev^2 / sum(pca$sdev^2) # 计算不同主成分解释的数据方差 # Calculate the variance of the data for different principal component explanations\ndims <- c(1,2) # 选择PC1和PC2进行可视化 # Select PC1 and PC2 for visualization\nxlab <- paste0(\"Dim1 (\", round(vars.percent[dims[1]]*100, 1), \"%)\")\nylab <- paste0(\"Dim2 (\", round(vars.percent[dims[2]]*100, 1), \"%)\")\ncolors.use <- c(\"red\", \"blue\")\n画图 Drawing\nggplot(data.use, aes(PC1, PC2, shape=cluster, color=cluster)) + \n  geom_point(size = 2.5) + \n  geom_convexhull(aes(fill=cluster), alpha = 0.15) + \n  ggrepel::geom_text_repel(\n    aes(label=name), \n    size = 3, \n    max.iter = 2000, # 如果样本太多，text overlap无法解决，可以增大max.iter参数 # If there are too many samples and the text overlap cannot be solved, you can increase the max.iter parameter\n    show.legend = F) + \n  scale_color_manual(values = colors.use) + \n  scale_fill_manual(values = colors.use) + \n  labs(x = xlab, y = ylab) + \n  theme_classic(base_size = 15) + \n  theme(\n    legend.position = \"top\",\n    plot.title = element_blank(),\n    axis.text = element_text(color = \"black\")\n  )\nggsave(\"PCA_ggplot2.pdf\")\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa244PCAPlot_FigureYa244PCAPlot",
      "title": "FigureYa244PCAPlot/FigureYa244PCAPlot.html",
      "html": "FigureYa244PCAPlot/FigureYa244PCAPlot.html",
      "text": "texts/main_FigureYa244PCAPlot_FigureYa244PCAPlot.txt",
      "folder": "FigureYa244PCAPlot",
      "thumb": "gallery_compress/FigureYa244PCAPlot.webp"
    },
    "word_count": 539,
    "lines_count": 112,
    "title": "FigureYa244PCAPlot",
    "description": "基因聚类，然后在图上标注出来。不用说要跟原文一个数据吧，只要输入数据得出类似的图就行。 Requirement Description Genes are clustered and then annotated on the graph. Needless to say,",
    "input_data_types": [
      "临床数据",
      "表达矩阵"
    ],
    "output_types": [
      "PCA图"
    ],
    "technical_methods": [
      "主成分分析",
      "聚类分析"
    ],
    "biology_areas": [],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "values",
      "header",
      "ggtheme",
      "legend",
      "habillage",
      "type",
      "iter",
      "shape"
    ]
  },
  {
    "id": "main_FigureYa280TMEofSTS_FigureYa280TMEofSTS",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa280TMEofSTS_FigureYa280TMEofSTS.txt",
    "content": "FigureYa280TMEofSTS\nFigureYa280TMEofSTS\nAuthor(s)\n: Xiaofan Lu; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-9-17\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nDemand description\n软组织肉瘤（STSs）\nSoft-tissue sarcomas (STSs)\n出自：\nhttps://www.nature.com/articles/s41586-019-1906-8\n图1 | SICs表现出显著不同的肿瘤微环境（TME）。本图基于TCGA SARC队列（n\n= 213）。a. 按SIC和组织学类型划分的TCGA SARC队列构成。b. 通过MCP-counter\nZ值定义的各SIC组TME组成。NK细胞指自然杀伤细胞。c. 按SIC分组的免疫TME功能相关基因标志物表达。d. 按SIC分组的免疫检查点相关基因表达。校正P值通过双侧Kruskal-Wallis检验的Benjamini-Hochberg校正获得。\nSource:\nhttps://www.nature.com/articles/s41586-019-1906-8\nFig. 1 | The SICs exhibit strongly different TMEs. This figure refers\nto the TCGA SARC cohort (n = 213). a, Composition of the TCGA SARC\ncohort by SIC, and histology. b, Composition of the TME by SIC as\ndefined by the MCP-counter Z- scores. NK cells, natural killer cells. c,\nExpression of gene signatures related to the functional orientation of\nthe immune TME by SIC. d, Expression of genes related to immune\ncheckpoints by SIC. Adjusted P values are obtained from\nBenjamini–Hochberg correction of two-sided Kruskal–Wallis tests P\nvalues.\n应用场景\nApplication scenarios\n用MCPcounter计算免疫富集得分，根据MCPcounter结果进行分型。\n我们曾实现过FigureYa56immune_inflitration，也是用TCGA的表达数据计算免疫浸润，并画热图。我们这次画的图信息更丰富。\nThe immune enrichment scores were calculated using MCP-counter, and\nsubtyping was performed based on the MCP-counter results.\nWe previously conducted FigureYa56immune_infiltration, which also\nused TCGA expression data to compute immune infiltration and generate\nheatmaps. However, the current visualization provides more comprehensive\nanalytical dimensions.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nsource(\"MCPcounter.R\") # From MCPcounter\nlibrary(GSVA)\nlibrary(ComplexHeatmap)\nlibrary(ClassDiscovery)\nlibrary(gplots)\nlibrary(RColorBrewer)\n\n# 自定义函数\n# Custom Function\nstandarize.fun <- function(indata=NULL, halfwidth=NULL, centerFlag=T, scaleFlag=T) {  \n  outdata=t(scale(t(indata), center=centerFlag, scale=scaleFlag))\n  if (!is.null(halfwidth)) {\n    outdata[outdata>halfwidth]=halfwidth\n    outdata[outdata<(-halfwidth)]= -halfwidth\n  }\n  return(outdata)\n}\n\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n输入文件\nInput Files\n从XENA下载数据：\nTCGA-SARC.star_fpkm.tsv.gz，表达谱数据FPKM，已经过\nlog2(fpkm+1)\n转换，下载地址：\nhttps://xenabrowser.net/datapages/?dataset=TCGA-SARC.star_fpkm.tsv&host=https%3A%2F%2Fgdc.xenahubs.net&removeHub=https%3A%2F%2Fxena.treehouse.gi.ucsc.edu%3A443\ngencode.v36.annotation.gtf.gene.probemap，ID/Gene\nMapping，下载地址同上。\nTCGA-SARC.clinical.tsv.gz，临床信息，下载地址：\nhttps://xenabrowser.net/datapages/?dataset=TCGA-SARC.clinical.tsv&host=https%3A%2F%2Fgdc.xenahubs.net&removeHub=https%3A%2F%2Fxena.treehouse.gi.ucsc.edu%3A443\nData downloaded from XENA:\nTCGA-SARC.star_fpkm.tsv.gz, expression profile data FPKM, already\ntransformed by\nlog2(fpkm+1)\n, download link:\nhttps://xenabrowser.net/datapages/?dataset=TCGA-SARC.star_fpkm.tsv&host=https%3A%2F%2Fgdc.xenahubs.net&removeHub=https%3A%2F%2Fxena.treehouse.gi.ucsc.edu%3A443\ngencode.v36.annotation.gtf.gene.probemap, ID/Gene Mapping, download\nlink same as above.\nTCGA-SARC.clinical.tsv.gz, clinical information, download link:\nhttps://xenabrowser.net/datapages/?dataset=TCGA-SARC.clinical.tsv&host=https%3A%2F%2Fgdc.xenahubs.net&removeHub=https%3A%2F%2Fxena.treehouse.gi.ucsc.edu%3A443\n# 读取XENA下载的FPKM表达谱数据\n# Read FPKM expression profile data downloaded from XENA\nfpkm <- read.table(\"TCGA-SARC.star_fpkm.tsv.gz\", row.names = 1,check.names = F,stringsAsFactors = F,header = T)\nGinfo <- read.table(\"gencode.v36.annotation.gtf.gene.probemap\", row.names = 1,check.names = F,stringsAsFactors = F,header = T)\n\n# 获取表达数据和基因注释之间的共有基因\n# Get common genes between expression data and gene annotation\ncomgene <- intersect(rownames(fpkm), rownames(Ginfo))\nfpkm <- fpkm[comgene,]\nGinfo <- Ginfo[comgene,]\n\n# 添加基因符号并按中位数表达量聚合\n# Add gene symbols and aggregate by median expression\nfpkm$gene <- Ginfo[rownames(fpkm),\"gene\"]\nfpkm <- as.data.frame(apply(fpkm[,setdiff(colnames(fpkm), \"gene\")], 2, function(x) tapply(x, INDEX=factor(fpkm$gene), FUN=median, na.rm=TRUE)))\n\n# 根据原文设置感兴趣签名\n#Define signatures of interest as per the original text\nimmunosuppression.signature <- c(\"CXCL12\",\"TGFB1\",\"TGFB3\",\"LGALS1\")\nt.cell.activation.signature <- c(\"CXCL9\",\"CXCL10\",\"CXCL16\",\"IFNG\",\"IL15\")\nt.cell.survival.signature <- c(\"CD70\",\"CD27\")\nregulatory.t.cell.signature <- c(\"FOXP3\",\"TNFRSF18\")\nmhc.signature <- c(\"HLA-A\",\"HLA-B\",\"HLA-E\",\"HLA-F\",\"HLA-G\",\"B2M\")\nmyeloid.signature <- \"CCL2\"\ntls.signature <- \"CXCL13\"\n\n# 免疫检查点靶点基因（分别为PD1, PDL1, PDL2, CTLA4, TIM3和LAG3）\n# Immune checkpoint target genes (PD1, PDL1, PDL2, CTLA4, TIM3 and LAG3)\nici.gene <- c(\"PDCD1\",\"CD274\",\"PDCD1LG2\",\"CTLA4\",\"HAVCR2\",\"LAG3\")\n\n# 检查这些签名基因是否可以被匹配\n# Check if these signature genes can be matched\nis.element(immunosuppression.signature, rownames(fpkm))\nis.element(t.cell.activation.signature, rownames(fpkm))\nis.element(t.cell.survival.signature, rownames(fpkm))\nis.element(regulatory.t.cell.signature, rownames(fpkm))\nis.element(mhc.signature, rownames(fpkm))\nis.element(myeloid.signature, rownames(fpkm))\nis.element(tls.signature, rownames(fpkm))\nis.element(ici.gene, rownames(fpkm))\n# 加载临床信息并获取共有的样本\n# Load clinical information and get common samples\nsinfo <- read.delim(file = \"TCGA-SARC.clinical.tsv.gz\", sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\ncomsam <- intersect(rownames(sinfo), colnames(fpkm))\nsinfo <- sinfo[comsam,]\nfpkm <- fpkm[,comsam]\n计算免疫富集得分，聚类分析\nCalculate immune enrichment scores and perform cluster analysis\n# 计算免疫富集得分\n# 这里读取的genes.txt和probesets.txt出自MCPcounter包，这样操作速度更快\n# Calculate immune enrichment scores and perform cluster analysis\n# The genes.txt and probesets.txt here are from the MCPcounter package for faster processing\nmcp <- MCPcounter.estimate(fpkm,\n                           featuresType = \"HUGO_symbols\",\n                           genes = read.table(\"genes.txt\",sep = \"\\t\",stringsAsFactors = F,header = T,colClasses = \"character\",check.names = F),\n                           probesets = read.table(\"probesets.txt\",sep = \"\\t\",stringsAsFactors = F,header = F,colClasses = \"character\",check.names = F))\nmcp <- mcp[-10, ] # 根据原文移除纤维化，剩下9种细胞\n\n# 对MCPcounter得分进行聚类分析\n# Cluster analysis of MCPcounter scores\nindata <- t(scale(t(mcp)))\nhcs <- hclust(distanceMatrix(as.matrix(indata), \"euclidean\"), \"ward.D\") # 原文提到使用欧式距离以及ward's聚类方式\ngroup <- cutree(hcs, k = 5) # 原文分为5类\ngroup <- paste0(\"C\", group); names(group) <- colnames(mcp)\n\n# 先简单绘图看一下趋势\n# First make a simple plot to observe the trend\nindata <- mcp\nplotdata <- standarize.fun(indata, halfwidth = 2)\n\n# 设置颜色\n# Set colors\nsic.col <- c(\"#2B7AB5\", \"#ABD9E8\", \"#339E2B\", \"#FDAE61\", \"#D71719\")\nhit.col <- c(\"#FFFF99\", \"#BDAED4\", \"#7DC77D\", \"#FFD700\", \"#87CEEB\", \"#FFA07A\")\n\nhm <- pheatmap(plotdata,\n         border_color = NA,\n         color = bluered(64),\n         show_rownames = T,\n         show_colnames = F,\n         cutree_cols = 5,\n         cluster_rows = F,\n         cluster_cols = hcs,\n         name = \"MCPcounter\",\n         cellheight = 12,\n         cellwidth = 300/ncol(plotdata),\n         annotation_col = data.frame(row.names = colnames(plotdata),\n                                     SIC = group[colnames(plotdata)]),\n         annotation_colors = list(SIC = c(\"C1\" = sic.col[1], \n                                          \"C2\" = sic.col[2],\n                                          \"C3\" = sic.col[3],\n                                          \"C4\" = sic.col[4],\n                                          \"C5\" = sic.col[5])))\npdf(file = \"heatmap for refer.pdf\", width = 8,height = 4)\ndraw(hm)\ninvisible(dev.off())\n\n# 根据此热图对样本进行修正和排序，并将组别映射到新的字母顺序\n# Correct and sort samples based on this heatmap, and map groups to new alphabetical order\nsic <- sapply(group,function(x) {\n  switch(x, \n         \"C1\" = \"B\", \n         \"C2\" = \"A\",\n         \"C3\" = \"C\",\n         \"C4\" = \"D\",\n         \"C5\" = \"E\")})\n\n# 计算其他签名\n# Calculate other signatures\ngeoMean <- function(x) {exp(mean(log(x)))} \nimmunosuppression.geoMean <- apply(fpkm[immunosuppression.signature,], 2, geoMean)\nt.cell.activation.geoMean <- apply(fpkm[t.cell.activation.signature,], 2, geoMean)\nt.cell.survival.geoMean <- apply(fpkm[t.cell.survival.signature,], 2, geoMean)\nregulatory.t.cell.geoMean <- apply(fpkm[regulatory.t.cell.signature,], 2, geoMean)\nmhc.geoMean <- apply(fpkm[mhc.signature,], 2, geoMean)\nmyeloid.geoMean <- apply(fpkm[myeloid.signature,], 2, geoMean)\ntls.geoMean <- apply(fpkm[tls.signature,], 2, geoMean)\n\n# 将签名得分合并\n# Combine signature scores\ntme.dat <- data.frame(\"Immunosuppression\" = immunosuppression.geoMean,\n                      \"T cell activation\" = t.cell.activation.geoMean,\n                      \"T cell survival\" = t.cell.survival.geoMean,\n                      \"Regulatory T cell\" = regulatory.t.cell.geoMean,\n                      \"Class I MHC\" = mhc.geoMean,\n                      \"Myeloid cells chemotactism\" = myeloid.geoMean,\n                      \"TLSs\" = tls.geoMean)\n\n# 组间比较并计算p值\n# Inter-group comparison and p-value calculation\noutTab <- NULL\nindata <- as.data.frame(t(rbind.data.frame(mcp, t(tme.dat), fpkm[ici.gene,])))\nindata$SIC <- sic[rownames(indata)]\nfor (i in setdiff(colnames(indata), \"SIC\")) {\n  kt <- kruskal.test(as.numeric(indata[,i]) ~ indata$SIC)\n  outTab <- rbind.data.frame(outTab,\n                             data.frame(feature = i,\n                                        p = kt$p.value,\n                                        stringsAsFactors = F),\n                             stringsAsFactors = F)\n}\n\n# 矫正p值\n# Adjusted p-values\noutTab$fdr <- p.adjust(outTab$p, method = \"fdr\") \n\n# 将FDR改为科学计数法\n# Convert FDR to scientific notation\noutTab$txt <- formatC(outTab$fdr, digits = 2, format = \"e\") \n\n# 修改文本\n# Modify text\noutTab$txt <- gsub(\"e\",\" × 10\", outTab$txt) \n\nrownames(outTab) <- outTab$feature\nwrite.table(outTab, file = \"kruskal waills test among different sic groups.txt\",sep = \"\\t\",row.names = F,col.names = T,quote = F)\n开始画图\nPlotting\n# 创建列注释和对应颜色\n# Create column annotations and corresponding colors\nannCol <- data.frame(row.names = comsam,\n                     Disease = sinfo$disease_type, \n                     SIC = sic,\n                     stringsAsFactors = F) \n\n# 简化疾病类型名称\n# Simplify disease type names\nannCol$Disease <- sapply(annCol$Disease,function(x) {\n  switch(x, \n         \"Myomatous Neoplasms\" = \"MN\",\n         \"Nerve Sheath Tumors\" = \"NST\",\n         \"Lipomatous Neoplasms\" = \"LN\",\n         \"Fibromatous Neoplasms\" = \"FN\",\n         \"Soft Tissue Tumors and Sarcomas, NOS\" = \"STT or STS\",\n         \"Synovial-like Neoplasms\" = \"SLN\")})\n\n\n# 设置Disease的因子水平\n# Set factor levels for Disease\nannCol$Disease <- factor(annCol$Disease, levels = c(\"MN\", \"NST\", \"LN\", \"FN\", \"SLN\", \"STT or STS\"))\n\n# 按SIC和Disease排序\n# Order by SIC and Disease\nannCol <- annCol[order(annCol$SIC, annCol$Disease),,drop = F]\n\n# 定义注释的颜色方案\n# Define color schemes for annotations\nannColors <- list()\n\n# SIC颜色映射\n# SIC color mapping\nannColors[[\"SIC\"]] <- c(\"A\" = sic.col[1], \n                        \"B\" = sic.col[2],\n                        \"C\" = sic.col[3],\n                        \"D\" = sic.col[4],\n                        \"E\" = sic.col[5])\n\n# Disease颜色映射\n# Disease color mapping\nannColors[[\"Disease\"]] <- c(\"MN\" = hit.col[1],\n                              \"NST\" = hit.col[2],\n                              \"LN\" = hit.col[3],\n                              \"FN\" = hit.col[4],\n                              \"SLN\" = hit.col[5],\n                              \"STT or STS\" = hit.col[6])\n\n# 重新绘图\n# Re-draw heatmaps\n\n## MCPcounter部分\n## MCPcounter section\nindata <- mcp\nplotdata <- standarize.fun(indata, halfwidth = 2)\n\n# 将签名和矫正p值的文本合并\n# Append adjusted p-values to row names\nrownames(plotdata) <- paste(rownames(plotdata), outTab[rownames(plotdata), \"txt\"], sep = \" \") \n\nhm1 <- pheatmap(plotdata[,rownames(annCol)],\n               border_color = NA, \n               color = bluered(64),\n               show_rownames = T, \n               show_colnames = F, \n               cluster_rows = F, \n               cluster_cols = F, \n               name = \"Gene/metagene\\nZ-score\", \n               cellheight = 12, \n               cellwidth = 300/ncol(plotdata), \n               gaps_col = cumsum(table(annCol$SIC)), \n               annotation_col = annCol, \n               annotation_colors = annColors) \n\n## 其他免疫签名部分\n## Other immune signatures section\nplotdata <- standarize.fun(t(tme.dat), halfwidth = 2)\nrownames(plotdata) <- paste(rownames(plotdata), outTab[rownames(plotdata), \"txt\"], sep = \" \")\nhm2 <- pheatmap(plotdata[,rownames(annCol)],\n                border_color = NA,\n                color = bluered(64),\n                show_rownames = T,\n                show_colnames = F,\n                cluster_rows = F,\n                cluster_cols = F,\n                name = \"Gene/metagene\\nZ-score\",\n                cellheight = 12,\n                cellwidth = 300/ncol(plotdata),\n                gaps_col = cumsum(table(annCol$SIC)))\n\n## 免疫检查点表达部分\n## Immune checkpoint expression section\nplotdata <- standarize.fun(fpkm[ici.gene,], halfwidth = 2)\nrownames(plotdata) <- paste(rownames(plotdata), outTab[rownames(plotdata), \"txt\"], sep = \" \")\nhm3 <- pheatmap(plotdata[,rownames(annCol)],\n                border_color = NA,\n                color = bluered(64),\n                show_rownames = T,\n                show_colnames = F,\n                cluster_rows = F,\n                cluster_cols = F,\n                name = \"Gene/metagene\\nZ-score\",\n                cellheight = 12,\n                cellwidth = 300/ncol(plotdata),\n                gaps_col = cumsum(table(annCol$SIC)))\n\n# 保存合并的热图到PDF\n# Save combined heatmaps to PDF\npdf(file = \"TMEheatmap.pdf\", width = 10,height = 6)\ndraw(hm1 %v% hm2 %v% hm3, \n     heatmap_legend_side = \"left\", \n     annotation_legend_side = \"left\")\ninvisible(dev.off())\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa280TMEofSTS_FigureYa280TMEofSTS",
      "title": "FigureYa280TMEofSTS/FigureYa280TMEofSTS.html",
      "html": "FigureYa280TMEofSTS/FigureYa280TMEofSTS.html",
      "text": "texts/main_FigureYa280TMEofSTS_FigureYa280TMEofSTS.txt",
      "folder": "FigureYa280TMEofSTS",
      "thumb": "gallery_compress/FigureYa280TMEofSTS.webp"
    },
    "word_count": 1342,
    "lines_count": 367,
    "title": "FigureYa280TMEofSTS",
    "description": "Demand description 软组织肉瘤（STSs） Soft-tissue sarcomas (STSs)",
    "input_data_types": [
      "临床数据",
      "生存数据"
    ],
    "output_types": [
      "热图",
      "统计表格",
      "生存曲线"
    ],
    "technical_methods": [
      "聚类分析",
      "通路分析"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "annotation_col",
      "colClasses",
      "center",
      "header",
      "width",
      "cluster_cols",
      "n",
      "cellwidth",
      "name"
    ]
  },
  {
    "id": "main_FigureYa131CMap_update_FigureYa131CMap_update",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa131CMap_update_FigureYa131CMap_update.txt",
    "content": "FigureYa131CMap_update\nFigureYa131CMap_update\nAuthor(s)\n: Rongfang Shen\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nDescription of the Task\n药物分析，Connectivity\nmap(CMap)分析鉴定能够靶向干性特征的潜在化合物/抑制剂，重复出下图 Drug\nanalysis: Connectivity map (CMap) analysis identifies potential\ncompounds/inhibitors that can target stemness features. Reproduce the\nfigure below.\n出自\nhttps://www.sciencedirect.com/science/article/pii/S0092867418303581?via%3Dihub#app2\nFrom\nhttps://www.sciencedirect.com/science/article/pii/S0092867418303581?via%3Dihub#app2\nFigure 7. Correlation of cancer stemness with drug resistance –\nConnectivity map analysis (A) Heatmap showing enrichment score (positive\nin blue, negative in red) of each compound from the CMap for each cancer\ntype. Compounds sorted from right to left by descending number of cancer\ntype significantly enriched. (B) Heatmap showing each compound\n(perturbagen) from the CMap that share Mechanism of actions (rows).\nSorted by descending number of compound with shared mechanism of\nactions. See also Figure S7 and Tables S3 and S4.\n应用场景\nApplication Scenario\n任何感兴趣的差异基因都可以用CMap分析得到可能的靶向药物，关于CMap的介绍和原理可以参考\nThe\nConnectivity Map-揭示化合物，基因和疾病状态的功能联系\n. Any\ndifferentially expressed genes of interest can be used for CMap analysis\nto identify possible targeted drugs. For an introduction to CMap and its\nprinciples, refer to The Connectivity Map - Revealing functional links\nbetween compounds, genes, and disease states. (\nhttps://mp.weixin.qq.com/s/N0ZvANnWsbBB3XJpSr1j1g\n).\nCMap build\n02\n包含~1,300小分子化合物处理的Affymetrix芯片数据，目前还可以使用但是已经不更新和维护了。考虑到新版的\nclue.io\nquery只能上传最多150个上调和下调差异基因，而CMap\nbuild\n02版本可以总共上传1000个基因（上调和下调基因总和不超过1000个基因）。\nCMap build 02\ncontains Affymetrix chip data of ~1,300 small molecule compounds. It is\nstill available but no longer updated and maintained. Considering that\nthe new version of\nclue.io\nquery can only\nupload up to 150 up-regulated and down-regulated differentially\nexpressed genes, while CMap build 02 can upload a total of 1,000 genes\n(the total number of up-regulated and down-regulated genes does not\nexceed 1,000 genes).\n作者在查询这个步骤依旧使用的是CMap build 02. The author still uses\nCMap build 02 for this query step.\n而在分析mechanism of actions (MoA)和drug-target部分则选用的是\nCLUE\n，对感兴趣的小分子进行MoA药物作用机制分析，探索其共同的内在作用机制。\nIn the analysis of mechanism of actions (MoA) and drug-target,\nCLUE\nis used to perform MoA drug action\nmechanism analysis on the small molecules of interest and explore their\ncommon intrinsic mechanisms of action.\n环境设置\nEnvironment Setup\nInstall packages using domestic mirrors\nsource(\"install_dependencies.R\")\nlibrary(xlsx)\nlibrary(tidyverse)\nlibrary(GEOquery)\nlibrary(plyr)\nlibrary(circlize)\nlibrary(ComplexHeatmap)\n\noptions(java.parameters = \"-Xmx8000m\")\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 Display English error message\noptions(stringsAsFactors = FALSE) #禁止chr转成factor Disable conversion of chr to factor\nPART 1: 重复出文章Figure 7A\nPART 1: Repeat Figure 7A\n生成CMap输入文件\nGenerate Input Files for CMap\npandif_mRNAsi.xlsx，这里用的是TCGA泛癌数据根据mRNAsi指标高低求出的差异基因。出自例文附件Table\nS3\nhttps://ars.els-cdn.com/content/image/1-s2.0-S0092867418303581-mmc3.xlsx\n，你也可以用任何你感兴趣的差异基因作为输入。\npandif_mRNAsi.xlsx, here we use the differentially expressed genes from\nthe TCGA pan-cancer data according to the mRNAsi index. From the example\ntext attachment Table S3\nhttps://ars.els-cdn.com/content/image/1-s2.0-S0092867418303581-mmc3.xlsx\n,\nyou can also use any differentially expressed genes you are interested\nin as input.\n#CMap要求输入基因是GPL96 platform ID的形式\n#Refer to the CMap query_update.docx in the same folder for detailed operation steps. Use ACC as an example.\nGPL96 <- getGEO(\"GPL96\", destdir = getwd())\nGPL96 <- Table(GPL96)[, c(\"ID\", \"Gene Symbol\")]\n\npan_n <- 33\npancancertype <- c(\"ACC\", \"BLCA\", \"BRCA\", \"CESC\", \"CHOL\", \"COAD\", \"DLBC\", \"ESCA\", \"GBM\", \"HNSC\", \n                   \"KICH\", \"KIRC\", \"KIRP\", \"LAML\", \"LGG\", \"LIHC\", \"LUAD\", \"LUSC\", \"MESO\", \"OV\",\n                   \"PAAD\", \"PCPG\", \"PRAD\", \"READ\", \"SARC\", \"SKCM\", \"STAD\", \"TGCT\", \"THCA\", \"THYM\",\n                   \"UCEC\", \"UCS\", \"UVM\")\ndiflist <- list()\n\n# 读取数据\n# # Read data\nfor (i in 1:pan_n){\n  print(paste0(\"Load \", pancancertype[i], \" differentially expressed gene data\"))\n  difdata <- openxlsx::read.xlsx(\"pandif_mRNAsi.xlsx\", sheet = i, colNames = TRUE) %>% \n    merge(GPL96, ., by.x = \"Gene Symbol\", by.y = \"GeneSymbol\")\n  difdata$logFC <- as.numeric(difdata$logFC)\n  difdata <- difdata[order(difdata$logFC, decreasing = T), ]\n  diflist[[i]] <- difdata\n}\nnames(diflist) <- pancancertype\n\n# 输出grp文件(one gene per line)\nif (!file.exists(\"./grpfile\")){\n  dir.create(\"./grpfile\")\n}\nfor (i in 1:pan_n){\n  print(paste0(pancancertype[i], \" processing\"))\n  tmpdata <- diflist[[i]]\n  tmp_updata <- tmpdata[tmpdata$logFC > 0, ]\n  tmp_downdata <- tmpdata[tmpdata$logFC < 0, ]\n  # 选择差异最大的前500个基因\n  # Select the top 500 genes with the largest differences\n  if (nrow(tmp_updata) > 500){\n    top500up <- tmp_updata[, \"ID\"][1:500]\n  } else {top500up <- tmp_updata[, \"ID\"]}\n  \n  if (nrow(tmp_downdata) > 500){\n    top500down <- rev(tmp_downdata[, \"ID\"])[1:500]\n  } else {top500down <- rev(tmp_downdata[, \"ID\"])}\n  # 写成grp格式文件\n  # Written in grp format\n  write.table(top500up, paste0(\"grpfile/\", pancancertype[i], \"_up500.grp\"),\n              row.names = F, sep = \"\\t\", quote = F, col.names = F)\n  write.table(top500down, paste0(\"grpfile/\", pancancertype[i], \"_down500.grp\"),\n              row.names = F, sep = \"\\t\", quote = F, col.names = F)\n}\nCMap query\n需要用到CMap，具体操作方法见同一文件夹下的\nCMap\nquery_update.docx\n文件，这里以ACC为例，获得ACC_CMap_result.xls。\nCMap is needed. For specific operation methods, see the\nCMap\nquery_update.docx\nfile in the same folder. Here, ACC is taken\nas an example to obtain ACC_CMap_result.xls.\n把按照操作文档运行的结果ACC_CMap_result.xls跟文章提供附件结果做对比。Connectivity_Map_Output.xlsx出自例文附件Table\nS4，\nhttps://ars.els-cdn.com/content/image/1-s2.0-S0092867418303581-mmc4.xlsx\n。\nCompare the result ACC_CMap_result.xls of running according to the\noperation document with the result provided in the article.\nConnectivity_Map_Output.xlsx is from Table S4 of the example article,\nhttps://ars.els-cdn.com/content/image/1-s2.0-S0092867418303581-mmc4.xlsx\n.\n# 按操作文档得到的结果\n# According to the procedure described in the operation manual\nACC_CMap_result <- xlsx::read.xlsx(\"ACC_CMap_result.xls\", sheetIndex = 1, header = T)\nACC_CMap_result$p <- as.numeric(ACC_CMap_result$p)\n# p < 0.05 筛选具有统计学意义的化合物\n# Filter compounds with statistically significant p-values (p < 0.05)\nACC_CMap_sig <- na.omit(ACC_CMap_result)\nACC_CMap_sig <- ACC_CMap_sig[ACC_CMap_sig$p < 0.05, ]\ndim(ACC_CMap_sig)\n# 例文的结果\n# Result from the example article\nACC_CMap_paper <- openxlsx::read.xlsx(\"Connectivity_Map_Output.xlsx\", sheet = 1, colNames = T) #读取sheet1 ACC\n# Read sheet 1 (ACC) from the Connectivity Map Output file\ndim(ACC_CMap_paper)\n# 两个结果的交集\n# Intersection between two results\ncamp_inter <- length(intersect(ACC_CMap_sig$cmap.name, ACC_CMap_paper$cmap.name)) \ncamp_inter\npaper_cmap <- ACC_CMap_result[ACC_CMap_result$cmap.name %in% ACC_CMap_paper$cmap.name, ]\nhead(paper_cmap)\n虽然跟原文提供的结果不是完全一致。分析的原因可能是在处理输入差异基因这一步骤上，文章说在匹配gpl96探针数据FC排序之后去掉重复的ID。这一步骤我是多个探针匹配同一个基因只保留一个探针。还试过删除掉多个探针匹配一个基因的全部探针以及保留全部的unique探针。结果都不能达到完全一致。\nAlthough the results are not exactly the same as those provided in\nthe article, the likely reason lies in the preprocessing step of input\ndifferential genes. The article mentions removing duplicate IDs after FC\nranking with gpl96 probe data. In my case, I retained only one probe per\ngene when multiple probes matched the same gene. I also tried removing\nall such probes or keeping all unique probes, but none achieved perfect\nconsistency.\n可以看到在140有85个交集，并且rank在前面的compound基本一致。\nAs shown, there are 85 overlapping compounds among the 140\ncompounds, and the top-ranked compounds are mostly consistent.\n因此差异应该是由于数据预处理问题，方法是没有问题的。\nTherefore, the discrepancy is likely due to data preprocessing\nrather than methodological issues.\n画图\nPlotting\n按照操作文档CMap query_update.docx里的方法，对全部癌种执行完CMap\nquery之后，整理好文件。\nAccording to the method described in CMap query_update.docx, after\nperforming CMap queries for all cancer types, organize the output\nfiles.\n这里就不重复这一过程了，我们直接拿文章的附件来画图。\nThis step is omitted here; we use the data from the article’s\nsupplementary files for plotting.\nConnectivity_Map_Output.xlsx: 全部癌种的Connectivity Map\nOutput结果。出自例文附件Table S4，\nhttps://ars.els-cdn.com/content/image/1-s2.0-S0092867418303581-mmc4.xlsx\n。\nConnectivity_Map_Output.xlsx: Connectivity Map Output results for\nall cancer types from Supplementary Table S4 of the article.\ncamp_outputlist <- list()\nfor (i in 1:pan_n){\n  camp_output_tmp <- openxlsx::read.xlsx(\"Connectivity_Map_Output.xlsx\", sheet = i, colNames = T)\n  camp_outputlist[[i]] <- camp_output_tmp\n}\nnames(camp_outputlist) <- pancancertype\ncamp_output <- plyr::ldply(camp_outputlist, data.frame)\ncolnames(camp_output)[1] <- \"Cancer\"\nstr(camp_output)\nsummary(camp_output$p)\n# 整理成complexheatmap的输入形式\n# Reshape data into input format required by ComplexHeatmap\noncoplotdata <- reshape2::dcast(camp_output[, c(\"Cancer\", \"cmap.name\", \"enrichment\")], Cancer ~ cmap.name)\nrownames(oncoplotdata) <- oncoplotdata$Cancer\noncoplotdata <- oncoplotdata[, -1]\nmean(apply(oncoplotdata, 1, function(x) sum(!is.na(x)))) #average of 74 compounds per tumor type\n#可以发现Figure4A enrichment score跟提供的数据是方向是完全相反的，我认为作者是为了更好地解释结果。enrichment score越高，代表这个药物引起的改变和stemness改变越相似，enrichment score越负，改变越相反，因而该种药物才有可能inhibit stemness-related tumorigenicity。在这里我就不对其进行改变，保留原始CMap output结果。\n# It appears that the enrichment scores in Figure 4A are reversed compared to the provided data, likely for better interpretability. A higher enrichment score indicates a drug-induced change similar to stemness, while a more negative score suggests an opposing change, implying potential inhibition of stemness-related tumorigenicity. Here, we retain the original CMap output values.\n\noncoplotdata[, \"zardaverine\"]\n# 作者画图的处理并没有进一步的说明，作者在文中只提到筛选p<0.05，并且展示在多于3个癌种都有富集的复合物。但看文章显示的结果应该有进行进一步的筛选。\n# The author did not provide further explanation on plotting details. The paper mentions selecting compounds with p<0.05 and showing those enriched in more than 3 cancer types, but the figure suggests further filtering was applied.\n\n# 这里我们选取富集多于10个癌种的复合物进行展示。\n# Here, we display compounds enriched in more than 10 cancer types.\noncoplotdata2 <- oncoplotdata[, apply(oncoplotdata, 2, function(x) sum(!is.na(x)) > 10)]\n# compounds ordered by number of significantly enriched\ncol_sum <- apply(oncoplotdata2, 2, function(x)sum(!is.na(x)))\noncoplotdata2 <- oncoplotdata2[, order(col_sum, decreasing = F)]\ncalculate_sum <- function(x){\n  sumdata <- data.frame(positive = sum(x > 0,na.rm = T), negative = sum(x < 0, na.rm = T))\n  return(sumdata)\n}\ncampsum <- apply(oncoplotdata2, 2, calculate_sum)\ncampsum <- plyr::ldply(campsum, data.frame)\nrownames(campsum) <- campsum$.id\ncampsum <- campsum[, -1]\ncolumn_ha = HeatmapAnnotation(cancernumber = anno_barplot(campsum, axis = TRUE,\n                                                          axis_param = list(side = \"right\"),\n                                                          bar_width = 1, border = F,\n                                                          gp = gpar(fill = c(\"#E41A1C\",\n                                                                             \"#377EB8\")),\n                                                          height = unit(2.5, \"cm\")),\n                              show_annotation_name = FALSE)\ncol_fun = colorRamp2(c(-1, 0, 1), c(\"#377EB8\", \"white\", \"#E41A1C\"))\n\npdf(\"CMap_heatmap.pdf\", width = 12, height = 8)\nht_list = Heatmap(as.matrix(oncoplotdata2), col = col_fun, name = \"legend\",\n                  heatmap_width = unit(1, \"npc\"),\n                  heatmap_height = unit(0.8, \"npc\"),\n                  column_names_side = \"top\", show_row_dend = FALSE, show_column_dend = FALSE,\n                  show_column_names = TRUE, show_row_names = TRUE,\n                  bottom_annotation = column_ha,na_col = \"white\", rect_gp = gpar(col = \"grey\"),\n                  cluster_rows =  F, cluster_columns = F, \n                  heatmap_legend_param = list(grid_width = unit(2, \"cm\"),\n                                              grid_height = unit(1.5, \"cm\")))\ndraw(ht_list, column_title = \"specific inhibitors\", column_title_gp = gpar(fontsize = 25))\ndecorate_annotation(\"cancernumber\", {\n    grid.text(\"Number of cancer \\ntype with p < 0.05\", \n              unit(1, \"npc\") + unit(8, \"mm\"), just = \"left\",\n              gp = gpar(fontsize = 12, col=\"black\"))})\ndev.off()\nPART 2: 重复出文章Figure 7B\nPART 2: Reproducing Figure 7B from the article\nMoA分析\nMoA Analysis\n探讨感兴趣药物的作用机制，具体操作方法参考操作文档CMap_MoA.docx。\nExplore the mechanism of action of the drug of interest. For specific\noperation methods, refer to the operation document CMap_MoA.docx.\nmoa_target_export.txt:\n是从网站下载的全部MoA和target信息，只需要对感兴趣的药物进行筛选整理就可以得到文章的输入文件。\nmoa_target_export.txt: It is all the MoA and target information\ndownloaded from the website. You only need to screen and organize the\ndrugs of interest to get the input file of the article.\nMoAinput2 <- read.table(\"moa_target_export.txt\", sep = \"\\t\", header = T, )\n# 原文中提及74 compounds没有明确说明筛选方法，这里取前50个。\n# The article mentions 74 compounds without specifying the selection criteria; here we take the top 50.\n# 实际运行时，自己先筛选一下感兴趣的compouds\n# In actual practice, filter compounds of interest first\nMoAinput2 <- MoAinput2[1:50,]\n\n# 整理成oncoPrint需要的输入形式\n# Reshape data into the input format required by oncoPrint\nPerturbagenID <- MoAinput2$Name\nnames(PerturbagenID) <- MoAinput2$ID\nMoAinput2$Type <- NULL\nMoAinput2$Name <- NULL\nMoAinput2$MoA <- NULL\nMoAinput2$Target <- NULL\ncolnames(MoAinput2) <- c(\"inhibitors\", \"mechanisms of action\") \n\noncoprintinput <- reshape2::dcast(MoAinput2, `mechanisms of action` ~ inhibitors)\nrownames(oncoprintinput) <- oncoprintinput$`mechanisms of action` \noncoprintinput <- as.matrix(oncoprintinput[, -1])\noncoprintinput[!is.na(oncoprintinput)] <- \"inhibitor\"\noncoprintinput[is.na(oncoprintinput)] <- \"\"\ncolnames(oncoprintinput) <- PerturbagenID[colnames(oncoprintinput)]\noncoprintinput <- oncoprintinput[, order(colnames(oncoprintinput))]\n下面我们就用文章提供的附件重复原图： Below we use the attachment\nprovided by the article to reproduce the original image:\nConnectivity_Map_Output.xlsx，出自例文附件Table S4里的TableS4B，\nhttps://ars.els-cdn.com/content/image/1-s2.0-S0092867418303581-mmc4.xlsx\n。表34是MoA结果，作为Figure\n7B的输入结果。 Connectivity_Map_Output.xlsx, from Table S4B in the\nexample article attachment Table S4,\nhttps://ars.els-cdn.com/content/image/1-s2.0-S0092867418303581-mmc4.xlsx\n.\nTable 34 is the MoA result, which is used as the input result of Figure\n7B.\nMoAinput <- openxlsx::read.xlsx(\"Connectivity_Map_Output.xlsx\", sheet = 34, colNames = T)\n#parthenolide药物在NFkB pathway inhibitor有2个，其Perturbagen.Id不同\n#Parthenolide has 2 NFkB pathway inhibitors, and their Perturbagen.Id is different\nMoAinput[MoAinput$MoA == \"NFkB pathway inhibitor\", ]\n# 整理成oncoPrint需要的输入形式\n# # Arrange it into the input format required by oncoPrint\nPerturbagenID <- unlist(str_split(MoAinput$Name, \", \"))\nnames(PerturbagenID) <- unlist(str_split(MoAinput$Perturbagen.Id, \", \")) \nMoAinput <- MoAinput[, c(\"MoA\", \"Perturbagen.Id\")] %>% split(.$MoA) %>% lapply(\"[[\", 2) %>% \n  lapply(., function(x)unlist(str_split(x, \", \"))) %>% plyr::ldply(., data.frame)\ncolnames(MoAinput) <- c(\"mechanisms of action\", \"inhibitors\") \noncoprintinput <- reshape2::dcast(MoAinput, `mechanisms of action` ~ inhibitors)\nrownames(oncoprintinput) <- oncoprintinput$`mechanisms of action` \noncoprintinput <- as.matrix(oncoprintinput[, -1])\noncoprintinput[!is.na(oncoprintinput)] <- \"inhibitor\"\noncoprintinput[is.na(oncoprintinput)] <- \"\"\ncolnames(oncoprintinput) <- PerturbagenID[colnames(oncoprintinput)]\noncoprintinput <- oncoprintinput[, order(colnames(oncoprintinput))]\n画图\nPlotting\nalter_fun = list(\n    background = function(x, y, w, h) \n        grid.rect(x, y, w*0.9, h*0.9, gp = gpar(fill = \"white\", col = \"grey\")),\n    # dots\n    inhibitor = function(x, y, w, h) \n        grid.points(x, y, pch = 16, size = unit(0.8, \"char\"))\n    \n)\nha_coldata <- colSums(apply(oncoprintinput, 2, function(x) x==\"inhibitor\") + 0) %>% as.numeric()\nha_rowdata <- rowSums(apply(oncoprintinput, 2, function(x) x==\"inhibitor\") + 0) %>% as.numeric() \ntop_ha <- HeatmapAnnotation(inhibitors = anno_barplot(ha_coldata, axis = F, border = F, \n                                                      gp = gpar(fill = \"grey\"),\n                                                      bar_width = 1),\n                            annotation_name_side = \"left\",\n                            annotation_name_rot = 90)\nright_ha <- rowAnnotation(count = anno_barplot(ha_rowdata, axis = F, border = F, \n                                               gp = gpar(fill = \"grey\"),\n                                               bar_width = 1, width = unit(1.5, \"cm\")),\n                          annotation_name_side = \"top\",\n                          annotation_name_rot = 0)\n\npdf(\"MoA.pdf\", width = 10, height = 8, onefile = F)\noncoPrint(oncoprintinput, alter_fun = alter_fun, \n          show_column_names = TRUE, column_names_side = \"top\",\n          column_order = 1:ncol(oncoprintinput), \n          top_annotation = top_ha,\n          right_annotation = right_ha,\n          show_pct = FALSE, show_heatmap_legend = F)\ndecorate_annotation(\"inhibitors\", {\n    grid.text(\"mechanism of action\", unit(1, \"npc\") + unit(3, \"mm\"), just = \"left\")})\ndev.off()\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa131CMap_update_FigureYa131CMap_update",
      "title": "FigureYa131CMap_update/FigureYa131CMap_update.html",
      "html": "FigureYa131CMap_update/FigureYa131CMap_update.html",
      "text": "texts/main_FigureYa131CMap_update_FigureYa131CMap_update.txt",
      "folder": "FigureYa131CMap_update",
      "thumb": "gallery_compress/FigureYa131CMap_update.webp"
    },
    "word_count": 1911,
    "lines_count": 381,
    "title": "FigureYa131CMap_update",
    "description": "Description of the Task 药物分析，Connectivity map(CMap)分析鉴定能够靶向干性特征的潜在化合物/抑制剂，重复出下图 Drug",
    "input_data_types": [],
    "output_types": [
      "散点图",
      "热图",
      "统计表格"
    ],
    "technical_methods": [
      "通路分析"
    ],
    "biology_areas": [
      "癌症研究",
      "药物研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "column_names_side",
      "show_pct",
      "",
      "show_heatmap_legend",
      "bottom_annotation",
      "alter_fun",
      "header",
      "show_row_dend",
      "count",
      "heatmap_width"
    ]
  },
  {
    "id": "main_FigureYa268panCNVexpr_FigureYa268panCNVexpr",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa268panCNVexpr_FigureYa268panCNVexpr.txt",
    "content": "FigureYa268panCNVexpr\nFigureYa268panCNVexpr\nAuthor(s)\n: Xiaofan Lu; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-05-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nDemand description\n想实现这篇铁死亡泛癌的其他图片，主要是Figure\n1。感觉这个套路只要换一个通路就可以测试，我看Xiaofan\nLu写了这篇文章的Figure\n2A（铁死亡基因在泛癌肿瘤与正常的差异箱线图，FigureYa208FPI），Figure\n3B（铁死亡与免疫通路的相关性，FigureYa253panGSEA），可否请Xiaofan\nLu详细写一下文章Figure 1的相关代码？\n1A（铁死亡在泛癌中体细胞拷贝数变异情况，绘制条形图，可参考FigureYa265panCNV）\n1B（铁死亡基因在肿瘤与正常的差异表达，绘制拼接的点图和柱状图，可参考FigureYa263panDiff）\n1C（铁死亡基因体细胞拷贝数与基因表达的相关性点图）\n1D（铁死亡基因肿瘤与正常组织甲基化状态点图）\n1E（铁死亡转录组表达与启动子甲基化相关性的点图）\n这些图都是泛癌的，不知道Xiaofan Lu可不可以用例文数据分别实现个教程\n[皱眉] ？（感觉都可以出一期专栏——iSicence复现了哈哈）\n这次实现Figure 1C，铁死亡基因体细胞拷贝数与基因表达的相关性点图。\nThe other figures from this pan-cancer ferroptosis study, mainly\nFigure 1. It seems that this approach can be tested just by switching to\na different pathway. I noticed that Xiaofan Lu has already written about\nFigure 2A (boxplot of ferroptosis gene differences between tumors and\nnormal tissues in pan-cancer, FigureYa208FPI) and Figure 3B (correlation\nbetween ferroptosis and immune pathways, FigureYa253panGSEA) from this\narticle. Could Xiaofan Lu please provide a detailed explanation of the\ncode for Figure 1 in the article?\n1A (somatic copy number variation of ferroptosis in pan-cancer, bar\nplot, refer to FigureYa265panCNV)\n1B (differential expression of ferroptosis genes in tumors\nvs. normal tissues, combined dot and bar plot, refer to\nFigureYa263panDiff)\n1C (correlation scatter plot between somatic copy number and gene\nexpression of ferroptosis genes)\n1D (methylation status dot plot of ferroptosis genes in tumor\nvs. normal tissues)\n1E (scatter plot of correlation between ferroptosis transcriptome\nexpression and promoter methylation)\nAll these figures are pan-cancer analyses. I wonder if Xiaofan Lu\ncould create separate crowdsourcing tutorials using the example data?\n(Feels like it could even be a column—iScience reproduction, haha!)\nThis time, we’re drawing Figure 1C: the scatter plot showing the\ncorrelation between somatic copy number and gene expression of\nferroptosis genes.”\n出自\nhttps://linkinghub.elsevier.com/retrieve/pii/S2589004220304892\n图1. 铁死亡调控基因（FRGs）的失调。\n其中，正调控因子和负调控因子分别用红色和蓝色标注。 (C)\nFRGs体细胞拷贝数变异与基因表达的Spearman相关性分析。\n接下来会陆续实现Figure1DE，敬请关注。\nSource:\nhttps://linkinghub.elsevier.com/retrieve/pii/S2589004220304892\nFigure 1. The Dysregulation of Ferroptosis Regulator Genes (FRGs).\nFor which the positive and negative regulators are marked in red and\nblue, respectively. (C) The Spearman’s correlation between somatic copy\nnumber alterations and the expression of FRGs.\nFigure 1DE will be launched successively, so stay tuned.\n应用场景\nApplication scenarios\n分析基因（以铁死亡为例）体细胞拷贝数与基因表达的相关性，并绘制点图。\nAnalyze the correlation between somatic copy number and gene\nexpression (using ferroptosis as an example) and plot a scatter\ndiagram.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(ggplot2)\nlibrary(data.table)\nlibrary(randomcoloR)\nlibrary(ggpubr)\nlibrary(GSVA)\nlibrary(clusterProfiler)\nlibrary(impute)\nlibrary(ComplexHeatmap)\nsource(\"twoclasslimma.R\")\n\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n输入文件\nInput Files\n跟FigureYa263panDiff、FigureYa265panCNV使用的是同一套数据，已经下载的小伙伴就不用重复下载了。\nmerged_sample_quality_annotations.tsv，下载自\nhttps://gdc.cancer.gov/about-data/publications/pancanatlas\n，下载地址\nhttp://api.gdc.cancer.gov/data/1a7d7be8-675d-4e60-a105-19d4121bdebf\nEBPlusPlusAdjustPANCAN_IlluminaHiSeq_RNASeqV2.geneExp.tsv，表达矩阵，第一列是基因，之后是其在每个样本中的表达量。下载自\nhttp://api.gdc.cancer.gov/data/3586c0da-64d0-4b74-a449-5ff4d9136611\nTCGA.PANCAN.sampleMap_Gistic2_CopyNumber_Gistic2_all_data_by_genes.gz，CNV数据，下载地址\nhttps://xenabrowser.net/datapages/?dataset=TCGA.PANCAN.sampleMap%2FGistic2_CopyNumber_Gistic2_all_data_by_genes&host=https%3A%2F%2Ftcga.xenahubs.net&removeHub=https%3A%2F%2Fxena.treehouse.gi.ucsc.edu%3A443\nThe same dataset is used as in FigureYa263panDiff and\nFigureYa265panCNV, so those who have already downloaded it do not need\nto download it again.\nmerged_sample_quality_annotations.tsv: Downloaded from\nhttps://gdc.cancer.gov/about-data/publications/pancanatlas\n,\ndownload link:\nhttp://api.gdc.cancer.gov/data/1a7d7be8-675d-4e60-a105-19d4121bdebf\nEBPlusPlusAdjustPANCAN_IlluminaHiSeq_RNASeqV2.geneExp.tsv: Expression\nmatrix, where the first column contains gene names, followed by their\nexpression levels in each sample. Downloaded from\nhttp://api.gdc.cancer.gov/data/3586c0da-64d0-4b74-a449-5ff4d9136611\nTCGA.PANCAN.sampleMap_Gistic2_CopyNumber_Gistic2_all_data_by_genes.gz:\nCNV data, download link:\nhttps://xenabrowser.net/datapages/?dataset=TCGA.PANCAN.sampleMap%2FGistic2_CopyNumber_Gistic2_all_data_by_genes&host=https%3A%2F%2Ftcga.xenahubs.net&removeHub=https%3A%2F%2Fxena.treehouse.gi.ucsc.edu%3A443\n# 获得同时有肿瘤和正常样本的肿瘤名\n# Get tumor names that have both tumor and normal samples\ntumors <- c(\"BLCA\",\"BRCA\",\"CESC\",\"CHOL\",\"COAD\",\n            \"ESCA\",\"GBM\",\"HNSC\",\"KICH\",\"KIRC\",\n            \"KIRP\",\"LIHC\",\"LUAD\",\"LUSC\",\"PAAD\",\n            \"PRAD\",\"READ\",\"STAD\",\"THCA\",\"UCEC\")\n\n# 获得感兴趣的基因集(TTC35是EMC2的同名)\n# Get the gene set of interest (TTC35 is an alias for EMC2)\nfrg <- c(\"CDKN1A\",\"HSPA5\",\"TTC35\",\"SLC7A11\",\"NFE2L2\",\"MT1G\",\"HSPB1\",\"GPX4\",\"FANCD2\",\"CISD1\",\"FDFT1\",\"SLC1A5\",\"SAT1\",\n         \"TFRC\",\"RPL8\",\"NCOA4\",\"LPCAT3\",\"GLS2\",\"DPP4\",\"CS\",\"CARS\",\"ATP5G3\",\"ALOX15\",\"ACSL4\",\"EMC2\")\n\n# 修正TCGA名称\n# 数据来自PanCanAtlas\n# Correct TCGA names\n# Data from PanCanAtlas\nrawAnno <- read.delim(\"merged_sample_quality_annotations.tsv\",sep = \"\\t\",row.names = NULL,check.names = F,stringsAsFactors = F,header = T) \n# 简化样本ID（取前15位TCGA条码）\n# Simplify sample IDs (first 15 characters of TCGA barcode)\nrawAnno$simple_barcode <- substr(rawAnno$aliquot_barcode,1,15)\n\n# 创建精简注释表（去重+关键列）\n# Create concise annotation table (deduplicated + key columns)\nsamAnno <- rawAnno[!duplicated(rawAnno$simple_barcode),c(\"cancer type\", \"simple_barcode\")]\n\n# 过滤无效记录（癌症类型为空）\n# Filter invalid records (empty cancer type)\nsamAnno <- samAnno[which(samAnno$`cancer type` != \"\"),]\n\n# 保存注释文件（供后续分析使用）\n# Save annotation (for downstream analysis)\nwrite.table(samAnno,\"simple_sample_annotation.txt\",sep = \"\\t\",row.names = F,col.names = T,quote = F)\n\n# 快速读取表达谱，然后按癌症名拆分成单个文件\n# Quickly read the expression profile and split it into individual files by cancer name\nexpr <- fread(\"EBPlusPlusAdjustPANCAN_IlluminaHiSeq_RNASeqV2.geneExp.tsv\",sep = \"\\t\",stringsAsFactors = F,check.names = F,header = T)\n\n# 转换为数据框并设置行名\n# Convert to dataframe and set row names\nexpr <- as.data.frame(expr); rownames(expr) <- expr[,1]; expr <- expr[,-1]\n\n# 调整基因名（去除Ensembl ID版本号）\n# Adjust gene names (remove Ensembl ID version)\ngene <- sapply(strsplit(rownames(expr),\"|\",fixed = T), \"[\",1) \nexpr$gene <- gene\n\n# 移除重复样本\n# Remove duplicate samples\nexpr <- expr[!duplicated(expr$gene),] \n\n# 重置行名并移除临时基因列\n# Reset row names and remove temporary gene column\nrownames(expr) <- expr$gene; expr <- expr[,-ncol(expr)]\n\n# 取部分表达谱（感兴趣的基因集）\n# Extract a subset of the expression profile (gene set of interest)\ncomgene <- intersect(rownames(expr),frg) \n\n# 提取基因表达子集\n# Extract gene expression subset\nexpr_sub <- expr[comgene,]\n\n# 简化样本ID（取前15位）\n# Simplify sample IDs (first 15 characters)\ncolnames(expr_sub) <- substr(colnames(expr_sub),1,15)\n\n# 去除重复样本（基于简化后的ID）\n# Remove duplicate samples (based on simplified IDs)\nexpr_sub <- expr_sub[,!duplicated(colnames(expr_sub))]\n\n# 按癌症类型分割表达数据\n# Split Expression Data by Cancer Type\nfor (i in tumors) {\n  message(\"--\",i,\"...\")\n  \n  # 获取该肿瘤的全部样本\n  # Get all samples for this tumor\n  sam <- samAnno[which(samAnno$`cancer type` == i),\"simple_barcode\"] \n  \n  # 取出与基因表达泛癌数据交集的样本\n  # Extract samples overlapping with the pan-cancer gene expression data\n  comsam <- intersect(colnames(expr_sub), sam) \n  \n  # 获得肿瘤样本\n  # Get tumor samples\n  tumsam <- comsam[substr(comsam,14,14) == \"0\"] \n  \n  # 获得正常样本\n  # Get normal samples\n  norsam <- comsam[substr(comsam,14,14) == \"1\"] \n  \n  # 提取当前癌症的表达子集\n  # Extract expression subset for current cancer\n  expr_subset <- expr_sub[,c(tumsam,norsam)]\n  \n  # 这份数据里存在负值，即便负值比较小，但也要矫正，如果使用其他泛癌表达谱根据情况而定\n  # This dataset contains negative values, which are relatively small but still need correction. Adjust accordingly if using other pan-cancer expression profiles.\n  expr_subset[expr_subset < 0] <- 0 \n  \n  # 使用KNN算法填补缺失值\n  # Impute missing values using KNN algorithm\n  expr_subset <- as.data.frame(impute.knn(as.matrix(expr_subset))$data)\n  \n  # 保存癌症特异的表达子集\n  # Save cancer-specific expression subset\n  write.table(expr_subset, paste0(\"TCGA_\",i,\"_expr_subset.txt\"),sep = \"\\t\",row.names = T,col.names = NA,quote = F)\n}\nrm(expr); gc()\n# 快速读取CNA数据\n# Quickly read CNA data\ncna <- fread(\"TCGA.PANCAN.sampleMap_Gistic2_CopyNumber_Gistic2_all_data_by_genes.gz\",sep = \"\\t\",stringsAsFactors = F,header = T,check.names = F)\ncna <- as.data.frame(cna)\ncomgene <- intersect(cna$Sample,frg)\n\n# 只包含感兴趣基因的CNA子集\n# CNA subset containing only genes of interest\ncna <- cna[cna$Sample %in% comgene,] \n\nrownames(cna) <- cna[,1]; cna <- cna[,-1]\n相关性分析\nCorrelation Analysis\n# 创建空对象存储拷贝数与表达相关性结果\n# Create empty object to store CNA-expression correlations\ncorCnaExpr <- NULL\n\n# 跨癌种相关性分析\n# Pan-Cancer Correlation Analysis\nfor (i in tumors) {\n  message(\"--\",i,\"...\")\n  \n  # 读取上面拆分好的表达数据\n  # Read the pre-split expression data\n  expr_subset <- read.table(paste0(\"TCGA_\",i,\"_expr_subset.txt\"),sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\n  \n  # 取出同时具有表达且具有拷贝数的样本\n  # Extract samples that have both expression and copy number data \n  comsam <- intersect(colnames(expr_subset),colnames(cna))\n  \n  # 生成拷贝数子集\n  # Generate a copy number subset\n  cna_subset <- cna[,comsam] \n  \n  # EMC2是原文使用的TTC35基因的同名，使用子集数据时无须修正\n  # EMC2 is an alias for the TTC35 gene used in the original study; no correction is needed when using subset data\n  rownames(cna_subset) <- gsub(\"EMC2\",\"TTC35\",rownames(cna_subset)) \n  \n  # 生成基因表达子集\n  # Generate a gene expression subset\n  expr_subset <- expr_subset[,comsam] \n  \n  # 把cnv按癌症名保存到单个文件\n  # Save CNV data by cancer type into individual files\n  # write.table(cna_subset, paste0(\"TCGA_\",i,\"_broadcnv_subset_matched_expr.txt\"),sep = \"\\t\",row.names = F,col.names = T,quote = F)\n  \n  # 计算相关系数\n  # Calculate correlation coefficients\n  corTab <- NULL\n  for (j in rownames(cna_subset)) {\n    \n    # 相应的CNA数据\n    # Corresponding CNA data\n    tmp1 <- as.numeric(cna_subset[j,]) \n    \n    # 相应的表达数据\n    # Corresponding expression data\n    tmp2 <- as.numeric(expr_subset[j,]) \n    \n    # Spearman相关性\n    # Spearman correlation\n    cor.res <- cor.test(tmp1,tmp2, method = \"spearman\") \n    \n    # 将结果存入临时表（处理可能的NA值）\n    # Store results in temp table (handling potential NAs)\n    corTab <- rbind.data.frame(corTab,\n                               data.frame(gene = j,\n                                          tumor = i,\n                                          Correlation = ifelse(is.na(cor.res$estimate), 0, cor.res$estimate),\n                                          Pvalue = ifelse(is.na(cor.res$p.value), 1, cor.res$p.value),\n                                          stringsAsFactors = F),\n                               stringsAsFactors = F)\n  }\n  \n  # 将当前癌种结果合并到总表\n  # Merge current cancer results to master table\n  corCnaExpr <- rbind.data.frame(corCnaExpr,\n                                 corTab,\n                                 stringsAsFactors = F)\n}\n# 保存相关性分析结果（包含所有癌种）\n# Save correlation results (all cancer types)\nwrite.table(corCnaExpr, \"TCGA_pancan_correlation_cnv_expr_subset.txt\",sep = \"\\t\",row.names = F,col.names = T,quote = F)\n开始画图\nPlotting\n画泡泡图\nBubble Plot\n# 设置颜色\n# Set colors\nblue <- \"#4577FF\"\nred <- \"#C2151A\"\norange <- \"#E45737\"\n\n# 设置基因显示顺序\n# Set gene display order\ncorCnaExpr$gene <- factor(corCnaExpr$gene,\n                          levels = rev(c(\"CDKN1A\",\"HSPA5\",\"TTC35\",\"SLC7A11\",\"NFE2L2\",\"MT1G\",\"HSPB1\",\"GPX4\",\"FANCD2\",\"CISD1\",\n                                         \"FDFT1\",\"SLC1A5\",\"SAT1\",\"TFRC\",\"RPL8\",\"NCOA4\",\"LPCAT3\",\"GLS2\",\"DPP4\",\"CS\",\"CARS\",\"ATP5G3\",\"ALOX15\",\"ACSL4\")))\n\n# 创建渐变颜色板\n# Create color gradient\nmy_palette <- colorRampPalette(c(blue,\"white\",orange), alpha=TRUE)(n=128)\n\n# 相关性热图绘制\n# Correlation Heatmap Visualization\nggplot(corCnaExpr, aes(x=tumor,y=gene)) +\n  geom_point(aes(size=-log10(Pvalue), color=Correlation)) +\n  scale_color_gradientn('Correlation', \n                        colors=my_palette) + \n  scale_size_continuous(range = c(1,12)) + \n\n  theme_bw() +\n  theme(#panel.grid.minor = element_blank(), \n        #panel.grid.major = element_blank(),\n        axis.text.x = element_text(angle = 45, size = 12, hjust = 0.3, vjust = 0.5, color = \"black\"),\n        axis.text.y = element_text(size = 12, color = rep(c(red,blue),c(14,10))),\n        axis.title = element_blank(),\n        panel.border = element_rect(size = 0.7, linetype = \"solid\", colour = \"black\"),\n        legend.position = \"bottom\",\n        plot.margin = unit(c(1,1,1,1), \"lines\"))\n# 保存为出版级PDF\n# Save as publication-quality PDF\nggsave(\"Figure 1C correlation between cna and expression of interested genes in pancancer.pdf\", width = 8,height = 8)\n\n# 清理拷贝数数据对象\n# Clean up CNA data object\nrm(cna); gc()\n例文图中大多数为正相关，与我们这里获得的结果有出入，欢迎小伙伴讨论。\nThe example plot shows mostly positive correlations, which differs\nfrom the results we obtained here. Fellow researchers are welcome to\njoin the discussion.\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa268panCNVexpr_FigureYa268panCNVexpr",
      "title": "FigureYa268panCNVexpr/FigureYa268panCNVexpr.html",
      "html": "FigureYa268panCNVexpr/FigureYa268panCNVexpr.html",
      "text": "texts/main_FigureYa268panCNVexpr_FigureYa268panCNVexpr.txt",
      "folder": "FigureYa268panCNVexpr",
      "thumb": "gallery_compress/FigureYa268panCNVexpr.webp"
    },
    "word_count": 1351,
    "lines_count": 362,
    "title": "FigureYa268panCNVexpr",
    "description": "Demand description 想实现这篇铁死亡泛癌的其他图片，主要是Figure 1。感觉这个套路只要换一个通路就可以测试，我看Xiaofan",
    "input_data_types": [
      "临床数据",
      "表达矩阵",
      "RNA-seq"
    ],
    "output_types": [
      "火山图",
      "热图",
      "统计表格",
      "箱线图",
      "散点图"
    ],
    "technical_methods": [
      "通路分析",
      "质量控制",
      "差异表达分析"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "gene",
      "colour",
      "header",
      "width",
      "n",
      "pvalue",
      "vjust",
      "major",
      "method"
    ]
  },
  {
    "id": "main_FigureYa89ggplotCirco_FigureYa89ggplotCirco",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa89ggplotCirco_FigureYa89ggplotCirco.txt",
    "content": "FigureYa89ggplotCircos\nFigureYa89ggplotCircos\nAuthor(s)\n: Yuhui Li, Taojun Ye\nReviewer(s)\n: Ying Ge\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n用R画出paper里的这种圆圈图。\nRequirement description\nDraw the circle diagram in the paper using R.\n出自\nhttps://genomebiology.biomedcentral.com/articles/10.1186/s13059-016-0990-4\nfrom\nhttps://genomebiology.biomedcentral.com/articles/10.1186/s13059-016-0990-4\nFig. 2 Candidates’ selection and characterization. a. Circos plot\nshows\n58 upregulated RNA-binding proteins (RBPs)\nin\nglioblastoma (GBM) samples from The Cancer Genome Atlas (TCGA) and\nglioma stem cell (GSC) lines.\nFold-changes and corrected\np-values\nwere extracted from the RNA-Seq analysis (GBM TCGA).\nTwenty-one RBPs were also associated with survival reduction and were\nfurther investigated.\n应用场景\n圆圈图上用热图、柱形图、热图展示多组数据、pvalue和log2FC，可灵活换成其他特征值。\nApplication scenarios\nUse heatmaps, bar charts, and heatmaps on the circle chart to display\nmultiple sets of data, p-values, and log2FC, which can be flexibly\nreplaced with other feature values.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\n# 加载数据处理和可视化所需的包\n# Load packages required for data processing and visualization\nlibrary(readxl)      # 用于读取Excel文件 / For reading Excel files\nlibrary(magrittr)    # 提供管道操作符 %>% / Provides pipe operator %>%\nlibrary(dplyr)       # 数据处理工具集 / Data manipulation toolkit\nlibrary(tibble)      # 增强型数据框 / Enhanced data frames\nlibrary(ggplot2)     # 用于数据可视化 / For data visualization\n\n# 设置环境选项\n# Set environment options\nSys.setenv(LANGUAGE = \"en\")  # 设置英文错误信息，便于查找解决方案 / Set English error messages for easier troubleshooting\noptions(stringsAsFactors = FALSE)  # 禁止自动将字符串转换为因子类型，避免数据类型意外转换 / Prevent automatic conversion of strings to factors\n输入数据的整理\n如果你的数据已经整理成easy_input.csv的格式，就可以跳过这步，直接进入“开始画图”。\n从文献中看，需要读取\nTableS2.TCGA_GBM_DiffExpRBPs\n和\nTableS3.GSCs_DiffExpRBPs\n两个sheet。\n另外，图中基因是按照Survival Reduction排列的，根据图反推survival\nReduction，保存在survival.csv文件里。\nOrganizing input data\nIf your data has already been organized into easy_input.csv format,\nyou can skip this step and directly enter “Start Drawing”.\nAccording to the literature, it is necessary to read two sheets,\n‘TableS2. TCGA-GBM-DiffExpRBPs’ and’ TableS3. GSCs_DiffExpRBPs’.\nIn addition, the genes in the figure are arranged according to the\nSurvival Reduction. Based on the figure, the Survival Reduction is\ndeduced and saved in the Survival.csv file.\n#先按基因名降序排列基因名\n# Sort genes by name in descending order\nsurInfo <- arrange(surInfo, desc(Gene))\n#合并后按survival降序排列\n# Merge datasets and sort by survival in descending order\ndata_bind <- left_join(surInfo, sheet_bind, by = \"Gene\") %>% arrange(desc(survival)) \nhead(data_bind)  # 查看合并结果 / View merged data\n# 导出分析结果为CSV文件\n# Export analysis results to CSV\nwrite.csv(data_bind, \"easy_input.csv\", quote = F, row.names = F)\n输入文件\n至少包含基因、log2FC、P_value，给出一列或多列的01用于画最外面的圈。\n此处把GBM、GSC、survival画到最外面的三个圈上，有就是1（最后显示为黑色），无就是0（最后显示为浅灰色）。\n用柱形图展示log2FC，用热图展示P value。\nInput file\nAt least including genes log2FC、P_value， Give one or more columns\nof 01 to draw the outermost circle.\nDraw GBM, GSC, and Survival on the outermost three circles here,\nwhere ‘1’ represents’ 1 ‘(displayed in black) and’ 0 ‘represents’ 0’\n(displayed in light gray).\nDisplay log2FC using a bar chart and P value using a heatmap.\n# 读取之前导出的CSV文件，指定各列数据类型\n# Read the previously exported CSV file, specifying data types for each column\ndata_bind <- read.csv(\"easy_input.csv\", \n                      colClasses=c('character',  # Gene列作为字符型 / Gene column as character\n                                  'numeric',   # survival列作为数值型 / survival column as numeric\n                                  'numeric',   # GBM_log2FC列作为数值型 / GBM_log2FC column as numeric\n                                  'numeric',   # GBM_P_value列作为数值型 / GBM_P_value column as numeric\n                                  'numeric',   # GSC列作为数值型 / GSC column as numeric\n                                  'numeric'))  # GBM列作为数值型 / GBM column as numeric\n\n# 查看数据的基本结构和前几行\n# View the basic structure and first few rows of the data\nhead(data_bind)\n开始画图\n首先画外面的3个环\n环形文字的写法：\nhttps://www.r-graph-gallery.com/296-add-labels-to-circular-barplot/\nStart drawing\nFirst, draw the three outer rings\nThe writing style of circular text:<\nhttps://www.r-graph-gallery.com/296-add-labels-to-circular-barplot/\n>\n# 三个环的坐标设置：稍高于log2FC的最大值，确保数据点不重叠\n# Coordinates for the three outer rings: Slightly higher than the maximum log2FC value to avoid overlap\nh <- max(data_bind$log2FC) + 0.2\n\n# 创建环形图坐标数据框\n# Create coordinate dataframe for circular plot\ntile_coord <- data.frame(\n  Gene = data_bind$Gene, \n  x = 1:nrow(data_bind),          # x是中间x坐标 / Middle x-coordinate for each gene\n  y1 = h, y2 = h + 2, y3 = h + 4, # 最外围三个圈的y坐标 / y-coordinates for the three outer rings\n  stringsAsFactors = FALSE\n)\n\n# 设置基因名称显示参数\n# Set parameters for gene name display\nAngle_space <- 8    # 设置角度空隙大小 / Angular spacing between genes\nAngle_just <- 90    # 角度偏移量 / Angular offset for text alignment\n\n# 计算每个基因的角度位置\n# Calculate angular positions for each gene\nunit_angle <- 360 / (nrow(tile_coord) + Angle_space + 0.5)  # 单位角度 / Angular unit per gene\ntext_angle <- Angle_just - cumsum(rep(unit_angle, nrow(tile_coord)))  # 文本角度 / Text rotation angle\n\n# 根据角度调整文本对齐方式，避免文字倒置\n# Adjust text alignment to prevent upside-down labels\ntile_coord$hjust <- ifelse(text_angle < -90, 1, 0)  # 水平对齐方式 / Horizontal alignment\ntile_coord$text_angle <- ifelse(text_angle < -90, text_angle + 180, text_angle)  # 修正极端角度 / Correct extreme angles\n\n# 合并坐标数据与原始数据\n# Merge coordinate data with original dataset\ndata_result <- left_join(data_bind, tile_coord, by = \"Gene\")\nhead(data_result)\n# 使用ggplot2创建环形图\n# Create circular plot using ggplot2\np1 <- ggplot(data_result) + \n  # 第一圈：生存状态(Survival)\n  # First ring: Survival status\n  geom_tile(data = filter(data_result, survival == 1),\n            aes(x = x, y = y1, width = 1, height = 2), \n            fill = \"grey20\", color = \"lightgrey\", size = .3) +  # 生存组 / Survival group\n  geom_tile(data = filter(data_result, survival == 0),\n            aes(x = x, y = y1, width = 1, height = 2),\n            fill = \"grey96\", color = \"lightgrey\", size = .3) +  # 非生存组 / Non-survival group\n  \n  # 第二圈：GSC状态\n  # Second ring: GSC status\n  geom_tile(data = filter(data_result, GSC == 1),\n            aes(x = x, y = y2, width = 1, height = 2), \n            fill = \"grey20\", color = \"lightgrey\", size = .3) +  # GSC阳性 / GSC positive\n  # 如果有0值，取消下面三行注释\n  # Uncomment below if there are GSC negative values\n  # geom_tile(data = filter(data_result, GSC == 0),\n  #          aes(x = x, y = y2, width = 1, height = 2),\n  #          fill = \"grey96\", color = \"lightgrey\", size = .3) + \n  \n  # 第三圈：GBM状态\n  # Third ring: GBM status\n  geom_tile(data = filter(data_result, GBM == 1),\n            aes(x = x, y = y3, width = 1, height = 2), \n            fill = \"grey20\", color = \"lightgrey\", size = .3) +  # GBM阳性 / GBM positive\n  # 如果有0值，取消下面三行注释\n  # Uncomment below if there are GBM negative values\n  # geom_tile(data = filter(data_result, GBM == 0),\n  #          aes(x = x, y = y3, width = 1, height = 2),\n  #          fill = \"grey96\", color = \"lightgrey\", size = .3) + \n  # 如果需要更多圈，可以继续添加\n  \n  # 添加基因名称标签：survival为1的基因名为黑色，否则为浅灰色\n  # Add gene names: Black for survival=1, grey for survival=0\n  geom_text(data = filter(data_result, survival == 1),\n            aes(x = x, y = y3 + 1.6, label = Gene,\n                angle = text_angle, hjust = hjust), color = \"black\", size = 2) + \n  geom_text(data = filter(data_result, survival == 0),\n            aes(x = x, y = y3 + 1.6, label = Gene,\n                angle = text_angle, hjust = hjust), color = \"grey43\", size = 2) + \n  \n  # 转换为极坐标系统\n  # Convert to polar coordinates\n  coord_polar(theta = \"x\", start = 0, direction = 1) + \n  ylim(-5,13) +  # 设置y轴范围 / Set y-axis limits\n  xlim(0, nrow(data_bind) + Angle_space) +  # 设置x轴范围 / Set x-axis limits\n  theme_void()  # 使用空白主题 / Apply minimal theme\np1  # 显示图形 / Display plot\n画\nlog2FC\nlog2FC的y坐标从1开始，因此画图时要“y = log2FC - 1”\nDraw ‘log2FC’`\nThe y-coordinate of log2FC starts from 1, so when drawing, it should\nbe “y=log2FC -1”\n# 在原有图形(p1)基础上叠加柱状图层，展示log2FC数据\n# Add bar chart layer to the original plot (p1) to show log2FC values\np2 <- p1 + \n  geom_col(\n    aes(x = x, y = log2FC - 1),  \n    fill = \"grey85\",             \n    color = \"grey80\"             \n  )\n\np2\n添加log2FC的坐标轴及刻度文字\nAdd coordinate axis and scale text for log2FC\n# 在原有图形(p2)基础上添加坐标轴标记和参考线\n# Add axis markers and reference lines to the existing plot (p2)\np3 <- p2 + \n  # 添加垂直参考线（从原点到y=3）\n  # Add vertical reference line from origin to y=3\n  geom_segment(\n    x = 0, y = 0, xend = 0, yend = 3,  \n    color = \"black\", size = .3         \n  ) + \n  \n  # 添加y轴刻度标签（1-4）\n  # Add y-axis tick labels (1-4)\n  geom_text(x = -.5, y = 0, label = \"1_\", vjust = -.3, size = 1, color = \"black\") +  \n  geom_text(x = -.5, y = 1, label = \"2_\", vjust = -.3, size = 1, color = \"black\") +  \n  geom_text(x = -.5, y = 2, label = \"3_\", vjust = -.3, size = 1, color = \"black\") +  \n  geom_text(x = -.5, y = 3, label = \"4_\", vjust = -.3, size = 1, color = \"black\")    \n\np3\n画\nP_value\n热图\nDraw a ‘P_value’ heatmap\n# 在原有图形(p3)基础上添加P值热图层\n# Add P-value heatmap layer to the existing plot (p3)\np4 <- p3 + \n  # 添加P值热图：位于y=-1.2位置，每个基因对应一个矩形\n  # Add P-value heatmap: Positioned at y=-1.2, each gene is represented by a rectangle\n  geom_tile(\n    aes(x = x, y = -1.2, width = 1, height = 2, fill = P_value),  \n    color = \"white\" \n  ) + \n  \n  # 设置填充颜色渐变：P值越小颜色越深（firebrick3），越大颜色越浅（yellow）\n  # Set color gradient: Smaller P-values are darker (firebrick3), larger values are lighter (yellow)\n  scale_fill_gradient(\n    low = \"firebrick3\",  \n    high = \"yellow\"      \n  ) \n\np4\n插入文本\nInsert Text\n# 在原有图形(p4)基础上添加各数据层的文本标签\n# Add text labels for each data layer to the existing plot (p4)\n\n# First, ensure 'h' is properly defined (this should be defined earlier in your code)\n# If not, you'll need to calculate or define an appropriate value for h\n# h <- [appropriate value based on your data]\n\np5 <- p4 + \n  # 添加GBM TCGA层标签\n  # Label for GBM TCGA layer\n  geom_text(aes(x = -2.1, y = h + 4.5, label = \"GBM TCGA\"), \n            size = 3, color = \"black\", inherit.aes = FALSE) + \n  \n  # 添加GSCs层标签\n  # Label for GSCs layer\n  geom_text(aes(x = -1.1, y = h + 2.5, label = \"GSCs\"), \n            size = 3, color = \"black\", inherit.aes = FALSE) + \n  \n  # 添加Survival Reduction层标签（支持换行）\n  # Label for Survival Reduction layer (with line break)\n  geom_text(aes(x = -1.8, y = h + 0.5, label = \"Survival\\nReduction\"), \n            size = 2.5, color = \"black\", inherit.aes = FALSE) + \n  \n  # 添加Log2FC坐标轴标签（旋转90度）\n  # Label for Log2FC axis (rotated 90 degrees)\n  geom_text(aes(x = -2.1, y = h - 2.4, label = \"Log[2]~FC\"), \n            angle = 90, size = 2.2, color = \"black\", parse = TRUE, inherit.aes = FALSE) + \n  \n  # 添加p-value热图层标签（旋转90度）\n  # Label for p-value heatmap (rotated 90 degrees)\n  geom_text(aes(x = -3.3, y = h - 5, label = \"p-value\"), \n            angle = 90, size = 1.5, color = \"black\", inherit.aes = FALSE) + \n  \n  # 添加中心标题（支持换行）\n  # Add center title (with line break)\n  geom_text(aes(x = 0, y = -5, label = \"Upregulated\\nRBPs\"), \n            size = 2.5, color = \"black\", inherit.aes = FALSE)\n\np5\n画P value的图例\n将图例调整到panel内部，并且调节文本的相对大小和相对位置。\nDraw a legend for P value\nAdjust the legend inside the panel and adjust the relative size and\nposition of the text.\n# 在原有图形(p5)基础上添加p值参考刻度和图例\n# Add p-value reference scale and legend to the existing plot (p5)\np6 <- p5 +\n  # 添加p值=0的参考标记\n  # Add reference mark for p-value=0\n  geom_text(x = -.5, y = -0.2, label = 0, size = 1, color = \"black\") + \n  \n  # 添加p值=0.05的参考标记（对应热图中黄色区域）\n  # Add reference mark for p-value=0.05 (corresponding to yellow area in heatmap)\n  geom_text(x = -1.8, y = -2, label = 0.05, size = 1, color = \"black\") + \n  \n  # 自定义颜色渐变图例\n  # Customize color gradient legend\n  guides(fill = guide_colorbar(\n    title = \"\",                \n    reverse = TRUE,            \n    label = FALSE,             \n    barwidth = 0.1,            \n    barheight = 1.1            \n  )) + \n  \n  # 设置图例位置和样式\n  # Set legend position and style\n  theme(\n    legend.position = c(0.5, 0.585),  \n    legend.title = element_blank()    \n  )\n\np6  # 显示最终图形\n# 保存图形为PDF文件\n# Save the plot as a PDF file\nggsave(\"ggplotCircos.pdf\")\n后期加工\n前面的代码通过x和y的值一点一点调整好文字和图例的位置。\n更容易的做法是：用矢量图编辑软件打开pdf文件，用鼠标调整。\nPost processing\nThe previous code adjusted the position of the text and legend bit by\nbit based on the values of x and y.\nAn easier approach is to open the PDF file with vector graphics\nediting software and adjust it with the mouse.\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa89ggplotCirco_FigureYa89ggplotCirco",
      "title": "FigureYa89ggplotCirco/FigureYa89ggplotCirco.html",
      "html": "FigureYa89ggplotCirco/FigureYa89ggplotCirco.html",
      "text": "texts/main_FigureYa89ggplotCirco_FigureYa89ggplotCirco.txt",
      "folder": "FigureYa89ggplotCirco",
      "thumb": "gallery_compress/FigureYa89ggplotCirco.webp"
    },
    "word_count": 1855,
    "lines_count": 344,
    "title": "FigureYa89ggplotCircos",
    "description": "用R画出paper里的这种圆圈图。 Requirement description Draw the circle diagram in the paper using R.",
    "input_data_types": [
      "生存数据"
    ],
    "output_types": [
      "热图",
      "统计表格",
      "生存曲线"
    ],
    "technical_methods": [],
    "biology_areas": [
      "癌症研究",
      "发育生物学"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "colClasses",
      "width",
      "xend",
      "pvalue",
      "direction",
      "y1",
      "angle",
      "从原点到y"
    ]
  },
  {
    "id": "main_FigureYa139TMB_titv_FigureYa139TMB_titv",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa139TMB_titv_FigureYa139TMB_titv.txt",
    "content": "FigureYa139TMB_titv\nFigureYa139TMB_titv\nAuthor(s)\n: Rongfang Shen\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n输入TCGA突变的数据，重复出如下图。 Input TCGA mutation data and\nrepeat the following figure.\n出自\nhttps://www.nature.com/articles/ng.2868\nFrom\nhttps://www.nature.com/articles/ng.2868\nFigure 1 Plot of the number of nonsynonymous mutations per megabase\nin craniopharyngiomas (n = 15) in comparison to a broad range of\npediatric and adult tumors n = 3,083). Data for all other tumor types,\nas well as the figure design, were taken from Lawrence et al.14. Each\ndot in this plot corresponds to a\nmatched tumor-normal\npair\n. The vertical position indicates the\nfrequency of\nsomatic mutations\nin that exome. Tumor types are ordered on the\nbasis of their median nonsynonymous frequency, and within each tumor\ntype, tumor-normal pairs are ordered from lowest to highest frequency.\nThe relative proportions of\nsix different possible base-pair\nsubstitutions\nare indicated at the bottom. Craniopharyngioma\ndata are derived from whole-exome sequencing of 15 tumor-normal pairs,\nincluding 12 adamantinomatous and 3 papillary craniopharyngioma, and are\nmarked in red.\nIn consonance with the benign histology of these tumors, we\nidentified only a relatively small number of nonsynonymous somatic\nmutations in both craniopharyngioma subtypes when compared to large\ncohorts of other tumor types14 (Fig. 1). The\nnonsynonymous\nmutation rate\nof 0.9 per Mb in the craniopharyngioma samples\nwas similar to that found in a number of pediatric tumors, as well as\nthat in low-grade tumors in adults, for example, World Health\nOrganization– classified grade I meningioma15 (Fig. 1). 58% of the\nmutations were\ncytosine to thymidine at CpG\ndinucleotides\n, which is consistent with spontaneous deamination\nand not a carcinogen-induced process (Fig. 1)14. As we anticipated, the\nallelic fraction for many of the mutations was very low (median, 3%;\nrange, 0.96–48%).\n图的解读\nInterpretation of the\ngraph\n把颅咽管瘤跟其他癌症一同展示，便于做对比。图分上下两部分： Display\ncraniopharyngioma with other cancers for easy comparison. The graph is\ndivided into two parts:\n上半部分散点图： Upper part scatter plot:\n散点图中每个点对应1个matched tumor-normal pair\n纵坐标为突变频率\n横坐标的各种肿瘤按nonsynonymous\nfrequency的中值排列，每个肿瘤内部按突变频率排序\nEach point in the scatter plot corresponds to a matched tumor-normal\npair\nThe vertical axis is the mutation frequency\nThe various tumors on the horizontal axis are arranged according to\nthe median of nonsynonymous frequency, and each tumor is sorted by\nmutation frequency\n底部为每个matched tumor-normal pair中6种碱基突变方式所占的比例 The\nbottom is the proportion of the six base mutations in each matched\ntumor-normal pair\n应用场景\nApplication scenario\n同时展示TCGA泛癌样本TMB情况以及6种碱基转换和颠换情况(T>G, T>A,\nT>C, C>G, C>T, C>A\n)。像例文一样用于直观展示感兴趣癌种与TCGA其他癌种的整体TMB情况。 Show\nthe TMB of TCGA pan-cancer samples and the six base conversions and\ntransversions (T>G, T>A, T>C, C>G, C>T, C>A) at the\nsame time. Like the example text, it is used to intuitively display the\noverall TMB of the cancer of interest and other TCGA cancers.\n还可以自定义分组，例如对比同一疾病不同亚型。 You can also customize\nthe grouping, such as comparing different subtypes of the same\ndisease.\n环境设置\nEnvironment settings\nBiocManager::install(\"maftools\")\nsource(\"install_dependencies.R\")\nlibrary(TCGAbiolinks)\nlibrary(maftools)\nlibrary(ggplot2)\nlibrary(tidyverse)\nlibrary(ggsci)\n\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 #Display English error message\noptions(stringsAsFactors = FALSE) #禁止chr转成factor #Disable conversion of chr to factor\n输入数据的下载\nDownload input data\n下载TCGA全部癌种的maf文件。 Download the maf files of all TCGA cancer\ntypes.\n这里我们用TCGAbiolinks下载maf文件。（也可以用R包TCGAmutations，这个包里面已经下载并且处理成maf的格式了，但是版本不是最新的。）\nHere we use TCGAbiolinks to download the maf files. (You can also use\nthe R package TCGAmutations, which has been downloaded and processed\ninto maf format, but the version is not the latest.)\ntumors <- TCGAbiolinks::getGDCprojects()$project_id %>% .[grep(\"TCGA\", .)] %>% str_sub(., 6)\n# pipeline 可以选择muse, varscan2, somaticsniper, mutect2 在这里选用mutect2\n# pipeline can choose muse, varscan2, somaticsniper, mutect2. Here, mutect2 is selected\nmaflist <- tumors %>% lapply(., GDCquery_Maf, save.csv = FALSE, directory = \"GDCdata\", pipelines = \"mutect2\") %>% lapply(., read.maf)\nnames(maflist) <- tumors\n# 保存数据，以后可以反复使用\n# Save the data for repeated use later\nsave(maflist, file = \"maflist.RData\")\nTMB.dat <- lapply(maflist, getSampleSummary)\ntitv.dat <- lapply(maflist, function(x)titv(maf = x, plot = FALSE, useSyn = FALSE#不添加同义突变 #Do not add synonymous mutations\n                                            )) %>% lapply(., function(x)x$fraction.contribution)\nsave(TMB.dat, titv.dat, file = \"TMB_titv.RData\")\n准备突变频率输入数据\nPrepare mutation frequency input data\n先准备上半部分散点图的数据（TMB.dat），底部图（titv.dat）中样本顺序按照散点图的TMB大小排列。\nFirst prepare the data of the scatter plot in the upper part (TMB.dat),\nand the order of samples in the bottom figure (titv.dat) is arranged\naccording to the TMB size of the scatter plot.\n# 原文TMB是算的nonsynonymous mutations per megabase\n# The original TMB counts nonsynonymous mutations per megabase\n#silent mutation突变包括：3'Flank，3'UTR，5'Flank，5'UTR，IGR，Intron，RNA，Silent，Splice_Region\n#Silent mutations include: 3'Flank, 3'UTR, 5'Flank, 5'UTR, IGR, Intron, RNA, Silent, Splice_Region\n# 定义6种突变的颜色\n# Define 6 mutation colors\ncol <- pal_npg(\"nrc\", alpha=0.7)(6) #用色板  # Use color palette\n# 或者像这样自己定义颜色\n# Or define colors yourself like this\n# col <- c(\"yellow\", \"blue\", \"orange\", \"red\", \"lightblue\", \"darkblue\")\nnames(col) <- c(\"C>T\", \"T>C\", \"C>A\", \"C>G\", \"T>A\", \"T>G\")\ncol\n(load(\"TMB_titv.RData\")) # 载入保存好的数据 # Load saved data\n#str(TMB.dat)\nTMB.dat <- TMB.dat %>% lapply(., as.data.frame) %>% \n  lapply(., function(x)x[, c(\"Tumor_Sample_Barcode\", \"total\")]) %>% plyr::ldply(., data.frame)\ncolnames(TMB.dat)[1] <- \"cohort\"; colnames(TMB.dat)[3] <- \"TMB\"\nhead(TMB.dat); str(TMB.dat)\n题外话\nOff-topic\nTMB.dat里面存储的是所有癌症的突变频率，其中第一列是癌症名称，第二列是sample\nID，第三列是突变频率。 TMB.dat stores the mutation frequency of all\ncancers, where the first column is the cancer name, the second column is\nthe sample ID, and the third column is the mutation frequency.\n如果你对pancancer不感兴趣，只想在某1种癌症不同分子亚型之间做对比，就把第一列换成分子亚型的名字。\nIf you are not interested in pancancer and only want to compare\ndifferent molecular subtypes of a certain cancer, replace the first\ncolumn with the name of the molecular subtype.\n可以这样导出数据格式，替换成自己的数据，然后导入： You can export the\ndata format like this, replace it with your own data, and then import\nit:\n# 保存到文件\n# Save to file\nwrite.csv(TMB.dat, \"easy_input.csv\", row.names = F)\n# 把第一列改为自己想要的分组后，读入文件\n# After changing the first column to the group you want, read the file\nTMB.dat <- read.csv(\"easy_input.csv\", check.names = F)\nhead(TMB.dat)\n继续 Continue\nTMB.dat$TMB <- TMB.dat$TMB/35 # 计算TMB # Calculate TMB\ntcga.cohort.med <- TMB.dat %>% group_by(cohort) %>% summarize(median = median(TMB)) %>%\n  as.data.frame() %>% .[order(.$median, decreasing = F), ]\nTMB.dat$cohort <- factor(x = TMB.dat$cohort, levels = tcga.cohort.med$cohort)\nTMB.dat <- TMB.dat[order(TMB.dat$cohort, TMB.dat$TMB, decreasing = F), ]\n\n# sample order in bottom panel\nsampleorder <- TMB.dat %>% split(.$cohort) %>% lapply(\"[[\", 2) %>% lapply(., as.character)\nTMB.plot <- split(TMB.dat, as.factor(TMB.dat$cohort))\nTMB.plot <- lapply(seq_len(length(TMB.plot)), function(i) {\n    x = TMB.plot[[i]]\n    x = data.frame(x = seq(i - 1, i, length.out = nrow(x)), \n                   TMB = x[, \"TMB\"], cohort = x[, \"cohort\"])\n    return(x)\n  })\nnames(TMB.plot) <- levels(as.factor(TMB.dat$cohort))\n准备titv输入数据\nPrepare titv input data\n#str(titv.dat)\ntitv.dat2 <- lapply(tcga.cohort.med$cohort, function(x){\n  tmp <- titv.dat[[x]]\n  tmp <- tmp[match(sampleorder[[x]], tmp$Tumor_Sample_Barcode), ]\n  return(tmp)\n  if (!all(tmp$Tumor_Sample_Barcode == sampleorder[[x]])){\n    stop(\"Inconsistent sample order\")\n  }\n}) \n\nnames(titv.dat2) <- tcga.cohort.med$cohort\ntitv.dat2 <- lapply(titv.dat2, function(x){\n  x <- as.data.frame(x)\n  rownames(x) <- x$Tumor_Sample_Barcode\n  x <- x[, -1]\n  x <- t(x)\n  #delete samples without mutation\n  if (length(which(colSums(x) == 0)) > 0) {\n      x = x[, -which(colSums(x) == 0), drop = FALSE]\n    }\n  return(x)\n})\n#str(titv.dat2)\nall(names(TMB.plot) == names(titv.dat2))\ntcga.cohort.med$Median_Mutations_log10 <- log10(tcga.cohort.med$median + 1)\n开始画图\nStart drawing\n用base plot一笔一笔画图 Use base plot to draw one stroke at a\ntime\n#base layout\nn1 <- seq(from = 0.105, to = 0.915, length.out = 33)\nn2 <- c(n1[2:length(n1)], n1[33] + n1[33] - n1[32])\nn <- data.frame(n1 = n1, n2 = n2, n3 = 0.05,\n                 n4 = 0.2) %>% rbind(c(0.05, 0.97, 0.25, 1), ., c(0, 0.1, 0.05, 0.25)) \nn <- as.matrix(n) #分为33 + 2个screen # Divided into 33 + 2 screens\nopar <- par(no.readonly = T)\n\npdf(\"TMB_titv.pdf\", width = 9, height = 5)\nsplit.screen(n, erase = T)\nscreen(1, new = T)\npar(xpd = T, mar = c(4, 1, 2, 0), oma = c(0, 0, 0, 0),\n    bty = \"n\", mgp = c(3, 1, 0)) #xpd = T,让超出画图范围的字也能显示出来 #xpd = T, so that words beyond the drawing range can also be displayed\ny_lims = range(log10(unlist(lapply(TMB.plot, function(x) max(x[, \"TMB\"], na.rm = TRUE))) + 1))\ny_lims[1] = 0\ny_lims[2] = ceiling(max(y_lims))\ny_at = c(0, 1, 2, 3)\n# 画散点图\n# Draw a scatter plot\nplot(NA, NA, xlim = c(0, length(TMB.plot)), ylim = y_lims, \n     xlab = NA, ylab = NA, xaxt=\"n\", yaxt = \"n\", xaxs = \"r\")\nlapply(seq_len(length(TMB.plot)), function(i){\n  tmp = TMB.plot[[i]]\n  points(tmp$x, log10(tmp$TMB+1), pch = 16, cex = 0.4, col = \"black\")\n})\n# 画坐标轴\n# Draw coordinate axes\naxis(side = 1, at = seq(0.5, length(TMB.plot) - 0.5, 1), labels = names(TMB.plot), \n     las = 2, tick = T, line = 0)\naxis(side = 2, at = y_at, las = 2, line = -1.25, tick = T, labels = c(0, 1, 2, 3))\n# 写y轴label\n# Write y-axis label\nmtext(text = \"log10(TMB+1)\", side = 2, \n      line = 1.75, cex = 1.1)\nlapply(seq_len(nrow(tcga.cohort.med)), function(i) {\n  segments(x0 = i - 1, x1 = i, \n           y0 = tcga.cohort.med[i, \"Median_Mutations_log10\"], \n           y1 = tcga.cohort.med[i, \"Median_Mutations_log10\"],     \n           col = \"grey\")})\n# 画底部6种突变比例\n# Draw the 6 mutation ratios at the bottom\nlapply(seq_len(length(titv.dat2)), function(i){\n  screen(i+1, new = T)\n  par(xpd = T, mar = c(0, 0, 0, 0), oma = c(0, 0, 0, 0),\n    bty = \"o\")#xpd = T，让超出画图范围的字也能显示出来 #xpd = T, so that words beyond the drawing range can also be displayed\n  tmp <- titv.dat2[[i]]\n  barplot(tmp, col = col[rownames(tmp)], names.arg = rep(\"\", ncol(tmp)),\n          axes = FALSE, space = 0, border = NA, lwd = 1.2)\n  box()\n})\nscreen(35, new = T)\npar(xpd = T, mar = c(0, 0, 0, 0), oma = c(0, 0, 0, 0),\n    bty = \"n\")\nplot(NA, NA, xlim = c(0, 1), ylim = c(0, 1), \n     axes = FALSE, xlab = NA, ylab = NA)\n# 画图例\n# Draw legend\nlegend(\"center\", \n  fill = col,\n  legend = names(col),\n  bty = \"n\",\n  cex=0.7)\nclose.screen(all = TRUE)\ndev.off()\npar(opar)\n把每个癌种的数目标在图的上方\nMark the number of each cancer type on the top of the picture\n上图就很好看了，不过原图最上方还标出了每个癌种的数目，下面复现原图。\nThe above picture looks good, but the original picture also marked the\nnumber of each cancer type at the top. The original picture is\nreproduced below.\nopar <- par(no.readonly = T)\n#######################################\npdf(\"TMB_titv2.pdf\", width = 10, height = 5)\nsplit.screen(n, erase = T)\nscreen(1, new = T)\npar(xpd = T, mar = c(4, 1, 2, 0), oma = c(0, 0, 0, 0),\n    bty = \"o\", mgp = c(3, 1, 0)) #bty= \"o\"让图的方框显示出来 #bty= \"o\" makes the box of the figure appear\ny_lims = range(log10(unlist(lapply(TMB.plot, function(x) max(x[, \"TMB\"], na.rm = TRUE))) + 1))\ny_lims[1] = 0\ny_lims[2] = ceiling(max(y_lims))\ny_at = c(0, 1, 2, 3)\nx_top_label <- as.numeric(unlist(lapply(TMB.plot, nrow)))\nplot(NA, NA, xlim = c(0, length(TMB.plot)), ylim = y_lims, \n     xlab = NA, ylab = NA, xaxt=\"n\", yaxt = \"n\", xaxs = \"r\")\nlapply(seq_len(length(TMB.plot)), function(i){\n  tmp = TMB.plot[[i]]\n  points(tmp$x, log10(tmp$TMB+1), pch = 16, cex = 0.4, col = \"black\")\n})\naxis(side = 1, at = seq(0.5, length(TMB.plot) - 0.5, 1), labels = names(TMB.plot), \n     las = 2, tick = T, line = 0)\naxis(side = 2, at = y_at, las = 2, line = 0, tick = T, labels = c(0, 1, 2, 3))\n\n# 添加每个癌症的matched tumor-normal pair数量\n# Add the number of matched tumor-normal pairs for each cancer\naxis(side = 3, at = seq(0.5, length(TMB.plot) - 0.5, 1), labels = x_top_label,\n     tick = T, line = 0, cex.axis = 0.6)\nmtext(text = \"log10(TMB+1)\", side = 2, \n      line = 1.75, cex = 1.1)\nlapply(seq_len(nrow(tcga.cohort.med)), function(i) {\n  segments(x0 = i - 1, x1 = i, \n           y0 = tcga.cohort.med[i, \"Median_Mutations_log10\"], \n           y1 = tcga.cohort.med[i, \"Median_Mutations_log10\"],     \n           col = \"grey\")})\nlapply(seq_len(length(titv.dat2)), function(i){\n  screen(i+1, new = T)\n  par(xpd = T, mar = c(0, 0, 0, 0), oma = c(0, 0, 0, 0),\n    bty = \"o\") #xpd = T，让超出画图范围的字也能显示出来 #xpd = T, so that words beyond the drawing range can also be displayed\n  tmp <- titv.dat2[[i]]\n  barplot(tmp, col = col[rownames(tmp)], names.arg = rep(\"\", ncol(tmp)),\n          axes = FALSE, space = 0, border = NA, lwd = 1.2)\n  box()\n})\nscreen(35, new = T)\npar(xpd = T, mar = c(0, 0, 0, 0), oma = c(0, 0, 0, 0),\n    bty = \"n\")\nplot(NA, NA, xlim = c(0, 1), ylim = c(0, 1), \n     axes = FALSE, xlab = NA, ylab = NA)\nlegend(\"center\", \n  fill = col,\n  legend = names(col),\n  bty = \"n\",\n  cex=0.7)\nclose.screen(all = TRUE)\ndev.off()\npar(opar)\n后期处理\nPost-processing\n后期需要用illustrator微调一下： 1. 把两边纵坐标往里再移动一下 2.\n在top_label第一个再加上”n = ” Illustrator needs to be used for\nfine-tuning in the later stage: 1. Move the vertical coordinates on both\nsides inward 2. Add “n =” to the first top_label\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa139TMB_titv_FigureYa139TMB_titv",
      "title": "FigureYa139TMB_titv/FigureYa139TMB_titv.html",
      "html": "FigureYa139TMB_titv/FigureYa139TMB_titv.html",
      "text": "texts/main_FigureYa139TMB_titv_FigureYa139TMB_titv.txt",
      "folder": "FigureYa139TMB_titv",
      "thumb": "gallery_compress/FigureYa139TMB_titv.webp"
    },
    "word_count": 1965,
    "lines_count": 349,
    "title": "FigureYa139TMB_titv",
    "description": "Requirement description 输入TCGA突变的数据，重复出如下图。 Input TCGA mutation data and repeat the following figure.",
    "input_data_types": [
      "临床数据",
      "突变数据"
    ],
    "output_types": [
      "散点图"
    ],
    "technical_methods": [],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "to",
      "y_at",
      "lwd",
      "width",
      "tick",
      "n4",
      "ylim",
      "n",
      "new"
    ]
  },
  {
    "id": "main_FigureYa265panCNV_FigureYa265panCNV",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa265panCNV_FigureYa265panCNV.txt",
    "content": "FigureYa265panCNV\nFigureYa265panCNV\nAuthor(s)\n: Xiaofan Lu; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-05-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nDemand description\n想实现这篇铁死亡泛癌的其他图片，主要是Figure\n1。感觉这个套路只要换一个通路就可以测试，我看Xiaofan\nLu写了这篇文章的Figure\n2A（铁死亡基因在泛癌肿瘤与正常的差异箱线图，FigureYa208FPI），Figure\n3B（铁死亡与免疫通路的相关性，FigureYa253panGSEA），可否请Xiaofan\nLu详细写一下文章Figure 1的相关代码？\n1A（铁死亡在泛癌中体细胞拷贝数变异情况，绘制条形图）\n1B（铁死亡基因在肿瘤与正常的差异表达，绘制拼接的点图和柱状图，可参考FigureYa263panDiff）\n1C（铁死亡基因体细胞拷贝数与基因表达的相关性点图）\n1D（铁死亡基因肿瘤与正常组织甲基化状态点图）\n1E（铁死亡转录组表达与启动子甲基化相关性的点图）\n这些图都是泛癌的，不知道Xiaofan Lu可不可以用例文数据分别实现个教程\n[皱眉] ？（感觉都可以出一期专栏——iSicence复现了哈哈）\n这次实现Figure 1A，铁死亡在泛癌中体细胞拷贝数变异情况。\nThe other figures from this pan-cancer ferroptosis paper, especially\nFigure 1. It seems like this approach can be easily adapted by switching\nto a different pathway. I noticed that Xiaofan Lu has already written\ncode for:\nFigure 2A (Boxplot of ferroptosis gene expression differences between\ntumor and normal tissues, FigureYa208FPI) Figure 3B (Correlation between\nferroptosis and immune pathways, FigureYa253panGSEA) Could Xiaofan Lu\nplease provide detailed code for Figure 1 as well? Specifically:\n1A (Somatic copy number alterations of ferroptosis genes in\npan-cancer, bar plot)\n1B (Differential expression of ferroptosis genes in tumor vs. normal\ntissues, combined dot + bar plot, similar to FigureYa263panDiff)\n1C (Correlation between somatic copy number and gene expression,\nscatter plot)\n1D (Methylation status of ferroptosis genes in tumor vs. normal\ntissues, dot plot)\n1E (Correlation between transcriptomic expression and promoter\nmethylation, scatter plot)\nAll these figures are pan-cancer analyses. Would Teacher Dayu be\nwilling to create separate crowdsourcing tutorials for each? [pleading\nface] (Feels like this could even become a dedicated column—iScience\nreproduction, haha!)\nFor now, let’s crowdsource Figure 1A: Somatic copy number alterations\nof ferroptosis genes in pan-cancer.\n出自\nhttps://linkinghub.elsevier.com/retrieve/pii/S2589004220304892\n图1.\n铁死亡调控基因（FRGs）的失调情况。其中，正调控因子和负调控因子分别用红色和蓝色标注）。\n(A) 柱状图展示各癌种中每个FRG基因的体细胞拷贝数变异频率。\n接下来会陆续实现Figure1CDE，敬请关注。\nSource:\nhttps://linkinghub.elsevier.com/retrieve/pii/S2589004220304892\nFigure 1. The Dysregulation of Ferroptosis Regulator Genes (FRGs).\nFor which the positive and negative regulators are marked in red and\nblue, respectively. (A) Histogram shows the frequency of somatic copy\nnumber alterations for each FRG in each cancer type.\nFor Figure1CDE will be launched successively. Stay tuned for\nupdates.\n应用场景\nApplication scenarios\n分析铁死亡在泛癌中体细胞拷贝数变异情况并绘制条形图。\nAnalyze somatic copy number variations (SCNAs) related to ferroptosis\nacross pan-cancer and generate bar plots.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(ggplot2)\nlibrary(data.table)\nlibrary(randomcoloR)\n\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n输入文件\nInput Files\n前两个文件跟FigureYa253panGSEA、FigureYa263panDiff使用的是同一套数据，已经下载的小伙伴就不用重复下载了。\nmerged_sample_quality_annotations.tsv，下载自\nhttps://gdc.cancer.gov/about-data/publications/pancanatlas\n，下载地址\nhttp://api.gdc.cancer.gov/data/1a7d7be8-675d-4e60-a105-19d4121bdebf\nEBPlusPlusAdjustPANCAN_IlluminaHiSeq_RNASeqV2.geneExp.tsv，表达矩阵，第一列是基因，之后是其在每个样本中的表达量。下载自\nhttp://api.gdc.cancer.gov/data/3586c0da-64d0-4b74-a449-5ff4d9136611\nTCGA.PANCAN.sampleMap_Gistic2_CopyNumber_Gistic2_all_data_by_genes.gz，CNV数据，下载地址\nhttps://xenabrowser.net/datapages/?dataset=TCGA.PANCAN.sampleMap%2FGistic2_CopyNumber_Gistic2_all_data_by_genes&host=https%3A%2F%2Ftcga.xenahubs.net&removeHub=https%3A%2F%2Fxena.treehouse.gi.ucsc.edu%3A443\nThe first two files use the same dataset as FigureYa253panGSEA and\nFigureYa263panDiff, so those who have already downloaded them do not\nneed to download them again.\nmerged_sample_quality_annotations.tsv: Downloaded from\nhttps://gdc.cancer.gov/about-data/publications/pancanatlas\n,\ndownload link:\nhttp://api.gdc.cancer.gov/data/1a7d7be8-675d-4e60-a105-19d4121bdebf\nEBPlusPlusAdjustPANCAN_IlluminaHiSeq_RNASeqV2.geneExp.tsv: Expression\nmatrix, where the first column contains gene names, followed by their\nexpression levels in each sample. Downloaded from\nhttp://api.gdc.cancer.gov/data/3586c0da-64d0-4b74-a449-5ff4d9136611\nTCGA.PANCAN.sampleMap_Gistic2_CopyNumber_Gistic2_all_data_by_genes.gz:\nCNV data, download link:\nhttps://xenabrowser.net/datapages/?dataset=TCGA.PANCAN.sampleMap%2FGistic2_CopyNumber_Gistic2_all_data_by_genes&host=https%3A%2F%2Ftcga.xenahubs.net&removeHub=https%3A%2F%2Fxena.treehouse.gi.ucsc.edu%3A443\n# 设置颜色\n# Set color palette\nblue <- \"#4577FF\"\nred <- \"#C2151A\"\n\n# 获得同时有肿瘤和正常样本的肿瘤名\n# Get tumor types with both tumor and normal samples\ntumors <- c(\"BLCA\",\"BRCA\",\"CESC\",\"CHOL\",\"COAD\",\n            \"ESCA\",\"GBM\",\"HNSC\",\"KICH\",\"KIRC\",\n            \"KIRP\",\"LIHC\",\"LUAD\",\"LUSC\",\"PAAD\",\n            \"PRAD\",\"READ\",\"STAD\",\"THCA\",\"UCEC\")\n\n# 获得感兴趣的基因集(TTC35是EMC2的同名)\n# Define ferroptosis-related gene set (TTC35 is alias for EMC2)\nfrg <- c(\"CDKN1A\",\"HSPA5\",\"TTC35\",\"SLC7A11\",\"NFE2L2\",\"MT1G\",\"HSPB1\",\"GPX4\",\"FANCD2\",\"CISD1\",\"FDFT1\",\"SLC1A5\",\"SAT1\",\n         \"TFRC\",\"RPL8\",\"NCOA4\",\"LPCAT3\",\"GLS2\",\"DPP4\",\"CS\",\"CARS\",\"ATP5G3\",\"ALOX15\",\"ACSL4\",\"EMC2\")\n\n# 修正TCGA名称\n# 数据来自PanCanAtlas\n# Process TCGA sample annotations\n# Data from PanCanAtlas\nrawAnno <- read.delim(\"merged_sample_quality_annotations.tsv\",sep = \"\\t\",row.names = NULL,check.names = F,stringsAsFactors = F,header = T) \n# 简化样本ID（取前15位TCGA条码）\n# Simplify sample IDs (first 15 characters of TCGA barcode)\nrawAnno$simple_barcode <- substr(rawAnno$aliquot_barcode,1,15)\n\n# 创建精简注释表（去重+关键列）\n# Create concise annotation table (deduplicated + key columns)\nsamAnno <- rawAnno[!duplicated(rawAnno$simple_barcode),c(\"cancer type\", \"simple_barcode\")]\n\n# 过滤无效记录（癌症类型为空）\n# Filter invalid records (empty cancer type)\nsamAnno <- samAnno[which(samAnno$`cancer type` != \"\"),]\n\n# 保存简化版注释文件（供后续分析使用）\n# Save simplified annotation (for downstream analysis)\nwrite.table(samAnno,\"simple_sample_annotation.txt\",sep = \"\\t\",row.names = F,col.names = T,quote = F)\n\n# 加载CNV数据\n# 数据来自XENA TCGA Pan-Cancer (PANCAN)\n# Load CNV data\n# Data from XENA TCGA Pan-Cancer (PANCAN)\ncnv <- fread(\"TCGA.PANCAN.sampleMap_Gistic2_CopyNumber_Gistic2_all_data_by_genes.gz\",sep = \"\\t\",stringsAsFactors = F,header = T,check.names = F) \n\n# 转换为数据框并设置行名\n# Convert to dataframe and set row names\ncnv <- as.data.frame(cnv); rownames(cnv) <- cnv[,1]; cnv <- cnv[,-1]\ncomgene <- intersect(rownames(cnv),frg)\ncnv <- cnv[comgene,]\n各癌型中每个铁死亡相关基因（FRG）的体细胞拷贝数变异频率\nFrequency of somatic copy number alterations for each FRG in each\ncancer type.\n# 初始化结果存储对象\n# Initialize result storage object\ncnvTab <- NULL\n\n# 肿瘤类型迭代分析\n# Tumor Type Iterative Analysis\nfor (i in tumors) {\n  message(\"--\",i,\"...\")\n  \n  # 获取该肿瘤的全部样本\n  # Get all samples for this tumor type\n  sam <- samAnno[which(samAnno$`cancer type` == i),\"simple_barcode\"] \n  \n  # 取出与拷贝数泛癌数据交集的样本\n  # Extract samples overlapping with pan-cancer copy number data\n  comsam <- intersect(colnames(cnv), sam) \n  \n  # 取出该肿瘤的拷贝数子集\n  # Create copy number subset for this tumor\n  cnv_subset <- cnv[,comsam] \n  \n  # 保存原始CNV数据\n  # Save raw CNV data\n  write.table(cnv_subset, paste0(\"TCGA_\",i,\"_cnv_subset.txt\"),sep = \"\\t\",row.names = T,col.names = NA,quote = F)\n  \n  # 这里扩增和缺失的阈值设为0.05，即5%，可根据自己的数据调整\n  # Using 0.05 (5%) as thresholds for amplification/deletion - can be adjusted based on your data\n  cnv_subset[cnv_subset > 0.05] <- \"Amp\" \n  cnv_subset[cnv_subset < -0.05] <- \"Del\" \n  \n  # 计算扩增率\n  # Calculate amplification frequency\n  amp <- rowSums(cnv_subset == \"Amp\")/length(comsam) \n  \n  # 计算缺失率\n  # Calculate deletion frequency (negative values)\n  del <- -rowSums(cnv_subset == \"Del\")/length(comsam) \n  \n  # 创建当前肿瘤的CNV频率数据框\n  # Create CNV frequency dataframe for current tumor\n  cnv_rate <- data.frame(gene = rownames(cnv_subset),\n                         Amp = amp,\n                         Del = del,\n                         tumor = i,\n                         stringsAsFactors = F)\n  \n  # 保存当前肿瘤的结果\n  # Save results for current tumor\n  write.table(cnv_rate, paste0(\"TCGA_\",i,\"_cnvrate_subset.txt\"),sep = \"\\t\",row.names = F,col.names = T,quote = F)\n  \n  # 合并到总结果表\n  # Merge to master result table\n  cnvTab <- rbind.data.frame(cnvTab,cnv_rate)\n  \n  # 实时保存整合结果\n  # Periodically save combined results\n  write.table(cnvTab, \"TCGA_pancan_cnvrate_subset.txt\",sep = \"\\t\",row.names = F,col.names = T,quote = F)\n}\n# 内存清理\n# Memory Cleanup\ngc()\n开始画图\nPlotting\n# 生成柱状图\n# Generate bar plot\n\n# 随机产生20种颜色\n# Randomly generate 20 distinct colors\nn <- 20 \npalette <- distinctColorPalette(n)\n\n# 数据重塑（长格式转换）\n# Data reshaping (to long format)\ndf <- reshape2::melt(cnvTab, id.vars = c(\"gene\",\"tumor\"), variable.name = \"CNV\")\n\n# 如果想的话可以设置基因的顺序\n# You can set gene order here if desired\ndf$gene <- factor(df$gene, \n                  levels = rev(c(\"CDKN1A\",\"HSPA5\",\"EMC2\",\"SLC7A11\",\"NFE2L2\",\"MT1G\",\"HSPB1\",\"GPX4\",\"FANCD2\",\"CISD1\",                       \"FDFT1\",\"SLC1A5\",\"SAT1\",\"TFRC\",\"RPL8\",\"NCOA4\",\"LPCAT3\",\"GLS2\",\"DPP4\",\"CS\",\"CARS\",\"ATP5G3\",\"ALOX15\",\"ACSL4\")))\n\n# 可视化绘制\n# Visualization Plotting\nggplot(df, aes(x=gene, y=value, fill=tumor)) + \n  geom_bar (stat=\"identity\", position = position_dodge(width = 0.7)) +   \n  scale_fill_manual(values = palette) + \n  scale_y_continuous(\n    breaks = c(-0.8, -0.6, -0.4, -0.2, 0, 0.2, 0.4, 0.6, 0.8),\n    labels = c(-80,-60,-40,-20,0,20,40,60,80)\n  ) +\n  geom_hline(yintercept = c(-0.05, 0.05), \n             lwd = .5, lty = 2) +\n\n  coord_flip() +\n  theme_classic() +\n  theme(axis.line.y = element_line(size = 0.8),\n        axis.ticks.y = element_line(size = 0.2),\n        axis.text.x = element_text(size = 12, color = \"black\"),\n        axis.text.y = element_text(size = 12, color = rep(c(red,blue),c(14,10))),\n        axis.title.y = element_blank(),\n        axis.title.x = element_blank(),\n        legend.title = element_blank(),\n        legend.position = \"bottom\")\n# 保存为PDF\n# Save as PDF\nggsave(\"Figure 1A copy number variation rate of interested genes in pancancer.pdf\", width = 6,height = 8)\n\n# 内存清理\n# Memory Cleanup\nrm(cnv); gc()\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa265panCNV_FigureYa265panCNV",
      "title": "FigureYa265panCNV/FigureYa265panCNV.html",
      "html": "FigureYa265panCNV/FigureYa265panCNV.html",
      "text": "texts/main_FigureYa265panCNV_FigureYa265panCNV.txt",
      "folder": "FigureYa265panCNV",
      "thumb": "gallery_compress/FigureYa265panCNV.webp"
    },
    "word_count": 1037,
    "lines_count": 277,
    "title": "FigureYa265panCNV",
    "description": "Demand description 想实现这篇铁死亡泛癌的其他图片，主要是Figure 1。感觉这个套路只要换一个通路就可以测试，我看Xiaofan",
    "input_data_types": [
      "临床数据",
      "表达矩阵",
      "RNA-seq"
    ],
    "output_types": [
      "火山图",
      "箱线图",
      "统计表格",
      "散点图"
    ],
    "technical_methods": [
      "通路分析",
      "质量控制",
      "差异表达分析"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "Del",
      "gene",
      "values",
      "header",
      "width",
      "labels",
      "name",
      "height",
      "yintercept"
    ]
  },
  {
    "id": "main_FigureYa285scRNA_monocle_FigureYa285scRNA_monocle",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa285scRNA_monocle_FigureYa285scRNA_monocle.txt",
    "content": "FigureYa285scRNA_monocle\nFigureYa285scRNA_monocle\nAuthor(s)\n: Xiao Gu; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-05-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nDemand description\n画出右图J，拟时间轨迹。\nPlot Figure J on the right, showing pseudotime trajectory.\n出自\nhttps://jitc.bmj.com/content/10/2/e003534\nSource:\nhttps://jitc.bmj.com/content/10/2/e003534\n应用场景\nApplication scenarios\n展示如何在单细胞数据中使用monocle2包预测细胞发育轨迹。\nShow how to use the monocle2 package in single-cell data to predict\ncell developmental trajectories.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(Seurat)\nlibrary(SeuratData)\nlibrary(ggplot2)\nlibrary(RColorBrewer)\nlibrary(dplyr)\nlibrary(magrittr)\nlibrary(monocle)\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n输入文件及预处理\nInput Files and Preprocessing\n输入文件\nInput Files\n使用最常用的SeuratData中的pbmc3k进行演示，如果自己的数据不是在seurat中分析的，只要有表达矩阵和细胞注释信息也可分析，可跳过下面seurat常规分析，直接运行“构建monocle对象”。\n由于pbmc数据并不适合分析发育轨迹，本示例只展示如何计算，不探究具体科学问题。\n建议对自己数据中\n存在发育关系的细胞群\n进行发育轨迹预测。\nThis demonstration uses the pbmc3k dataset from SeuratData. If your\ndata was not analyzed in Seurat but you have an expression matrix and\ncell annotation information, you can skip the standard Seurat analysis\nsteps below and directly proceed to “Constructing the monocle\nobject”.\nSince the PBMC dataset is not ideal for studying developmental\ntrajectories, this example only illustrates the computational steps\nrather than exploring specific biological questions.\nFor your own data, it is recommended to predict developmental\ntrajectories only for\ncell populations with potential\ndevelopmental relationships\n.\n# devtools::install_github(\"satijalab/seurat-data\")\n\n# InstallData(\"pbmc3k\") \n# Or download and install manually，http://seurat.nygenome.org/src/contrib/pbmc3k.SeuratData_3.1.4.tar.gz\n# install.packages(\"pbmc3k.SeuratData_3.1.4.tar.gz\", repos = NULL, type = \"source\")\n\n# 加载数据集\n# load dataset\nLoadData(\"pbmc3k\")\npbmc <- UpdateSeuratObject(pbmc3k)\n预处理\nPreprocessing\n# 进行质量控制（QC）\n# 计算mitochondria基因比例\n# Quality control (QC)  \n# Calculate mitochondrial gene percentage\npbmc[[\"percent.mt\"]] <- PercentageFeatureSet(pbmc, pattern = \"^MT-\")\npbmc <- subset(pbmc, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)\n\n# 数据预处理\n# Data Preprocessing\npbmc <- NormalizeData(pbmc, normalization.method = \"LogNormalize\", scale.factor = 10000)\npbmc <- FindVariableFeatures(pbmc, selection.method = \"vst\", nfeatures = 2000)\nall.genes <- rownames(pbmc)\npbmc <- ScaleData(pbmc, features = all.genes)\npbmc <- RunPCA(pbmc, features = VariableFeatures(object = pbmc))\npbmc <- FindNeighbors(pbmc, dims = 1:10)\npbmc <- FindClusters(pbmc, resolution = 0.5)\npbmc <- RunUMAP(pbmc, dims = 1:10)\n# 该数据中已注释了细胞类型，在metadata中的'seurat_annotations'列\n# The dataset already contains cell type annotations in the 'seurat_annotations' column of metadata\numap.plot <- DimPlot(pbmc, reduction = \"umap\", label=T, group.by = \"seurat_annotations\") + NoLegend()\nggsave(\"UMAP_cluster.pdf\", plot = umap.plot, width = 6, height = 6)\n\nsaveRDS(pbmc, file = \"pbmc3k.seurat.object.rds\")\n构建monocle对象\nConstructing the monocle object\n# 构建monocle对象需要三个文件：表达矩阵、基因信息和meta信息\n# monocle输入的是count矩阵（不建议使用data矩阵）\n# Three files are required to build a monocle object: expression matrix, gene information, and metadata  \n# monocle requires raw count matrix (not recommended to use normalized data matrix) \nexp.matrix <- pbmc@assays$RNA@counts %>% as.matrix(.) \n\ngene.df <- data.frame(gene_short_name=rownames(exp.matrix))\nrownames(gene.df) <- gene.df$gene_short_name\n\nmeta.df <- pbmc@meta.data\n\n# 构建CellDataSet（cds）对象\n# Construct CellDataSet (cds) object\ncds.object <- newCellDataSet(exp.matrix,\n                             phenoData = new(\"AnnotatedDataFrame\", data = meta.df),\n                             featureData = new(\"AnnotatedDataFrame\", data = gene.df),\n                             lowerDetectionLimit = 0.5,\n                             expressionFamily = negbinomial.size())\n\nDelayedArray:::set_verbose_block_processing(TRUE)\n# 数据标准化和方差估计\n# normalisation and variance estimation\ncds.object <- estimateSizeFactors(cds.object)\ncds.object <- estimateDispersions(cds.object)\n# 过滤数据：选择最低表达量为0.1和至少千分之5的细胞中表达的基因\n# Filter data: select genes with minimum expression of 0.1 and expressed in at least 0.5% of cells\ncds.object <- detectGenes(cds.object, min_expr = 0.1)\nselect_gene <- subset(fData(cds.object),num_cells_expressed>=ceiling(nrow(pData(cds.object))*0.005))$gene_short_name %>% as.vector()\ncds.object <- cds.object[select_gene,]\n确定用于轨迹排序的基因\nDetermining Genes for Trajectory Ordering\n用于轨迹排序的基因的本质细胞类型特异的特征性基因，可用两种方法来获得：\n一种是用monocle里面的differentialGeneTest函数计算\n另外一种是用Seurat包里面的FindAllMarkers函数计算\n当然也可自定义(即下面的 deg.order)\nThe genes used for trajectory ordering are essentially\ncell-type-specific marker genes. There are two main approaches to obtain\nthese genes:\nUsing the differentialGeneTest function from the monocle\npackage\nUsing the FindAllMarkers function from the Seurat package\nAlternatively, you can manually specify genes (as shown in deg.order\nbelow)\n# monocle中的differentialGeneTest函数差异分析\n# ~后面是为做差异分析的变量，选择pData(cds.object)中注释细胞类型的列名\n# Differential gene analysis using differentialGeneTest function in monocle\n# The variable after ~ is for differential analysis, select the column name in pData(cds.object) that annotates cell types  \ndeg.celltype <- differentialGeneTest(cds.object, fullModelFormulaStr=\"~seurat_annotations\",cores=20) \nhead(deg.celltype)\ndeg.celltype <- subset(deg.celltype, qval < 0.01) \ndeg.order.monocle <- deg.celltype$gene_short_name[order(deg.celltype$qval)][1:1500]\nhead(deg.order.monocle)\n# Seurat中的FindAllMarkers函数计算\n# Differential gene analysis using FindAllMarkers function in Seurat\nIdents(pbmc) <- \"seurat_annotations\"\ndeg.celltype <- FindAllMarkers(pbmc, group.by = \"seurat_annotations\", )\ndeg.celltype %<>% subset(.,p_val_adj<0.05 & avg_log2FC > 0.5)\ndeg.order.seurat <- deg.celltype$gene\n\n# 后续分析选用differentialGeneTest计算结果，具体根据自己数据决定，也可同时运行比较\n# Subsequent analysis uses differentialGeneTest results by default, can be determined based on your data or compare both methods\n\n# 降维聚类和对细胞进行排序\n# Dimension reduction, clustering and cell ordering\ncds.object <- setOrderingFilter(cds.object, ordering_genes = deg.order.monocle)\ncds.object <- reduceDimension(cds.object, method = \"DDRTree\")\ncds.object <- orderCells(cds.object)\n\n# 可视化\n# Visualization\np <- plot_cell_trajectory(cds.object, color_by = \"Pseudotime\")+\n  theme(legend.position = \"right\")\np\n# plot_cell_trajectory为ggplot语法，下面代码可改颜色：\n# plot_cell_trajectory follows ggplot syntax, colors can be modified with: \n# p <- p +  scale_color_gradientn(colours = rev(c(\"grey80\", \"yellow\", \"red\")))\n\nggsave(\"trajectory_pseudotime.pdf\", plot = p, width = 7, height = 5)\n\n\np <- plot_cell_trajectory(cds.object, color_by = \"State\")+\n  theme(legend.position = \"right\")\nggsave(\"trajectory_state.pdf\", plot = p, width = 7, height = 5)\n\n# root_state可自定义拟时间轴的根，按照state分布设置根起点。默认情况下伪时间值为0时在state 1, 也可更改为state 2。\n# root_state can customize the root of pseudotime axis, set root position based on state distribution. By default pseudotime=0 at state 1, can be changed to state 2.\n\n# 下面这个函数用于计算自定义的根细胞类型所处的state值， 由root_celltype变量指定，对应具体细胞类型名：\n# The following function calculates the state value for custom root cell type specified by root_celltype variable: \n# root_celltype = \"XXX\"\n# state <- function(cds.object){\n#   if (length(unique(pData(cds.object)$State)) > 1){\n#     T0_counts <- table(pData(cds.object)$State, pData(cds.object)$seurat_annotations)[,root_celltype]\n#     return(as.numeric(names(T0_counts)[which(T0_counts == max(T0_counts))]))\n#   } else {\n#     return (1)\n#   }\n# }\n\n# cds.object <- orderCells(cds.object, root_state = 2) #把State2设成拟时间轴的起始点\n# Set State 2 as pseudotime starting point\n\n# 按细胞类型着色\n# Color by cell type\ncelltype.col <- colorRampPalette(colors = brewer.pal(9, \"Set1\"))(9)\np <- plot_cell_trajectory(cds.object, color_by = \"seurat_annotations\", ) + \n  scale_color_manual(values = celltype.col)+\n  theme(legend.position = \"right\")\np\nggsave(\"trajectory_celltype.pdf\", plot = p, width = 7, height = 5)\n\nsaveRDS(cds.object, \"monocle.cds.object.rds\")\n开始画图\nPlotting\n# 鉴定分支点依赖的基因，BEAM函数\n# branch_point为要研究的分支点，改示例中只有一个分支点1，后续分析选择branch1，\n# 具体分支点和自己数据结合确定\n# Identify branch-dependent genes using BEAM function\n# branch_point specifies the branch point to study. This example has only branch point 1 (branch1)\n# The specific branch point should be determined based on your own data\n\n# 要研究的分支点编号\n# Branch point number to study\nbranch_point = 1 \n\n# 调用5个核进行并行计算(按计算资源调整)\n# Use 5 cores for parallel computing (adjust based on computing resources) \ncores = 5 \n\nBEAM_res <- BEAM(cds.object, branch_point = branch_point, cores = cores,\n                 progenitor_method = \"duplicate\") %>% .[order(.$qval),]\nwrite.csv(BEAM_res, \"BEAM_res_data.csv\")\n\nBEAM_res <- BEAM_res[,c(\"gene_short_name\", \"pval\", \"qval\")]\n\ntable(BEAM_res$qval < 1e-4)\n# 选择q值小于0.0001的基因用于热图展示(阈值可自定义)\n# Select genes with q-value < 0.0001 for heatmap display (threshold can be adjusted)\nbeam.deg <- subset(BEAM_res, qval < 1e-4) %>% .$gene_short_name\n\n# num_clusters确定基因聚类数量(可多次尝试，本示例用4类)\n# num_clusters determines how many clusters to divide these genes into (can try different values, demo uses 4)\nnum_clusters = 4\n\n#pdf(\"branched_heatmap.pdf\", height = 6, width = 5)\nmy_branched_heatmap <- plot_genes_branched_heatmap(cds.object[beam.deg,],\n                                                   branch_point = branch_point,\n                                                   num_clusters = num_clusters,\n                                                   cores = cores,\n                                                   use_gene_short_name = TRUE,\n                                                   show_rownames = FALSE,\n                                                   return_heatmap = TRUE)\n#dev.off()\n获取上述热图中各个聚类中的对应基因，保存到文件。\nExtract the corresponding genes in each cluster from the\naforementioned heatmap and save them to a file.\ncluster_df <- cutree(my_branched_heatmap$ph_res$tree_row, k = num_clusters) %>% data.frame(.)\ncolnames(cluster_df) <- \"Gene_Clusters\"\ncluster_df$Gene <- rownames(cluster_df)\ncluster_df <- cluster_df[order(cluster_df$Gene_Clusters,decreasing = F),]\nhead(cluster_df)\ntable(cluster_df$Gene_Clusters)\nwrite.csv(cluster_df,\"branch_pseudotime_gene_list.csv\", row.names = F)\n后续使用这些基因做富集分析，将term标注到对应cluster的热图位置即可。\nSubsequently, use these genes for enrichment analysis and annotate\nthe terms to the corresponding cluster positions on the heatmap.\n确定热图中Cell fate 1和2对应的轨迹\nDetermining the Trajectories Corresponding to Cell Fate 1 and 2 in\nthe Heatmap\n即BEAM试图从分支点上的细胞一直向后遍历到根细胞(伪时间为0的细胞)，并将所有这些细胞作为前分支\n细胞命运1对应state ID小的细胞，而细胞命运2对应 state ID大的细胞\n具体可参考github主页对此问题的回复\nhttps://github.com/cole-trapnell-lab/monocle-release/issues/219\n所以此示例数据中：\nPre−branch为 state1 细胞群\nCell fate 1 为 state2 细胞群\nCell fate 2 为 state3 细胞群\nThat is, BEAM attempts to traverse from the cells at the branch point\nall the way back to the root cells (cells with pseudotime 0) and\nconsiders all these cells as the pre-branch.\nCell fate 1 corresponds to cells with smaller state IDs, while cell\nfate 2 corresponds to cells with larger state IDs.\nFor specific details, refer to the response to this issue on the\nGitHub homepage\nhttps://github.com/cole-trapnell-lab/monocle-release/issues/219\nThus, in this example dataset:\nPre-branch corresponds to the state1 cell population\nCell fate 1 corresponds to the state2 cell population\nCell fate 2 corresponds to the state3 cell population\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa285scRNA_monocle_FigureYa285scRNA_monocle",
      "title": "FigureYa285scRNA_monocle/FigureYa285scRNA_monocle.html",
      "html": "FigureYa285scRNA_monocle/FigureYa285scRNA_monocle.html",
      "text": "texts/main_FigureYa285scRNA_monocle_FigureYa285scRNA_monocle.txt",
      "folder": "FigureYa285scRNA_monocle",
      "thumb": "gallery_compress/FigureYa285scRNA_monocle.webp"
    },
    "word_count": 1277,
    "lines_count": 295,
    "title": "FigureYa285scRNA_monocle",
    "description": "Demand description 画出右图J，拟时间轨迹。 Plot Figure J on the right, showing pseudotime trajectory.",
    "input_data_types": [
      "表达矩阵",
      "单细胞"
    ],
    "output_types": [
      "热图",
      "统计表格",
      "PCA图"
    ],
    "technical_methods": [
      "聚类分析",
      "通路分析",
      "标准化",
      "质量控制"
    ],
    "biology_areas": [
      "发育生物学"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "values",
      "repos",
      "width",
      "expressionFamily",
      "object",
      "colours",
      "root_state",
      "num_clusters"
    ]
  },
  {
    "id": "main_FigureYa269scMetabolism_FigureYa269scMetabolism",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa269scMetabolism_FigureYa269scMetabolism.txt",
    "content": "FigureYa269scMetabolism\nFigureYa269scMetabolism\nAuthor(s)\n: Yandong Zheng; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-05-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nDemand description\n用scMetabolism实现单细胞RNA-seq数据的代谢分析，并画图。\nPerforming metabolic analysis and visualization of single-cell\nRNA-seq data using scMetabolism.\n出自\nhttps://aacrjournals.org/cancerdiscovery/article/12/1/134/675646/Spatiotemporal-Immune-Landscape-of-Colorectal\n图4. 转移性肿瘤中的MRC1+ CCL18+巨噬细胞表现出高代谢活性。 C图：MRC1+\nCCL18+巨噬细胞的代谢基因平均表达量和代谢通路评分中位数的热图。红色标注的基因代表潜在的可成药基因（详见方法部分）。\nSource:\nhttps://aacrjournals.org/cancerdiscovery/article/12/1/134/675646/Spatiotemporal-Immune-Landscape-of-Colorectal\nFigure 4. MRC1+ CCL18+ macrophages in metastatic tumors showed high\nmetabolic activity. C, The heat map of average metabolic gene expression\nand median metabolic pathway score of MRC1+ CCL18+ macrophages. The\ngenes highlighted with red represent the potential druggable genes\n(Methods).\n应用场景\nApplication scenarios\nMining metabolic activity at single-cell\nresolution，为了方便使用，例文作者把整个pipeline写成了R包scMetabolism。还开发了在线版\nhttp://www.cancerdiversity.asia/scMetabolism/\n。\n本文档带你跑通R版本的scMetabolism，适用于scRNA-seq数据，友好对接seurat。\nMining metabolic activity at single-cell resolution. For ease of use,\nthe authors of the example have packaged the entire pipeline into an R\npackage called scMetabolism. They also developed an online version\navailable at\nhttp://www.cancerdiversity.asia/scMetabolism/\n.\nThis document guides you through running the R version of\nscMetabolism, which is suitable for scRNA-seq data and seamlessly\nintegrates with Seurat.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(Seurat)\nlibrary(SeuratData)\nlibrary(patchwork)\nlibrary(RColorBrewer)\nlibrary(pheatmap)\nlibrary(dplyr)\nlibrary(magrittr)\nlibrary(scMetabolism)\nlibrary(ggplot2)\nlibrary(rsvd)\n\n\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n输入文件预处理\nInput File Preprocessing\n跟FigureYa267scCellChat一样的处理，可以直接跳到“Metabolic\ngenes”。\nifnb\n- A Seurat object with the PBMC\ncontrol/IFNB-stimulated dataset。出自\nhttps://pubmed.ncbi.nlm.nih.gov/29227470/\n，已被打包到SeuratData里，我们直接安装、加载它。\n示例数据ifnb有STIM和CTRL两组：\n先拆分成两个seurat\nobject，对两个数据集单独进行normalize并识别各自的高变异基因，使用高变异基因在两个基因集中分别执行PCA。\n然后对两个数据集进行整合，进行常规数据预处理，存入immune.combined，以便进行后续分析。\nThe same processing as FigureYa267scCellChat, you can directly skip\nto “Metabolic genes”.\nifnb\n- A Seurat object containing the PBMC\ncontrol/IFNB-stimulated dataset. It originates from\nhttps://pubmed.ncbi.nlm.nih.gov/29227470/\nand has been\npackaged into SeuratData. We will directly install and load it.\nThe example dataset ifnb consists of two groups: STIM and CTRL:\nFirst, split it into two Seurat objects. Perform normalization and\nidentify highly variable genes for each dataset separately. Use the\nhighly variable genes to perform PCA on both gene sets\nindividually.\nThen, integrate the two datasets and conduct standard data\npreprocessing, storing the result in immune.combined for subsequent\nanalysis.\n左图 - Metabolic genes\nLeft Panel - Metabolic Genes\n提取特定通路里的差异表达基因，用热图展示其表达变化。\n这里用Y叔的clusterProfiler读取scMetabolism包里整理的gmt文件，按照自己安装路径寻找，一般位于\n安装目录/lib/R/library/scMetabolism/data/KEGG_metabolism_nc.gmt\n。或者直接从msigdb下载gmt文件，\nhttps://www.gsea-msigdb.org/gsea/msigdb/\nExtract differentially expressed genes from a specific pathway and\nvisualize their expression changes using a heatmap.\nHere, we use Y-shu’s clusterProfiler to read the GMT file organized\nin the scMetabolism package. Locate the file based on your installation\npath, typically found at:\ninstallation_directory/lib/R/library/scMetabolism/data/KEGG_metabolism_nc.gmt\n.\nAlternatively, you can directly download the GMT file from MSigDB:\nhttps://www.gsea-msigdb.org/gsea/msigdb/\n# 加载上面保存的immune.combined.rds文件\n# Load the previously saved 'immune.combined.rds' file \nimmune.combined <- readRDS(\"immune.combined.rds\")\n\n# 加载gmt文件\n# Load the GMT file  \nkegg_geneset <- clusterProfiler::read.gmt(\"KEGG_metabolism_nc.gmt\")\n# 提取目标通路基因，这里以Glycolysis / Gluconeogenesis为例\n# Extract genes from the target pathway (here, \"Glycolysis / Gluconeogenesis\" as an example) \npathway_gene <- subset(kegg_geneset, term==\"Glycolysis / Gluconeogenesis\") %>% .$gene %>% as.vector(.)\n\n# 提取目标基因的表达量\n# Extract expression levels of the target genes  \nIdents(immune.combined) <- \"stim\"\nave_exp <- AverageExpression(immune.combined, \n                             features = pathway_gene, \n                             assays = \"RNA\") %>% .$RNA\n这里把参与该通路的基因都画到图中。也可以结合自己数据的情况，筛选差异表达基因来画图。具体操作可参考右图的“计算差异显著的metabolism\npathway”里的方法，或参考FigureYa177RNAvelocity里的s5_DEG.Rmd用DESeq2分析。\nHere, all the genes involved in this pathway are plotted in the\ndiagram. You can also filter differentially expressed genes based on\nyour own data for plotting. For specific operations, please refer to the\nmethod in the “Calculate significantly different metabolism pathways”\nsection of the figure on the right, or consult the s5_DEG.Rmd file in\nFigureYa177RNAvelocity for analysis using DESeq2.\n# 创建PDF输出文件\n# Create PDF output file\npdf(\"select_pathway_gene_pheatmap.pdf\",height = 12,width = 8)\n\n# 绘制热图\n# Generate Heatmap\npheatmap(ave_exp,\n         cluster_row = T,\n         treeheight_row = \"0\",\n         cluster_col = F,\n         show_rownames=T,\n         cellwidth = 40,\n         border_color = NA,\n         color = colorRampPalette(colors = c(\"#31315d\",\"#ee5fa1\",\"#edec77\"))(100),\n         legend = T,\n         scale=\"row\")\n# 关闭图形设备\n# Close graphics device\ndev.off()\n右图 - Metabolism pathways\nRight panel - Metabolic pathways\n运行scMetabolism\nRunning scMetabolism\n# 设置参数，对 method 和 metabolism.type 做选择\n# Set parameters and select method and metabolism.type\ncountexp.Seurat <- sc.metabolism.Seurat(\n  obj = immune.combined, \n  \n  # 支持VISION(默认)、AUCell、ssgsea和gsva\n  # Supported methods: VISION(default), AUCell, ssgsea, gsva\n  method = \"AUCell\",  \n  \n  # 是否进行数据填补（FALSE=直接使用原始数据）\n  # Whether to perform data imputation (FALSE=use raw data)\n  imputation = FALSE, \n  \n  # 减少核心数避免内存问题\n  # Reduce core count to avoid memory issues \n  ncores = 10,         \n  \n  # 支持KEGG(85条代谢通路)和REACTOME(82条) \n  # Supported types: KEGG(85 pathways), REACTOME(82)\n  metabolism.type = \"KEGG\"   \n  \n)\n# 保存分析结果（包含每个细胞的代谢通路活性评分）\n# Save results (containing metabolic pathway activity scores per cell)\nsaveRDS(countexp.Seurat,\"countexp.Seurat.rds\")\n计算差异显著的metabolism pathway\nIdentifying significantly differential metabolic pathways\n# 从Seurat对象中提取代谢通路活性评分矩阵\n# Extract metabolic pathway activity scores from Seurat object\nsignature_exp <- countexp.Seurat@assays$METABOLISM$score\n\n# 提取样本分组和细胞类型注释信息\n# Extract sample groups and cell type annotations\nsignature_meta <- countexp.Seurat@meta.data[,c(\"stim\", \"seurat_annotations\")]\n\n# 创建包含代谢活性和元数据的联合数据框\n# Create combined dataframe with metabolic activity and metadata\nsignature_df <- data.frame(signature_meta, t(signature_exp))\ncolnames(signature_df)[3:nrow(signature_exp)] <- rownames(signature_exp)\n# 提取两组数据\n# Extract data for two groups\nsignature_df_ctrl <- subset(signature_df, stim%in%\"CTRL\")[3:nrow(signature_exp)]\nsignature_df_stim <- subset(signature_df, stim%in%\"STIM\")[3:nrow(signature_exp)]\n\n# 进行差异检验\n# Perform differential testing\ndf_pvalue <- c()\nfor (i in 1:ncol(signature_df_stim)) {\n  pvalue <- wilcox.test(signature_df_ctrl[,i], signature_df_stim[,i]) %>% .$p.value\n  df <- data.frame(Pathway = colnames(signature_df_stim)[i], p_val = pvalue)\n  df_pvalue <- rbind(df_pvalue,df)\n}\n\n# p值校正\n# p-value adjustment\np.adj <- p.adjust(df_pvalue$p_val,method = \"BH\") \ndf_pvalue$p.adj <- p.adj\n\n# 计算各组中位代谢活性水平\n# Calculate median metabolic activity levels per group\nctrl_df <- apply(signature_df_ctrl, 2, median) %>% as.data.frame() \ncolnames(ctrl_df) <- \"CTRL\"\nctrl_df$Pathway <- as.vector(rownames(ctrl_df))\n\nstim_df <- apply(signature_df_stim, 2, median) %>% as.data.frame()\ncolnames(stim_df) <- \"STIM\"\nstim_df$Pathway <- as.vector(rownames(stim_df))\n\n# 合并统计检验结果和代谢活性数据\n# Merge statistical results with metabolic activity data\ncombine_df <- full_join(ctrl_df, stim_df, by=\"Pathway\")\npathway_df <- full_join(df_pvalue, combine_df, by=\"Pathway\")\nrownames(pathway_df) <- as.vector(pathway_df$Pathway)\npathway_df$Pathway <- NULL\n\n# 筛选显著差异通路\n# Filter significant pathways\nsignificance_pathway <- subset(pathway_df, p.adj<0.05)\n\n# 结果输出\n# Output results\nwrite.table(significance_pathway, \"output_metabolic pathway score.txt\", sep = \"\\t\", quote = F)\n开始画图\nPlotting\n用pheatmap画图\nPlotting with pheatmap\n# 创建用于绘图的数据副本（移除统计检验结果列）\n# Create plotting dataframe copy (remove statistical test columns)\npathway_plot_df <- significance_pathway\npathway_plot_df$p_val <- NULL\npathway_plot_df$p.adj <- NULL\n\n# 移除包含 NA/NaN/Inf 的行\n# Remove rows containing NA/NaN/Inf\npathway_plot_df_clean <- pathway_plot_df[complete.cases(pathway_plot_df), ]\npathway_plot_df_clean <- pathway_plot_df_clean[!is.infinite(rowSums(pathway_plot_df_clean)), ]\n\n# 检查并移除全零行（标准化会生成 NaN）\n# Check and remove all-zero rows (normalization produces NaN)\nzero_rows <- which(apply(pathway_plot_df_clean, 1, function(x) all(x == 0)))\nif (length(zero_rows) > 0) {\n  pathway_plot_df_clean <- pathway_plot_df_clean[-zero_rows, ]\n}\n\n# 创建PDF输出文件\n# Create PDF output\npdf(\"significance_metabolism pathway_pheatmap.pdf\",height = 12,width = 8)\n\n# 绘制标准化热图\n# Draw scaled heatmap\npheatmap(pathway_plot_df_clean,\n         cluster_row = T,\n         treeheight_row = \"0\",\n         cluster_col = F,\n         show_rownames=T,\n         cellwidth = 40,\n         border_color = NA,\n         color = colorRampPalette(colors = c(\"#333189\",\"#306faf\",\"#efe92b\"))(100),\n         legend = T,\n         scale=\"row\")\n# 关闭图形设备\n# Close graphics device\ndev.off()\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa269scMetabolism_FigureYa269scMetabolism",
      "title": "FigureYa269scMetabolism/FigureYa269scMetabolism.html",
      "html": "FigureYa269scMetabolism/FigureYa269scMetabolism.html",
      "text": "texts/main_FigureYa269scMetabolism_FigureYa269scMetabolism.txt",
      "folder": "FigureYa269scMetabolism",
      "thumb": "gallery_compress/FigureYa269scMetabolism.webp"
    },
    "word_count": 1023,
    "lines_count": 287,
    "title": "FigureYa269scMetabolism",
    "description": "Demand description 用scMetabolism实现单细胞RNA-seq数据的代谢分析，并画图。 Performing metabolic analysis and visualization of single-cell",
    "input_data_types": [
      "临床数据",
      "单细胞"
    ],
    "output_types": [
      "火山图",
      "热图",
      "统计表格"
    ],
    "technical_methods": [
      "通路分析",
      "生存分析",
      "标准化",
      "差异表达分析"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学",
      "药物研究",
      "代谢疾病"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "Pathway",
      "cluster_row",
      "width",
      "p_val",
      "pvalue",
      "cellwidth",
      "FALSE",
      "legend",
      "obj"
    ]
  },
  {
    "id": "main_FigureYa112Plus_venn_FigureYa112Plus_venn",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa112Plus_venn_FigureYa112Plus_venn.txt",
    "content": "FigureYa112Plus_venn\nFigureYa112Plus_venn\nAuthor(s)\n: Ying Ge, Taojun Ye\nReviewer(s)\n: Ying Ge\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nvennyhttp://bioinfogp.cnb.csic.es/tools/venny/，新出来个选项，颜色填充by%。\n缺点：只能填充灰色，只能保存成png。\n我想要彩色，我想要pdf矢量图。\n实现FigureYa112venn时还没有R包能直接实现这样按百分比填充颜色的效果，于是FigureYa112venn的作者李誉辉综合了VennDiagram和colorfulVennPlot等R包，实现了想要的效果。\n后来高春辉写了R包ggVennDiagram，方便好用，下面就展示一下用这个R包画venn图的用法。\n输入基因列表，画出按百分比填充颜色的venn图，并输出各个区域的基因名。\nRequirement description\nvennyhttp://bioinfogp.cnb.csic.es/tools/venny/ A new option has\nemerged, color filling by%.\nDisadvantage: It can only be filled in gray and can only be saved as\nPNG.\nI want color, I want PDF vector graphics.\nWhen we wrote FigureYa112venn, there was no R package that could\ndirectly achieve the effect of filling colors by percentage. Therefore,\nthe author of FigureYa112venn, Li Yuhui, integrated R packages such as\nVennDiagram and colorfulVennPlot to achieve the desired effect.\nLater, Gao Chunhui wrote the R package ggVennDiagram, which is\nconvenient and easy to use. Below is a demonstration of how to use this\nR package to draw Venn diagrams.\nInput the gene list, draw a Venn chart filled with colors by\npercentage, and output the gene names for each region.\n出自\nhttp://bioinfogp.cnb.csic.es/tools/venny/\nfrom\nhttp://bioinfogp.cnb.csic.es/tools/venny/\n应用场景\n展示重叠关系，例如多个分组之间共有的、特异的差异表达基因。\n适用于2、3或4个list的overlap，超过4个用upsetR更合适。\nApplication scenarios\nDisplay overlapping relationships, such as shared and specific\ndifferentially expressed genes between multiple groups.\nSuitable for overlaps of 2, 3, or 4 lists, with upsetR being more\nappropriate for more than 4 lists.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\n# 加载stringr包 - 提供字符串处理函数\n# Load the stringr package - provides functions for string processing\nlibrary(stringr)\n\n# 加载ggplot2包 - 用于创建优雅的图形和可视化\n# Load the ggplot2 package - used for creating elegant graphics and visualizations\nlibrary(ggplot2)\n\n# 加载ggVennDiagram包 - 用于绘制维恩图\n# Load the ggVennDiagram package - used for drawing Venn diagrams\nlibrary(ggVennDiagram)\n\n# 加载export包 - 用于导出图形到不同格式\n# Load the export package - used for exporting graphics to different formats\nlibrary(export)\n\n# 设置环境变量使R显示英文错误信息（便于查找解决方案）\n# Set environment variable to display R error messages in English (easier for finding solutions)\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止将字符向量自动转换为因子类型（避免意外的数据转换）\n# Disable automatic conversion of character vectors to factors (to avoid unexpected data transformations)\noptions(stringsAsFactors = FALSE)\n自定义函数\nCustom functions\n# 读取文件并筛选差异表达基因，保留统计数值\n# 参数：\n#   file - 输入文件路径\n# 返回：\n#   包含FDR值小于等于adjcutoff的差异表达基因的数据框\n# Read a file and filter differentially expressed genes (DEGs), retaining statistical values\n# Parameters:\n#   file - Path to the input file\n# Returns:\n#   Data frame containing DEGs with FDR values less than or equal to adjcutoff\nread_cut <- function(file){\n  df <- read.table(file, header = T)\n  DEG <- df[df$FDR <= adjcutoff, ]\n}\n\n# 读取文件并筛选差异表达基因，只保留基因名\n# 参数：\n#   file - 输入文件路径\n# 返回：\n#   包含FDR值小于等于adjcutoff的差异表达基因的ID向量\n# Read a file and filter differentially expressed genes (DEGs), retaining only gene names\n# Parameters:\n#   file - Path to the input file\n# Returns:\n#   Vector containing IDs of DEGs with FDR values less than or equal to adjcutoff\nread_cut_ID <- function(file){\n  df <- read.table(file, header = T)\n  DEG <- df[df$FDR <= adjcutoff, ]$id\n}\n\n# 读取文件并筛选差异表达基因，把上调和下调分开，只保留基因名\n# 参数：\n#   file - 输入文件路径\n# 返回：\n#   包含两个元素的列表：\n#     up - FDR值小于等于adjcutoff且log2FC大于0的上调基因ID向量\n#     down - FDR值小于等于adjcutoff且log2FC小于0的下调基因ID向量\n# Read a file and filter differentially expressed genes (DEGs), separating upregulated and downregulated genes, retaining only gene names\n# Parameters:\n#   file - Path to the input file\n# Returns:\n#   List containing two elements:\n#     up - Vector of IDs for upregulated genes (FDR <= adjcutoff and log2FC > 0)\n#     down - Vector of IDs for downregulated genes (FDR <= adjcutoff and log2FC < 0)\nread_cut_updown <- function(file){\n  df <- read.table(file, header = T)\n  DEG <- df[df$FDR <= adjcutoff, ]\n  return(list(up = DEG[DEG$log2FC > 0,]$id, \n              down = DEG[DEG$log2FC < 0,]$id))\n}\n输入文件\nSKCM_*_test_result.*.txt，差异表达结果，可以包含全部基因，这里用FDR筛选显著差异基因。\n怎样获得差异表达结果？\n用FigureYa59Plus_GEO2DEG\n获得芯片的差异表达分析结果文件\neasy_input_limma.csv\n用FigureYa118MulticlassDESeq2、FigureYa119Multiclasslimma和FigureYa120MulticlassedgeR获得RNA-seq的差异表达分析结果。\n这里就以FigureYa118MulticlassDESeq2和FigureYa120MulticlassedgeR的输出文件作为输入，画出venn图展示不同对比的重叠情况。\nInput file\nSKCM_*_test_result.*.txt， The differential expression results can\ninclude all genes, and here FDR is used to screen for significantly\ndifferentially expressed genes.\nHow to obtain differential expression results?\n-Using FigureYa59Plus_GEO2DEG Obtain the differential expression\nanalysis result file of the chip ‘easy_input_imma. csv’`\n-Obtain differential expression analysis results of RNA seq using\nFigureYa118MulticlassDESeq2, FigureYa119Multiclasslimma, and\nFigureYa120MulticlassedgeR.\nHere, taking the output files of FigureYa118MulticlassDESeq2 and\nFigureYa120MulticlassedgeR as inputs, draw Venn diagrams to show the\noverlap of different comparisons.\n文件信息的整理\n可参考\neasy_input_info.txt\n文件的格式，自己在Excel里写这个文件，至少要有第一列文件名和最后一列condition。\nOrganizing file information\nYou can refer to the format of the ‘easy_input_info. txt’ file and\nwrite this file yourself in Excel, with at least the first column of\nfile names and the last column of conditions.\n# 读取输入文件：获取当前目录下所有以\"SKCM\"开头、\".txt\"结尾的文件名\n# 参数：\n#   \"SKCM*.txt\" - 文件通配符，匹配所有SKCM开头的txt文件\n# 返回：\n#   包含所有匹配文件名的字符向量\n# Read input files: retrieve all file names in the current directory starting with \"SKCM\" and ending with \".txt\"\n# Parameters:\n#   \"SKCM*.txt\" - File wildcard to match all txt files starting with SKCM\n# Returns:\n#   Character vector containing all matched file names\nfnames <- Sys.glob(\"SKCM*.txt\")\n\n# 整理文件信息：从文件名中提取分组和分析方法信息\n# 参数：\n#   file - 原始文件名向量\n#   group - 从文件名中提取的分组信息（通过\".\"分割后的第二部分）\n#   method - 从文件名中提取的分析方法信息（通过\"_\"分割后的第二部分）\n# 返回：\n#   包含文件名、分组、方法和组合条件的数据框\n# Organize file information: extract group and analysis method information from file names\n# Parameters:\n#   file - Original file name vector\n#   group - Group information extracted from file name (second part after splitting by \".\")\n#   method - Analysis method information extracted from file name (second part after splitting by \"_\")\n# Returns:\n#   Data frame containing file names, groups, methods, and combined conditions\nfinfo <- data.frame(file = fnames, \n                 group = str_split_fixed(fnames, \"\\\\.\",3)[,2],\n                 method = str_split_fixed(fnames, \"_\",3)[,2])\nfinfo$condition <- paste(finfo$group, finfo$method, sep = \"_\")\nhead(finfo)\n# 输出到文件：将整理后的文件信息保存为制表符分隔的文本文件\n# 参数：\n#   finfo - 待保存的数据框\n#   \"easy_input_info.txt\" - 输出文件名\n#   row.names = F - 不保存行名\n#   quote = F - 不使用引号包裹字符值\n#   sep = \"\\t\" - 使用制表符作为分隔符\n# 输出：\n#   生成包含文件信息的文本文件\n# Output to file: save the organized file information as a tab-separated text file\n# Parameters:\n#   finfo - Data frame to be saved\n#   \"easy_input_info.txt\" - Output file name\n#   row.names = F - Do not save row names\n#   quote = F - Do not enclose character values in quotes\n#   sep = \"\\t\" - Use tab as separator\n# Output:\n#   Text file containing file information\nwrite.table(finfo, \"easy_input_info.txt\", row.names = F,quote = F, sep = \"\\t\")\n差异表达基因筛选\nDifferential expression gene screening\n# 读入文件信息：从制表符分隔的文本文件中读取先前整理的文件信息\n# 参数：\n#   \"easy_input_info.txt\" - 输入文件路径，需包含表头\n# 返回：\n#   包含文件元数据的数据框（文件名、分组、方法等）\n# Read file information: load previously organized file metadata from a tab-separated text file\n# Parameters:\n#   \"easy_input_info.txt\" - Path to input file with headers\n# Returns:\n#   Data frame containing file metadata (names, groups, methods, etc.)\nfinfo <- read.table(\"easy_input_info.txt\", header = T)\n\n# 读入差异表达分析的结果，筛选显著差异基因\n# 设置FDR调整后的p值阈值（可根据具体数据分析需求修改）\n# Read differential expression analysis results and filter significant genes\n# Set threshold for FDR-adjusted p-value (modify according to specific data analysis needs)\nadjcutoff <- 0.05 #根据自己的数据修改阈值\n\n# 读取文件并筛选差异表达基因\n# 使用lapply函数对每个文件名调用read_cut函数，返回包含多个数据框的列表\n# 参数：\n#   fnames - 包含待读取文件名的字符向量\n#   read_cut - 自定义函数，用于读取文件并筛选显著差异表达基因\n# 返回：\n#   命名列表，每个元素是一个数据框，包含一个样本的差异表达基因\n# Read files and filter differentially expressed genes\n# Apply read_cut function to each file name using lapply, returning a list of data frames\n# Parameters:\n#   fnames - Character vector containing file names to read\n#   read_cut - Custom function to read file and filter significant DEGs\n# Returns:\n#   Named list where each element is a data frame containing DEGs for one sample\nfdataset <- lapply(fnames, read_cut)\nnames(fdataset) <- finfo$condition\n\n# 输出到Excel文件，每种对比结果占一个sheet，稍微修改一下格式就可以作为文章的Supplementary File了\n# 使用openxlsx包将多个数据框写入Excel文件，每个数据框为一个工作表\n# 参数：\n#   fdataset - 包含多个数据框的列表，将作为不同工作表写入Excel\n#   file = paste0(...) - 输出文件名，动态包含阈值信息\n#   row.names = F - 不保存行名\n# 输出：\n#   包含多个工作表的Excel文件，可作为论文补充材料\n# Output to Excel file: each comparison result occupies one sheet, \n# which can be used as Supplementary File after minor formatting\n# Use openxlsx package to write multiple data frames to Excel, each as a worksheet\n# Parameters:\n#   fdataset - List containing multiple data frames to be written as worksheets\n#   file = paste0(...) - Output file name dynamically including threshold information\n#   row.names = F - Do not save row names\n# Output:\n#   Excel file with multiple worksheets, suitable for use as paper supplementary material\nopenxlsx::write.xlsx(fdataset, file = paste0(\"DEG_adj\", adjcutoff, \".xlsx\"), row.names = F)\n开始画图\n两个圈\n对比两个文件\n以SKCM_deseq2_test_result.immune_vs_Others.txt和SKCM_edgeR_test_result.immune_vs_Others.txt为例，展示在两种方法中都被筛到的差异基因。\nStart drawing\nTwo circles\nCompare two files\nTaking SKCM_deseq2_test_desult.immune-vs_Others.txt and SKCM_\nedgeR_test_desult.immune-vs_Others.txt as examples, show the\ndifferentially expressed genes that were screened in both methods.\n# 读取带有immune_vs_Others的文件，筛选差异基因\n# 从文件信息中筛选分组为immune_vs_Others的文件，读取并提取差异表达基因ID\n# 参数：\n#   finfo[finfo$group == \"immune_vs_Others\",]$file - 筛选出分组为immune_vs_Others的文件名向量\n#   read_cut_ID - 自定义函数，读取文件并返回差异表达基因ID\n# 返回：\n#   命名列表，每个元素是一个基因ID向量，对应一种分析方法的差异表达基因\n# Read files containing \"immune_vs_Others\" and filter differentially expressed genes\n# Filter files with group \"immune_vs_Others\" from file information, read and extract DEG IDs\n# Parameters:\n#   finfo[finfo$group == \"immune_vs_Others\",]$file - Vector of file names filtered by group \"immune_vs_Others\"\n#   read_cut_ID - Custom function to read file and return DEG IDs\n# Returns:\n#   Named list where each element is a vector of gene IDs, corresponding to DEGs from one analysis method\nlist_ID <- lapply(finfo[finfo$group == \"immune_vs_Others\",]$file, read_cut_ID)\nnames(list_ID) <- finfo[finfo$group == \"immune_vs_Others\",]$method\n\n# 画venn图\n# 使用ggVennDiagram包绘制维恩图，展示不同分析方法鉴定的差异基因重叠情况\n# 参数：\n#   list_ID - 包含多个基因ID向量的列表\n#   label_alpha=0 - 不显示区域内的文本标签\n#   scale_fill_gradient - 设置填充颜色从白色到浅蓝色渐变\n# 返回：\n#   ggplot对象，可用于显示或保存维恩图\n# Draw Venn diagram\n# Use ggVennDiagram package to visualize overlapping DEGs identified by different methods\n# Parameters:\n#   list_ID - List containing multiple vectors of gene IDs\n#   label_alpha=0 - Do not display text labels inside regions\n#   scale_fill_gradient - Set fill color gradient from white to light blue\n# Returns:\n#   ggplot object for displaying or saving the Venn diagram\np <- ggVennDiagram(list_ID, label_alpha=0) + \n  scale_fill_gradient(low=\"white\", high = \"lightblue\")\np\n# 保存成pdf文件\n# 将维恩图保存为PDF格式，设置宽度和高度为4英寸\n# 参数：\n#   \"venn_2.pdf\" - 输出文件名\n#   width = 4, height = 4 - 图像宽高（英寸）\n# 输出：\n#   高质量矢量图形文件，可用于学术论文\n# Save as PDF file\n# Save the Venn diagram as PDF with width and height of 4 inches\n# Parameters:\n#   \"venn_2.pdf\" - Output file name\n#   width = 4, height = 4 - Image dimensions in inches\n# Output:\n#   High-quality vector graphic file suitable for academic publications\nggsave(\"venn_2.pdf\", width = 4, height = 4)\n\n# 保存到ppt里\n# 使用export包将ggplot对象导出到PowerPoint幻灯片\n# 参数：\n#   p - ggplot对象（维恩图）\n#   file=\"venn_2.pptx\" - 输出文件名\n#   width = 4, height = 4 - 图像宽高（英寸）\n# 输出：\n#   包含矢量图形的PPTX文件，便于在演示中使用\n# Export to PowerPoint\n# Use export package to export ggplot object to PowerPoint slide\n# Parameters:\n#   p - ggplot object (Venn diagram)\n#   file=\"venn_2.pptx\" - Output file name\n#   width = 4, height = 4 - Image dimensions in inches\n# Output:\n#   PPTX file containing vector graphic for easy presentation\ngraph2ppt(p, file=\"venn_2.pptx\",width = 4,height = 4)\n# 以上两种文件都是矢量图，可以在illustrator或ppt里打开修改文字和图形。\n# Both output formats are vector graphics, editable in Illustrator or PowerPoint.\n\n# 把各区域的基因输出到文件\n# 提取维恩图各重叠区域的基因ID，保存到Excel文件\n# 参数：\n#   get_region_items(list_ID) - 获取列表中各组的交集和并集基因ID\n#   \"venn_2.xlsx\" - 输出Excel文件名\n# 输出：\n#   包含多个工作表的Excel文件，每个表对应维恩图的一个区域\n# Output genes in each Venn diagram region to file\n# Extract gene IDs in each overlapping region and save to Excel file\n# Parameters:\n#   get_region_items(list_ID) - Get gene IDs for intersections and unions of groups in the list\n#   \"venn_2.xlsx\" - Output Excel file name\n# Output:\n#   Excel file with multiple sheets, each representing a region in the Venn diagram\nlibrary(openxlsx)\nvenn_list <- list_ID\nintersect_1_2 <- intersect(venn_list[[1]], venn_list[[2]])\nwrite.xlsx(list(Intersect_1_2 = intersect_1_2), \"venn_2.xlsx\")\n四个圈\n对比四个文件\n以SKCM_deseq2_test_result.immune_vs_Others.txt和SKCM_edgeR_test_result.immune_vs_Others.txt为例，把上调和下调拆开，展示在两种方法中都被筛到的差异基因。\nFour circles\nCompare four files\nTaking SKCM_deseq2_test_desult.immune-vs_Others.txt and SKCM_\nedgeR_test_desult.immune-vs_Others.txt as examples, the upregulation and\ndownregulation were separated to display the differentially expressed\ngenes screened in both methods.\nfile1 <- \"SKCM_deseq2_test_result.immune_vs_Others.txt\"\nfile2 <- \"SKCM_edgeR_test_result.immune_vs_Others.txt\"\nlist_ID <- list(deseq2_up = read_cut_updown(file1)$up,\n                deseq2_down = read_cut_updown(file1)$down,\n                edgeR_up = read_cut_updown(file2)$up,\n                edgeR_up = read_cut_updown(file2)$down\n)\n\n# 画venn图\np <- ggVennDiagram(list_ID, label_alpha=0) + \n  scale_fill_gradient(low=\"white\", high = \"lightblue\")\np\n# 保存成pdf文件\nggsave(\"venn_4.pdf\", width = 6, height = 6)\n\n# 保存到ppt里\ngraph2ppt(p, file=\"venn_4.pptx\",width = 6,height = 6)\n# 把各区域的基因输出到文件\nvenn_list <- list_ID\nintersect_1_2 <- intersect(venn_list[[1]], venn_list[[2]])\nwrite.xlsx(list(Intersect_1_2 = intersect_1_2), \"venn_4.xlsx\")\n三个圈\n对比三个文件\n以DESeq2获得的三种差异表达基因为例，展示其overlap\nThree circles\nCompare three files\nTaking the three differentially expressed genes obtained from DESeq2\nas an example, demonstrate their overlap\n# 读取带有deseq2的文件，筛选差异基因\nlist_ID <- lapply(finfo[finfo$method == \"deseq2\", ]$file, read_cut_ID)\nnames(list_ID) <- str_remove(finfo[finfo$method == \"deseq2\",]$group, \"_vs_Others\")\n\n# 画venn图，这次换个配色\np <- ggVennDiagram(list_ID, label_alpha=0) + \n  scale_fill_gradient(low=\"yellow\", high = \"brown\")\np\n# 保存成pdf文件\nggsave(paste0(\"venn_3.pdf\"), width = 6, height = 6)\n\n# 保存到ppt里\ngraph2ppt(p, file=\"venn_3.pptx\",width = 6,height = 6)\n# 把各区域的基因输出到文件\nvenn_list <- list_ID\nintersect_1_2 <- intersect(venn_list[[1]], venn_list[[2]])\nwrite.xlsx(list(Intersect_1_2 = intersect_1_2), \"venn_3.xlsx\")\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa112Plus_venn_FigureYa112Plus_venn",
      "title": "FigureYa112Plus_venn/FigureYa112Plus_venn.html",
      "html": "FigureYa112Plus_venn/FigureYa112Plus_venn.html",
      "text": "texts/main_FigureYa112Plus_venn_FigureYa112Plus_venn.txt",
      "folder": "FigureYa112Plus_venn",
      "thumb": "gallery_compress/FigureYa112Plus_venn.webp"
    },
    "word_count": 1979,
    "lines_count": 417,
    "title": "FigureYa112Plus_venn",
    "description": "vennyhttp://bioinfogp.cnb.csic.es/tools/venny/，新出来个选项，颜色填充by%。 缺点：只能填充灰色，只能保存成png。 我想要彩色，我想要pdf矢量图。",
    "input_data_types": [
      "临床数据"
    ],
    "output_types": [
      "火山图",
      "统计表格"
    ],
    "technical_methods": [
      "质量控制",
      "差异表达分析"
    ],
    "biology_areas": [
      "免疫学"
    ],
    "complexity_level": "高级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "header",
      "width",
      "group",
      "label_alpha",
      "method",
      "sep",
      "high",
      "height",
      "LANGUAGE"
    ]
  },
  {
    "id": "main_FigureYa32ID_table_FigureYa32ID_table",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa32ID_table_FigureYa32ID_table.txt",
    "content": "FigureYa32 ID_table\nFigureYa32 ID_table\nAuthor(s)\n: Shipeng Guo; Ying Ge, Yijing Chen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n用基因ID提取基因表达量，输出csv文件，作为下一步分析的输入文件。\nGene ID is used to extract the gene expression and output a csv file\nto be used as an input file for the next analysis.\n应用场景\nApplication scenario\n场景一：GO富集分析获得了GO\nterm里的多个基因，需要获得这些基因的表达矩阵。\n场景二：手里有已分类的基因列表，想提取相应的表达矩阵。\n下一步，根据实际需要，用下面这些代码进行可视化：\n用\nFigureYa9 heatmap\n绘制heatmap，为单个GO\nterm对应的基因进行聚类分析。\n用\nFigureYa17 已分类的heatmap\n绘制多个GO\nterm对应基因的heatmap\n用\nFigureYa12 box\n批量绘制单个基因的box plot\n用\nFigureYa16 fitting\n批量绘制表达谱曲线\nScenario 1: GO enrichment analysis has obtained multiple genes in the\nGO term, and the expression matrix of these genes needs to be\nobtained.\nScenario 2: We have a list of categorized genes in hand, and we want\nto extract the corresponding expression matrices.\nIn the next step, visualize with these codes below as per the actual\nneed:\nPlot the heatmap with\nFigureYa9 heatmap\nto perform\ncluster analysis for the genes corresponding to a single GO\nterm.\nPlot heatmap for multiple GO term corresponding genes with\nFigureYa17 categorized heatmap\nBatch plot box plot of individual genes with\nFigureYa12 box\n.\nBatch plot expression profiles with\nFigureYa16 fitting\n.\n输入文件\nInput file\n需要两种文件：\n基因列表文件，\nnot_easy_input.txt\n或\nGO*.txt\n表达矩阵文件，\nnot_easy_input_expr.txt\n或\neasy_input_expr.txt\n。\nTwo types of files are needed:\nGene list file,\nnot_easy_input.txt\nor\nGO*.txt\nExpression matrix file,\nnot_easy_input_expr.txt\nor\neasy_input_expr.txt\n.\n基因表达矩阵\nGene expression matrix\n每行一个基因，每列一个sample\nOne gene per row, one sample per column\nsource(\"install_dependencies.R\")\nexprSet<-read.table(\"not_easy_input_expr.txt\",as.is = T)\nexprSet[1:3,1:5]\n如果你不需要排序，可以跳过下面这段，直接进入“基因列表”。\n下面按照表达量由高到低给基因排序：\nIf you don’t need to sort, you can skip the following paragraph and\ngo directly to the “Gene list”.\nBelow, the genes are ranked in descending order based on their\nexpression levels:\nlibrary(dplyr)\nlibrary(tidyr)\nlibrary(tibble)\nexprSet <- exprSet %>% \n  #把行名变成一列，命名为symbol\n  #turn the row name into a column named symbol\n  rownames_to_column(var = \"symbol\")%>% \n  #新建一列rowMeans，每一行求平均值并填充进去\n  #create a new rowMeans column, average each row and fill it in\n  dplyr::mutate(rowMeans =rowMeans(.[grep(\"TCGA\", names(.))])) %>%\n  #按照求得的平均值把其他列从高到低排序\n  #sort the other columns from highest to lowest according to the average value obtained\n  dplyr::arrange(desc(rowMeans)) %>% \n  #把symbol这一列变成行名\n  #turn the symbol column into a row name\n  tibble::column_to_rownames(var = \"symbol\")%>% \n  #去掉平均值那一列\n  #remove the average column\n  dplyr::select(-rowMeans)\n\nwrite.table(exprSet[,1:10],\"easy_input_expr.txt\",quote = F)\neasy_input_expr.txt\n是按基因表达量从高到低排好序的表达矩阵。\neasy_input_expr.txt\nis an expression matrix sorted from\nhighest to lowest gene expression.\n基因列表\nGene list\n如果你的基因列表已经整理成\nGO*.txt\n那样，就可以跳过这步，直接进入“开始提取”。\n此处的输入文件是GO富集分析的输出文件：\nnot_easy_input_GO.txt\n，每行一个GO\nterm，GO terms对应的基因位于第8列，并且以“/”号分隔。\n以下代码同样适用于\nFigureYa11bubbles\n的\nnoteasy_input.txt\n，该文件里基因名以“,\n”分隔，只需把下面代码里的\n/\n改为\n,\n。\nIf your gene list has been organized like\nGO*.txt\n, you\ncan skip this step and go directly to\nStart extraction\n.\nThe input file here is the output file from the GO enrichment\nanalysis:\nnot_easy_input_GO.txt\n. Each row contains a GO\nterm, and the genes corresponding to these GO terms are located in the\n8th column, separated by “/”.\nThe following code also applies to\nnoteasy_input.txt\nof\nFigureYa11bubbles\n, where the gene names are separated by\n“,”, just change\n/\nto\n,\nin the code below.\nego_BP_df<- read.table(\"not_easy_input_GO.txt\",sep = \"\\t\")\nego_BP_df[1:3,]\n#输出排名靠前的GO term里的基因\n#此处输出前两个\n#output the genes in the top ranked GO term\n#output the first two here\nfor (i in 1:2){\n  #此处用\"/\"分隔基因列表，这取决于你的基因ID之间用的是哪个分隔符\n  #the list of genes is separated here by “/”, depending on which separator is used between your gene ID\n  genelist <- unlist(strsplit(as.character(ego_BP_df[i,]$geneID),\"/\")) \n  write.table(genelist,paste0(rownames(ego_BP_df)[i],\".txt\"),row.names = F,col.names = F,quote = F)\n}\n\n#或者提取特定的几个GO term\n#or extract a few specific GO terms\nGO_id <- c(\"GO:0060333\",\"GO:0050900\") #把你想要提取的GO term放在这里 put the GO term you want to extract here\nfor (i in 1:length(GO_id)){\n  index <- grep(GO_id[i],ego_BP_df$ID) #在总GO term列表中的位置 position in the total GO term list\n  genelist <- unlist(strsplit(as.character(ego_BP_df[index,]$geneID),\"/\"))\n  write.table(genelist,paste0(GO_id[i],\".txt\"),row.names = F,col.names = F,quote = F)\n}\n到这里，基因名就被整理成\nGO*.txt\n文件的格式：\n基因列表保存在多个文件里，每个文件包含一个GO term的基因ID。\n基因名呈一列，每行一个基因名。\nBy this point, gene names are organized into the format of\nGO*.txt\nfiles:\nThe list of genes is saved in multiple files, each containing the\ngene ID of a GO term.\nGene names are presented in a column, one gene name per row.\n开始提取\nStart extraction\n读入基因表达矩阵\nRead the gene expression matrix\nexprSet<-read.table(\"easy_input_expr.txt\",as.is = T)\nexprSet[1:3,1:5]\n从基因列表文件逐一提取表达矩阵，保存到文件\nExtract expression matrix from gene list file one by one, save to\nfile\n#按照文件名的规律，读取基因列表文件\n#即使你只有一个基因ID列表文件，也可以这样操作\n#read the gene list file according to the pattern of file names\n#even if you only have one gene ID list file, you can still do this\nfnames<-Sys.glob(\"GO*.txt\") \n\nfor (i in 1:length(fnames)){\n  genelist<-read.table(fnames[i])\n  #按表达矩阵中基因的顺序排列\n  #arrange in the order of genes in the expression matrix.\n  genelist <- rownames(exprSet)[rownames(exprSet) %in% genelist$V1]\n  genelist_expr <- exprSet[genelist,]\n  write.csv(genelist_expr,paste0(unlist(strsplit(fnames[i],\".txt\"))[1],\".csv\"),quote = F)\n}\n这里输出的\nGO*.csv\n文件里就是基因表达矩阵。\n通常情况下，到这里就结束了。除非：\n你要用一条pheatmap命令画出多个GO\nterm里的基因，就要继续运行下面的代码：\nHere in the output\nGO*.csv\nfile is the gene expression\nmatrix.\nNormally, it ends here. Unless:\nYou want to draw the genes in multiple GO terms with a single\npheatmap command, go ahead and run the following code:\n重复出现的基因名处理\nHandling of repeated gene names\n例如用\nFigureYa17 已分类heatmap\n，一步画出所有GO\nterm里的基因表达谱heatmap。\n会遇到报错提示“基因名不唯一”。\n那是因为很多基因在多个GO\nterm间重复出现，因此，用下面代码在基因名后面加上数字，以区分来源于不同GO\nterm的同一基因。\nFor example, using\nFigureYa17 Classified Heatmap\n, you\ncan draw a heatmap of gene expression profiles in all GO terms in one\nstep.\nYou will encounter an error message “Gene name not unique”.\nThat’s because many genes are recurring in multiple GO terms, so use\nthe following code to add a number after the gene name to distinguish\nthe same gene from different GO terms.\nfnames<-Sys.glob(\"GO*.txt\")\n\nfor (i in 1:length(fnames)){\n  genelist<-read.table(fnames[i])\n  #按照表达矩阵中的位置排序\n  #sort by position in the expression matrix\n  genelist <- rownames(exprSet)[rownames(exprSet) %in% genelist$V1]\n  genelist_expr <- exprSet[genelist,]\n  #在基因名后面加上“.数字”\n  #after the gene name, add “.number”\n  rownames(genelist_expr)<-paste0(rownames(genelist_expr),\".\",i) \n  write.csv(genelist_expr,paste0(unlist(strsplit(fnames[i],\".txt\"))[1],\".csv\"),quote = F)\n}\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa32ID_table_FigureYa32ID_table",
      "title": "FigureYa32ID_table/FigureYa32ID_table.html",
      "html": "FigureYa32ID_table/FigureYa32ID_table.html",
      "text": "texts/main_FigureYa32ID_table_FigureYa32ID_table.txt",
      "folder": "FigureYa32ID_table",
      "thumb": "gallery_compress/FigureYa32ID_table.webp"
    },
    "word_count": 899,
    "lines_count": 261,
    "title": "FigureYa32 ID_table",
    "description": "Requirement description 用基因ID提取基因表达量，输出csv文件，作为下一步分析的输入文件。 Gene ID is used to extract the gene expression and output a csv file",
    "input_data_types": [
      "表达矩阵"
    ],
    "output_types": [
      "热图",
      "统计表格"
    ],
    "technical_methods": [
      "聚类分析",
      "通路分析"
    ],
    "biology_areas": [],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "quote",
      "rowMeans",
      "var",
      "names",
      "is"
    ]
  },
  {
    "id": "main_FigureYa200pairwiseAUC_FigureYa200pairwiseAUC",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa200pairwiseAUC_FigureYa200pairwiseAUC.txt",
    "content": "FigureYa200pairwiseAUC\nFigureYa200pairwiseAUC\nAuthor(s)\n: Xiaofan Lu\nReviewer(s)\n: Ying Ge, Hui Huang\nDate\n: 2025-10-07\nAcademic Citation\nIf you use this code in your work or research, we kindly request that you cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization Framework for Enhancing Biomedical Data Interpretation and Research Efficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n我想实现Figure 1B，两个数据集里面看预后判断力都很好的基因。\nRequirement Description\nI want to draw Figure 1B, and look at the genes with good prognostic judgment in both datasets.\n出自\nhttps://aasldpubs.onlinelibrary.wiley.com/doi/abs/10.1002/hep.30930\nFrom\nhttps://aasldpubs.onlinelibrary.wiley.com/doi/abs/10.1002/hep.30930\nFIg. 1. PDLIM1 is down-regulated in human metastatic HCC tissues. (A) Heat map showing 402 genes differentially expressed in HCC tissues with or without metastasis based on data set\nGSE364\n. (B) area under the curve evaluation of the prognostic value of candidate genes involved in metastasis-related events based on data sets\nTCGA and GSE10816\n. Those genes with no detectable protein expression in liver cancer were excluded and are colored in\ngray\n.\n应用场景\n训练集定义候选基因，后在两个测试集里寻找预后判断力都好的基因集合。\nApplication Scenarios\nThe training set defines the candidate genes, and then looks for the set of genes with good prognostic judgment in both test sets.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nlibrary(limma)       # 芯片差异表达 # Differential expression of chips\nlibrary(impute)      # 芯片缺失值多重填补 # Chip missing values are multi-filled\nlibrary(dplyr)       # 用于数据筛选、变换和汇总 # Data manipulation package for filtering, transforming, and summarizing data\nlibrary(pheatmap)    # 用于生成热图 # Heatmap plotting package for generating heatmaps\nlibrary(gplots)      # 提供额外的绘图功能 # Graphics plotting package providing additional plotting functionalities\nlibrary(pROC)        # 用于计算AUC值 # ROC curve analysis package for calculating AUC values\nlibrary(ggplot2)     # 用于绘制图形 # Data visualization package for creating plots\n\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # error messages are displayed in English\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # It is forbidden to convert chr into factor\n自定义函数 Custom functions\n# 自定义函数显示进度 # Custom functions display progress\ndisplay.progress = function ( index, totalN, breakN=20) {\n  if ( index %% ceiling(totalN/breakN)  ==0  ) {\n    cat(paste(round(index*100/totalN), \"% \", sep=\"\"))\n  }\n} \n\n# 自定义函数标准化表达谱 # Custom functions normalize the expression spectrum\nstandarize.fun <- function(indata=NULL, halfwidth=NULL, centerFlag=T, scaleFlag=T) {  \n  outdata=t(scale(t(indata), center=centerFlag, scale=scaleFlag))\n  if (!is.null(halfwidth)) {\n    outdata[outdata>halfwidth]=halfwidth\n    outdata[outdata<(-halfwidth)]= -halfwidth\n  }\n  return(outdata)\n}\n输入文件\n需要多套带预后信息的表达数据，分别作为训练集和测试集。\n训练集：\nGSE364.expr.txt\nGSE364.sinfo.txt\n测试集：\nLIHC.expr.txt (TCGA)\nLIHC.sinfo.txt (TCGA)\nGSE10186.expr.txt\nGSE10186.sinfo.txt\nInput Files\nMultiple sets of expression data with prognostic information are required, serving as the training set and test set, respectively.\nTraining Set:\nGSE364.expr.tx\nGSE364.sinfo.txt\nTest Set:\nLIHC.expr.txt (TCGA)\nLIHC.sinfo.txt (TCGA)\nGSE10186.expr.txt\nGSE10186.sinfo.txt\n加载训练集数据 —— GSE364\nLoad the training set data - GSE364\ngse364.expr <- read.table(\"GSE364.expr.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\ngse364.sinfo <- read.table(\"GSE364.sinfo.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\n#gse364.sinfo$prefix <- sapply(strsplit(gse364.sinfo$Title,\"-\",fixed = T),\"[\",1)\nmeta.sam <- rownames(gse364.sinfo[grep(\"-M[12]$\",gse364.sinfo$Title),]) # \nlocal.sam <- rownames(gse364.sinfo[grep(\"-P[12]$\",gse364.sinfo$Title),]) # 例文只有29个样本 # There are only 29 samples in the example\n#comid <- intersect(meta.sam$prefix,local.sam$prefix) # 本以为是配对样本但是配对只有20个 # I thought it was a paired sample, but there were only 20 pairings\n\ngse364.expr <- gse364.expr[,c(meta.sam,local.sam)] %>% as.matrix() %>% impute.knn()\ngse364.expr <- log2(gse364.expr$data + 1) %>% as.data.frame()\n加载测试集\nLoad the test set\n# TCGA\nlihc.expr <- read.table(\"LIHC.expr.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\nlihc.sinfo <- read.table(\"LIHC.sinfo.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\ncomsam <- intersect(colnames(lihc.expr), rownames(lihc.sinfo))\nlihc.expr <- log2(lihc.expr[,comsam] + 1)\nlihc.sinfo <- lihc.sinfo[comsam,,drop = F]\n\n# GSE10186\ngse10186.expr <- read.table(\"GSE10186.expr.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\ngse10186.sinfo <- read.table(\"GSE10186.sinfo.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\ncomsam <- intersect(colnames(gse10186.expr), rownames(gse10186.sinfo))\ngse10186.expr <- log2(gse10186.expr[,comsam] + 1)\ngse10186.sinfo <- gse10186.sinfo[comsam,,drop = F]\n\n# 处理预后信息\n# Process prognostic information\nlihc.sinfo$fustat <- ifelse(lihc.sinfo$OS == 1 | lihc.sinfo$PFI == 1, 1, 0) # death or progression\n用训练集定义候选基因集\nDefine the candidate gene set with the training set\n用limma分析差异表达，定义候选基因集，顺便画出图A\nDifferential expression analysis was conducted using the limma package, followed by the identification of candidate genes. Figure A was generated to visualize the results.\npd <- data.frame(Samples = c(meta.sam,local.sam),\n                 Group = rep(c(\"meta\",\"local\"),c(length(meta.sam),length(local.sam))),\n                 row.names = c(meta.sam,local.sam),\n                 stringsAsFactors = FALSE)\ndesign <- model.matrix(~ -1 + factor(pd$Group, levels = c(\"meta\",\"local\")))\ncolnames(design) <- c(\"meta\",\"local\")\nfit <- limma::lmFit(as.matrix(gse364.expr), design = design);\ncontrastsMatrix <- limma::makeContrasts(meta - local, levels = c(\"meta\", \"local\"))\nfit2 <- limma::contrasts.fit(fit, contrasts = contrastsMatrix)\nfit2 <- limma::eBayes(fit2, 0.01)\nresData <- limma::topTable(fit2, adjust = \"fdr\", sort.by = \"B\", number = 100000)\nresData <- as.data.frame(subset(resData, select=c(\"logFC\",\"t\",\"B\",\"P.Value\",\"adj.P.Val\")))\nresData$id <- rownames(resData)\ncolnames(resData) <- c(\"log2fc\",\"t\",\"B\",\"pvalue\",\"padj\",\"id\")\nresData$fc <- 2^resData$log2fc\nresData <- resData[order(resData$padj),]\nresData <- resData[,c(\"id\",\"fc\",\"log2fc\",\"t\",\"B\",\"pvalue\",\"padj\")]\n\n# 定义差异表达基因 （原文用log2fc>0.6和p<0.05的阈值我完全找不到差异表达基因，即便用GEO2R网页分析也没有任何满足阈值的基因）\n# Defining Differentially Expressed Genes (DEGs) (Using the thresholds of |log2FC| > 0.6 and p < 0.05, I was unable to identify any differentially expressed genes (DEGs). Even when analyzing the data with GEO2R, no genes met the significance criteria.)\n\nupgene <- rownames(resData[which(resData$log2fc > 0 & resData$pvalue < 0.1),])\ndngene <- rownames(resData[which(resData$log2fc < 0 & resData$pvalue < 0.1),])\n\n# 用前面自定义的函数做标准化\n# Standardize with the previous custom function\nplotdata <- standarize.fun(gse364.expr[c(upgene, dngene),],halfwidth = 3)\n\nannCol <- pd\nannRow <- data.frame(Dys = rep(c(\"up\",\"dn\"),c(length(upgene),length(dngene))),\n                     row.names = c(upgene,dngene),\n                     stringsAsFactors = F)\nannColors <- list(Group = c(\"meta\"=\"red\",\"local\"=\"blue\"),\n                  Dys = c(\"up\"=\"darkred\",\"dn\"=\"darkblue\"))\npheatmap(plotdata,\n         cluster_cols = F,\n         cluster_rows = F,\n         annotation_col = annCol[,\"Group\",drop = F],\n         annotation_row = annRow,\n         annotation_colors = annColors,\n         show_rownames = F,\n         show_colnames = F,\n         color = greenred(64),\n         border_color = NA)\ndev.copy2pdf(file = \"heatmap.pdf\", width = 5,height = 5)\nwrite.table(annRow,\"differential expressed gene.txt\",sep = \"\\t\",row.names = T,col.names = NA,quote = F)\n在两个测试集里寻找预后判断力都好的基因集合\nLook for a set of genes with good prognostic judgment in both test sets\n# 计算auc\n# Calculate the AUC\ncomgene <- intersect(intersect(rownames(gse10186.expr),\n                               rownames(lihc.expr)),\n                     rownames(annRow))\nauc1 <- auc2 <- c()\nfor (i in comgene) {\n  # TCGA-LIHC\n  tmp <- data.frame(expr = as.numeric(lihc.expr[i,]),\n                    fustat = lihc.sinfo$fustat,\n                    stringsAsFactors = F)\n  auc1 <- c(auc1, roc(predictor = tmp$expr, response = tmp$fustat)$auc)\n  \n  # GSE10186\n  tmp <- data.frame(expr = as.numeric(gse10186.expr[i,]),\n                    fustat = gse10186.sinfo$fustat,\n                    stringsAsFactors = F)\n  auc2 <- c(auc2,roc(predictor = tmp$expr,response = tmp$fustat)$auc)\n}\nnames(auc1) <- names(auc2) <- comgene\n\n# 原文在Human Protemome Project上去找哪些定义的基因是有人类蛋白表达的，这里我就随便取了几个基因，只是为了绘图方便而已。\n# 找到满足条件的基因\n# To identify genes with confirmed human protein expression, original article referenced the Human Proteome Project database. For illustrative purposes, I selected a subset of genes meeting these criteria solely for visualization convenience\n# Find the genes that meet the criteria\nFAKE.protein.positive <- sample(comgene, size = 0.7 * length(comgene)) #随机取了一些基因作为蛋白表达基因\n# A number of genes were randomly selected as protein expression genes\nFAKE.protein.negtive <- setdiff(comgene, FAKE.protein.positive)\n\nauc1.cutoff <- 0.55\nauc2.cutoff <- 0.55\nfinalgene <- intersect(comgene[auc1 > auc1.cutoff & auc2 > auc2.cutoff], FAKE.protein.positive) # 既满足阈值又是蛋白表达的基因 # Genes that both meet the threshold and are protein expressed\navgauc <- c(auc1[finalgene] + auc2[finalgene])/2\npickgene <- \"B4GALNT1\" # 因为和原文结果不同所以随便选的 # As it is different from the original result, I choose it willingly\n开始画图\nStart plot\n用base plot画图，从plot开始整段运行。\nDraw with base plot and run the entire section from the plot\nxrange <- pretty(range(auc1))\nyrange <- pretty(range(auc2))\n\npar(mfrow = c(1,2)) # 把画布分成左右两个 # Divide the canvas into two sides, left and right\npar(bty=\"l\", mgp = c(2.4,.33,0), mar=c(4.1,4.6,2.1,2.1)+.1, las=1, tcl=-.25)\n\n# 绘制“假的”有蛋白表达的散点\n# Plot the \"fake\" scatter with protein expression\nplot(x = auc1[FAKE.protein.positive],\n     y = auc2[FAKE.protein.positive],\n     xlab = \"AUC for disease event\\ninTCGA-LIHC\",\n     ylab = \"AUC for disease event\\nin GSE10186\",\n     pch = 19,\n     col = \"#5D7ABE\",\n     cex = 1.2,\n     xlim = c(xrange[1],xrange[length(xrange)]),\n     ylim = c(yrange[1],yrange[length(yrange)]),\n     xaxt = \"n\",\n     yaxt = \"n\")\n# 添加“假的”无蛋白表达的散点\n# Add \"fake\" scatters without protein expression\npoints(x = auc1[FAKE.protein.negtive],\n       y = auc2[FAKE.protein.negtive],\n       pch = 19,\n       cex = 1.2,\n       col = ggplot2::alpha(\"grey70\", 0.8))\n# 添加“假的”有蛋白表达且AUC满足阈值且感兴趣的目标基因\n# Add the \"fake\" target gene that has protein expression and AUC meets the threshold and is of interest\npoints(x = auc1[pickgene],\n       y = auc2[pickgene],\n       pch = 19,\n       cex = 1.2,\n       col = ggplot2::alpha(\"red\", 0.8))\naxis(side = 1,at = xrange)\naxis(side = 2,at = yrange)\n# 添加阈值区域框\n# Add a threshold area box\nrect(xleft = auc1.cutoff,xright = max(auc1) + 0.01,\n     ybottom = auc2.cutoff,ytop = max(auc2) + 0.01,\n     lwd = 1.5,\n     lty = 2)\n\n# 右侧绘制AUC均值\n# The AUC mean is plotted on the right\npar(bty=\"l\", mgp = c(1.9,.33,0), mar=c(4.1,5.1,2.1,2.1)+.1, las=1, tcl=-.25)\na <- barplot(sort(avgauc,decreasing = F),\n        horiz = T,\n        col = ifelse(names(sort(avgauc,decreasing = F)) == pickgene,\"red\",\"#5D7ABE\"),\n        xlab = \"Mean AUC\")\naxis(side = 2,at = a,labels = F)\ndev.copy2pdf(file = \"combined pairwise auc.pdf\", width = 9, height = 5)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa200pairwiseAUC_FigureYa200pairwiseAUC",
      "title": "FigureYa200pairwiseAUC/FigureYa200pairwiseAUC.html",
      "html": "FigureYa200pairwiseAUC/FigureYa200pairwiseAUC.html",
      "text": "texts/main_FigureYa200pairwiseAUC_FigureYa200pairwiseAUC.txt",
      "folder": "FigureYa200pairwiseAUC",
      "thumb": "gallery_compress/FigureYa200pairwiseAUC.webp"
    },
    "word_count": 1316,
    "lines_count": 254,
    "title": "FigureYa200pairwiseAUC",
    "description": "我想实现Figure 1B，两个数据集里面看预后判断力都很好的基因。 Requirement Description I want to draw Figure 1B, and look at the genes with good prognostic judgment in both datasets.",
    "input_data_types": [
      "临床数据"
    ],
    "output_types": [
      "火山图",
      "热图",
      "统计表格",
      "散点图"
    ],
    "technical_methods": [
      "标准化",
      "差异表达分析"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "annotation_col",
      "center",
      "header",
      "lwd",
      "width",
      "cluster_cols",
      "ylim",
      "xlim",
      "side"
    ]
  },
  {
    "id": "main_FigureYa208FPI_FigureYa208FPI",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa208FPI_FigureYa208FPI.txt",
    "content": "FigureYa208FPI\nFigureYa208FPI\nAuthor(s)\n: Xiaofan Lu; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-05-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirements Description\n想实现铁死亡指数（FPI）的计算方法，根据基因表达，算出ssGSEA富集分数，再计算FPI，并用GSE121689数据集验证。\nI want to try the calculation method of the Ferroptosis Potential\nIndex (FPI), which involves calculating ssGSEA enrichment scores based\non gene expression, then deriving the FPI, and validating it using the\nGSE121689 dataset.\n图2. FPI与癌症组织学类型和分子亚型的关系。 (A)\n不同癌症类型中肿瘤组织与正常组织间FPI的差异比较。\nFigure 2. The Relations between FPI and Histological Types and\nMolecular Subtypes among Cancers. (A) The different FPIs between tumor\nand normal tissues among cancers.\n出自：\nhttps://linkinghub.elsevier.com/retrieve/pii/S2589004220304892\nSource:\nhttps://linkinghub.elsevier.com/retrieve/pii/S2589004220304892\n应用场景\nApplication Scenario\n例文通过查文献收集基因，用GSVA计算正负两个基因集的富集分数，然后计算FPI。\n可批量计算多组（TCGA pancancer\nRNA-seq）、也可以单独计算一个数据集（GEO表达谱数据）。\n另外，不仅可以计算铁死亡指数FPI，还可以按照这个方法，替换为自己收集的某一功能相关的基因集，自己自定义一个某某指数。\nThe example demonstrates collecting genes from literature,\ncalculating enrichment scores for both positive and negative gene sets\nusing GSVA, and then deriving the FPI.\nThis method can be applied to batch-process multiple datasets (e.g.,\nTCGA pan-cancer RNA-seq) or analyze a single dataset (e.g., GEO\nexpression profile data).\nAdditionally, it is not limited to calculating the Ferroptosis\nPotential Index (FPI). By replacing the gene sets with custom\ncollections related to a specific function, users can define their own\n“XX Index” following the same approach.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(data.table)\nlibrary(GSVA)\nlibrary(ggplot2)\n\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\")\n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n输入文件\nInput Files\n下载TCGA pan-cancer数据\nDownload TCGA Pan-Cancer Data\nGSVA的输入数据可以是microarray data，也可以是RNA-seq\ncount、CPM、RPKM、TPM。\n原文：We calculate now GSVA enrichment scores for these gene sets\nusing first the microarray data and then the\nRNA-seq integer\ncount\ndata. Note that the only requirement to do the latter is\nto set the argument\nkcdf=“Poisson”\nwhich is “Gaussian”\nby default. Note, however, that if our RNA-seq derived expression levels\nwould be\ncontinous, such as log-CPMs, log-RPKMs or\nlog-TPMs\n, the the default value of the\nkcdf argument\nshould remain unchanged\n.\n出自：\nhttps://www.bioconductor.org/packages/release/bioc/vignettes/GSVA/inst/doc/GSVA.pdf\n表达矩阵和Gene mapping：\n这里跟FigureYa55panCancer_violin保持一致，从\nXENA\n下载UCSC Toil RNA-seq\nRecompute TPM：\nTCGA\nPan-Cancer (PANCAN) (41 datasets)\n里的\nTOIL\nRSEM tpm (n=10,535) UCSC Toil RNA-seq Recompute\n，\nGene\nMapping\n或者下载GDC pipeline的FPKM-UQ：\nGDC\nPan-Cancer (PANCAN) (17 datasets)\n里的\nHTSeq\n- FPKM-UQ (n=11,768) GDC Hub\n，\nGene\nMapping\nTCGA_phenotype_denseDataOnlyDownload.tsv，样本注释。\nTCGA\nPan-Cancer (PANCAN) (41 datasets) phenotype\n里的\nsample\ntype and primary disease (n=12,804) Pan-Cancer Atlas\nHub\n，只有癌症全称，没有缩写。\nsamplepair.txt，癌症缩写跟全称的对应关系\nGSVA input data can be microarray data or RNA-seq counts, CPM, RPKM,\nTPM.\nOriginal text: We calculate now GSVA enrichment scores for these gene\nsets using first the microarray data and then the\nRNA-seq\ninteger count\ndata. Note that the only requirement to do the\nlatter is to set the argument\nkcdf=“Poisson”\nwhich is\n“Gaussian” by default. Note, however, that if our RNA-seq derived\nexpression levels would be\ncontinuous, such as log-CPMs,\nlog-RPKMs or log-TPMs\n, then the default value of the\nkcdf argument should remain unchanged\n.\nSource:\nhttps://www.bioconductor.org/packages/release/bioc/vignettes/GSVA/inst/doc/GSVA.pdf\nExpression matrix and Gene mapping:\nTo maintain consistency with FigureYa55panCancer_violin, download\nUCSC Toil RNA-seq Recompute TPM from\nXENA\n:\nTCGA\nPan-Cancer (PANCAN) (41 datasets)\n:\nTOIL\nRSEM tpm (n=10,535) UCSC Toil RNA-seq Recompute\n，\nGene\nMapping\nOr download GDC pipeline FPKM-UQ:\nGDC\nPan-Cancer (PANCAN) (17 datasets)\n:\nHTSeq\n- FPKM-UQ (n=11,768) GDC Hub\n，\nGene\nMapping\nTCGA_phenotype_denseDataOnlyDownload.tsv, sample annotation.\nTCGA\nPan-Cancer (PANCAN) (41 datasets) phenotype\n:\nsample\ntype and primary disease (n=12,804) Pan-Cancer Atlas Hub\n, contains\nonly full cancer names without abbreviations.\nsamplepair.txt, mapping between cancer abbreviations and full\nnames\n# 读取泛癌表达谱和基因名文件\n# 文件较大，占内存，请谨慎操作\n# Reading Pan-cancer Expression Profiles and Gene Annotation Files\n# Large file size, memory intensive - proceed with caution\npanexpr <- fread(\"tcga_RSEM_gene_tpm\",sep = \"\\t\",header = T,check.names = F,stringsAsFactors = F)\nannopb <- read.delim(\"gencode.v23.annotation.gene.probemap\",row.names = 1,check.names = F,stringsAsFactors = F,header = T,sep = \"\\t\")\n\n# 匹配基因名\n# Gene Name Matching\npanexpr <- as.data.frame(panexpr)\nrownames(panexpr) <- panexpr$sample; panexpr <- panexpr[,-1]\ncomgene <- intersect(rownames(annopb), rownames(panexpr))\npanexpr <- panexpr[comgene,]; annopb <- annopb[comgene,]\npanexpr$genename <- annopb$gene; panexpr <- panexpr[!duplicated(panexpr$genename),]\nrownames(panexpr) <- panexpr$genename; panexpr <- panexpr[,-ncol(panexpr)]\npanexpr[1:3,1:3]\n# 读取样本注释\n# Reading Sample Annotations\ntcgacase <- read.delim(file=\"TCGA_phenotype_denseDataOnlyDownload.tsv\",header = T,row.names = NULL,check.names = F,stringsAsFactors = F,sep = \"\\t\")\ntcgacase[1:2,]\n# 读取疾病缩写和全称\n# Reading Disease Abbreviations and Full Names\nsamplepair <- read.delim(\"samplepair.txt\",as.is = T)\ntissueinfo <- samplepair[,1:2]\ntissueinfo[1:2,]\n# 把疾病缩写加到样本注释里\n# Adding disease abbreviations to sample annotations\ncolnames(tcgacase)[4] <- \"Detail\"\ntcgacase <- merge(tcgacase, tissueinfo, by = \"Detail\", all.x = T)\nrownames(tcgacase) <- tcgacase$sample\n\n# 取出原位癌以及癌旁样本\n# Extracting Primary Tumor and Adjacent Normal Samples\ntcgacase <- tcgacase[which(tcgacase$sample_type_id %in% c(1,11)),]\n\n# 取出例文图中的癌症Samples\n# Extracting Cancer Samples Shown in Example Figure\ntumors <- c(\"KIRC\",\"THCA\",\"COAD\",\"STAD\",\"CHOL\",\"LUAD\",\"HNSC\",\"LIHC\",\"KIRP\",\"READ\",\"PRAD\",\"LUSC\",\"GBM\",\"ESCA\",\"BLCA\",\"PAAD\",\"UCEC\",\"BRCA\",\"KICH\",\"CESC\")\ntcgacase <- tcgacase[which(tcgacase$TCGA %in% tumors),]\n\n# 提取既有表达数据又有样本注释信息的Samples\n# Extracting Samples with Both Expression Data and Annotations\ncomsam <- intersect(colnames(panexpr),rownames(tcgacase)) \ntcgacase <- tcgacase[comsam,] # TCGA的sample\n\n# 提取pancancer表达矩阵\n# Extracting Pan-cancer Expression Matrix\npanexpr <- panexpr[,comsam]\n\n# 输出到文件，可用于后续更多分析\n# Output to file for downstream analysis\n#write.csv(panexpr, \"output_pancancer_expr.csv\", quote = F)\n计算FPI\nCalculating FPI\n套用例文计算FPI的方法，你也可以自己定义个某某index/score。\n查文献定义了24个ferroptosis regulator genes (FRGs)。\n原文：In this study, the twenty four genes that were identified to\nplay critical roles in regulating ferroptosis by pre- vious studies were\ndefined as ferroptosis regulator genes (FRGs).\n定义了两类基因：positive components (pos.comp)和negative components\n(neg.comp)。\n原文：The index to represent the ferroptosis level was establish\nbased on the expression data for genes of ferroptosis core machine\nincluding positive components of LPCAT3, ACSL4, NCOA4, ALOX15, GPX4,\nSLC3A2, SLC7A11, NFE2L2, NOX1, NOX3, NOX4, NOX5 and negative components\nof FDFT1, HMGCR, COQ10A, COQ10B.\n用GSVA里的ssGSEA计算positively (pos.comp) or negatively (neg.comp)\nregulated ferroptosis的enrichment score，二者相减就是FPI。\n原文：The enrichment score (ES) of gene set that positively or\nnegatively regulated ferroptosis was calculated using single sample gene\nset enrichment analysis (ssGSEA) in the R package ‘GSVA’ (Hanzelmann et\nal., 2013), and the normalized differences between the ES of the\npositive components minus negative components was defined as the\nferroptosis potential index (FPI) to computationally dissect the\nferroptosis levels/trends of the tissue samples.\nFollowing the example method for calculating FPI, you can also define\nyour own XX index/score.\nLiterature review identified 24 ferroptosis regulator genes\n(FRGs).\nOriginal text: In this study, the twenty four genes that were\nidentified to play critical roles in regulating ferroptosis by pre-\nvious studies were defined as ferroptosis regulator genes (FRGs).\nDefined two gene categories: positive components (pos.comp) and\nnegative components (neg.comp).\nOriginal text: The index to represent the ferroptosis level was\nestablish based on the expression data for genes of ferroptosis core\nmachine including positive components of LPCAT3, ACSL4, NCOA4, ALOX15,\nGPX4, SLC3A2, SLC7A11, NFE2L2, NOX1, NOX3, NOX4, NOX5 and negative\ncomponents of FDFT1, HMGCR, COQ10A, COQ10B.\nUsing ssGSEA in GSVA to calculate enrichment scores for positively\n(pos.comp) or negatively (neg.comp) regulated ferroptosis, with FPI\nobtained by subtracting the two.\nOriginal text: The enrichment score (ES) of gene set that positively\nor negatively regulated ferroptosis was calculated using single sample\ngene set enrichment analysis (ssGSEA) in the R package ‘GSVA’\n(Hanzelmann et al., 2013), and the normalized differences between the ES\nof the positive components minus negative components was defined as the\nferroptosis potential index (FPI) to computationally dissect the\nferroptosis levels/trends of the tissue samples.\n# 用ssGSEA计算\n# Calculating with ssGSEA\npos.comp <- c(\"LPCAT3\",\"ACSL4\",\"NCOA4\",\"ALOX15\",\"GPX4\",\"SLC3A2\",\"SLC7A11\",\"NFE2L2\",\"NOX1\",\"NOX3\",\"NOX4\",\"NOX5\")\nneg.comp <- c(\"FDFT1\",\"HMGCR\",\"COQ10A\",\"COQ10B\")\nfpi.sig <- list(pos.comp = pos.comp,\n                neg.comp = neg.comp)\n\n# 写个循环批量计算出所有癌症的enrichment score\n# Writing loop to batch calculate enrichment scores for all cancers\nssgsea.list <- list()\nfor (t in tumors) {\n  message(\"--analysis of \",t,\" starts...\")\n  tumsam <- rownames(tcgacase[which(tcgacase$TCGA == t & tcgacase$sample_type == \"Primary Tumor\"),])\n  norsam <- rownames(tcgacase[which(tcgacase$TCGA == t & tcgacase$sample_type == \"Solid Tissue Normal\"),])\n  \n  # 每次计算一个癌症类型的enrichment score\n  # 提取当前癌症的表达矩阵\n  # Calculating enrichment score for each cancer type\n  # Extract expression matrix for current cancer\n  expr <- panexpr[,c(tumsam,norsam)]\n\n  ## 重新对表达谱对数化（以下步骤请根据自己表达谱的情况来）\n  ## Re-logarithmize expression profile (Adjust following steps according to your expression profile)\n  \n  # 原始数据为log2(x+0.001) \n  # Original data is log2(x+0.001)\n  expr <- 2^expr - 0.001 \n  \n  # 小于0的值拉到0 \n  # Set values <0 to 0\n  expr[expr < 0] <- 0 \n  \n  # 重新对数化 \n  # Re-logarithmize\n  expr <- log2(expr + 1)\n  \n  # 去除全0值 \n  # Remove all-zero rows\n  expr <- expr[rowSums(expr) > 0,]\n  \n  # 去除平坦值 \n  # Remove flat rows\n  expr <- expr[apply(expr, 1, sd) > 0,] \n  \n  #expr <- t(scale(t(expr)))\n  \n  #write.csv(expr, paste0(\"normalized_expr_\", t, \".csv\"), quote = F)\n  \n  # 创建参数对象\n  # Create parameter object\n  params_es <- GSVA::ssgseaParam(expr = as.matrix(expr),\n                           geneSets = fpi.sig)\n\n  # 运行GSVA分析\n  # Run GSVA analysis\n  es <- GSVA::gsva(params_es)\n \n  # 存储结果 \n  # Store results\n  ssgsea.list[[t]] <- es\n  \n  # 释放内存 \n  # Free up memory\n  gc() \n}\n# 查看ssgsea.list里的结构\n# Examine structure of ssgsea.list\nssgsea.list$KIRC[,1:4]\n# 可以看出，每种癌症有两行：pos.comp和neg.comp，接下来，用这两行相减，获得每个sample的PFI\n# Each cancer has two rows: pos.comp and neg.comp. Next, subtract these to get FPI for each sample\n\n# 计算FPI\n# Calculate FPI\nfpi.res <- NULL\ndirct <- c()\nfor (t in tumors) {\n  tumsam <- rownames(tcgacase[which(tcgacase$TCGA == t & tcgacase$sample_type == \"Primary Tumor\"),])\n  norsam <- rownames(tcgacase[which(tcgacase$TCGA == t & tcgacase$sample_type == \"Solid Tissue Normal\"),])\n  \n  # 获取当前癌症的富集分数 \n  # Get enrichment scores for current cancer\n  es <- ssgsea.list[[t]]\n  \n  # 计算FPI并标准化 \n  # Calculate FPI and standardize\n  fpi <- scale(as.numeric(es[1,] - es[2,]))[,1] \n  \n  # 命名样本 \n  # Name samples\n  names(fpi) <- c(tumsam, norsam)\n  \n  # 计算肿瘤中位数 \n  # Calculate tumor median\n  med.fpi.tum <- median(fpi[tumsam]) \n  \n  # 计算正常中位数 \n  # Calculate normal median\n  med.fpi.nor <- median(fpi[norsam]) \n  \n  # 秩和检验 \n  # Wilcoxon rank sum test\n  wt <- wilcox.test(fpi[tumsam],fpi[norsam]) \n  \n  # 若肿瘤FPI大于癌旁，则标签为黄色\n  # If tumor FPI > normal, label yellow\n  dirct <- c(dirct, ifelse(med.fpi.tum > med.fpi.nor, \"yellow\", \"green\")) \n  \n  fpi.res <- rbind.data.frame(fpi.res,\n                              data.frame(sampleID = names(fpi),\n                                         fpi = as.numeric(fpi),\n                                         tissue = rep(c(\"Tumor\",\"Normal\"), c(length(tumsam),length(norsam))),\n                                         p = wt$p.value,\n                                         p.lab = ifelse(wt$p.value < 0.001,formatC(wt$p.value,format = \"e\",digits = 1), round(wt$p.value, 3)),\n                                         TCGA = t,\n                                         stringsAsFactors = F),\n                              stringsAsFactors = F)\n}\n\n# 命名方向向量 \n# Name direction vector\nnames(dirct) <- tumors\n\n# 根据标签的颜色排序 \n# Sort by label color\ndirct <- sort(dirct) \n\n# 设置因子 \n# Set factor levels\nfpi.res$TCGA <- factor(fpi.res$TCGA, levels = names(dirct)) \n\n# 查看前几行结果 \n# View first few results\nhead(fpi.res)\n# 输出到文件\n# Output to file\nwrite.csv(fpi.res, \"output_FPI.csv\", quote = F, row.names = F)\n绘制泛癌箱型图\nDrawing Pan-Cancer Boxplots\n# 定义颜色\n# Define colors\ngreen <- \"#2E8049\"\nyellow <- \"#DD8606\"\n\n# 创建ggplot对象 \n# Create ggplot object\np <- ggplot(fpi.res, aes(TCGA, fpi, fill=tissue)) + \n  geom_boxplot(outlier.shape = NA) + \n  geom_text(aes(TCGA, y = 4,\n                label = paste0(\"P = \", p.lab)),\n            data = fpi.res,\n            inherit.aes = F) +\n  scale_fill_manual(values = c(green, yellow)) + \n  scale_y_continuous(breaks = c(-2.5,0,2.5,5), labels = c(-2.5,0,2.5,5), limits = c(-3,5)) + \n  xlab(NULL) + ylab(\"FPI\") + coord_flip() +\n  theme_classic() +\n  \n  theme(axis.text.x = element_text(angle = 0, hjust = 0.5,vjust = 0.5,size = 11, colour = \"black\"),\n        axis.text.y = element_text(colour = ifelse(as.character(dirct) == \"yellow\", yellow, green), size = 10), \n        legend.position = \"bottom\",\n        legend.title = element_blank())\n# 显示图形 \n#  Display plot\np\n# 保存图形 \n# Save plot\nggsave(\"FPI_Pancancer.pdf\", width = 5, height = 6)\n输出的pdf文件是矢量图，可以用Adobe\nIllustrator等矢量图编辑器打开，移动文字位置。\nThe output PDF files are vector graphics that can be opened and\nedited in vector editing software like Adobe Illustrator, allowing you\nto reposition text elements.\nGEO数据验证FPI\nValidating FPI Using GEO Data\n这里所谓的验证，其实就是在另一套数据里看到同样的趋势。\nHere, “validation” essentially means observing the same trends in an\nindependent dataset.\n输入文件\nInput Files\n# 数据加载 (数据下载方式可参考FigureYa203ComBat)\n# Data Loading (refer to FigureYa203ComBat for download method)\ngse.expr <- read.table(\"GSE121689.expr.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\ngse.sinfo <- read.table(\"GSE121689.sinfo.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\n\n# 取出DMSO样本 \n# Extract DMSO control samples\ndmso.sam <- rownames(gse.sinfo)[grep(\"DMSO\",gse.sinfo$Title)] \n\n# 取出Erastin样本 \n# Extract Erastin-treated samples\nerastin.sam <- rownames(gse.sinfo)[grep(\"erastin\",gse.sinfo$Title)] \n\n# 处理表达谱行名并去重复\n# Processing expression matrix rownames and removing duplicates\ngse.expr$genename <- sapply(strsplit(rownames(gse.expr), \" /// \", fixed = T), \"[\", 1)\ngse.expr <- gse.expr[!duplicated(gse.expr$genename),]; rownames(gse.expr) <- gse.expr$genename; gse.expr <- gse.expr[,-ncol(gse.expr)]\n计算FPI\nCalculate FPI\n# 使用 ssgseaParam 创建参数对象\n# Creating parameter object using ssgseaParam\nparams_es.gse <- GSVA::ssgseaParam(\n  expr = as.matrix(gse.expr),  \n  geneSets = fpi.sig         \n)\n\n# 运行 GSVA 分析\n# Running GSVA analysis\nes.gse <- GSVA::gsva(params_es.gse)\n# 计算FPI\n# Calculating FPI\nfpi.gse <- as.numeric(scale(es.gse[1,] - es.gse[2,])); names(fpi.gse) <- colnames(gse.expr)\n\n# 统计分析 \n# Statistical analysis\nwt <- wilcox.test(fpi.gse[dmso.sam],fpi.gse[erastin.sam])\n绘制箱型图\nDrawing Boxplots\n# 设置图形参数 \n# Setting graphic parameters\npar(bty=\"l\", mgp = c(2,0.5,0), mar = c(3.1,4.1,2.1,2.1),tcl=-.25,las = 1,xpd = T)\n\n# 绘制箱线图 \n# Drawing boxplot\nboxplot(fpi.gse[dmso.sam],\n        fpi.gse[erastin.sam],\n        col = c(\"#2E8049\",\"#DD8606\"),\n        ylab = \"FPI (GSE121689)\",\n        xlab = \"\",\n        ylim = c(-2,2), \n        names = c(\"DMSO\",\"Erastin\"))\n\n# 添加显著性标记 \n# Adding significance markers\nlines(c(1,2),c(2.2,2.2)) \nlines(c(1,1),c(2.1,2.2)) \nlines(c(2,2),c(2.1,2.2)) \ntext(1.5, 2.3, paste0(\"p = \",round(wt$p.value, 3)))\n# 保存图形 \n# Saving plot\ndev.copy2pdf(file = \"FPI_GSE121689.pdf\", width = 3, height = 3.8)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa208FPI_FigureYa208FPI",
      "title": "FigureYa208FPI/FigureYa208FPI.html",
      "html": "FigureYa208FPI/FigureYa208FPI.html",
      "text": "texts/main_FigureYa208FPI_FigureYa208FPI.txt",
      "folder": "FigureYa208FPI",
      "thumb": "gallery_compress/FigureYa208FPI.webp"
    },
    "word_count": 1988,
    "lines_count": 507,
    "title": "FigureYa208FPI",
    "description": "Requirements Description 想实现铁死亡指数（FPI）的计算方法，根据基因表达，算出ssGSEA富集分数，再计算FPI，并用GSE121689数据集验证。 I want to try the calculation method of the Ferroptosis Potential",
    "input_data_types": [
      "临床数据",
      "表达矩阵"
    ],
    "output_types": [
      "箱线图",
      "统计表格"
    ],
    "technical_methods": [
      "通路分析",
      "生存分析",
      "标准化"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "sampleID",
      "colour",
      "values",
      "header",
      "width",
      "comp",
      "ylim",
      "n"
    ]
  },
  {
    "id": "main_FigureYa314SingleRScore_FigureYa314SingleRScore",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa314SingleRScore_FigureYa314SingleRScore.txt",
    "content": "FigureYa314SingleRScore\nFigureYa314SingleRScore\nAuthor(s)\n: Xiaofan Lu; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-05-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nDemand description\nFigureS5B是怎么实现的？这个计算公式要如何实现？\nHow is FigureS5B implemented? How to implement this calculation\nformula?\n出自：\nhttps://www.cell.com/cell/fulltext/S0092-8674(21)00010-6?_returnURL=https%3A%2F%2Flinkinghub.elsevier.com%2Fretrieve%2Fpii%2FS0092867421000106%3Fshowall%3Dtrue\n图S5. LAMP3+ cDC的起源与调控，与图4相关。 (B)\n基于\n三个cDC亚群特征基因评分\n的树突状细胞转录组分层。\nSource:\nhttps://www.cell.com/cell/fulltext/S0092-8674(21)00010-6?_returnURL=https%3A%2F%2Flinkinghub.elsevier.com%2Fretrieve%2Fpii%2FS0092867421000106%3Fshowall%3Dtrue\nFigure S5. Origins and regulation of LAMP3+ cDCs, related to Figure 4\n(B) Stratification of cDC transcriptomes by\nscores generated\nfrom signature genes of three cDC subsets\n.\n应用场景\nApplication scenarios\n近期研究表明，LAMP3+\ncDCs可能具有同时从cDC1和cDC2分化而来的潜力（Maier et al., 2020; Zhang et\nal., 2019）。\n为了证实这个假设，原文作者用了如下计算方法：\n通过多种计算方法，包括Monocle2（图4A）、CytoTRACE（图S5A）、LAMP3+\ncDCs的\n直接分层分析（图S5B，本文档）\n以及SingleR（图S5C），我们在多种癌症类型中证实了LAMP3+\ncDCs的这两种潜在起源。\nRecent studies have suggested that LAMP3+ cDCs had the\npotential to develop from both cDC1s and cDC2s\n(Maier\net al., 2020; Zhang et al., 2019).\nTo validate this hypothesis, the authors employed the following\ncomputational approaches:\nUsing multiple computational methods, including Monocle2 (Figures\n4A), CytoTRACE (Figures S5A), the\ndirect stratification of\nLAMP3+ cDCs (Figures S5B，this document)\nand SingleR (Figures\nS5C), we confirmed the two potential origins of the LAMP3+ cDCs among\nvarious cancer types.\n环境设置\nEnvironment Setup\nUsing domestic mirrors for package installation.\nsource(\"install_dependencies.R\")\ninstall.packages(\"Matrix\")\n加载包\nLoading packages\nlibrary(Matrix)\nlibrary(Seurat)\nlibrary(ggplot2)\n\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n输入文件\nInput Files\n原文作者已把数据上传到GEO数据库\nhttps://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE154763\n。我们从Supplementary\nfile表格里下载csv.gz文件，放到当前目录下的InputData文件夹。\n可以把所有癌症文件放进去合并起来跑，也可以每次只跑一种癌症类型，这里以UCEC为例：\nThe original authors have uploaded the data to the GEO database\nhttps://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE154763\n.\nWe downloaded the csv.gz files from the Supplementary files table and\nplaced them in the InputData folder under the current directory.\nYou can either combine all cancer files to run them together or\nprocess one cancer type at a time. Here we use UCEC as an example:\ndata.path <- file.path(\"InputData\")\n\n# 读取表达矩阵\n# Read expression matrices\nemats <- lapply(list.files(data.path, pattern = \"expression\", full.names = T), function(x){\n  emat = data.table::fread(x, data.table = F, sep = \",\")\n  rownames(emat) = emat$index; emat$index = NULL\n  emat = as(as.matrix(t(emat)), \"dgCMatrix\")\n  return(emat)\n})\n\n# 读取元数据文件\n# Read metadata files\neinfos <- lapply(list.files(data.path, pattern = \"metadata\", full.names = T), function(x){\n  einfo = read.csv(x)\n  rownames(einfo) = einfo$index\n  return(einfo)\n})\n\n# 创建Seurat对象\n# Create Seurat objects\nseu.objs <- mapply(function(x, y){\n  seu = CreateSeuratObject(x, meta.data = y)\n}, emats, einfos)\n# 注意：当InputData文件夹包含多个癌症类型数据时，使用merge合并所有对象\n# Note: When InputData contains multiple cancer type files, use merge to combine all objects\n# seu <- merge(seu.objs[[1]], seu.objs[-1]) \n\nseu <- seu.objs[[1]]\n\n# 筛选特定细胞亚群以降低计算量\n# Subset specific cell clusters to reduce computation load\nseu <- subset(seu, MajorCluster %in% c(\"M03_cDC1_CLEC9A\", \"M04_cDC2_CD1C\", \"M05_cDC3_LAMP3\"))\n鉴定signature genes（下一步会用它计算得分）\nIdentify signature genes (will be used for scoring in next\nstep)\n三个细胞群：在cDC中发现了三个不同的亚群，包括两个经典的cDC亚群（\nCLEC9A+\ncDC1s\n和\nCD1C+\ncDC2s\n）和一个成熟的cDC亚群（\nLAMP3+ cDC\n）。\n筛选条件：定义cDC1和cDC2的特征基因筛选标准：比较cDC1与cDC2转录组时，\n|log2FC|>0.3且校正P值<0.05\n的基因。\nThree cell groups：Three distinct subsets in cDCs were identified,\nincluding two classical cDC subsets (\nCLEC9A+ cDC1s\nand\nCD1C+ cDC2s\n) and a mature cDC subset (\nLAMP3+\ncDC\n) recently characterized.\nFiltering criteria：signature genes for\ncDC1 and\ncDC2\nwere defined as genes with an\nabsolute log2FC more\nthan 0.3 and adjusted P-value less than 0.05\nwhen comparing the\ntranscriptome of cDC1s to cDC2s.\nIdents(seu) <- seu$MajorCluster\n\n# 在进行\"一对多\"差异分析前，再次确认Seurat对象包含的细胞亚群\n# Subset specific cDC populations before one-vs-other differential analysis\nseu <- subset(seu, MajorCluster %in% c(\"M03_cDC1_CLEC9A\", \"M04_cDC2_CD1C\", \"M05_cDC3_LAMP3\")) \n\n# 数据标准化（生成\"data\"层供差异分析使用）\n# Normalize data for differential analysis (generates \"data\" slot)\nseu <- NormalizeData(seu)\n# 显式设置默认assay为RNA\n# Explicitly set default assay to RNA\nDefaultAssay(seu) <- \"RNA\"  \n\n# 运行差异分析（显式指定参数）\n# differential analysis with explicit parameters\nsig.gene <- FindAllMarkers(\n  seu,\n  assay = \"RNA\",          \n  slot = \"data\",        \n  min.pct = 0.1,          \n  logfc.threshold = 0.25   \n)\n# 筛选显著差异基因\n# Filter significant genes \nsig.gene <- subset(sig.gene, avg_log2FC > 0.3 & p_val_adj < 0.05)\n\nsig.gene <- split(sig.gene$gene, sig.gene$cluster)\n计算基因集得分\nCalculate gene set scores\n这里提供两种打分策略，自选其一即可：\n策略一：自定义函数，实现原文的计算公式\n策略二：用AUCell的函数\nHere we provide two scoring strategies, choose either one:\nMethod 1: Custom function implementing the original paper’s\nformula\nMethod 2: Using AUCell functions\n开始画图\nPlotting\n# 绘制散点图\n# Draw a scatter plot\nggplot(plot.data, aes(x = M04_cDC2_CD1C - M03_cDC1_CLEC9A, \n                      y = M05_cDC3_LAMP3, \n                      color = celltype)) +\n  geom_point() + \n  scale_color_manual(values = c(\"#DC2C44\",\"#EC8D37\",\"#45924F\")) + \n  geom_vline(xintercept = 0, color=\"black\", \n             linetype=\"longdash\", lwd = 0.6) + \n  theme_classic() + \n  labs(x = \"cDC2-cDC1 score\", y = \"LAMP3+cDC score\") +\n  theme(axis.text.x = element_text(hjust = 0.5, size = 12, color = \"black\"),\n        axis.title.y = element_text(hjust = 0.5, size = 12, color = \"black\"),\n        axis.text.y = element_text(hjust = 0.5, size = 12, color = \"black\"),\n        axis.ticks = element_line(size=0.2, color=\"black\"),\n        axis.ticks.length = unit(0.2, \"cm\"),\n        panel.background = element_blank(),\n        panel.grid = element_blank(),\n        legend.position = \"top\",\n        axis.title = element_text(size = 10),\n        axis.text = element_text(size = 10))\nggsave(\"ScoreVisual.pdf\", width = 6, height = 6)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa314SingleRScore_FigureYa314SingleRScore",
      "title": "FigureYa314SingleRScore/FigureYa314SingleRScore.html",
      "html": "FigureYa314SingleRScore/FigureYa314SingleRScore.html",
      "text": "texts/main_FigureYa314SingleRScore_FigureYa314SingleRScore.txt",
      "folder": "FigureYa314SingleRScore",
      "thumb": "gallery_compress/FigureYa314SingleRScore.webp"
    },
    "word_count": 763,
    "lines_count": 216,
    "title": "FigureYa314SingleRScore",
    "description": "Demand description FigureS5B是怎么实现的？这个计算公式要如何实现？ How is FigureS5B implemented? How to implement this calculation",
    "input_data_types": [
      "表达矩阵",
      "RNA-seq"
    ],
    "output_types": [
      "散点图",
      "统计表格"
    ],
    "technical_methods": [
      "标准化"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "ticks",
      "values",
      "acc",
      "pattern",
      "lwd",
      "width",
      "grid",
      "xintercept",
      "slot"
    ]
  },
  {
    "id": "main_FigureYa55plus_pancancer_boxplot_FigureYa55plus_pancancer_boxplot",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa55plus_pancancer_boxplot_FigureYa55plus_pancancer_boxplot.txt",
    "content": "FigureYa55plus_pancancer_boxplot\nFigureYa55plus_pancancer_boxplot\nAuthor(s)\n: Chris Lou, Yijing Chen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n问：FigureYa55pancancer_violin的图能不能画成box plot？\n答：可参考FigureYa12box的画法，能让R水平上一个台阶。\n问：能不能用FigureYa55pancancer_violin的输出文件easy_input.csv作为输入，直接画出boxplot？想要无缝对接。\n答：能。感谢Jiacheng\nLou帮忙更新，分享两个版本的解决方案：ggpubr版和纯ggplot2版\nQ: Can the figure of FigureYa55pancancer_violin be drawn as a box\nplot?\nA: You can refer to the drawing of FigureYa12box, which can make the\nR level a step up.\nQ：Can I use the output file easy_input.csv of\nFigureYa55pancancer_violin as input and draw boxplot directly? I want to\nbe seamless.\nA: Yes. Thanks to Jiacheng Lou for helping to update and share two\nversions of the solution: ggpubr version and pure ggplot2 version\n环境设置\nEnvironment setting\nsource(\"install_dependencies.R\")\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 display English error messages\noptions(stringsAsFactors = FALSE) #禁止chr转成factor prohibit the conversion of chr to factor\n输入文件\nInput file\neasy_input.csv，每行一个sample。第一列组织部位，第二列肿瘤/对照组，第三列基因表达量。\n将为每种组织部位计算肿瘤vs.对照之间的p value，在图中用/*标注。\n怎样获得这个输入文件？\nFigureYa55pancancer_violin带你从xena下载数据开始，到提取基因在33种癌症中的表达量。不怕TCGA的normal太少，用GTEx的正常组织作为对照，输出easy_input.csv文件。\neasy_input.csv, one sample per row. The first column is the tissue\nsite, the second column is the tumor/control group, and the third column\nis the gene expression level.\nThe p value between tumor vs. control will be calculated for each\ntissue site, marked with /* in the figure.\nHow to get this input file?\nFigureYa55pancancer_violin takes you from the beginning of the xena\ndownload data to extracting gene expression in 33 cancers. Not afraid of\ntoo little TCGA normal, use GTEx normal tissue as a control and output\nthe easy_input.csv file.\ntcga_gtex <- read.csv(\"easy_input.csv\", row.names = 1, header = T, as.is = F)\nhead(tcga_gtex)\n开始画图\nStart drawing\n方法一：ggpubr\nMethod 1: ggpubr\nlibrary(ggpubr)\nylabname <- paste(\"TP53\", \"expression\")\ncolnames(tcga_gtex) <- c(\"Tissues\", \"Groups\", \"Gene\")\n\np1 <- ggboxplot(tcga_gtex, x = \"Tissues\", y = \"Gene\", fill = 'Groups',\n                ylab = ylabname,\n                color = \"Groups\", #两组用不同颜色 two groups use different colors\n                palette = \"jco\", #配色方案 color scheme\n                ggtheme = theme_minimal())\np1\n# 画box的同时画散点\n# draw the box while drawing the scatter points\np2 <- ggboxplot(tcga_gtex, x = \"Tissues\", y = \"Gene\", fill = 'Groups',\n                ylab = ylabname,\n                color = \"Groups\", \n                palette = \"jco\", \n                add = \"jitter\", #加散点 add scatter points\n                #shape = \"Groups\", #两组散点用不同形状 two sets of scatter points use different shapes\n                ggtheme = theme_minimal())\np2\n# 标注p value\n# mark p value\nanno_df <- compare_means(Gene ~ Groups, group.by = \"Tissues\", data = tcga_gtex,\n                         #这里是两组对比，用wilcox.test或t.test\n                         #here are two sets of comparisons, using wilcox.test or t.test\n                         method = \"wilcox.test\", \n                         #如果多组对比就用下面这行，kruskal.test或anova\n                         #if you want to compare multiple groups, use the following line, kruskal.test or anova\n                         #method = \"kruskal.test\", \n                         p.adjust.method = \"holm\") #\nhead(anno_df)\np3 <- p2 + \n  stat_pvalue_manual(anno_df, x = \"Tissues\", y.position = 15,\n                     label = \"p.signif\", position = position_dodge(0.8))\np3\nggsave(\"pancancer_ggpubr.pdf\", width = 14, height = 5)\n方法二：ggplot2\nMethod 2: ggplot2\n用ggplot2自己画，更灵活。\nDraw it yourself with ggplot2 for more flexibility.\nlibrary(ggplot2)\n\nylabname <- paste(\"TP53\", \"expression\")\ncolnames(tcga_gtex) <- c(\"Tissues\", \"Groups\", \"Gene\")\n\n# 剔除没有normal sample的tissue\n# exclude tissue without normal sample\ntcga_gtex_MESO <- tcga_gtex[tcga_gtex$Tissues==\"MESO\",]\ntcga_gtex_UVM <- tcga_gtex[tcga_gtex$Tissues==\"UVM\",]\ntcga_gtex_withNormal <- tcga_gtex[tcga_gtex$Tissues != \"MESO\" & tcga_gtex$Tissues != \"UVM\",]\n\n# 计算p value\n# calculate p value\npvalues <- sapply(tcga_gtex_withNormal$Tissues, function(x) {\n  res <- wilcox.test(as.numeric(Gene) ~ Groups, data = subset(tcga_gtex_withNormal, Tissues == x)) #两组，wilcox.test或t.test；多组，kruskal.test或aov(one-way ANOVA test) two groups, wilcox.test or t.test; multiple groups, kruskal.test or aov(one-way ANOVA test)\n  res$p.value\n})\npv <- data.frame(gene = tcga_gtex_withNormal$Tissues, pvalue = pvalues)\npv$sigcode <- cut(pv$pvalue, c(0,0.0001, 0.001, 0.01, 0.05, 1), \n                  labels=c('****','***', '**', '*', 'ns'))\n\n# 画box plot\n# draw box plot\np.box <- ggplot(tcga_gtex_withNormal, aes(x=Tissues, y=Gene, color=Groups, fill=Groups)) +\n  geom_boxplot(alpha = .5) + #半透明 semi-transparent\n  theme_classic() + #或theme_bw() or theme_bw()\n  scale_fill_brewer(palette = \"Set1\") + #按类填充颜色 fill color by category\n  scale_color_brewer(palette = \"Set1\") + #按类给边框着色 colorize borders by category\n\n  theme(axis.text.x = element_text(colour=\"black\", size = 11,\n                                   #癌症名太挤，旋转45度\n                                   #cancer name is too crowded, rotate 45 degrees\n                                   angle = 45, hjust = .5, vjust = .5)) +\n  geom_text(aes(x=gene, y=max(tcga_gtex_withNormal$Gene) * 1.1,\n                         label = pv$sigcode),\n                     data=pv, \n                     inherit.aes=F) +\n  ylab(ylabname)\np.box\nggsave(\"pancancer_ggplot2box.pdf\", width = 14, height = 5)\n# 画带散点的box plot\n# draw a box plot with scatter points\np.box.dot <- p.box + geom_point(shape = 21, size=.5, # 点的形状和大小 shape and size of points\n             position = position_jitterdodge(), # 让点散开 let the points be scattered\n             alpha = .5) #半透明 semi-transparent\np.box.dot\nggsave(\"pancancer_ggplot2boxDot.pdf\", width = 14, height = 5)\n# 把不带normal的tissue也画上\n# draw the non-normal issue as well\np.box.dot + \n  # MESO\n  geom_boxplot(alpha = .5, data = tcga_gtex_MESO,\n                     mapping = aes(x=Tissues,y=Gene,fill=Groups)) +\n  geom_point(data = tcga_gtex_MESO,\n                     mapping = aes(x=Tissues,y=Gene,fill=Groups),\n             shape = 21, size=.5, # 点的形状和大小 shape and size of points\n             position = position_jitterdodge(), # 让点散开 let the points be scattered\n             alpha = .5) + #半透明 semi-transparent\n  # UVM\n  geom_boxplot(alpha = .5, data = tcga_gtex_UVM,\n                    mapping = aes(x=Tissues,y=Gene,fill=Groups)) +\n  geom_point(data = tcga_gtex_UVM,\n                    mapping = aes(x=Tissues,y=Gene,fill=Groups),\n             shape = 21, size=.5, # 点的形状和大小 shape and size of points\n             position = position_jitterdodge(), # 让点散开 let the points be scattered\n             alpha = .5) + #半透明 semi-transparent\n  theme_classic() + #或theme_bw() or theme_bw()\n  theme(axis.text.x=element_text(colour=\"black\", size = 11,\n                                   angle = 45, hjust = .5, vjust = .5))\nggsave(\"pancancer_ggplot2boxDot_all.pdf\", width = 14, height = 5)\nSession Info\n会话信息\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa55plus_pancancer_boxplot_FigureYa55plus_pancancer_boxplot",
      "title": "FigureYa55plus_pancancer_boxplot/FigureYa55plus_pancancer_boxplot.html",
      "html": "FigureYa55plus_pancancer_boxplot/FigureYa55plus_pancancer_boxplot.html",
      "text": "texts/main_FigureYa55plus_pancancer_boxplot_FigureYa55plus_pancancer_boxplot.txt",
      "folder": "FigureYa55plus_pancancer_boxplot",
      "thumb": "gallery_compress/FigureYa55plus_pancancer_boxplot.webp"
    },
    "word_count": 828,
    "lines_count": 169,
    "title": "FigureYa55plus_pancancer_boxplot",
    "description": "Requirement description 问：FigureYa55pancancer_violin的图能不能画成box plot？ 答：可参考FigureYa12box的画法，能让R水平上一个台阶。",
    "input_data_types": [],
    "output_types": [
      "散点图",
      "箱线图"
    ],
    "technical_methods": [
      "生存分析"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "add",
      "label",
      "gene",
      "colour",
      "header",
      "width",
      "pvalue",
      "labels",
      "ggtheme"
    ]
  },
  {
    "id": "main_FigureYa126CorrelationHeatmap_FigureYa126CorrelationHeatmap",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa126CorrelationHeatmap_FigureYa126CorrelationHeatmap.txt",
    "content": "FigureYa126CorrelationHeatmap\nFigureYa126CorrelationHeatmap\nAuthor(s)\n: Xiaofan Lu, Taojun Ye\nReviewer(s)\n: Ying Ge\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n根据相关系数排列的无聚类热图，展示和TIM-3基因表达（某一连续变量）相关的免疫基因（其他连续变量）在样本中的分布情况。使用TCGA\nGBM数据以及例文给出的基因集，复现原图。\nRequirement description\nDisplay the distribution of immune genes (other continuous variables)\nrelated to TIM-3 gene expression (a certain continuous variable) in the\nsample using a non clustered heatmap arranged according to the\ncorrelation coefficient. Using TCGA GBM data and the gene set provided\nin the example text, reproduce the original image.\n出自\nhttps://www.tandfonline.com/doi/full/10.1080/2162402X.2017.1328339\nfrom\nhttps://www.tandfonline.com/doi/full/10.1080/2162402X.2017.1328339\nFigure 3. (C, D) Most immune response related genes were\nsignificantly positively correlated with TIM-3 expression, while there\nwere still a small number of genes were significantly negatively\ncorrelated with Tim-3 expression.\n应用场景\n展示跟某一个基因呈正/负相关的多个基因的表达模式。\n例如像例文这种，每列一个样本，每行一个基因。上半部分画出与目标基因的表达模式呈正相关的免疫相关基因，下半部分是负相关的。顶部展示样本的亚组、基因型或其他临床信息。\nApplication scenarios\nDisplay the expression patterns of multiple genes that are\npositively/negatively correlated with a certain gene.\nFor example, in the example text, there is one sample per column and\none gene per row. The upper part shows immune related genes that are\npositively correlated with the expression pattern of the target gene,\nwhile the lower part shows a negative correlation. Display the\nsubgroups, genotypes, or other clinical information of the sample at the\ntop.\n环境设置\nEnvironment settings\nUse domestic image installation package\nsource(\"install_dependencies.R\")\n# 加载clusterProfiler包，用于基因富集分析和功能注释\n# Load the clusterProfiler package for gene enrichment analysis and functional annotation\nlibrary(clusterProfiler)\n# 加载org.Hs.eg.db包，包含人类基因注释信息\n# Load the org.Hs.eg.db package containing human gene annotation information\nlibrary(org.Hs.eg.db)\n# 加载biomaRt包，用于访问Ensembl数据库获取基因注释\n# Load the biomaRt package for accessing Ensembl databases to retrieve gene annotations\nlibrary(biomaRt)\n\n# 加载pheatmap包，用于绘制热图\n# Load the pheatmap package for drawing heatmaps\nlibrary(pheatmap)\n\n# 加载RColorBrewer包，提供丰富的配色方案\n# Load the RColorBrewer package providing a variety of color schemes\nlibrary(RColorBrewer)\n\n# 设置环境语言为英文，使报错信息以英文显示\n# Set the environment language to English to display error messages in English\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止字符串自动转换为因子类型，避免数据处理中的意外转换\n# Disable automatic conversion of strings to factors to prevent unexpected conversions during data processing\noptions(stringsAsFactors = FALSE)\n输入文件\neasy_input_expr.csv，TCGA-GBM.htseq_fpkm，基因表达谱。从XENA下载得到，值为log2（FPKM+1），为方便传输，小数点后保留2位。需要把基因名换成gene\nsymbol。\ngbm_tcga_pub2013_clinical_data.tsv，临床信息。从cBioPortal上下载得到：\nhttp://www.cbioportal.org/study/clinicalData?id=gbm_tcga_pub2013\neasy_input_genes.txt，immune-response-related基因集。来自例文补充材料：Supplementary\ntable1.xlsx\nInput file\neasy_input_expr.csv，TCGA-GBM.htseq_fpkm， Gene expression profile.\nDownloaded from XENA, the value is log2 (FPKM+1), with 2 decimal places\nreserved for ease of transmission. We need to change the gene name to\ngene symbol.\ngbm_tcga_pub2013_clinical_data.tsv， Clinical information. Download\nfrom cBioPortal:\nhttp://www.cbioportal.org/study/clinicalData?id=gbm_tcga_pub2013\nEasyinput_genes. txt, immune response related gene set. Supplementary\nTable 1. xlsx\n# 去除重复的基因符号\n# Remove duplicate gene symbols\nensembl2gs <- ensembl2gs[!duplicated(ensembl2gs$SYMBOL),] \n\n# 根据TCGA样品名的命名规律，提取出肿瘤样本\n# Extract tumor samples based on TCGA sample naming convention\ntum.sam <- colnames(expr)[which(substr(colnames(expr),14,15) == \"01\")]\n\n# 生成新的表达谱，行名为基因符号，列名为肿瘤样本\n# Generate a new expression matrix with gene symbols as row names and tumor samples as column names\nexpr2 <- expr[ensembl2gs$ENSEMBL,tum.sam]\nrownames(expr2) <- ensembl2gs$SYMBOL\n# 查看新表达谱的前3行3列\n# View the first 3 rows and 3 columns of the new expression matrix\nexpr2[1:3, 1:3]\n# 提取带临床信息的样本对应的表达谱\n# Extract expression profiles for samples with clinical information\nexpr2 <- expr2[,rownames(Sinfo)]\n\n# 根据TIM-3的表达量，给样本排序（TIM-3即为HAVCR2）\n# Sort samples by the expression level of TIM-3 (HAVCR2)\nsam.order <- sort(sapply(expr2[\"HAVCR2\",], as.factor),decreasing = F)\n\n### 读取相关基因的表达量，用于画热图，例文画的是免疫相关基因 ###\n# Read the list of genes for heatmap generation, example uses immune-related genes\ngenelist <- read.table(\"easy_input_genes.txt\",sep = \"\\t\",check.names = F,stringsAsFactors = F,header = T,row.names = NULL)\n# 查看基因列表前几行\n# View the first few rows of the gene list\nhead(genelist)\n# 提取基因列表中存在于表达谱中的基因，并按TIM-3表达量排序\n# Extract genes from the gene list that exist in the expression matrix and order by TIM-3 expression\nimm.expr <- expr2[intersect(rownames(expr2), genelist$`GENE LIST`), names(sam.order)]\n# 查看免疫相关基因表达量矩阵的前3行3列\n# View the first 3 rows and 3 columns of the immune-related gene expression matrix\nimm.expr[1:3, 1:3]\n与基因集的相关性分析\nCorrelation analysis with gene set\n# 初始化相关性结果矩阵\n# Initialize matrix to store correlation results\ncor.res <- NULL\n\n# 计算免疫相关基因表达量与TIM-3表达量的Spearman相关性\n# Calculate Spearman correlation between immune-related gene expression and TIM-3 expression\nfor (i in 1:nrow(imm.expr)) {\n  tmp <- cor.test(as.numeric(imm.expr[i,]),as.numeric(sam.order),method = \"spearman\") # 使用非参相关性分析\n  # Non-parametric correlation analysis using Spearman method\n  cor.res <- rbind.data.frame(cor.res,data.frame(gene = rownames(imm.expr)[i], rho = tmp$estimate, p = tmp$p.value, stringsAsFactors = F))\n}\n# 筛选与TIM-3表达显著正相关的基因（rho>0.3且p<0.05）\n# Select genes significantly positively correlated with TIM-3 expression (rho>0.3 and p<0.05)\npos.cor.gene <- cor.res[which(cor.res$rho > 0.3 & cor.res$p < 0.05), c(\"gene\",\"rho\")] \n\n# 筛选与TIM-3表达显著负相关的基因（rho<-0.3且p<0.05）\n# Select genes significantly negatively correlated with TIM-3 expression (rho<-0.3 and p<0.05)\nneg.cor.gene <- cor.res[which(cor.res$rho < -0.3 & cor.res$p < 0.05), c(\"gene\",\"rho\")] \n# 注释：若用例文的-0.4 cutoff，这里只能找到2个基因，最终图的效果可能不明显\n# Note: Using -0.4 cutoff as in the example yields only 2 genes, resulting in less visible heatmap patterns\n\n# 按相关系数升序排列正相关基因，使热图呈现楔形渐变效果\n# Sort positively correlated genes by rho ascending for wedge-shaped gradient in heatmap\npos.cor.gene <- pos.cor.gene[order(pos.cor.gene$rho,decreasing = F),] \n\n# 按相关系数升序排列负相关基因，使热图呈现楔形渐变效果\n# Sort negatively correlated genes by rho ascending for wedge-shaped gradient in heatmap\nneg.cor.gene <- neg.cor.gene[order(neg.cor.gene$rho,decreasing = F),]\n开始画图\nStart drawing\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa126CorrelationHeatmap_FigureYa126CorrelationHeatmap",
      "title": "FigureYa126CorrelationHeatmap/FigureYa126CorrelationHeatmap.html",
      "html": "FigureYa126CorrelationHeatmap/FigureYa126CorrelationHeatmap.html",
      "text": "texts/main_FigureYa126CorrelationHeatmap_FigureYa126CorrelationHeatmap.txt",
      "folder": "FigureYa126CorrelationHeatmap",
      "thumb": "gallery_compress/FigureYa126CorrelationHeatmap.webp"
    },
    "word_count": 766,
    "lines_count": 158,
    "title": "FigureYa126CorrelationHeatmap",
    "description": "根据相关系数排列的无聚类热图，展示和TIM-3基因表达（某一连续变量）相关的免疫基因（其他连续变量）在样本中的分布情况。使用TCGA GBM数据以及例文给出的基因集，复现原图。 Requirement description",
    "input_data_types": [
      "临床数据",
      "表达矩阵"
    ],
    "output_types": [
      "散点图",
      "热图",
      "统计表格"
    ],
    "technical_methods": [
      "聚类分析",
      "通路分析"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "LANGUAGE",
      "stringsAsFactors",
      "gene",
      "id",
      "method",
      "p",
      "header",
      "decreasing",
      "rho"
    ]
  },
  {
    "id": "main_FigureYa190batchLogistic_FigureYa190batchLogistic",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa190batchLogistic_FigureYa190batchLogistic.txt",
    "content": "FigureYa190batchLogistic\nFigureYa190batchLogistic\nAuthor(s)\n: Xiaofan Lu\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement\n逻辑回归，这篇文章应该是一个一个做的，我主要想要的是批量。 Logistic\nregression. This article should be done one by one. What I mainly want\nis batch production.\n出自\nhttps://doi.org/10.1371/journal.pone.0201515\nfromhttps://doi.org/10.1371/journal.pone.0201515\n应用场景\nApplication Scenarios\n批量计算单变量和多变量逻辑回归。 Batch calculation of univariate and\nmultivariate logistic regression.\n这个是逻辑回归，如果要cox回归，可参考FigureYa47HR2table。 This is\nlogistic regression. If you want cox regression, you can refer to Figure\nA47HR2Table.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(SimDesign) # 用于沉默逐步回归的信息 # Information for silent stepwise regression\n\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息  # displays an English error message\noptions(stringsAsFactors = FALSE) #禁止chr转成factor   # prohibit chr from being converted to factor\n输入文件\nInput File\neasy_input.csv，每行一个sample，第一列就是sample\nID，第二列为分组（响应变量），其后每列一个特征（自变量）。这里是基因的表达量，可以换其他临床信息。\neasy_input.csv, each row contains a sample. The first column is the\nsample ID, the second column is the group (response variable), and each\nsubsequent column contains a feature (independent variable). Here is the\nexpression level of the gene, which can be replaced with other clinical\ninformation.\ndat <- read.table(\"easy_input.txt\",row.names = 1,sep = \"\\t\",header = T,check.names = F,stringsAsFactors = F)\ndat[1:3, 1:3]\ntable(dat$MetaStatus)\n# 注意，如果变量是基因，一定要把“-”替换成别的符号比如“_”。\n# Note that if the variable is a gene, the \"-\" must be replaced with another symbol, such as \"_\".\ncolnames(dat) <- gsub(\"-\",\"_\",colnames(dat))\n循环运算单变量逻辑回归\nLoop operation for univariate logistic regression\nrname <- \"MetaStatus\" #设置响应变量y的变量名  # Set the variable name of the response variable y\nvname <- setdiff(colnames(dat), rname) # 设置自变量x的变量名  # sets the variable name of the independent variable x\n\n# 初始化结果向量 # Initialize the result vector\nor <- p <- p.lab <- c() \np.cutoff <- 0.05 # 名义p值的阈值   # The threshold of nominal p value\nstep.dir <- \"forward\" # 逐步回归的方向，可为backward，forward和both，例文为forward  # The direction of stepwise regression can be backward, forward, or both. The example text is forward\n\nfor (v in vname) {\n  f <- as.formula(paste0(rname,\"~\",v)) # 创建公式  # Create Formulas\n  t <- dat[,c(rname,v)]\n  \n  # 单变量逻辑回归\n  # Univariate Logistic regression\n  l <- glm(f, \n           data = t, \n           family = \"binomial\", \n           control = list(maxit = 50), \n           na.action = na.exclude)\n  \n  s <- format(round(exp(cbind(\"OR\" = coef(l), confint.default(l, level = 0.95)))[2,],3),nsmall = 3) # 调整格式  # Adjust Format\n  s <- paste0(s[1],\" (\",s[2],\"-\",s[3],\")\")\n  or <- c(or,s) # odd ratio\n  p <- c(p,format(round(summary(l)$coefficients[2,4],3),nsmall = 3))\n  p.lab <- c(p.lab, # 名义p值的标签  # Nominal P-value label\n             ifelse(summary(l)$coefficients[2,4] < 0.001,\n                    \"<0.001\", format(round(summary(l)$coefficients[2,4],3),nsmall = 3)))\n}\n多变量回归\nMultivariate regression\n# 找出显著变量\n# Identify significant variables\nvname.sig <- vname[which(as.numeric(p) < p.cutoff)]\n\nif(length(vname.sig) == 0) {\n  cat(\"No significant variable found!\\n\") # 单变量结果没有显著变量  There are no significant variables in the univariate results\n} else if(length(vname.sig) == 1) {\n  cat(\"Only one significant variable found!\\n\") # 单变量结果只有一个显著变量，不进行多变量回归  The univariate result has only one significant variable and no multivariate regression is conducted\n} else {\n  cat(paste0(\"A total of \",length(vname.sig),\" significant variables found!\\n\"))\n  f <- as.formula(paste0(rname,\"~\",paste0(vname.sig,collapse = \" + \"))) # 创建多变量公式  # Create Multivariate formulas\n  t <- dat[,c(rname,vname.sig)]\n  l <- glm(f, \n           data = t, \n           family = \"binomial\", \n           control = list(maxit = 50), \n           na.action = na.exclude)\n  l.step <- quiet(step(l,direction = step.dir, k = qchisq(p.cutoff/2,1,lower.tail=FALSE))) # 向前支部回归  # Return to the previous branch\n  l.step.s <- as.data.frame(format(round(exp(cbind(\"OR\" = coef(l.step), \n                                     confint.default(l.step, level = 0.95))),3),nsmall = 3)) # 调整格式  # Adjust Format\n  l.step.s$p <- format(round(summary(l.step)$coefficients[,4],3),nsmall = 3)\n  l.step.s$p.lab <- ifelse(summary(l.step)$coefficients[,4] < 0.001,\n                       \"<0.001\",format(round(summary(l.step)$coefficients[,4],3),nsmall = 3))\n  \n  l.step.s <- l.step.s[setdiff(rownames(l.step.s),\"(Intercept)\"),] # 移除截距项  # Remove the intercept item\n}\nstep.p <- ifelse(l.step.s$p < p.cutoff, l.step.s$p,\"\")\nstep.or <- ifelse(step.p == \"\",\"NA\",paste0(l.step.s$OR,\" (\",l.step.s$`2.5 %`,\"-\",l.step.s$`97.5 %`,\")\"))\n\n# 找到在原本显著变量里的位置\n# Find the position within the original significant variable\nstep.p.lab <- rep(\"\", length(vname)); names(step.p.lab) <- vname; step.p.lab[vname.sig] <- step.p\nstep.or.lab <- rep(\"NA\", length(vname)); names(step.or.lab) <- vname; step.or.lab[vname.sig] <- step.or\n输出表格文件\nOutput the table file\n生成简易表格\nGenerate a simple table\noutTab <- cbind.data.frame(vname, or, p.lab, step.or.lab, step.p.lab)\ncolnames(outTab) <- c(\"\",\"Univariate analysis\\nOR (95% CI)\",\"\\nP value\",\"Multivariate analysis\\nOR (95% CI)\",\"\\nP value\")\nrownames(outTab) <- NULL\nwrite.table(outTab,\"batch logistic results.txt\",sep = \"\\t\",row.names = F,quote = F)\n输出CSV格式\nOutput in CSV format\ntable_subtitle <- c(NA,\"OR (95% CI)\",\"P value\",\"OR (95% CI)\",\"P value\")\ncomtable <- rbind(table_subtitle,outTab,stringsAsFactors = F)\ncolnames(comtable) <- c(\"\",\"Univariate analysis\",\"\",\"Multivariate analysis\",\"\")\ncomtable[is.na(comtable)] <- \"\" #表格里面不打印抬头的NA，但保留“NA”字符串  # Do not print the header \"NA\" in the table, but keep the \"NA\" string\nstr(comtable)\nwrite.csv(comtable,\"Table.csv\", quote = F, row.names = F)\n输出WORD格式\nOutput in WORD format\ntable_subtitle <- c(NA,\"OR (95% CI)\",\"P value\",\"OR (95% CI)\",\"P value\")\ncomtable <- rbind(table_subtitle,outTab,stringsAsFactors = F)\ncolnames(comtable)<-c(NA,\"Univariate analysis\",NA,\"Multivariate analysis\",NA)\ncomtable[is.na(comtable)] <- \"\" #表格里面不打印抬头的NA，但保留“NA”字符串  # Do not print the header \"NA\" in the table, but keep the \"NA\" string\n\n#保存到word文档\n# Save to a word document\ntitle_name<-'Table *. Univariate and multivariate logistic regression'\ntable1 <- comtable\nmynote <- \"Note: ...\"\n\nif(!require(officer)) (install.packages('officer'))\nlibrary(officer)\nlibrary(dplyr)\nmy_doc <- read_docx()  #初始化一个docx  # Initialize a docx\nmy_doc %>%\n  ##添加段落标题名称\n  ##Add paragraph title names\n  body_add_par(value = title_name, style = \"table title\") %>%\n  \n  #添加表格\n  #Add Table\n  body_add_table(value = table1, style = \"Light List Accent 2\" ) %>% \n  \n  #添加Note\n  #Add Note\n  body_add_par(value = mynote) %>% \n  \n  #打印到word文档\n  #Print to word document\n  print(target = \"Table.docx\")\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa190batchLogistic_FigureYa190batchLogistic",
      "title": "FigureYa190batchLogistic/FigureYa190batchLogistic.html",
      "html": "FigureYa190batchLogistic/FigureYa190batchLogistic.html",
      "text": "texts/main_FigureYa190batchLogistic_FigureYa190batchLogistic.txt",
      "folder": "FigureYa190batchLogistic",
      "thumb": "gallery_compress/FigureYa190batchLogistic.webp"
    },
    "word_count": 821,
    "lines_count": 168,
    "title": "FigureYa190batchLogistic",
    "description": "Requirement 逻辑回归，这篇文章应该是一个一个做的，我主要想要的是批量。 Logistic regression. This article should be done one by one. What I mainly want",
    "input_data_types": [
      "临床数据"
    ],
    "output_types": [
      "统计表格"
    ],
    "technical_methods": [
      "生存分析"
    ],
    "biology_areas": [],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "level",
      "tail",
      "header",
      "nsmall",
      "direction",
      "k",
      "maxit",
      "style",
      "family"
    ]
  },
  {
    "id": "main_FigureYa229PCOA_FigureYa229PCOA",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa229PCOA_FigureYa229PCOA.txt",
    "content": "FigureYa229PCOA\nFigureYa229PCOA\nAuthor(s)\n: Xiaofan Lu\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n把PCOA的散点图变成这样的：\nRequirement Description\nTurn the scatter plot of PCOA like this:\n出自\nhttps://www.cell.com/cell-metabolism/fulltext/S1550-4131(20)30312-0?_returnURL=https%3A%2F%2Flinkinghub.elsevier.com%2Fretrieve%2Fpii%2FS1550413120303120%3Fshowall%3Dtrue\nfrom\nhttps://www.cell.com/cell-metabolism/fulltext/S1550-4131(20)30312-0?_returnURL=https%3A%2F%2Flinkinghub.elsevier.com%2Fretrieve%2Fpii%2FS1550413120303120%3Fshowall%3Dtrue\nFigure 1. Shifts in the Gut Microbiota Composition in Parallel with\nImpaired Glycemic Status (A) The\nprinciple coordinate\nanalysis\nof Bray-Curtis dissimilarities obtained for the\nmetagenomic species profiles in the discovery (closed circles) and\nvalidation (open circles) cohorts.\nThe circles and error bars\nindicate the mean and standard errors of the mean\n. p values for\nthe comparison of gut microbiota composition in the high-risk NGT\n(hrNGT), IFG, IGT, CGI, and T2D groups versus the low-risk NGT (lrNGT)\ngroup in the discovery cohort are 0.086, 0.069, 0.00070, 0.00010, and\n0.00030, respectively, and in the IGT, CGI, and T2D groups versus the\nNGT group in the validation cohort are 0.009, 0.015, and 0.0001,\nrespectively (PERMANOVA test with 10,000 permutations).\nPrincipal coordinate analysis of the gut microbiota profiles in the\ndiscovery cohort showed that\nsignificant shifts\nseparated\nthe gut microbiota composition of the IGT, CGI, and\nT2D groups from that of the low-risk NGT group (p = 0.0007, 0.00010, and\n0.00030, respectively; PERMANOVA test with 10,000 permutations), but no\nsignificant changes in composition were observed between the high- and\nlow-risk NGT groups (p = 0.086), between the IFG and low-risk NGT group\n(p = 0.069), or between the CGI and T2D groups (p = 0.14; Figure 1A) … A\nsimilar pattern\nwas observed for the shifts in\nmicrobial composition\nin the validation cohort\n(Figures\n1A and S3A).\n应用场景\n转录组的表达矩阵都有成千上万个基因，这类高维度数据很难直接进行可视化展示。\n为了能够在二维平面上展示，就需要对其进行降维，PCA分析是目前最常用的降维工具。\n实际应用时，想突出强调自己想要展示的特征，就需要变换展示方式：\n样本量不太大、区分比较好，可以画经典的带圈（置信区间）、带箭头的PCA，画法可参考FigureYa38PCA；\n大部分情况两个主成分就够了，有时你可能需要3个主成分才能区分开，就需要画3D\nPCA展示三个主成分，可参考FigureYa164PCA3D；\n想看多次生物学重复的重复效果，需要用不同形状和颜色同时展示分组和重复，可参考FigureYa101PCA；\n当分组（亚型）较多且每组样本量较大时，画散点图相互覆盖很难看清，就可以像例文这样计算相同组的均值以及标准误后画图。这样能够看出各亚型距离较远，两个队列的结果相近。这种眼睛看出来的差异有统计学意义吗？作者用PERMANOVA\ntest来做组间差异显著性分析，做法见“附：PERMANOVA test (2-way\nadonis)”。\nApplication Scenarios\nThe transcriptome expression matrix has thousands of genes, and such\nhigh-dimensional data is difficult to visualize directly.\nIn order to be able to display it on a two-dimensional plane, it is\nnecessary to reduce the dimensionality, and PCA analysis is the most\ncommonly used dimensionality reduction tool at present.\nIn practice, if you want to highlight the features you want to show,\nyou need to change the way you display them:\nIf the sample size is not too large and the discrimination is good,\nyou can draw the classic PCA with circles (confidence intervals) and\narrows, and refer to FigureYa38PCA for the drawing method;\nIn most cases, two principal components are enough, sometimes you\nmay need 3 principal components to distinguish them, you need to draw 3D\nPCA to show the three principal components, you can refer to\nFigureYa164PCA3D;\nIf you want to see the repetition effect of multiple biological\nreplicates, you need to display the grouping and repetition with\ndifferent shapes and colors at the same time, please refer to\nFigureYa101PCA;\nWhen there are many groups (subtypes) and the sample size of each\ngroup is large, and it is difficult to see that the scatter plots cover\neach other, you can calculate the mean of the same group and the\nstandard error after plotting as in the example. This allows for the\ndistantness of the subtypes and the similar results of the two cohorts.\nIs there a statistically significant difference in what the eye sees?\nThe authors used the PERMANOVA test to analyze the significance of\ndifferences between groups, as described in “Appendix: PERMANOVA test\n(2-way adonis)”.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nlibrary(vegan)        #用于计算距离矩阵 # Used to calculate the distance matrix\nlibrary(ape)          #做PCoA # Do PCoA\nlibrary(RColorBrewer) #配色 # Color matching\nlibrary(usedist)      #PERMANOVA test时处理距离矩阵 # Handle distance matrices when doing PERMANOVA test\n\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # error messages are displayed in English\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # chr is not allowed to be converted to factor\n输入文件\neasy_input_expr.txt，表达矩阵。\neasy_input_sinfo.txt，样本信息，第一列是sample\nID，跟表达矩阵一致，第二列是第一种分组方式（这里是亚型），第三列是二种分组方式（这里是队列），这里对比两个队列。\nInput files\neasy_input_expr.txt, the expression matrix.\neasy_input_sinfo.txt, the sample information, the first column is the\nsample ID, which is consistent with the expression matrix, the second\ncolumn is the first grouping method (here the subtype), and the third\ncolumn is the two grouping methods (here the cohort), and here the two\ncohorts are compared.\n# 读取表达矩阵\n# Read the expression matrix\nexpr <- read.table(\"easy_input_expr.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\n\n# 读取样本信息\n# Read the sample information\nsinfo <- read.table(\"easy_input_sinfo.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\n# 查看亚型\n# View subtypes\ntable(sinfo$PAM50) # 这里有5个亚型\n# 查看队列\n# View the queue\ntable(sinfo$Cohort) # 2个队列\nPCA\n# 计算距离矩阵（非相似性矩阵）\n# Calculating Distance Matrix (Non-Similarity Matrix)\nbrca.dist <- vegdist(t(expr), # 注意行为观测（样本），列为特征（基因）# Attention rows are Observations (Sample),columns as Trait (Gene)\n                     method = \"euclidean\") # 原文使用Bray-Curtis dissimilarity matrix针对非负矩阵(method = \"bray\")，这里表达谱有负值，所以采用普通的欧氏距离 # The original text uses the Bray-Curtis dissimilarity matrix for the non-negative matrix (method = \"bray\"), where the expression spectrum has a negative value, so the ordinary Euclidean distance is used\n\n# 计算principal coordinates\n# Calculate principal coordinates\npc <- cmdscale(brca.dist, eig = FALSE)\n\n# 计算percentage of variance explained\n# Calculate the percentage of variance explained\neig <- pcoa(brca.dist)\npct1 <- round(eig$values$Relative_eig[1]/sum(eig$values$Relative_eig), digits=3)*100\npct2 <- round(eig$values$Relative_eig[2]/sum(eig$values$Relative_eig), digits=3)*100\nxlab.text = paste(\"PCoA1 [\", pct1, \"%]\", sep = \"\") # 生成x轴标签 # Generate x-axis labels\nylab.text = paste(\"PCoA2 [\", pct2, \"%]\", sep = \"\") # 生成y轴标签 # Generate y-axis labels\n开始画图\n先产生基本图看一下效果\nStart drawing\nLet’s start by generating a base diagram and see the effect\n# 创建绘图信息\n# Create drawing information\nplotinfo <- cbind.data.frame(x = pc[,1],\n                             y = pc[,2],\n                             PAM50 = sinfo[rownames(pc),\"PAM50\"],\n                             Cohort = sinfo[rownames(pc),\"Cohort\"],\n                             Class = paste(sinfo[rownames(pc),\"PAM50\"], # 根据class信息确定颜色 # Determine the color based on the class information\n                                           sinfo[rownames(pc),\"Cohort\"],\n                                           sep = \"_\"))\n\n# 为了使来自两个队列相同亚型的颜色相近，像这样修改因子，使得配对颜色可以对应上\n# In order to make the colors from the same subtype of the two cohorts similar, modify the factor like this so that the paired colors can correspond\nplotinfo$Class <- factor(plotinfo$Class, \n                         levels = c(\"Basal_TCGA\",\"Basal_Yau\",\n                                    \"Her2_TCGA\",\"Her2_Yau\",\n                                    \"LumA_TCGA\",\"LumA_Yau\",\n                                    \"LumB_TCGA\",\"LumB_Yau\",\n                                    \"Normal_TCGA\",\"Normal_Yau\"))\n\n# 10个组（5个亚型*2个队列），定义10种颜色，采用配对颜色分别表示TCGA和Yau对应亚型\n# 10 groups (5 subtypes * 2 cohorts), 10 colors are defined, and paired colors are used to represent the corresponding subtypes of TCGA and Yau\nmycol <- brewer.pal(n = 10, name = \"Paired\") # Paired最多可设置12组颜色 # Paired can be set up to 12 groups of colors\nplotinfo$color <- mycol[plotinfo$Class] # 匹配颜色 # Match the color\n\n# 保存到文件\n# Save to file\nwrite.csv(plotinfo, \"output_PCA1_PCA2.csv\", quote = F)\n\n# 产生基本图看一下效果，可以看到不同的亚型还是可以分开的\n# Generate a basic diagram and look at the effect, you can see that the different subtypes can be separated\npdf(\"basic scatter plot.pdf\", width = 5,height = 5)\npar(bty=\"o\", mgp = c(1.9,.33,0), mar=c(3.1,3.1,2.1,2.1)+.1, las=1, tcl=-.25)\nplot(plotinfo$x,\n     plotinfo$y,\n     pch = 19,\n     col = plotinfo$color,\n     xlab = xlab.text,\n     ylab = ylab.text)\ninvisible(dev.off())\n可以看到不同的亚型还是可以分开的\n存在的问题\n：由于样本太多，各个分组的散点叠在一起，不易辨认。\n例文的解决方法：计算相同组的均值以及标准误后画图\nIt can be seen that the different subtypes can be separated\nProblem\n: Due to the large number of samples, the\nscatters of each grouping are stacked on top of each other and are not\neasy to identify.\nExample workaround: Calculate the mean for the same group and plot\nafter the standard error\nplotinfo2 <- NULL\nfor (i in unique(plotinfo$Class)) {\n  tmp <- plotinfo[plotinfo$Class == i,] # 取出当前亚型当前来源下的数据 # Retrieve the data from the current source of the current subtype\n  avgx <- mean(tmp$x) # 计算横坐标均值 # Calculate the mean abscissa value\n  avgy <- mean(tmp$y) # 计算纵坐标均值 # Calculate the mean ordinate of the ordinate\n  sdx <- sd(tmp$x) # 计算横坐标标准差 # Calculate the abscissa standard deviation\n  sdy <- sd(tmp$y) # 计算纵坐标标准差 # Calculate the standard deviation of the ordinate\n  \n  plotinfo2 <- rbind.data.frame(plotinfo2,\n                                data.frame(Class = i,\n                                           color = unique(tmp$color), # 添加颜色 # Add color\n                                           shape = ifelse(unique(tmp$Cohort) == \"TCGA\", # 如果是TCGA就实心圆 # If it is a TCGA, it is a solid circle\n                                                          \"closed\",\"opened\"), # 如果是Yau就为空心圆 # If it is Yau, it is a hollow circle\n                                           label = switch(i, # 创建简易标签以显示在圆中 # Create a simple label to display in a circle\n                                                          \"Her2_TCGA\" = \"HT\",\n                                                          \"Normal_TCGA\" = \"NT\",\n                                                          \"Basal_TCGA\" = \"BT\",\n                                                          \"LumA_TCGA\" = \"LaT\",\n                                                          \"LumB_TCGA\" = \"LbT\",\n                                                          \"Her2_Yau\" = \"HY\",\n                                                          \"Normal_Yau\" = \"NY\",\n                                                          \"Basal_Yau\" = \"BY\",\n                                                          \"LumA_Yau\" = \"LaY\",\n                                                          \"LumB_Yau\" = \"LbY\"),\n                                           avgx = avgx, # 添加圆的x位置 # Add the x-position of the circle\n                                           avgy = avgy, # 添加圆的y位置 # Add the y-position of the circle\n                                           sdx = sdx, # 添加圆的水平标准差 # Add the horizontal standard deviation of the circle\n                                           sdy = sdy, # 添加圆的垂直标准差 # Add the vertical standard deviation of the circle\n                                           stringsAsFactors = F),\n                                stringsAsFactors = F)\n}\n\n# 保存到文件\n# Save to file\nwrite.csv(plotinfo2, \"output_av_sd.csv\", quote = F)\n\n# 绘图\n# Drawing\npdf(\"PoCA.pdf\", width = 5,height = 5)\npar(bty=\"o\", mgp = c(1.9,.33,0), mar=c(3.1,3.1,2.1,2.1)+.1, las=1, tcl=-.25)\n# 根据上面的基础图像，调整横轴纵轴的宽度，生成一张空白图像\n# Based on the base image above, adjust the width of the horizontal and vertical axes to generate a blank image\nplot(NULL,NULL,\n     xlab = xlab.text,\n     ylab = ylab.text,\n     xlim = c(-25,25),\n     ylim = c(-20,20))\n\n# 先产生误差线，这样可以被后面的圆挡住\n# Error bars are generated first, so that they can be blocked by the circles that follow\nfor (i in 1:nrow(plotinfo2)) {\n  tmp <- plotinfo2[i,]\n  \n  # 产生横向误差线\n  # Generate transverse error bars\n  lines(x = c(tmp$avgx - tmp$sdx,\n              tmp$avgx + tmp$sdx),\n        y = c(tmp$avgy, tmp$avgy),\n        lty = ifelse(tmp$shape == \"closed\",1,2), # 如果是closed就是实线，否则为虚线 # If it is closed, it is a solid line, otherwise it is a dotted line\n        col = tmp$color,\n        lwd = 2)\n  \n  # 产生横向误差线的封口线\n  # A sealing line that produces transverse error bars\n  lines(x = c(tmp$avgx - tmp$sdx,\n              tmp$avgx - tmp$sdx),\n        y = c(tmp$avgy - 0.5, # 宽度根据情况调整 # The width is adjusted according to the situation\n              tmp$avgy + 0.5),\n        col = tmp$color,\n        lwd = 2)\n  lines(x = c(tmp$avgx + tmp$sdx,\n              tmp$avgx + tmp$sdx),\n        y = c(tmp$avgy - 0.5,\n              tmp$avgy + 0.5),\n        col = tmp$color,\n        lwd = 2)\n  \n  # 产生纵向误差线\n  # Generate longitudinal error bars\n  lines(x = c(tmp$avgx, tmp$avgx),\n        y = c(tmp$avgy - tmp$sdy,\n              tmp$avgy + tmp$sdy),\n        lty = ifelse(tmp$shape == \"closed\",1,2),\n        col = tmp$color,\n        lwd = 2)\n  \n  # 产生纵向误差线的封口线\n  # # Generate longitudinal error bars and sealing lines\n  lines(x = c(tmp$avgx - 0.5,\n              tmp$avgx + 0.5),\n        y = c(tmp$avgy + tmp$sdy,\n              tmp$avgy + tmp$sdy),\n        col = tmp$color,\n        lwd = 2)\n  lines(x = c(tmp$avgx - 0.5,\n              tmp$avgx + 0.5),\n        y = c(tmp$avgy - tmp$sdy,\n              tmp$avgy - tmp$sdy),\n        col = tmp$color,\n        lwd = 2)\n}\n\n# 后添加圆，以挡住误差线\n# Add a circle to block the error bars\npoints(plotinfo2$avgx,\n       plotinfo2$avgy,\n       pch = ifelse(plotinfo2$shape == \"closed\",19,21), # 如果为closed就是实心圆，否则为空心圆 # If it is closed, it is a solid circle, otherwise it is a hollow circle\n       bg = ifelse(plotinfo2$shape == \"closed\",plotinfo2$color,\"white\"), # 填充背景色，如果为closed就是为该颜色，否则为白色 # Fill the background color, if it is closed, it is this color, otherwise it is white\n       col = plotinfo2$color, # 填充边框颜色 # Fill the border color\n       lwd = 2, # 边框粗细 # Border thickness\n       cex = 5) # 圆的大小 # The size of the circle\n\n# 添加文本\n# Add text\ntext(plotinfo2$avgx,\n     plotinfo2$avgy,\n     plotinfo2$label,\n     col = ifelse(plotinfo2$shape == \"closed\",\"white\",plotinfo2$color), # 如果是实心圆文字为白色，否则为对应颜色 # If it is a solid circle, the text is white, otherwise it is the corresponding color\n     cex = 1.1)\n\n# 关闭图像句柄\n# Close the image handle\ninvisible(dev.off())\n附：PERMANOVA test (2-way adonis)\n各组之间的差异有统计学意义吗？作者用了PERMANOVA test。\n这是生态学中常用的统计方法，样品组间差异显著性分析。非参数检验，不需要满足正态分布。\n这里分别以两个队列（TCGA和Yau）的各亚组之间比较为例，展示其用法。具体到自己的数据，自己决定谁跟谁比。\nAttached: PERMANOVA test (2-way adonis)\nWas there a statistically significant difference between the groups?\nthe authors used the PERMANOVA test.\nThis is a commonly used statistical method in ecology to analyze the\nsignificance of differences between sample groups. Non-parametric test,\nwhich does not need to satisfy a normal distribution.\nHere, a comparison between the subgroups of the two cohorts (TCGA and\nYau) is used as an example to illustrate its usage. Be specific to your\nown data and decide who compares to whom.\n# 结果表明TCGA样本在PAM50（亚型，第一种分组方式）上确实存在很大差异\n# 提取P value\n# The results show that there is indeed a large difference in the PAM50 (subtype, the first grouping) of the TCGA samples\n# Extract P value\nbrca.TCGA$`Pr(>F)`\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa229PCOA_FigureYa229PCOA",
      "title": "FigureYa229PCOA/FigureYa229PCOA.html",
      "html": "FigureYa229PCOA/FigureYa229PCOA.html",
      "text": "texts/main_FigureYa229PCOA_FigureYa229PCOA.txt",
      "folder": "FigureYa229PCOA",
      "thumb": "gallery_compress/FigureYa229PCOA.webp"
    },
    "word_count": 1919,
    "lines_count": 340,
    "title": "FigureYa229PCOA",
    "description": "把PCOA的散点图变成这样的： Requirement Description Turn the scatter plot of PCOA like this:",
    "input_data_types": [
      "突变数据",
      "临床数据",
      "表达矩阵",
      "RNA-seq"
    ],
    "output_types": [
      "散点图",
      "统计表格",
      "PCA图"
    ],
    "technical_methods": [
      "主成分分析"
    ],
    "biology_areas": [],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "avgx",
      "label",
      "",
      "header",
      "Cohort",
      "lwd",
      "width",
      "ylim",
      "n",
      "xlim"
    ]
  },
  {
    "id": "main_FigureYa210survivalScape_FigureYa210survivalScape",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa210survivalScape_FigureYa210survivalScape.txt",
    "content": "FigureYa210survivalScape\nFigureYa210survivalScape\nAuthor(s)\n: Xiaofan Lu\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n用survdiff复现文章里的图，把所有基因的HR、pvalue输出到文件。\nRequirement Description\nUse survdiff to reproduce the graph in the article, and output the HR\nand pvalue of all genes to a file.\n出自\nhttps://molecular-cancer.biomedcentral.com/articles/10.1186/s12943-019-1066-3\nfrom\nhttps://molecular-cancer.biomedcentral.com/articles/10.1186/s12943-019-1066-3\nFig. 3 Clinical relevance of m6A regulators across cancer types. a\nSummary of the correlation between expression of m6A regulators and\npatient survival.\nRed\nrepresents a higher expression of\nm6A regulator associated with\nworse survival\n, and\nblue\nrepresents an association with\nbetter\nsurvival\n. Only p values < 0.05 are shown.\n基于这一结果，下一步的做法：\n例文分析每个m6A基因在pancancer和GEO多个数据集中的hazard\nratios，画出森林图Fig. 3b The distribution of hazard ratios across\ndifferent cancer types. 可参考FigureYa66单因素cox。\n筛选获得显著影响生存的基因/癌症，然后批量画生存曲线，可参考FigureYa35batch_bestSeparation\n我们还复现过这篇文章的Fig.\n2A，用\nFigureYa199crosslink\n带你实现连线自由。\nBased on these results, the next steps are as follows:\n-Analyze each m6A gene by calculating hazard ratios across pan-cancer\nand multiple GEO datasets, then generate a forest plot (Fig. 3b: The\ndistribution of hazard ratios across different cancer types). Refer to\nFigureYa66 single Cox for implementation.\n-Screen for genes/cancers with significant survival impact, then\nbatch-plot survival curves. Refer to FigureYa35batch_bestSeparation for\nguidance.\nWe have also reproduced Fig. 2A from this paper—use\nFigureYa199crosslink to achieve flexible linkage visualization.\n应用场景\n场景一：像例文那样，用TCGA-pancancer表达数据计算某个基因集的survival\nlandscape。\n场景二：批量筛选。或许你可以计算基因组上所有基因的survival\nlandscape，筛选出genes associated with the overall survival of patients\n(worse/better survival) in at least one cancer\ntype或你关心的几种癌症或所有癌症。\n这里提供cox和survdiff（logrank，中位数区分高低组）两种方式：\n方法一：（推荐）用cox来说明protective和risky是比较合理的做法。\n方法二：（需求者提出的）survdiff的logrank，对于输入FPKM和TPM都可以用。\n结果的可视化。例文用红蓝白表示风险、保护和不显著。或许你想用颜色的深浅来展示具体的数值，或者用形状和颜色同时展示HR和pvalue，可参考的FigureYa97correlation画法。\nApplication Scenarios\nScenario 1: Calculate the survival landscape of a gene set using\nTCGA-pancancer expression data as in the example.\nScenario 2: Batch filtering. Perhaps you can calculate the survival\nlandscape of all genes on the genome and screen out genes associated\nwith the overall survival of patients (worse/better survival) in at\nleast one cancer type or a few or all cancers that you care about.\nThere are two ways to use cox and survdiff (logrank, median\ndistinguishes between high and low groups):\nMethod 1: (Recommended) It is reasonable to use COX to illustrate\nthat Protective and Risky are used.\nMethod 2: The logrank of survdiff (proposed by the demander) can be\nused for both FPKM and TPM.\nVisualization of results. Examples are written in red, blue, and\nwhite for risk, protection, and non-significant. Maybe you want to use\nthe shade of color to show specific values, or use shapes and colors to\nshow HR and pvalue at the same time, you can refer to\nFigureYa97correlation.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nlibrary(data.table)\nlibrary(survival)\nlibrary(pheatmap)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # error messages are displayed in English\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # chr is not allowed to be converted to factor\n输入文件的获得\n需要表达矩阵和生存数据，如果你已经准备好easy_input_gene.txt、easy_input_expr.csv和easy_input_surv.csv文件，就可以跳过这步，直接进入“输入文件”。\neasy_input_gene.txt，例文中的m6A基因，用到\nSymbol\n列，将提取这些基因的表达矩阵。\ntcga_RSEM_gene_tpm和gencode.v23.annotation.gene.probemap，表达矩阵和Gene\nmapping，跟FigureYa208FPI的一样。\n建议自己动手，从xena网站下载\n，下载方式：\n这里跟FigureYa55panCancer_violin保持一致，从\nXENA\n下载UCSC Toil RNA-seq\nRecompute TPM：\nTCGA\nPan-Cancer (PANCAN) (41 datasets)\n里的\nTOIL\nRSEM tpm (n=10,535) UCSC Toil RNA-seq Recompute\n，\nGene\nMapping\n或者下载GDC pipeline的FPKM-UQ：\nGDC\nPan-Cancer (PANCAN) (17 datasets)\n里的\nHTSeq\n- FPKM-UQ (n=11,768) GDC Hub\n，\nGene\nMapping\npancancerSurvivalData.txt，样本注释及生存信息，从\nXENA\n下载后整理而成。\n生存信息的下载方式：\nCurated\nclinical data (n=12,591)\n里的\nCurated\nclinical data\n样本信息的下载方式：\nTCGA\nPan-Cancer (PANCAN) (41 datasets) phenotype\n里的\nsample\ntype and primary disease (n=12,804) Pan-Cancer Atlas Hub\n。\nAcquisition of input files\nMatrix and survival data need to be expressed, and if you already\nhave easy_input_gene.txt, easy_input_expr.csv, and easy_input_surv.csv\nfiles ready, you can skip this step and go straight to the “Input\nFile”.\neasy_input_gene.txt, the m6A gene in the example is used in the\n‘Symbol’ column to extract the expression matrix of these\ngenes.\ntcga_RSEM_gene_tpm and gencode.v23.annotation.gene.probemap,\nexpression matrix and gene mapping, the same as FigureYa208FPI\nIt is recommended to do it yourself, download it from the Xena\nwebsite\n, download method:\nConsistent with FigureYa55panCancer_violin here, download UCSC\nToil RNA-seq Recompute TPM from\nXENA\n:\nTCGA\nPan-Cancer (PANCAN) (41 datasets)\n. Recompute](\nhttps://toil.xenahubs.net/download/tcga_rsem_isoform_tpm.gz\n)，\nGene\nMapping\nOr download the FPKM-UQ of GDC pipeline:\ngdc\nPan-Cancer (PANCAN) (17 datasets)\n,\nGene\nMapping\npancancerSurvivalData.txt, sample annotations and survival\ninformation, downloaded from\nXENA\nSurvival information is available as a download method: [Curated\nclinical data (n=12, 591)](\nhttps://xenabrowser.net/datapages/?dataset=Survival_SupplementalTable_S1_20171025_xena_sp&host=https://pancanatlas.xenahubs.net&removeHub=https://xena.treehouse.gi.ucsc.edu:443\nCurated\nclinical data\nHow to download the sample information: [TCGA Pan-Cancer (PANCAN)\n(41 datasets) phenotype](\nhttps://xenabrowser.net/datapages/?cohort=TCGA\nPan-Cancer (PANCAN)&removeHub=\nhttps://xena.treehouse.gi.ucsc.edu\nsample\ntype and primary disease (n=12,804) Pan-Cancer Atlas Hub\n。\n输入文件\n跟FigureYa35batch_bestSeparation类似，都需要表达矩阵和生存信息。\n另外，画热图时需要基因分组信息。\neasy_input_surv.csv，生存信息。每行一个sample，三列分别是sample分组（这里是cancer\ntype）、OS、OS.time。\neasy_input_expr.csv，表达矩阵。每行一个基因，每列一个sample。\neasy_input_gene.txt，例文中的m6A基因，用到Symbol和Function两列。前面用\nSymbol\n列提取了表达矩阵；\nFunction\n列作为分组在热图中用不同颜色显示出来，非必需。可以替换成你感兴趣的基因及其分组信息，例如某些特征基因所在的通路等。\nInput files\nSimilar to FigureYa35batch_bestSeparation, both the matrix and the\nsurvival information need to be expressed.\nIn addition, gene grouping information is required for heat\nmapping.\neasy_input_surv.csv, survival information. Each row has a sample,\nand the three columns are sample grouping (here cancer type), OS, and\nOS.time.\neasy_input_expr.csv, Expression Matrix. One gene per row and one\nsample per column.\neasy_input_gene.txt, the m6A gene in the example uses the Symbol and\nFunction columns. The expression matrix was extracted with the ‘Symbol’\ncolumn; The ‘Function’ column is shown as a grouping in different colors\nin the heatmap and is not required. It can be replaced with the gene you\nare interested in and its grouping information, such as the pathway\nwhere certain characteristic genes are located.\n# 读取生存信息和样品分组\n# Read survival information and sample grouping\npansurv <- read.csv(\"easy_input_surv.csv\", row.names = 1, check.names = F)\ntumors <- unique(pansurv$type)\n# 读取表达矩阵\n# Read the expression matrix\npanexpr <- read.csv(\"easy_input_expr.csv\", row.names = 1, check.names = F)\n# 读取目标基因及其分组，用于最后画热图\n# Read the target gene and its grouping for final heat mapping\ngene_group <- read.table(\"easy_input_gene.txt\",sep = \"\\t\",row.names = NULL,check.names = F,stringsAsFactors = F,header = T)\n# 根据GeneCards，该基因替换同义名，否则在TCGA数据里查不到\n# According to GeneCards, this gene is replaced with a synonym, otherwise it will not be found in TCGA data\ngene_group[which(gene_group$Symbol == \"VIRMA\"),\"Symbol\"] <- \"KIAA1429\"\n循环计算基因与癌症的预后关系\ncox和logrank两种方式都计算出来\nCycle calculation of the prognostic relationship between genes and\ncancer\nBoth cox and logrank are calculated\n# cox分析的数据初始化\n# Data initialization for COX analysis\nsurvland.coxhr <- matrix(NA,nrow = nrow(gene_group),ncol = length(tumors),dimnames = list(gene_group$Symbol,tumors)) # 初始化cox分析HR结果 # Initialize the cox analysis of HR results\nsurvland.coxp <- matrix(NA,nrow = nrow(gene_group),ncol = length(tumors),dimnames = list(gene_group$Symbol,tumors)) # 初始化cox分析p值结果 # Initialize the p-value result of COX analysis\nsurvland.coxplot <- matrix(0,nrow = nrow(gene_group),ncol = length(tumors),dimnames = list(gene_group$Symbol,tumors)) # 初始化绘图数据 # Initialize the plot data\n\n# logrank分析的数据初始化\n# Initialize the data analyzed by logrank\nsurvland.logrankhr <- matrix(NA,nrow = nrow(gene_group),ncol = length(tumors),dimnames = list(gene_group$Symbol,tumors)) # 初始化logrank分析hr值结果 # Initialize LogRank to analyze the HR value\nsurvland.logrankp <- matrix(NA,nrow = nrow(gene_group),ncol = length(tumors),dimnames = list(gene_group$Symbol,tumors)) # 初始化logrank分析p值结果 # Initialize logrank to analyze the p-value result\nsurvland.logrankplot <- matrix(0,nrow = nrow(gene_group),ncol = length(tumors),dimnames = list(gene_group$Symbol,tumors)) # 初始化绘图数据 # Initialize the plot data\n\n# 循环计算每一个癌症\n# Cycle counting each cancer\nfor(t in tumors) {\n  for (g in gene_group$Symbol) { # 循环计算每一个基因 # Cycle count each gene\n    sam <- rownames(pansurv[which(pansurv$type == t),]) #提取当前癌症的sample ID # Extract the sample ID of the current cancer\n    expr <- as.numeric(panexpr[g,sam]) # 提取当前基因的表达量 # Extract the expression level of the current gene\n    \n    expr.surv <- data.frame(futime = pansurv[sam,\"OS.time\"], # 提取当前癌症的生存信息 # Extract the survival information of the current cancer\n                            fustat = pansurv[sam,\"OS\"], # 提取当前癌症的生存信息 # Extract the survival information of the current cancer\n                            expr = expr, # 基因表达量 # Gene expression\n                            stringsAsFactors = F)\n    \n    ## 方法一：cox\n    ## Method 1: cox\n    cox <- coxph(Surv(futime,fustat) ~ expr, data = expr.surv) # cox分析 # COX analysis\n    coxSummary <- summary(cox)\n    hr <- as.numeric(coxSummary$coefficients[,\"exp(coef)\"])[1] # 提出HR # Propose HR\n    pvalue <- as.numeric(coxSummary$coefficients[,\"Pr(>|z|)\"])[1] # 提出p值 # Propose a p-value\n    survland.coxhr[g,t] <- hr\n    survland.coxp[g,t] <- pvalue\n    \n    # 为画图准备矩阵\n    # Prepare the matrix for drawing\n    if(pvalue < 0.05) { # 如果p值显著的话存储数据 # Store data if the p-value is significant\n      survland.coxplot[g,t] <- ifelse(hr > 1, 1, -1) # HR>1为风险因素，记为“1”，HR<1为保护因素，记为-1，其余默认为0 # HR>1 is a risk factor, denoted as \"1\", HR<1 is a protective factor, denoted as -1, and the rest are defaulted to 0\n    }\n    \n    ## 方法二：logrank\n    # 用中值（median）为样本分组，如果想用最佳分组，可参考FigureYa35batch_bestSeparationV3_update\n    ## Method 2: logrank\n# Use the median value to group the samples, if you want to use the best grouping, you can refer to the FigureYa35batch_bestSeparationV3_update\n    \n    expr.surv$group = ifelse(expr > median(expr),\"high\",\"low\")\n    expr.surv$group <- factor(expr.surv$group, levels = c(\"low\", \"high\"))\n    \n    data.survdiff <- survdiff(Surv(futime,fustat) ~ group, data = expr.surv)\n    pvalue <- 1 - pchisq(data.survdiff$chisq, length(data.survdiff$n) - 1)\n    hr <- (data.survdiff$obs[2]/data.survdiff$exp[2])/(data.survdiff$obs[1]/data.survdiff$exp[1])\n    survland.logrankhr[g,t] <- hr\n    survland.logrankp[g,t] <- pvalue\n    \n    # 为画图准备矩阵\n    # Prepare the matrix for drawing\n    if(pvalue < 0.05) { # 如果p值显著的话存储数据 # Store data if the p-value is significant\n      survland.logrankplot[g,t] <- ifelse(hr > 1, 1, -1) # HR>1为风险因素，记为“1”，HR<1为保护因素，记为-1，其余默认为0 # HR>1 is a risk factor, denoted as \"1\", HR<1 is a protective factor, denoted as -1, and the rest are defaulted to 0\n    }\n  }\n}\n\n## 保存到文件，便于DIY其他形式的图\n# 或者以更大范围的基因（例如全基因组）作为输入，然后用HR和pvalue筛选出genes associated with the overall survival of patients (worse/better survival) in at least one cancer type或你关心的几种癌症或所有癌症\n# cox\n## Save to a file for DIY other forms of diagrams\n# Or take a larger range of genes (e.g., whole genome) as input, and then use HR and pvalue to filter out genes associated with the overall survival of patients (worse/better survival) in at least one cancer type or a few or all cancers you care about\n# cox\nwrite.table(survland.coxplot, file = \"cox_genes associated with the OS.txt\", sep = \"\\t\", row.names = T, col.names = T, quote = F)\nwrite.table(survland.coxhr,file = \"cox HR in survival landscape.txt\",sep = \"\\t\",row.names = T,col.names = NA,quote = F)\nwrite.table(survland.coxp,file = \"cox pvalue in survival landscape.txt\",sep = \"\\t\",row.names = T,col.names = NA,quote = F)\n\n# logrank\nwrite.table(survland.logrankplot, file = \"logrank_genes associated with the OS.txt\", sep = \"\\t\", row.names = T, col.names = T, quote = F)\nwrite.table(survland.logrankhr,file = \"logrank HR in survival landscape.txt\",sep = \"\\t\",row.names = T,col.names = NA,quote = F)\nwrite.table(survland.logrankp,file = \"logrank pvalue in survival landscape.txt\",sep = \"\\t\",row.names = T,col.names = NA,quote = F)\n开始画图\n用pheatmap分别画出cox和logrank的结果。\nStart drawing\nUse pheatmap to plot the results of cox and logrank,\nrespectively.\n# 自定义颜色\n# Custom colors\nred <- \"#D02E20\"\nblue <- \"#4D76B7\"\ngreen <- \"#50B544\"\nyellow <- \"#F8C77A\"\ncyan <- \"#5AC8F9\"\n\nannRow <- gene_group # 行基因注释 # row gene annotation\nrownames(annRow) <- annRow$Symbol\nannColors <- list(\"Function\" = c(\"Readers\" = green,\n                                 \"Writers\" = yellow,\n                                 \"Eraser\" = cyan))\n\n# cox\npheatmap(survland.coxplot,\n         border_color = \"grey50\",\n         show_rownames = T, # 显示行名 # Show the row name\n         show_colnames = T, # 显示列明 # Display column names\n         cluster_rows = F, # 行不聚类 # Rows are not clustered\n         cluster_cols = F, # 列不聚类 # Columns are not clustered\n         color = c(blue,\"grey95\",red),\n         annotation_row = annRow[,\"Function\",drop = F],\n         annotation_colors = annColors,\n         legend_breaks = c(-1,0,1), # 修改图例的显示位置 # Modify the display position of the legend\n         legend_labels = c(\"Protective\",\"p>0.05\",\"Risky\"), # 修改图例标签 # Modify legend labels\n         cellwidth = 10, # 单元格宽度 # Cell width\n         cellheight = 10, # 单元格高度 # Cell height\n         filename = \"m6A survival landscape using cox.pdf\", # 保存文件 # Save the file\n         width = 8, # 图片宽度 # Image width\n         height = 6) # 图片高度 # Image height\n\n# logrank\npheatmap(survland.logrankplot,\n         border_color = \"grey50\",\n         show_rownames = T, # 显示行名 # Show row names\n         show_colnames = T, # 显示列明 # Show column names\n         cluster_rows = F, # 行不聚类 # Rows are not clustered\n         cluster_cols = F, # 列不聚类 # Columns are not clustered\n         color = c(blue,\"grey95\",red),\n         annotation_row = annRow[,\"Function\",drop = F],\n         annotation_colors = annColors,\n         legend_breaks = c(-1,0,1), # 修改图例的显示位置 # Modify the display position of the legend\n         legend_labels = c(\"Protective\",\"p>0.05\",\"Risky\"), # 修改图例标签 # Modify legend labels\n         cellwidth = 10, # 单元格宽度 # Cell width\n         cellheight = 10, # 单元格高度 # Cell height\n         filename = \"m6A survival landscape using logrank.pdf\", # 保存文件  # Save the file\n         width = 8, # 图片宽度 # Image width\n         height = 6) # 图片高度 # Image height\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa210survivalScape_FigureYa210survivalScape",
      "title": "FigureYa210survivalScape/FigureYa210survivalScape.html",
      "html": "FigureYa210survivalScape/FigureYa210survivalScape.html",
      "text": "texts/main_FigureYa210survivalScape_FigureYa210survivalScape.txt",
      "folder": "FigureYa210survivalScape",
      "thumb": "gallery_compress/FigureYa210survivalScape.webp"
    },
    "word_count": 1885,
    "lines_count": 359,
    "title": "FigureYa210survivalScape",
    "description": "用survdiff复现文章里的图，把所有基因的HR、pvalue输出到文件。 Requirement Description Use survdiff to reproduce the graph in the article, and output the HR",
    "input_data_types": [
      "表达矩阵",
      "临床数据",
      "DNA-seq",
      "生存数据"
    ],
    "output_types": [
      "热图",
      "统计表格",
      "箱线图",
      "散点图",
      "生存曲线"
    ],
    "technical_methods": [
      "聚类分析",
      "通路分析",
      "生存分析"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "header",
      "width",
      "cluster_cols",
      "n",
      "pvalue",
      "nrow",
      "cellwidth",
      "group",
      "cohort"
    ]
  },
  {
    "id": "main_FigureYa21TCGA2table_FigureYa21TCGA2table",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa21TCGA2table_FigureYa21TCGA2table.txt",
    "content": "FigureYa21TCGA2table\nFigureYa21TCGA2table\nAuthor(s)\n: Guangchuang Yu; Ying Ge, Yijing\nChen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\nTCGA临床数据直接用R代码画出三线表。\nDraw a three-line table directly using R code for TCGA clinical\ndata.\n使用场景\nUsage scenario\n输入数据是临床样品信息，例如TCGA提供的clinical information。\n根据年龄、性别、种族、病毒感染、吸烟史等特征进行分类对比，可能发现疾病、癌症发病、转移、耐药跟这些特征的关系，例如发现亚洲非吸烟女性肺癌发病率高。\n如果还想加入某个基因的表达数据，计算单因素和多因素cox回归的HR，可参考FigureYa47HRtable，还能生成html、word、csv格式的表格。\nThe input data is information on clinical samples, such as the\nclinical information provided by TCGA.\nCategorical comparisons based on characteristics such as age, gender,\nethnicity, viral infection, smoking history, etc., may reveal the\nrelationship between disease, cancer incidence, metastasis, and drug\nresistance and these characteristics, for example, a high incidence of\nlung cancer was found in Asian non-smoking women.\nIf you also want to add the expression data of a certain gene, and\ncalculate the HR of one-way and multi-factor cox regression, you can\nrefer to FigureYa47HRtable, which can also generate tables in html, word\nand csv formats.\n环境设置\nEnvironment setting\nsource(\"install_dependencies.R\")\nlibrary(TCGAbiolinks)\nlibrary(dplyr)\nlibrary(kableExtra)\n你可能还需要安装pdflatex\nYou may also need to install pdflatex\n输入文件的准备\nPreparation of input files\n下载TCGA临床数据。\n如果你不需要TCGA数据，而是自己收集的数据，可以整理成像\neasy_input.csv\n那样的格式，跳过这步，直接进入下一步：“按列分成4组”。\nDownload the TCGA clinical data.\nIf you don’t need the TCGA data, but have collected it yourself, you\ncan organize it in a format like\neasy_input.csv\n, skip this\nstep, and go directly to the next step: “Split into 4 groups by\ncolumns”.\n#参数`project = `后面写你要看的癌症名称缩写\n#parameter `project = ` followed by the abbreviated name of the cancer you want to see\nclinical <- GDCquery(project = \"TCGA-LIHC\", \n                  data.category = \"Clinical\", \n                  file.type = \"xml\")\nGDCdownload(clinical)\ncliquery <- GDCprepare_clinic(clinical, clinical.info = \"patient\")\ncolnames(cliquery)[1] <- \"Tumor_Sample_Barcode\"\nwrite.csv(cliquery,\"easy_input.csv\")\n按列分成4组\nSplit into 4 groups by columns\n即\nAlive\n、\nDead with tumor\n、\nDead tumor free\n、\nTotal\n。\nThat is,\nAlive\n,\nDead with tumor\n,\nDead tumor free\n,\nTotal\n.\nx <- read.csv(\"easy_input.csv\")\n\n#%>%，是管道操作符，将上一个函数的输出作为下一个函数的输入\n#其实用for循环一个一个嵌套也能实现，就是写起来太烦\n#用dplyr包的管道操作符，无论读写都变得清晰容易了\n#%>% is a pipeline operator that takes the output of the previous function and uses it as input for the next function.\n#In fact, it can be realized by nesting one by one in a for loop, but it's too annoying to write.\n#Using the pipeline operator of the dplyr package, both reading and writing become clear and easy\n\n#挑出生存状态是“Alive”的行\n#select rows with a survival status of \"Alive\"\nx1 <- x %>% filter(vital_status == \"Alive\") \n#挑出生存状态是“Dead”并且有tumor的行\n#select rows with a survival status of \"Dead\" and a presence of a tumor\nx2 <- x %>% filter(vital_status == \"Dead\" & person_neoplasm_cancer_status == \"WITH TUMOR\") \nx3 <- x %>% filter(vital_status == \"Dead\" & person_neoplasm_cancer_status == \"TUMOR FREE\")\n\n#把没信息的行去掉，用于算总数\n#remove lines without information to calculate the total\nxx = x %>% filter(vital_status != \"\" & person_neoplasm_cancer_status != \"\")\n按项细分\nBreakdown by item\n性别\nGender\n#还记得前面提取的x1是生存状态是“Alive”的行，把这些行按性别分组\n#remember the rows where x1 was extracted with the survival status \"Alive\" and group these rows by gender\ns1 = x1 %>% group_by(gender) %>% summarise(alive=n())\ns1\ns2 = x2 %>% group_by(gender) %>% summarise(tumor=n())\ns3 = x3 %>% group_by(gender) %>% summarise(tumor_free=n())\n\n#依次合并s1、s2、s3\n#merge s1, s2, and s3 in sequence\nsex = full_join(s1, s2, by='gender') %>% full_join(s3, by='gender') %>% as.data.frame\nsex\nrn = sex[,1]#取出第一列，后面作为行名 take out the first column followed by the row name\nsex = sex[,-1]#先把不需要计算的第一列删除 first delete the first column that does not need to be calculated\n\n#计算p value\n#calculate p value\nsex.p = chisq.test(sex)$p.value\nprint(sex.p)\n#算总数\n#calculate total\nsex$total = rowSums(sex)\ncs = colSums(sex)\n\n#算百分比、写到括号里\n#用sprintf格式化为小数点后保留1位，加上百分号\n#用paste0加到个数后面，默认是sep=\"\"，比paste代码更简洁\n#calculate the percentage, write it in parentheses\n#format with sprintf to 1 decimal place, add percent sign\n#add after the number of digits with paste0, default is sep=\"\", more concise than paste code\nsex <- rbind(paste0(sex[1,], \" (\", sprintf(\"%1.1f\\\\%%\", sex[1,]/cs*100), \")\"),\n    paste0(sex[2,], \" (\", sprintf(\"%1.1f\\\\%%\", sex[2,]/cs*100), \")\"))\n\n#加上行名、列名\n#add row and column names\nrownames(sex) = rn\ncolnames(sex) = paste0(c(\"Alive\", \"Dead with tumor\", \"Dead tumor free\", \"Total\"), \n                \"\\n(n=\", cs, \")\")\nprint(sex)\n年龄\nAge\n#先写个函数，用到dplyr包\n#有些年龄数据缺失，需要去掉\n#write a function first, using the dplyr package\n#some age data is missing and needs to be removed\nage_stats <- function(x) {\n   res <- x %>% summarise(age = round(mean(age_at_initial_pathologic_diagnosis,na.rm = T), 1), \n                sd=round(sd(age_at_initial_pathologic_diagnosis,na.rm = T), 1),\n                median=round(median(age_at_initial_pathologic_diagnosis,na.rm = T), 1),\n                min=round(min(age_at_initial_pathologic_diagnosis,na.rm = T), 1),\n                max=round(max(age_at_initial_pathologic_diagnosis,na.rm = T), 1)\n                )\n   c(\"Mean (SD)\" = with(res, paste0(age, \" (\", sd, \")\")),\n       \"Median [MIN, MAX]\" = with(res, paste0(median, \" [\", min, \",\", max, \"]\"))#,\n   )             \n}\n\na1 = age_stats(x1)\na2 = age_stats(x2)\na3 = age_stats(x3)\naa = age_stats(xx)\n#依次合并a1、a2、a3、aa\n#merge a1, a2, a3 and aa in sequence\nage = cbind(a1, a2) %>% cbind(a3) %>% cbind(aa)\n\ncolnames(age) = colnames(sex)\nprint(age)\n阶段\nStage\nstage_stats <- function(x) {\n    x %>% filter(stage_event_pathologic_stage != \"\") %>% \n        group_by(stage_event_pathologic_stage) %>% summarise(stage = n())\n}\n\nsg1 = stage_stats(x1)\nsg2 = stage_stats(x2)\nsg3 = stage_stats(x3)\nsgx = stage_stats(xx)\nsg = full_join(sg1, sg2, by=\"stage_event_pathologic_stage\") %>% \n    full_join(sg3, by=\"stage_event_pathologic_stage\") %>% \n    full_join(sgx, by=\"stage_event_pathologic_stage\") %>% \n    as.data.frame\n\nrownames(sg) = sg[,1]\nsg = sg[,-1]\ncolnames(sg) = colnames(sex)\n\nprint(sg)\n# 卡方检验  \n# total列不用于计算，删掉它\n# chisq test\n# the total column is not used for calculation, delete it\nsgx <- sg[, -4]\n# 有些stage在分组里没人，不用于计算p value\n# some stages in the group have no participants and are not used for calculating the p-value\nsgx <- sgx[!apply(sgx, 1, anyNA),]\n# 计算p value\n# calculate p value\nsg.p = chisq.test(sgx)$p.value\n\n# NA的啥都不打印\n# NA doesn't print anything\nsgv2 = lapply(1:nrow(sg), function(i) ifelse(is.na(sg[i,]), \"\", \n    paste0(sg[i,], \" (\", sprintf(\"%1.1f\\\\%%\", sg[i,]/cs * 100), \")\"))) %>% \n    do.call(rbind, .)\n#或者用下面这种，打印“NA”字样\n#or use the following, which prints “NA”.\n#sgv2 = lapply(1:nrow(sg), function(i) ifelse(is.na(sg[i,]), NA, \n#    paste0(sg[i,], \" (\", sprintf(\"%1.1f\\\\%%\", sg[i,]/cs * 100), \")\"))) %>% \n#    do.call(rbind, .)\n\nrownames(sgv2) = rownames(sg)\ncolnames(sgv2) = colnames(sg)\nprint(sgv2)\n合并\nMerge\nres = rbind(sex, age) %>% rbind(sgv2) %>% as.data.frame\nprint(res)\n生成表格\nGenerate tables\n用\nkableExtra\n包生成好看的html表格\nGenerate nice looking html tables with the\nkableExtra\npackage\nif (knitr:::is_html_output()) {\n    cn = sub(\"\\n\", \"<br>\", colnames(res))\n} else if (knitr:::is_latex_output()) {\n    usepackage_latex('makecell')\n    usepackage_latex('booktabs')\n    cn = linebreak(colnames(res), align=\"c\")\n}   \n\n#如果你不用knit，而是复制粘贴代码，需要运行下面这行\n#If you don't use knit but instead copy and paste the code, you need to run the following line\n#cn = colnames(res)\n\nres %>%\n    kable(booktabs = T, escape = F, caption = \"Example Table\",\n        col.names = cn) %>%\n    kable_styling(c(\"striped\", \"scale_down\")) %>%\n    group_rows(\"Gender*\", 1, 2) %>% #根据p value手动加* manually add * according to p value\n    group_rows(\"Age\", 3, 4) %>% #根据具体分组数设置行数，例如这里年龄是两行，这里写3和4 set the number of rows according to the number of specific groups, for example, here age is two rows, here write 3 and 4\n    group_rows(\"Stage\", 5, 13) %>% #根据具体分组数设置行数，例如从5到13都是stage，这里写5和13 set the number of rows according to the number of specific groups, for example, from 5 to 13 are stage, here write 5 and 13\n    footnote(general = \"significant\",\n             #general = paste(\"P-value =\", sg.p), #或者用这行直接打印p value or use this line to print p value directly\n             general_title = \"*: \", \n             footnote_as_chunk = T, title_format = \"italic\")\nExample Table\nAlive<br>(n=315)\nDead with tumor<br>(n=56)\nDead tumor free<br>(n=33)\nTotal<br>(n=404)\nGender*\nFEMALE\n96 (30.5%)\n27 (48.2%)\n10 (30.3%)\n133 (32.9%)\nMALE\n219 (69.5%)\n29 (51.8%)\n23 (69.7%)\n271 (67.1%)\nAge\nMean (SD)\n58.8 (13.3)\n62.6 (12.9)\n68.3 (11)\n60.1 (13)\nMedian [MIN, MAX]\n61 [16,84]\n62.5 [23,90]\n69 [35,83]\n61 [16,90]\nStage\nStage I\n150 (47.6%)\n20 (35.7%)\n20 (60.6%)\n182 (45.0%)\nStage II\n78 (24.8%)\n7 (12.5%)\n7 (21.2%)\n85 (21.0%)\nStage III\n1 (0.3%)\n1 (1.8%)\n2 (0.5%)\nStage IIIA\n53 (16.8%)\n11 (19.6%)\n4 (12.1%)\n65 (16.1%)\nStage IIIB\n8 (2.5%)\n2 (3.6%)\n10 (2.5%)\nStage IIIC\n8 (2.5%)\n1 (1.8%)\n9 (2.2%)\nStage IV\n1 (0.3%)\n1 (0.2%)\nStage IVA\n1 (0.3%)\nStage IVB\n2 (3.6%)\n2 (0.5%)\n*:\nsignificant\n#下面要把P value加到最后一列\n\n#如果p值太小，不想打太多位，round一下位数又变成0，就用科学记数\n#例如用sprintf(\"%1.1e\", sex.p)替换round(sex.p, 3)\n\n#哪个P value显著，就在哪个p value后面加上*\n#就像这样：“paste0(round(sg.p, 3), footnote_marker_symbol(1))”\n\n#The following is to add the p value to the last column.\n\n#If the p value is too small, and you don't want too many digits, and round turns the number of digits to 0, use scientific notation.\n#For example, use sprintf(“%1.1e”, sex.p) to replace round(sex.p, 3).\n\n# Add * to any p-value that is significant.\n#Like this: “paste0(round(sg.p, 3), footnote_marker_symbol(1))”\n\nres[[\"P Value\"]] = c(\"\", paste0(round(sex.p, 3), footnote_marker_symbol(1)), ## sex\n                 rep(\"\", 2), ## age\n                 rep(\"\", nrow(sg)-1), round(sg.p, 3) ## stage\n                 )\ncn <- c(cn, \"P Value\") #加个列名 add a column name\n\nres %>%\n    kable(booktabs = T, escape = F, caption = \"Example Table\",\n        col.names = cn) %>%\n    kable_styling(c(\"striped\", \"scale_down\")) %>%\n    group_rows(\"Gender\", 1, 2) %>% #根据具体分组数设置行数，例如性别是两行，这里写1和2 set the number of rows according to the number of specific groups, for example, gender is two rows, here write 1 and 2\n    group_rows(\"Age\", 3, 4) %>% #根据具体分组数设置行数，例如这里年龄是两行，这里写3和4 set the number of rows according to the number of specific groups, for example, here age is two rows, here write 3 and 4\n    group_rows(\"Stage\", 5, 13) %>% #根据具体分组数设置行数，例如从5到13都是stage，这里写5和13 set the number of rows according to the number of specific groups, for example, from 5 to 13 are stage, here write 5 and 13\n    footnote(general = \"significant\", \n             #general = paste(\"P-value =\", sg.p), #或者用这行直接打印p value or use this line to print p value directly\n            general_title = \"*\", \n            footnote_as_chunk = T, title_format = \"italic\")\nExample Table\nAlive<br>(n=315)\nDead with tumor<br>(n=56)\nDead tumor free<br>(n=33)\nTotal<br>(n=404)\nP Value\nGender\nFEMALE\n96 (30.5%)\n27 (48.2%)\n10 (30.3%)\n133 (32.9%)\nMALE\n219 (69.5%)\n29 (51.8%)\n23 (69.7%)\n271 (67.1%)\n0.032<sup>*</sup>\nAge\nMean (SD)\n58.8 (13.3)\n62.6 (12.9)\n68.3 (11)\n60.1 (13)\nMedian [MIN, MAX]\n61 [16,84]\n62.5 [23,90]\n69 [35,83]\n61 [16,90]\nStage\nStage I\n150 (47.6%)\n20 (35.7%)\n20 (60.6%)\n182 (45.0%)\nStage II\n78 (24.8%)\n7 (12.5%)\n7 (21.2%)\n85 (21.0%)\nStage III\n1 (0.3%)\n1 (1.8%)\n2 (0.5%)\nStage IIIA\n53 (16.8%)\n11 (19.6%)\n4 (12.1%)\n65 (16.1%)\nStage IIIB\n8 (2.5%)\n2 (3.6%)\n10 (2.5%)\nStage IIIC\n8 (2.5%)\n1 (1.8%)\n9 (2.2%)\nStage IV\n1 (0.3%)\n1 (0.2%)\nStage IVA\n1 (0.3%)\nStage IVB\n2 (3.6%)\n2 (0.5%)\n0.349\n*\nsignificant\n生成pdf格式的表格\nGenerate a table in pdf format\n打开FigureYa21TCGA2table.Rmd文件，把第5行换成\noutput: latex_document\n删除FigureYa21TCGA2table.Rmd中所有中文，保存为\nFigureYa21TCGA2table_latex.Rmd\n在Rstudio中点击\nKnit\n，会生成\nFigureYa21TCGA2table_latex.tex\n文件\n通过复制粘贴运行下面两行，就会输出pdf格式的文件\nopen FigureYa21TCGA2table.Rmd file, replace line 5 with\noutput: latex_document\nDelete all Chinese characters in FigureYa21TCGA2table.Rmd and\nsave it as\nFigureYa21TCGA2table_latex.Rmd\n.\nClick\nKnit\nin Rstudio, it will generate\nFigureYa21TCGA2table_latex.tex\nfile.\nRun the following two lines by copying and pasting, it will\noutput the file in pdf format\nlibrary(tools)\ntexi2pdf(\"FigureYa21TCGA2table_latex.tex\")\n注：如果要表格页不显示代码，就把第224行换成这句：“```{r eval=T, echo\n= F}”\nNote: If you want the form page to not show the code, replace line\n224 with this, “```{r eval=T, echo = F}”\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa21TCGA2table_FigureYa21TCGA2table",
      "title": "FigureYa21TCGA2table/FigureYa21TCGA2table.html",
      "html": "FigureYa21TCGA2table/FigureYa21TCGA2table.html",
      "text": "texts/main_FigureYa21TCGA2table_FigureYa21TCGA2table.txt",
      "folder": "FigureYa21TCGA2table",
      "thumb": "gallery_compress/FigureYa21TCGA2table.webp"
    },
    "word_count": 1694,
    "lines_count": 456,
    "title": "FigureYa21TCGA2table",
    "description": "Requirement description TCGA临床数据直接用R代码画出三线表。 Draw a three-line table directly using R code for TCGA clinical",
    "input_data_types": [
      "临床数据",
      "生存数据"
    ],
    "output_types": [
      "统计表格",
      "生存曲线"
    ],
    "technical_methods": [
      "生存分析"
    ],
    "biology_areas": [
      "癌症研究",
      "感染性疾病",
      "药物研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [
      "”\nNote: If you want the form page to not show the code, replace line\n224 with this, “"
    ],
    "key_parameters": [
      "info",
      "min",
      "res",
      "sd",
      "n",
      "age",
      "s1",
      "total",
      "a1",
      "sg1"
    ]
  },
  {
    "id": "main_FigureYa248MutLandscape_FigureYa248MutLandscape",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa248MutLandscape_FigureYa248MutLandscape.txt",
    "content": "FigureYa248MutLandscape\nFigureYa248MutLandscape\nAuthor(s)\n: Xiaofan Lu\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nXiaofan\nLu写的MOVICS包很神奇，一个包几乎就画出了分子分型文章的大部分图。Xiaofan\nLu写的这篇预印本最近已接收，刚好可以作为MOVICS包的应用案例。接下来会连续实现这篇文章里的几个图。\nFigure2b的突变综合性热图，看起来非常酷炫。里头涉及的分析可参考相应的FigureYa，包括TMB计算，突变signature，突变频数，拷贝数变异情况等等。如果Xiaofan\nLu可以随便拟定数据画图也可以！\nRequirement Description\nThe MOVICS package I wrote was amazing, and a single package almost\ndrew most of the diagram of the molecular typing article. This preprint\nI wrote was recently received and could be used as an example of the use\ncase for the MOVICS package. Next, we will continue to crowdsource\nseveral pictures in this article.\nFigure2b’s comprehensive heatmap of mutations looks really cool. The\nanalysis involved in it is also available in FigureYa, including TMB\ncalculation, mutation signature, mutation frequency, copy number\nvariation, and so on.\n出自\nhttps://www.biorxiv.org/content/10.1101/2021.05.30.446369v1.full\nfrom\nhttps://www.biorxiv.org/content/10.1101/2021.05.30.446369v1.full\nFigure 2. Molecular landscape of four MIBC iCSs. b) Genomic\nalteration landscape according to iCS. Samples are ordered by the\ncombined contribution of APOBEC-related mutational signatures (SBS2 +\nSBS13) with each iCS. Tumour mutation burden (TMB), relative\ncontribution of four mutational signatures, selected differentially\nmutated genes (>5%) and broad-level copy number alterations\n(>20%), and selected genes located within chromosome 9p21.3 are shown\nfrom the top to the bottom panels. The proportion of iCS in each\nalteration is presented in the right bar charts.\n应用场景\n这里用complexheatmap绘制mutation\nlandscape，图中同时展示了各亚型的突变01矩阵、突变频数、突变signature、拷贝数。这种组合热图也可以用于其他类型数据的合并展示。\n突变频数TMB可参考FigureYa51TMB的mutation-load.txt，TCGA的TMB，来源于2018年的这篇文献：The\nImmune Landscape of Cancer\nhttps://pubmed.ncbi.nlm.nih.gov/29628290/\n，我们直接拿来用就好。\n突变签名可参考FigureYa110mutationSignature。\n更多分析、展示突变、拷贝数的FigureYa看这里\n文中很多图我们都实现过，例如：\nFigure 1b的画法可参考FigureYa196PanPie\nFigure 3de可产考FigureYa25sankey和FigureYa125Fishertest\nFigure 4f可参考FigureYa106immunotherapy\nFigure 5b可参考FigureYa12box，f可参考FigureYa162boxViolin\nFigure\n6可参考FigureYa35batch_bestSeparation，FigureYa144DiagHeatmap或\nhttps://mp.weixin.qq.com/s/34WRZRBVPHUNRLlzNH2nzw\nApplication Scenarios\nHere, the mutation landscape is plotted with ComplexHeatMap, which\nshows the mutation 01 matrix, mutation frequency, mutation signature,\nand copy number of each subtype at the same time. This combined heatmap\ncan also be used for the combined display of other types of data.\nFor the mutation frequency TMB, please refer to the\nmutation-load.txt of FigureYa51TMB, the TMB of TCGA, from this 2018\narticle: The Immune Landscape of Cancer\nhttps://pubmed.ncbi.nlm.nih.gov/29628290/\n, let’s just\nuse it.\nFor more information about mutation signatures, see\nFigureYa110mutationSignature.\nFor more analysis and display of mutations and copy numbers of\nFigureYa see here\nMany of the pictures in the article, such as:\nFor more information about Figure 1b, see FigureYa196PanPie\nFigure 3de can be tested with FigureYa25sankey and\nFigureYa125Fishertest\nFigure 4f can refer to Figure Ya106 immunotherapy\nFigure 5b can refer to FigureYa12box, and f can refer to\nFigureYa162boxViolin\nFor Figure 6, see FigureYa35batch_bestSeparation,\nFigureYa144DiagHeatmap, or\nhttps://mp.weixin.qq.com/s/34WRZRBVPHUNRLlzNH2nzw\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nlibrary(ComplexHeatmap)\nlibrary(RColorBrewer)\n\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # error messages are displayed in English\noptions(stringsAsFactors = FALSE) #禁止chr转成factor  #chr is not allowed to be converted to factor\n输入文件\nInput files\n开始画图\n整个图形由热图、热图上方注释（包括柱形图和瀑布图）、热图右侧百分比堆积图组成。自上而下分别是：\n突变负荷柱状图，Tumour mutation burden (TMB)\n突变签名瀑布图，relative contribution of four mutational\nsignatures\n突变基因热图，selected differentially mutated genes (>5%)\n拷贝数热图1，broad-level copy number alterations (>20%)\n拷贝数热图2，selected genes located within chromosome 9p21.3\nStart drawing\nThe entire graph consists of a heatmap, annotations above the heatmap\n(including column charts and waterfall charts), and a percentage stacked\nplot on the right side of the heatmap. From top to bottom, they are:\nTumour mutation burden (TMB)\nWaterfall chart of mutational signatures, relative contribution of\nfour mutational signatures\nMutated gene heatmap, selected differentially mutated genes\n(>5%)\nCopy number heatmap 1, broad-level copy number alterations\n(>20%)\nCopy number heatmap 2, selected genes located within chromosome\n9p21.3\n# 设置亚型颜色\n# Set the subtype color\nclust.col <- c(\"#DD492E\",\"#40548A\",\"#32A087\",\"#EC7D21\")\nblue   <- \"#5bc0eb\"\nred    <- \"#f25f5c\"\n\n# 处理突变签名数据\n# Handle mutation signature data\nmutsig <- mutsig[,c(\"Signature.1\",\"Signature.2\",\"Signature.5\",\"Signature.13\")] # 文章中用到3种类型的signature， SBS1 (age-related), SBS2 and SBS13 (APOBEC activity-related) and SBS5 (ERCC2 mutation-related) # There are 3 types of signatures used in the article, SBS1 (age-related), SBS2 and SBS13 (APOBEC activity-related) and SBS5 (ERCC2 mutation-related)\nmutsig$APOBEC <- mutsig$Signature.2 + mutsig$Signature.13 # APOBEC相关的签名由签名2和3叠加 # APOBEC-related signatures are overlaid by signatures 2 and 3\nmutsig$CMOIC <- subt[rownames(mutsig),\"CMOIC\"] # 添加亚型结果 # Add subtype results\nmutsig <- mutsig[order(mutsig$CMOIC,-mutsig$APOBEC,decreasing = F),] # 确定整个热图的排序，按照亚型升序以及APOBEC降序排列 # Determine the order of the entire heat map, in ascending order of subtype and descending order of APOBEC\n突变主区域热图 （分析结果来自突变二值矩阵以及突变签名分析）\nHeatmap of the main region of the mutation (analysis results from\nthe mutation binary matrix and mutation signature analysis)\n# 挑选要展示的基因\n# Pick the genes you want to display\nmutgene <- c(\"FGFR3\",\n             \"TP53\",\n             \"RB1\",\n             \"NFE2L2\",\n             \"KIAA0947\",\n             \"MEGF8\",\n             \"STAG2\",\n             \"SMARCA2\",\n             \"RELN\",\n             \"INO80\",\n             \"TRANK1\",\n             \"SPEN\",\n             \"MED12\",\n             \"KMT2A\",\n             \"COL6A6\",\n             \"AKAP9\",\n             \"KIF21A\",\n             \"ARID2\",\n             \"DIDO1\")\n\n# 制作oncoprint的输入数据\n# Create input data for oncoprint\nonco.input <- mut[mutgene,rownames(mutsig),]\nonco.input[onco.input == 1] <- \"Mutated\" # 二值矩阵中1记为突变 # 1 in the binary matrix is denoted as a mutation\nonco.input[onco.input != \"Mutated\"] <- \"\" # 非“突变”给予空值 # Non-\"mutations\" are given null values\nalter_fun = list(\n  background = function(x, y, w, h) {\n    grid.rect(x, y, w-unit(0.5, \"mm\"), h-unit(0.5, \"mm\"), gp = gpar(fill = \"#dcddde\", col = \"#dcddde\"))\n  },\n  Mutated = function(x, y, w, h) {\n    grid.rect(x, y, w-unit(0.5, \"mm\"), h-unit(0.5, \"mm\"), gp = gpar(fill = \"#A60000\", col = \"#A60000\")) \n  }\n)\ncol = c(\"Mutated\" =\"#A60000\") # 突变颜色，注意这里只给了主图像的图例 # Mutate color, note that only the legend of the main image is given here\n\nmy_ann <- subt[rownames(mutsig),,drop = F]\nmy_annotation = HeatmapAnnotation(df = my_ann, \n                                  col = list(CMOIC = c(\"CS1\" = clust.col[1],\n                                                       \"CS2\" = clust.col[2],\n                                                       \"CS3\" = clust.col[3],\n                                                       \"CS4\" = clust.col[4])))\n\n# 突变主区域的上部注释（突变负荷柱状图）\n# Upper annotation of the main region of the mutation (histogram of mutation burden)\ntop_anno <- anno_barplot(as.numeric(tmb[rownames(mutsig),\"log10TMB\"]),\n                         border = FALSE,\n                         gp = gpar(fill = \"#3379B4\",border =NA,lty=\"blank\"), \n                         height = unit(2.5, \"cm\"))\n\n# 突变主区域的上部注释（突变签名柱状图）\n# Upper annotation of the main region of the mutation (histogram of mutation signature)\ntmp <- mutsig[,c(\"Signature.2\",\"Signature.13\",\"Signature.1\",\"Signature.5\")] # 只取和APOBEC有关的签名 # Only APOBEC-related signatures are taken\ntmp$Others <- 1 - rowSums(tmp) # 计算其他签名的比例 # Calculate the proportion of other signatures\ntop_anno2 <- anno_barplot(as.matrix(tmp),\n                          border = FALSE,\n                          gp = gpar(fill = c(brewer.pal(6,\"Paired\")[c(2,1,6,5)],\"grey90\"), \n                                    border = NA, # 无边框 # Borderless\n                                    lty = \"blank\"),\n                          height = unit(2, \"cm\")) # 高度 # Height\n\ntmp <- as.data.frame(t(mut[mutgene,rownames(mutsig),]))\nmut.order <- names(sort(colSums(tmp),decreasing = T)) # 根据突变频数高低排序展示突变的顺序 # Displays the order of mutations according to the frequency of mutations\ntmp$CMOIC <- subt[rownames(tmp),\"CMOIC\"]\npct <- NULL # 计算各个基因突变的百分比 # Calculate the percentage of mutations in each gene\nfor (i in mut.order) {\n  tmp1 <- tmp[,c(i,\"CMOIC\")]\n  tmp1 <- as.data.frame.array(table(tmp1[,1],tmp1$CMOIC))[2,]/sum(tmp1[,1])\n  pct <- rbind.data.frame(pct,tmp1)\n}\nrownames(pct) <- mut.order\n\n# 添加右侧百分比堆积柱状图\n# Add the percentage stacked histogram on the right\nright_anno <- anno_barplot(as.matrix(pct),\n                           which = \"row\",\n                           border = FALSE,\n                           gp = gpar(fill = clust.col,border=NA,lty=\"blank\"), \n                           bar_width = 0.6,\n                           width = unit(1.8, \"cm\"),\n                           height = unit(1, \"cm\"))\n \nop1 <- oncoPrint(onco.input[mut.order,rownames(my_ann)], # 排序的突变矩阵 # Sorted mutation matrix\n                 alter_fun = alter_fun,  # 主区域的函数，包括各单元格大小、背景颜色等等 # Functions in the main area, including cell size, background color, etc\n                 col = col, # 突变颜色 # Mutate colors\n                 bottom_annotation = NULL, # 无底部注释 # No bottom comment\n                 top_annotation = c(HeatmapAnnotation(TMB = top_anno), # 顶部第一个注释：TMB # First note at the top: TMB\n                                    my_annotation, # 顶部第二个注释：亚型 # Second note at the top: Isotype\n                                    HeatmapAnnotation(MutSig = top_anno2)), # 顶部第三个注释：突变签名 # Third note at the top: Mutation signature\n                 column_order = rownames(my_ann), # 样本的排序，根据突变签名的顺序 # Sorting of samples, according to the order of mutation signatures\n                 right_annotation = rowAnnotation(PCT = right_anno), # 右侧堆叠柱状图注释 # Annotation of the stacked column chart on the right\n                 show_pct = T, # 展示左侧的百分比 # Show the percentage on the left\n                 column_title = \"\", # 不显示主题 # Topics are not displayed\n                 show_heatmap_legend = T, # 展示图例 # Show legend\n                 column_split = my_ann$CMOIC, # 根据亚型切分热图 # Slice the heat map according to the subtype\n                 column_title_gp = gpar(fontsize = 8),\n                 row_names_gp = gpar(fontsize = 8),\n                 column_names_gp = gpar(fontsize = 8))\nop1\n拷贝数主区域热图1 （分析结果来自GISTIC2.0）\nCopy number primary region heatmap 1 (analysis results from\nGISTIC2.0)\n# 选择要展示的拷贝数区域\n# Select the copy number area you want to display\nlesion.sig <- c(\"3p25.2-Amp\",\n                \"7p15.3-Amp\",\n                \"8p11.23-Amp\",\n                \"10p14-Amp\",\n                \"17q11.2-Amp\",\n                \"17q12-Amp\",\n                \"2q37.1-Del\",\n                \"3p13-Del\",\n                \"5q12.1-Del\",\n                \"9p23-Del\",\n                \"9p21.3-Del\",\n                \"10q23.31-Del\",\n                \"14q24.1-Del\",\n                \"17p12-Del\",\n                \"22q13.32-Del\")\n\ncna <- cna.region[1:(nrow(cna.region)/2),c(1,8,9:(ncol(cna.region)-1))] # 选取有效列 # Select a valid column\nrownames(cna) <- paste0(gsub(\" \",\"\",cna$Descriptor),\"-\", substr(rownames(cna),1,3)) # 重命名行以确定扩增和缺失的位点 # Rename rows to identify amplified and missing sites\ncna.modified <- cna[1:nrow(cna),3:ncol(cna)]\nonco.input2 <- cna.modified[lesion.sig,rownames(mutsig)] # 选取要展示的拷贝数变异 # Select the copy number variation you want to display\ntmp1 <- onco.input2[1:6,] # 前6个为扩增 # The first 6 are amplification\ntmp1[tmp1 == 1] <- \"Gain\" # 数值大于0即为Gain # A value greater than 0 is considered a Gain\ntmp1[tmp1 == 2] <- \"Gain\"\ntmp1[tmp1 == 0] <- \"\"\n\ntmp2 <- onco.input2[7:15,] # 后9个为缺失 # The last 9 are missing\ntmp2[tmp2 == 1] <- \"Loss\"\ntmp2[tmp2 == 2] <- \"Loss\"\ntmp2[tmp2 == 0] <- \"\"\nonco.input2 <- rbind.data.frame(tmp1,tmp2)\n\nalter_fun2 = list(\n  background = function(x, y, w, h) {\n    grid.rect(x, y, w-unit(0.5, \"mm\"), h-unit(0.5, \"mm\"), gp = gpar(fill = \"#dcddde\", col = \"#dcddde\"))\n  },\n  Gain = function(x, y, w, h) {\n    grid.rect(x, y, w-unit(0.5, \"mm\"), h-unit(0.5, \"mm\"), gp = gpar(fill = red, col = red)) \n  },\n  Loss = function(x, y, w, h) {\n    grid.rect(x, y, w-unit(0.5, \"mm\"), h-unit(0.5, \"mm\"), gp = gpar(fill = blue, col = blue)) \n  }\n)\ncol2 = c(\"Gain\" = red,\n         \"Loss\" = blue)\n# 确定展示的顺序（看自己喜好，我这里是按照臂的顺序来的） \n# Determine the order of display (depending on your preference, I will follow the order of the arms here)\nlesion.order <- c(\"3p25.2-Amp\",\"7p15.3-Amp\",\"8p11.23-Amp\",\"10p14-Amp\",\"17q11.2-Amp\",\"17q12-Amp\",\n                  \"2q37.1-Del\",\"3p13-Del\",\"5q12.1-Del\",\"9p21.3-Del\",\"9p23-Del\",\"10q23.31-Del\",\"14q24.1-Del\",\"17p12-Del\",\"22q13.32-Del\")\ntmp <- as.data.frame(t(cna.modified[lesion.order,rownames(mutsig),]))\ntmp[tmp > 0] <- 1 # 所有大于1的均改为1以便计算变异频数 # All values greater than 1 are changed to 1 to calculate the variation frequency\ntmp$CMOIC <- as.character(subt[rownames(tmp),\"CMOIC\"])\npct <- NULL\nfor (i in lesion.order) {\n  tmp1 <- tmp[,c(i,\"CMOIC\")]\n  tmp1 <- as.data.frame.array(table(tmp1[,1],tmp1$CMOIC))[2,]/sum(tmp1[,1])\n  pct <- rbind.data.frame(pct,tmp1)\n}\nrownames(pct) <- lesion.order\n\n# 右侧堆叠百分比柱状图\n# Stacked percentage histogram on the right\nright_anno2 <- anno_barplot(as.matrix(pct),\n                            which = \"row\",\n                            border = FALSE,\n                            gp = gpar(fill = clust.col,\n                                      border = NA,\n                                      lty = \"blank\"), \n                            bar_width = 0.6,\n                            width = unit(1.8, \"cm\"),\n                            height = unit(1, \"cm\"))\n\n# 同样的方式绘制热图\n# Draw heatmaps the same way\nop2 <- oncoPrint(onco.input2[lesion.order,rownames(my_ann)], \n                 alter_fun = alter_fun2, \n                 col = col2, \n                 bottom_annotation = NULL, \n                 top_annotation = NULL,\n                 column_order = rownames(my_ann),\n                 right_annotation = rowAnnotation(PCT = right_anno2),\n                 row_order = lesion.order, \n                 show_pct = T,\n                 column_title = \"\", \n                 show_heatmap_legend = T, \n                 column_split = my_ann$CMOIC,\n                 column_title_gp = gpar(fontsize = 8),\n                 row_names_gp = gpar(fontsize = 8),\n                 column_names_gp = gpar(fontsize = 8))\nop2\n拷贝数主区域热图2 （分析结果来自GISTIC2.0）\nCopy number main region heatmap 2 (analysis results from\nGISTIC2.0)\ncna <- cna.gene\ncna <- cna[c(\"IFNA1\",\"MTAP\",\"CDKN2A\",\"CDKN2B\"),rownames(mutsig)] # 文章筛选了4个基因 # Four genes were screened in this article\nonco.input3 <- cna\n# 由于上面的分析中缺失的部分不存在High balanced loss，所以直接让2也属于Gain而没有添加High balanced gain\n# 这里小伙伴如果自己的数据满足要求，上面的拷贝数也可以分为4类\n# Since there is no High balanced loss in the missing part of the above analysis, we directly let 2 also belong to Gain and do not add High balanced gain\n# If your data meets the requirements, the number of copies above can also be divided into 4 categories\nonco.input3[onco.input3 == 1] <- \"Gain\"\nonco.input3[onco.input3 == 2] <- \"High_balanced_gain\"\nonco.input3[onco.input3 == 0] <- \"\"\nonco.input3[onco.input3 == -1] <- \"Loss\"\nonco.input3[onco.input3 == -2] <- \"High_balanced_loss\"\n\nalter_fun3 = list(\n  background = function(x, y, w, h) {\n    grid.rect(x, y, w-unit(0.5, \"mm\"), h-unit(0.5, \"mm\"), gp = gpar(fill = \"#dcddde\", col = \"#dcddde\"))\n  },\n  Gain = function(x, y, w, h) {\n    grid.rect(x, y, w-unit(0.5, \"mm\"), h-unit(0.5, \"mm\"), gp = gpar(fill = brewer.pal(6,\"Paired\")[5], col = brewer.pal(6,\"Paired\")[5])) \n  },\n  High_balanced_gain = function(x, y, w, h) {\n    grid.rect(x, y, w-unit(0.5, \"mm\"), h-unit(0.5, \"mm\"), gp = gpar(fill = brewer.pal(6,\"Paired\")[6], col = brewer.pal(6,\"Paired\")[6]))\n  },\n  Loss = function(x, y, w, h) {\n    grid.rect(x, y, w-unit(0.5, \"mm\"), h-unit(0.5, \"mm\"), gp = gpar(fill = brewer.pal(6,\"Paired\")[1], col = brewer.pal(6,\"Paired\")[1])) \n  },\n  High_balanced_loss = function(x, y, w, h) {\n    grid.rect(x, y, w-unit(0.5, \"mm\"), h-unit(0.5, \"mm\"), gp = gpar(fill = brewer.pal(6,\"Paired\")[2], col = brewer.pal(6,\"Paired\")[2]))\n  }\n)\ncol3 = c(\"Gain\" = brewer.pal(6,\"Paired\")[5],\n         \"High_balanced_gain\" =brewer.pal(6,\"Paired\")[6],\n         \"Loss\" = brewer.pal(6,\"Paired\")[1],\n         \"High_balanced_loss\" =brewer.pal(6,\"Paired\")[2])\n\nop3 <- oncoPrint(onco.input3[,rownames(my_ann)], \n                 alter_fun = alter_fun3,  \n                 col = col3, \n                 bottom_annotation = NULL, \n                 top_annotation = NULL,\n                 column_order = rownames(my_ann), \n                 right_annotation = NULL,\n                 show_pct = T, \n                 column_title = \"\", \n                 show_heatmap_legend=T, \n                 column_split = my_ann$CMOIC,\n                 column_title_gp = gpar(fontsize = 8),\n                 row_names_gp = gpar(fontsize = 8),\n                 column_names_gp = gpar(fontsize = 8))\nop3\n# 构建额外图例\n# Build additional legends\nlgd.mutsig = Legend(labels = c(\"SBS2\",\"SBS13\",\"SBS1\",\"SBS5\",\"Others\"), \n                    title = \"MutSig\", \n                    legend_gp = gpar(fill = c(brewer.pal(6,\"Paired\")[c(2,1,6,5)],\"grey90\")))\n\nlgd.cna.region = Legend(labels = c(\"Gain\",\"Loss\"), \n                    title = \"CNA (arm-level)\", \n                    legend_gp = gpar(fill = c(red,blue)))\n                    \nlgd.cna.gene = Legend(labels = c(\"Gain\",\"High_balanced_gain\",\"Loss\",\"High_balanced_loss\"), \n                        title = \"CNA (gene-level)\", \n                        legend_gp = gpar(fill = brewer.pal(6,\"Paired\")[c(5,6,1,2)]))              \n\nlgd_list <- list(lgd.mutsig, lgd.cna.region, lgd.cna.gene)\n\n# 合并热图\n# Merge heatmaps\npdf(\"mutational landscape in TCGA.pdf\", width = 10,height = 10)\ndraw(op1 %v% op2 %v% op3, # 垂直叠加热图 # Vertical overlay heatmap\n     annotation_legend_list = lgd_list) # 添加自定义的图例 # Add a custom legend\ninvisible(dev.off())\n写在后面\n我使用complexheatmap还没有那么熟练，也许还存在其他参数优化热图，但目前我没有做到，如果熟练的小伙伴可以在此技术上修缮代码。\n最明显的不足是右侧堆叠柱状图的长度不同，可能由于行名不等长引起的，但是由于最终排版，没有足够的位置让我把名字和百分比全部放到左边，因此依然保留了把名字放在右侧。最后我是通过AI把横向百分比柱状图拉到相同长度的；\n顶部亚型注释之所以在第二个位置，是因为如果在第一个位置，那个TMB和MutSig之间将会没有任何空隙，很难从AI中拉出一部分距离来填补文字，所以我这里把亚型注释放在第二位，最后通过AI拖动到顶部，并且在间隙处填补了文字；\n同样是右侧的堆叠柱状图，由于每个注释都有名字，所以上面的PCT会出现在下面柱状图的背景里，这里是用AI去掉的，不知道有没有参数可以隐藏名字。\nWritten last\nI’m not that proficient in using complexheatmap, and maybe there are\nother parameters that can optimize the heatmap, but at the moment I\nhaven’t done it, if a skilled guy can fix the code on this\ntechnique.\nThe most obvious disadvantage is that the length of the stacked\ncolumn chart on the right is different, which may be caused by the\nunequal length of the line names, but due to the final layout, there is\nnot enough space for me to put all the names and percentages on the\nleft, so I still put the names on the right. In the end, I used AI to\npull the horizontal percentage bar chart to the same length;\nThe reason why the top subtype annotation is in the second\nposition is because if it is in the first position, there will be no gap\nbetween TMB and MutSig, and it is difficult to pull out a part of the\ndistance from the AI to fill in the text, so I put the subtype\nannotation in the second position here, and finally drag it to the top\nby the AI, and fill the text in the gap;\nThe same is the stacked histogram on the right, because each\nannotation has a name, so the PCT above will appear in the background of\nthe lower histogram, which is removed by AI, I don’t know if there are\nany parameters to hide the name.\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa248MutLandscape_FigureYa248MutLandscape",
      "title": "FigureYa248MutLandscape/FigureYa248MutLandscape.html",
      "html": "FigureYa248MutLandscape/FigureYa248MutLandscape.html",
      "text": "texts/main_FigureYa248MutLandscape_FigureYa248MutLandscape.txt",
      "folder": "FigureYa248MutLandscape",
      "thumb": "gallery_compress/FigureYa248MutLandscape.webp"
    },
    "word_count": 2247,
    "lines_count": 427,
    "title": "FigureYa248MutLandscape",
    "description": "Xiaofan Lu写的MOVICS包很神奇，一个包几乎就画出了分子分型文章的大部分图。Xiaofan Lu写的这篇预印本最近已接收，刚好可以作为MOVICS包的应用案例。接下来会连续实现这篇文章里的几个图。",
    "input_data_types": [
      "临床数据",
      "突变数据"
    ],
    "output_types": [
      "热图",
      "统计表格",
      "箱线图"
    ],
    "technical_methods": [],
    "biology_areas": [
      "癌症研究",
      "免疫学"
    ],
    "complexity_level": "高级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "show_pct",
      "show_heatmap_legend",
      "col3",
      "row_names_gp",
      "MutSig",
      "gene",
      "alter_fun",
      "bottom_annotation",
      "width"
    ]
  },
  {
    "id": "main_FigureYa25Sankey_update_FigureYa25Sankey_update",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa25Sankey_update_FigureYa25Sankey_update.txt",
    "content": "FigureYa25Sankey_update\nFigureYa25Sankey_update\nAuthor(s)\n: Ying Ge, Xiaofan Lu; Yijing Chen\nDate\n: 2025-10-18\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n用R代码画出paper里的图。\nUse R code to draw the plot in paper.\n出自\nhttps://www.nature.com/articles/nature22973\nFrom\nhttps://www.nature.com/articles/nature22973\n应用场景\nApplication scenario\n一套数据集可能有多重属性，每层属性之间有交叉，就可以用这种图来展示。另外，以第一变量为参照，往后的多层变量均参考与第一变量的关系，从而展示第一变量的流向。\n场景一：一个group包含多个基因，同一个基因的不同突变可能属于多个group。像例图一样，展示高频突变基因所处的分组。\n原文：Graphical summary of the most frequently mutated genes (≥10\naffected cases) and their subgroup distribution.\n… many of which showed clear subgroup-specificity (Fig. 2a–c;\nExtended Data Fig. 3a, b; Supplementary Table 2).\n场景二：miRNA和靶基因的关系，可参考群里小伙伴的用法：\nhttps://onlinelibrary.wiley.com/doi/full/10.1002/jcp.28522\n场景三：人群按性别、年龄、家族史等特征分组，展示不同分组得癌症的规律。\nA dataset may have multiple attributes, and when there is an overlap\nbetween each layer of attributes, this type of plot can be used to\ndisplay it. Additionally, using the first variable as a reference,\nsubsequent multi-layer variables are all based on their relationship\nwith the first variable, thereby illustrating the flow of the first\nvariable.\nScenario 1: A group contains multiple genes, and different mutations\nof the same gene may belong to multiple groups. Display the groups\ncontaining high-frequency mutated genes, as shown in the example\nimage.\nOriginal text: Graphical summary of the most frequently mutated genes\n(≥10 affected cases) and their subgroup distribution.\n… many of which showed clear subgroup-specificity (Fig. 2a–c;\nExtended Data Fig. 3a, b; Supplementary Table 2).\nScenario 2: The relationship between miRNAs and target genes,\nplease refer to the usage of the group:\nhttps://onlinelibrary.wiley.com/doi/full/10.1002/jcp.28522\n.\nScenario 3: The population is grouped by gender, age, family\nhistory and other characteristics, to show the pattern of cancer in\ndifferent groups.\n环境设置\nEnvironment setting\nsource(\"install_dependencies.R\")\nlibrary(ggalluvial)\nlibrary(dplyr)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 display English error messages\noptions(stringsAsFactors = FALSE) #禁止chr转成factor prohibit the conversion of chr to factor\n输入数据\nInput data\neasy_input.txt，至少要有两列，想画出几列就提供几列数据。此处第一列是基因，第二列是突变，第三列是癌症亚型；想画更多层次关系就继续向后添加列。\n或者只写两列，第一列是miRNA，第二列是它的靶基因。\neasy_input.txt, there should be at least two columns; provide as many\ncolumns of data as you want to draw. Here the first column is the gene,\nthe second is the mutation, and the third is the cancer subtype; keep\nadding columns backwards if you want to draw more hierarchical\nrelationships.\nOr just write two columns, with the first column being the miRNA and\nthe second column being its target gene.\ndf <- read.table(\"easy_input.txt\",sep = \"\\t\",row.names = 1,header = T)\nhead(df)\n#定义足够多的颜色，后面从这里选颜色\n#define enough colors to pick colors from later\nmycol <- rep(c(\"#223D6C\",\"#D20A13\",\"#FFD121\",\"#088247\",\"#11AA4D\",\"#58CDD9\",\"#7A142C\",\"#5D90BA\",\"#029149\",\"#431A3D\",\"#91612D\",\"#6E568C\",\"#E0367A\",\"#D8D155\",\"#64495D\",\"#7CC767\"),2)\n开始画图\nStart drawing\n两种方式展示前后关系：\n后一层继承前一层的关系；\n后面多层继承第一层的关系。\nTwo ways to show the before and after relationships:\nThe latter layer inherits the relationship of the former layer;\nMultiple layers behind inherit the relationship of the first\nlayer.\n后一层继承前一层的关系\nThe latter layer inherits the relationship of the former layer\n#格式转换\n#format conversion\nUCB_lodes <- to_lodes_form(df[,1:ncol(df)],\n                           key = \"Gene\",\n                           axes = 1:ncol(df),\n                           id = \"Cohort\")\ndim(UCB_lodes)\nhead(UCB_lodes)\ntail(UCB_lodes)\nggplot(UCB_lodes,\n       aes(x = Gene, stratum = stratum, alluvium = Cohort,\n           fill = stratum, label = stratum)) +\n  scale_x_discrete(expand = c(0, 0)) + \n  geom_flow(width = 1/8) + #线跟方块间空隙的宽窄 the width of the gap between the line and the square\n  geom_stratum(alpha = .9,width = 1/10) + #方块的透明度、宽度 transparency, width of the square\n  geom_text(stat = \"stratum\", size = 3, color=\"black\") + #文字大小、颜色 text size, color\n  \n  #不喜欢默认的配色方案，用前面自己写的配色方案\n  #If you don't like the default color scheme, use the one you created earlier\n  scale_fill_manual(values = mycol) +\n\n  xlab(\"\") + ylab(\"\") +\n  theme_bw() + #去除背景色 remove background color\n  theme(panel.grid =element_blank()) + #去除网格线 remove gridlines\n  theme(panel.border = element_blank()) + #去除外层边框 remove outer border\n  theme(axis.line = element_blank(),axis.ticks = element_blank(),axis.text = element_blank()) + #去掉坐标轴 remove the axes\n  ggtitle(\"\")+\n  guides(fill = FALSE)\nggsave(\"sankey_stratum_3.pdf\")\n可以只选其中一部分列来画，此处只画第一列和第三列\nYou can select only some of the columns to draw, here only the first\nand third columns are drawn\nUCB_lodes <- to_lodes_form(df[,c(1,3)],\n                           key = \"Gene\",\n                           axes = 1:2,\n                           id = \"Cohort\")\ndim(UCB_lodes)\nggplot(UCB_lodes,\n       aes(x = Gene, stratum = stratum, alluvium = Cohort,\n           fill = stratum, label = stratum)) +\n  scale_x_discrete(expand = c(0, 0)) + \n  \n  #用aes.flow参数控制线从哪边来，颜色就跟哪边一致。\n  #默认是forward，此处用backward。\n  #use the aes.flow parameter to control the side from which the line originates, and the color will correspond to that side.\n  #default is forward, use backward here.\n  geom_flow(width = 1/8,aes.flow = \"backward\") +\n  \n  coord_flip() + #旋转90度 rotate 90 degrees\n  geom_stratum(alpha = .9,width = 1/10) +\n  geom_text(stat = \"stratum\", size = 3,color=\"black\") +\n\n  #如果分组少，可以用scale_fill_brewer。修改type和palette两个参数选择配色方案，更多配色方案参考下图，分别对应type参数的“Seq”、“qual”、“Div”\n  #If there are fewer groups, you can use scale_fill_brewer. Adjust the type and palette parameters to choose the color scheme., and refer to the following figure for more color schemes, corresponding to the type parameter's \"Seq\", \"Qual\", \"Div\" respectively.\n  #scale_fill_brewer(type = \"Div\", palette = \"BrBG\") +\n  \n  #如果分组太多，就要用前面自己写的配色方案\n  #If there are too many groups, you have to use the color scheme you wrote earlier on your own\n  scale_fill_manual(values = mycol) +\n\n  xlab(\"\") + ylab(\"\") +\n  theme_bw() + \n  theme(panel.grid =element_blank()) + \n  theme(panel.border = element_blank()) + \n  theme(axis.line.x = element_blank(),axis.ticks = element_blank(),axis.text.x = element_blank()) + #显示分组名字 show group name\n  ggtitle(\"\") +\n  guides(fill = FALSE)\nggsave(\"sankey_stratum_2.pdf\")\n后面多层继承第一层的关系（作者：Xiaofan Lu）\nMultiple layers behind inherit the relationship of the first\nlayer\n用到参数：stat = “alluvium”，即传说中的“冲击图”\n此时，只有连线有颜色，每层特征列就无法填充颜色了。\nUsing the parameter: stat = “alluvium”, which refers to the legendary\n“alluvial chart”.\nAt this point, only the connecting lines are colored, and the feature\ncolumns at each level are not filled with color.\nsubdf <- df\n\n# 计算频率\n# calculate frequency\nsubdf <- subdf %>% \n  group_by(gene, mutation, subtype) %>% #如果有更多列，就在括号里继续添加列名 If there are more columns, continue adding column names in parentheses\n  tally(name = \"Freq\") %>% \n  as.data.frame()\nhead(subdf)\nggplot(as.data.frame(subdf),\n       aes(y = Freq,\n           axis1 = gene, \n           axis2 = mutation, \n           axis3 = subtype)) + #这里画三列，如果有更多列，就继续添加，例如axis4 = 列名 Here draw three columns, if there are more columns, continue to add, for example axis4 = column name\n  scale_fill_manual(values = mycol) + \n  ggalluvial::geom_flow(stat = \"alluvium\",width = 1/8,aes(fill = gene)) +\n  geom_stratum(width = 1/8, reverse = T) +\n  geom_text(stat = \"stratum\", size = 3, aes(label = after_stat(stratum)),\n            reverse = T) +\n  scale_x_continuous(breaks = 1:3, labels = c(\"gene\", \"mutation\", \"subtype\")) +\n  \n  theme(legend.position = \"bottom\", #底部画图例 draw legend at bottom\n        legend.title = element_blank(),\n        axis.title.x = element_blank(),\n        axis.title.y = element_blank(),\n        axis.text.y = element_blank(),\n        axis.ticks = element_blank(),\n        axis.text.x = element_text(size = 12, face = \"bold\", color = \"black\")) +\n  \n  xlab(\"\") + ylab(\"\") +\n  theme_bw() + #去除背景色 remove background color\n  theme(panel.grid =element_blank()) + #去除网格线 remove gridlines\n  theme(panel.border = element_blank()) + #去除外层边框 remove outer border\n  theme(axis.line = element_blank(),axis.ticks = element_blank(), #不画xy轴 do not draw the xy-axis\n        axis.text.y = element_blank()) + # 只保留x轴label keep only the x-axis label\n  ggtitle(\"\")\nggsave(\"sankey_alluvium.pdf\")\nSessioninfo\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa25Sankey_update_FigureYa25Sankey_update",
      "title": "FigureYa25Sankey_update/FigureYa25Sankey_update.html",
      "html": "FigureYa25Sankey_update/FigureYa25Sankey_update.html",
      "text": "texts/main_FigureYa25Sankey_update_FigureYa25Sankey_update.txt",
      "folder": "FigureYa25Sankey_update",
      "thumb": "gallery_compress/FigureYa25Sankey_update.webp"
    },
    "word_count": 1038,
    "lines_count": 203,
    "title": "FigureYa25Sankey_update",
    "description": "Requirement description 用R代码画出paper里的图。 Use R code to draw the plot in paper.",
    "input_data_types": [
      "突变数据"
    ],
    "output_types": [
      "统计表格"
    ],
    "technical_methods": [
      "聚类分析"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "ticks",
      "key",
      "id",
      "values",
      "flow",
      "例如axis4",
      "header",
      "axis3"
    ]
  },
  {
    "id": "main_FigureYa185sciATAC_FigureYa185sciATAC",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa185sciATAC_FigureYa185sciATAC.txt",
    "content": "FigureYa185sciATAC\nFigureYa185sciATAC\n2025-5-20\nAuthor：Long Zhao\nReviewer：Ying Ge\n需求描述Requirement\n用Cicero分析cis-regulation，用washu browser展示结果，搞定中间的衔接。 Use Cicero to analyze cis-regulation, display the results using Washu Browser, and manage the connection between them.\nFigure 3. Cicero Constructs cis-Regulatory Models Genome-wide from Sci-ATAC-Seq Data (F) A summary of the Cicero co-accessibility links between the MYOG promoter and distal sites in the surrounding region. The height of connections indicates the magnitude of the Cicero co-accessibility score between the connected peaks. The top set of (red) links were constructed from cells in phase 1, while the bottom (in blue) were built from phase 2. See also Figures S3 and S4.\nFigure 5. Co-accessible DNA Elements Linked by Cicero Are Epigenetically Co-modified (E) The Cicero map for the 755 kb region surrounding MYH3 along with called MYOD1 ChIP-seq peaks from (Cao et al., 2010). Sites opening in accessibility are colored by their opening pseudotime (see STAR Methods), sites not opening in accessibility are shown in gray. Inset: 60 kb region surrounding MYH3 along with MYOD1 ChIP-seq and H3K27ac ChIP-seq signal tracks from Cao et al. (2010) and the ENCODE Project Consortium (2012). Only protein-coding genes are shown.\n出自from\nhttps://doi.org/10.1016/j.molcel.2018.06.044\n应用场景Application Scenarios\n用单细胞ATAC-seq数据找cis-regulation，为挖掘目的基因的远距离调控机制提供线索。Use single-cell ATAC-seq data to identify cis-regulation, providing clues for uncovering long-range regulatory mechanisms of target genes.\n还可参考这篇Cell paper的Figure 5和6深入挖掘，You can also refer to Figures 5 and 6 of this Cell paper for further analysis:\nhttps://www.sciencedirect.com/science/article/pii/S0092867418308559\n，需要的话，咱们再众筹。If needed, we can crowdfund.\n环境设置Environment Setup\n参考Refer to\nCicero for Monocle 3\n踩了软件安装的坑。软件安装有些麻烦，一些依赖不太好解决。所以这里直接用conda安装monocle3。I encountered some issues with software installation. Software installation is somewhat cumbersome, and some dependencies are difficult to resolve. Therefore, I installed Monocle 3 directly using conda.\nconda create -n py36 python=3.6\nconda activate py36\n#conda install -c r r-base=3.6.3\nconda install -c bioconda r-monocle3\nconda install -c bioconda bioconductor-cicero -y\ncicero直接安装github版。不用conda安装，是因为conda的cicero不是最新版本，在处理10X cell ranger的数据没问题，但是在处理稀疏矩阵的时候有问题。Install the GitHub version of Cicero directly. I didn't install it using conda because the Cicero version in conda isn't the latest version. It works fine with 10X Cell Ranger data, but has issues with sparse matrices.\nBiocManager::install(c(\"Gviz\", \"GenomicRanges\", \"rtracklayer\"))\n#install.packages(\"devtools\")\ndevtools::install_github(\"cole-trapnell-lab/cicero-release\", ref = \"monocle3\")\n#用上面的命令安装不成功，改从github下载后，重新压缩，本地安装，成功installation failed using the above command. I downloaded it from GitHub, recompressed it, and installed it locally. It worked.\n#install.packages(\"cicero-release-master.tar.gz\", repos = NULL, type = \"source\", ref = \"monocle3\")\n\n#MAC系统安装monocle时可能遇到问题，解决方法看这里You may encounter problems when installing Monocle on a Mac. See the solution here: https://cole-trapnell-lab.github.io/monocle3/docs/installation/\ndevtools::install_github('cole-trapnell-lab/leidenbase')\ndevtools::install_github('cole-trapnell-lab/monocle3')\n加载包Load the package\nlibrary(tidyverse)\nlibrary(cicero) #单细胞ATAC-seq数据分析Single-cell ATAC-seq data analysis\nlibrary(monocle3) #单细胞Single-cell\n\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息Display English error messages\noptions(stringsAsFactors = FALSE) #禁止chr转成factor，Disable conversion of chr to factor\n输入文件Input Files\n需要单细胞ATAC-seq数据和基因组注释gtf文件。Single-cell ATAC-seq data and genome annotation gtf files are required.\n这些文件已上传至微云These files have been uploaded to Weiyun:\nhttps://share.weiyun.com/gxepYhd9\n单细胞ATAC-seq数据Single-cell ATAC-seq Data\n从GEO下载单细胞ATAC-seq数据：Download single-cell ATAC-seq data from GEO:\nhttps://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSM2970932\n，以其中数据量小些的GSM2970932为例，包括两个细胞的mix，一个是HL60，另外一个是GM12878。This example uses the smaller GSM2970932 data set, which includes a mix of two cells: HL60 and GM12878.\nGSM2970932_sciATAC_GM12878_HL60_counts.txt.gz，每个peak的reads数量\nGSM2970932_sciATAC_GM12878_HL60_indextable.txt.gz，index\n这是一种常见格式，好多文章都在GEO中提供这种格式的文件。感兴趣的小伙伴可以参考本文的方式挖掘一下自己感兴趣问题的相关数据。This is a common format, and many articles provide this format in GEO. Interested parties can refer to this article to mine relevant data for their own questions.\n# peak read count\ncicero_data <- read.table(\"GSM2970932_sciATAC_GM12878_HL60_counts.txt\") \ncicero_data[1:3,]\n基因组注释gtf文件Genome annotation gtf file\n人和小鼠建议用genecode  For humans and mice, we recommend using genecode\nhttps://www.gencodegenes.org\n，其他物种可以从ensembl下载For other species, you can download it from ensembl at\nftp://ftp.ensembl.org/pub\n。\n这里用到的gtf文件我改过，不是原版。建议自己从以上\n官网\n下载。The gtf file used here has been modified and is not the original. It is recommended that you download it from the official website above.\ngene_anno <- rtracklayer::readGFF(\"hg19.gtf\") \ngene_anno[1:3,]\ngene_anno$chromosome <- gene_anno$seqid\ngene_anno$gene <- gene_anno$gene_id\ngene_anno$transcript <- gene_anno$transcript_id\ngene_anno$symbol <- gene_anno$gene_name\n评估co-acessiblity打分Evaluating co-acquisition scores\n因为单细胞ATAC的数据比较稀疏，所以一般为了评估co-acessiblity打分的时候，需要将feature比较相似的细胞汇聚到一起，再来评估。所以一般会先降维。这里用UMAP降维，也可以用其他任意的降维算法，例如t-SNE，可参考FigureYa27t-SNE。Because single-cell ATAC data is relatively sparse, it is generally necessary to group cells with similar features together for co-acquisition scores. Therefore, dimensionality reduction is usually performed first. UMAP is used for dimensionality reduction here, but any other dimensionality reduction algorithm, such as t-SNE, can also be used. See Figure Y a27 t-SNE.\ninput_cds <- make_atac_cds(cicero_data, binarize = TRUE)\n\nset.seed(1234)\n# 对于每个细胞来说，计算有多少表达的基因（或开放的peak）在阈值之上，默认是最小表达大于0。For each cell, calculate how many expressed genes (or open peaks) are above the threshold. The default is that the minimum expression is greater than 0.\n# 对于每个基因（peak），计算有多少细胞中有表达水平；For each gene (peak), calculate how many cells have an expression level;\n# 会在rowData或者colData中加一行或一列A row or column will be added to rowData or colData\ninput_cds <- detect_genes(input_cds) \n\n#计算size factor，Calculate size factor\ninput_cds <- estimate_size_factors(input_cds) \n\n#normalization：首先通过size factor和深度进行标准化。之后计算较低维度空间，作为下一步降维的输入文件。normalization: First, normalize by size factor and depth. Then calculate the lower dimensional space as the input file for the next dimensionality reduction.\n\ninput_cds <- preprocess_cds(input_cds, method = \"LSI\") \n\n#降维Dimensionality reduction\ninput_cds <- reduce_dimension(input_cds, reduction_method = 'UMAP', \n                              preprocess_method = \"LSI\") \nplot_cells(input_cds)\n因为是两个细胞的mix，所以分成两个大群，自己数据分析的时候应该注意，是否应该把两个群分开分别计算co-accessibility。这里为了方便展示，就混在一起了。Because this is a mixture of two cells, it is divided into two large groups. When analyzing your own data, you should consider whether to calculate co-accessibility for the two groups separately. Here, for ease of presentation, they are mixed together.\n降维之后可以通过make_cicero_cds来构建cell_data_set (CDS)。After dimensionality reduction, you can use make_cicero_cds to construct the cell_data_set (CDS).\numap_coords <- reducedDims(input_cds)$UMAP \ncicero_cds <- make_cicero_cds(input_cds, reduced_coordinates = umap_coords) #构建CDS  Build CDS\n\ndata(\"human.hg19.genome\")\nsample_genome <- human.hg19.genome\nconns <- run_cicero(cicero_cds, sample_genome, sample_num = 2)  #计算co-accessibility\nhead(conns)\n\n# conns里面就是两个位置的co-accessibility信息，Calculate co-accessibility\n# 保存到文件Save to file\n# write.csv(conns, \"output_co-accessibility.csv\", quote = F, row.names = F)\n开始画图Start plotting\n用cicero画图Plotting with cicero\ncicero自带画图函数，可以参考其说明文档来画图。cicero comes with built-in plotting functions; refer to its documentation for plotting.\nplot_connections(conns, \"chr2\", 9773451,10773451,\n                 gene_model = gene_anno, \n                 coaccess_cutoff = .25, \n                 connection_width = .5, \n                 collapseTranscripts = \"longest\" )\ncicero会调用Gviz包，跟Gviz类似，参数找起来太麻烦。很难调到自己理想的状态。因此，下面用washu browser来展示，\n重点是搞定输入文件格式转换\n。Cicero uses the Gviz package. Similar to Gviz, its parameters are difficult to navigate, making it difficult to achieve the desired results. Therefore, the following demonstration will use the Washu browser, focusing on converting the input file format.\n用washu browser展示Demonstrated using the Washu browser\n把co-accessibility信息转换为washu browser所需的格式。Convert the co-accessibility information to the format required by the Washu browser.\nconns_selected <- filter(conns, coaccess >= 0.5 | coaccess <= -0.5)\npeak1 <- conns_selected$Peak1 %>% str_split(\"_\",simplify=T)\npeak1_chr <- peak1[,1] %>% as.character()\npeak1_start <- peak1[,2] %>% as.numeric()\npeak1_end <- peak1[,3] %>% as.numeric()\npeak2 <- conns_selected$Peak2 %>% str_split(\"_\",simplify=T)\npeak2_cor <- peak2[,1] %>% paste(peak2[,2],sep=\":\") %>% paste(peak2[,3],sep=\"-\") %>% paste(conns_selected$coaccess*10,sep=\",\")\nconns_washu <- data.frame(V1=peak1_chr,V2=peak1_start,V3=peak1_end,V4=peak2_cor,V5=seq_along(peak1_chr)*2,V6=\".\") %>% arrange(V1,V2,V3,V4)\nwrite.table(conns_washu, \"conns_washu.txt\", sep=\"\\t\", row.names=F, col.names=F)\n导入import washu\nhttps://epigenomegateway.wustl.edu/browser/\n具体方法如下：\n如果想要example2.png那样展示bw的track，也可以在这里上传If you want to show the bw track like example2.png, you can also upload it here\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa185sciATAC_FigureYa185sciATAC",
      "title": "FigureYa185sciATAC/FigureYa185sciATAC.html",
      "html": "FigureYa185sciATAC/FigureYa185sciATAC.html",
      "text": "texts/main_FigureYa185sciATAC_FigureYa185sciATAC.txt",
      "folder": "FigureYa185sciATAC",
      "thumb": "gallery_compress/FigureYa185sciATAC.webp"
    },
    "word_count": 998,
    "lines_count": 133,
    "title": "FigureYa185sciATAC",
    "description": "用Cicero分析cis-regulation，用washu browser展示结果，搞定中间的衔接。 Use Cicero to analyze cis-regulation, display the results using Washu Browser, and manage the connection between them. Figure 3. Cicero Constructs cis-Regulatory Models Genome-wide from Sci-ATAC-Seq Data (F) A summary of the Cicero co-accessibility links between the MYOG promoter and distal sites in the surrounding region. The height of connections indicates the magnitude of the Cicero co-accessibility score between the connected peaks. The top set of (red) links were constructed from cells in phase 1, while the bottom (in blue) were built from phase 2. See also Figures S3 and S4. Figure 5. Co-accessible DNA Elements Linked by Cicero Are Epigenetically Co-modified (E) The Cicero map for the 755 kb region surrounding MYH3 along with called MYOD1 ChIP-seq peaks from (Cao et al., 2010). Sites opening in accessibility are colored by their opening pseudotime (see STAR Methods), sites not opening in accessibility are shown in gray. Inset: 60 kb region surrounding MYH3 along with MYOD1 ChIP-seq and H3K27ac ChIP-seq signal tracks from Cao et al. (2010) and the ENCODE Project Consortium (2012). Only protein-coding genes are shown.",
    "input_data_types": [
      "DNA-seq",
      "单细胞"
    ],
    "output_types": [
      "统计表格",
      "PCA图"
    ],
    "technical_methods": [
      "标准化"
    ],
    "biology_areas": [],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "V1",
      "acc",
      "repos",
      "python",
      "V5",
      "binarize",
      "method",
      "base",
      "simplify"
    ]
  },
  {
    "id": "main_FigureYa77baseZoom_FigureYa77baseZoom",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa77baseZoom_FigureYa77baseZoom.txt",
    "content": "FigureYa77baseZoom\nFigureYa77baseZoom\nAuthor(s)\n: Haitao Wang, Taojun Ye\nReviewer(s)\n: Ying Ge\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n用base plot画出C图这种zoom in效果的图。\nRequirement description\nUse a base plot to draw a C chart with zoom in effect.\n出自\nhttps://www.sciencedirect.com/science/article/pii/S0092867415011952\nfrom\nhttps://www.sciencedirect.com/science/article/pii/S0092867415011952\n应用场景\n有时会遇到这样的问题：点的分布很不均匀，堆在一起的点很难标label。\n解决办法：画整体的同时画局部，就能看清堆在一起的点了，写label也很清晰。\n示例图用于展示多个基因在两组中各变异类型所占的百分比，用颜色表示变异类型，泡泡大小表示pvalue，泡泡所在的位置偏左上说明在IDC中占比高于ILC，反之亦然。该图不仅限于基因。\nApplication scenarios\nSometimes we encounter such problems: the distribution of points is\nvery uneven, and it is difficult to label the points stacked\ntogether.\nSolution: While drawing the whole, draw the parts at the same time,\nso that you can see the points stacked together clearly, and the label\nis also very clear.\nThe example graph is used to display the percentage of multiple genes\nin each variant type in two groups, with colors indicating variant types\nand bubble sizes indicating p-value. The position of the bubble towards\nthe upper left indicates a higher proportion in IDC than in ILC, and\nvice versa. This map is not limited to genes.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\n# 设置系统环境变量，将语言设置为英文，确保R的报错信息以英文形式显示\n# Set system environment variable to display R error messages in English\nSys.setenv(LANGUAGE = \"en\") \n\n# 全局选项设置，禁止字符型变量自动转换为因子类型，避免数据类型意外转换\n# Global option to disable automatic conversion of character variables to factors, preventing unexpected data type conversions\noptions(stringsAsFactors = FALSE)\n输入文件\neasy_input.csv，提供分组、个数及总数（用于计算百分比）、pvalue：\n第一列是基因名；\n第二列是分组；\n第3-4、5-6列分别是在ILC（横坐标）和IDC（纵坐标）里的数量和总数，后面会用这两列计算百分比；\n最后一列是pvalue。\n示例数据整理自例文的Table 1. Recurrently Mutated Genes in Breast\nCancer，这里只用了mutation，没加CNV，因此泡泡的位置跟原图有出入。\nInput file\neasy_input.csv， Provide grouping, number, and total (for calculating\npercentages) pvalue：\n-The first column is the gene name; -The second column is grouping;\n-Columns 3-4 and 5-6 represent the quantities and total numbers in ILC\n(horizontal axis) and IDC (vertical axis), respectively. These two\ncolumns will be used later to calculate the percentage; -The last column\nis the p-value.\nThe example data is compiled from Table 1 of the example text.\nRecurrent Mutated Genes in Breast Cancer, where only mutation was used\nwithout adding CNV, resulting in a discrepancy in the position of the\nbubbles from the original image.\n# 从CSV文件读取数据，默认以逗号分隔，结果存储在dat2变量中\n# Read data from a CSV file (default separator is comma) and store it in variable dat2\ndat2 <- read.csv(\"easy_input.csv\")\n\n# 查看数据的基本结构和内容，显示数据集行数、列数和前几行信息\n# View the basic structure and content of the data, showing the number of rows, columns, and the first few lines of the dataset\nhead(dat2)\n把各列数据整理成画图所需的格式\nOrganize the data in each column into the format required for\ndrawing\n开始画图\nZoom in的效果，也就是画一个整体，再画一个局部。\nStart drawing\nThe effect of Zoom in is to draw a whole and then a part.\n画局部\nDraw a partial picture\n# 设置图形布局，一行两列，并调整边距为底部留出图例空间\n# Set graphics layout to 1 row and 2 columns, adjust margins to leave space for legends at the bottom\npar(mfrow=c(1,2),mar = par()$mar + c(3,0,0,3)) \n\n# 绘制局部散点图（放大视图）\n# Plot the local scatter plot (zoomed-in view)\nplot(ILC, IDC,\n     col = cols.code[as.character(dat2$group)],  # 根据分组设置点的颜色 / Set point color by group\n     xlim = c(0,15), ylim=c(0,15),              # 设置坐标轴范围，只显示局部数据 / Set axis limits to show局部data\n     pch = 16,                                   # 使用实心圆点作为绘图符号 / Use filled circles as symbols\n     ylab = \"IDC (% altered samples)\",          # Y轴标签 / Y-axis label\n     xlab=\"ILC (% altered samples)\",            # X轴标签 / X-axis label\n     cex = sizes)                                # 根据p值设置点的大小 / Set point size by p-value\n\n# 添加y=x参考线\n# Add y=x reference line\nabline(a = 0, b = 1, col = \"gray60\", lwd = 1, lty = 5)\n\n# 在实心点外部绘制白色圆圈，增强视觉效果\n# Draw white circles around the solid points for better visibility\npoints(ILC, IDC, pch = 1, col = \"white\", cex = sizes)\n\n# 标记IDC百分比大于6的点\n# Label points where IDC percentage > 6\nup <- which(IDC > 6)\n# 标记ILC百分比大于6的点\n# Label points where ILC percentage > 6\ndown <- which(ILC > 6)\n\n# 允许文本绘制在绘图区域外\n# Allow text to be drawn outside the plotting region\npar(xpd=TRUE)\n\n# 在指定点的左侧添加基因名称标签\n# Add gene name labels to the left of specified points\ntext(ILC[up], IDC[up], names(ILC[up]), pos=2) \n\n# 在指定点的右侧添加基因名称标签\n# Add gene name labels to the right of specified points\ntext(ILC[down], IDC[down], names(ILC[down]), pos=4)\n\n# 定义一个函数，用于给颜色添加透明度\n# Define a function to add transparency (alpha) to colors\nadd.alpha <- function(col, alpha=1){\n  if(missing(col))\n    stop(\"Please provide a vector of colours.\")\n  apply(sapply(col, col2rgb)/255, 2, \n        function(x) \n          rgb(x[1], x[2], x[3], alpha=alpha))  \n}\n\n# 创建带有透明度的橙色，用于背景填充\n# Create transparent orange color for background fill\ngray.alpha <- add.alpha(\"orange\", alpha=0.1)\n\n# 绘制带有透明度的橙色背景，覆盖整个绘图区域\n# Draw a transparent orange background covering the entire plot area\nrect(par(\"usr\")[1], par(\"usr\")[3], par(\"usr\")[2], par(\"usr\")[4], col = gray.alpha)\n\n# 在底部外部添加分组颜色图例\n# Add legend for group colors outside the plot at the bottom\nlegend(\"bottom\", \n       inset=c(0,-.5),  # 将图例放置在图的底部外部 / Position legend below the plot\n       ncol = 3,        # 图例分3列显示 / Arrange legend items in 3 columns\n       pch=16,          # 使用实心圆点作为图例符号 / Use filled circles as legend symbols\n       col=cols.code,   # 设置图例颜色 / Set legend colors\n       legend=cols.names,  # 设置图例标签 / Set legend labels\n       bty=\"n\")           # 不显示图例边框 / Omit legend box\n\n### 绘制整体视图 ###\n# Plot the overall view\nplot(ILC, IDC,\n     col = cols.code[as.character(dat2$group)],  # 根据分组设置点的颜色 / Color points by group\n     xlim=c(0,70), ylim=c(0,70),                # 设置更大的坐标轴范围，显示整体数据 / Set wider axis limits\n     ylab=\"\",                                   # 暂时不设置Y轴标签 / Empty Y label (will be added later)\n     xlab=\"ILC (% altered samples)\",            # X轴标签 / X-axis label\n     yaxt='n',                                  # 不显示左侧Y轴 / Suppress left Y-axis\n     pch=16,                                    # 使用实心圆点作为绘图符号 / Use filled circles\n     cex=sizes)                                 # 根据p值设置点的大小 / Scale points by p-value\n\n# 在实心点外部绘制白色圆圈，增强视觉效果\n# Draw white circles around the solid points for better visibility\npoints(ILC, IDC, pch=1, col = \"white\", cex=sizes)\n\n# 在右侧绘制Y轴\n# Draw the Y-axis on the right side\naxis(side = 4)\n\n# 在右侧添加Y轴标签，通过mgp参数调整标签位置\n# Add Y-axis label on the right side, adjust position using mgp parameter\ntitle(ylab=\"IDC (% altered samples)\", \n      mgp=c(-20,1,0))  # Adjust according to the specific plot size\n# 标记ILC或IDC百分比大于15的点\n# Label points where ILC or IDC percentage > 15\nw <- which(ILC > 15 | IDC > 15)\n\n# 在指定点的上方添加基因名称标签\n# Add gene name labels above the specified points\ntext(ILC[w], IDC[w], names(ILC[w]), pos=3)\n\n# 添加点大小的图例，表示显著性水平\n# Add legend for point size indicating significance level\nu <- par(\"usr\")  # 获取当前绘图区域的坐标范围 / Get current plot coordinates\nf <- c(1,2.5,5,10,20)  # 定义显著性水平的参考值 / Define reference values for significance\ns <- sqrt(f/3)  # 计算对应的点大小 / Calculate corresponding point sizes\n\n# 在底部外部添加大小图例\n# Add size legend outside the plot at the bottom\nlegend(\"bottom\", \n       inset=c(0,-.5),  # 将图例放置在图的底部外部 / Position legend below the plot\n       legend=rep(\"\", length(f)),  # 空标签，仅显示符号 / Empty labels, show symbols only\n       title = \"Significance level [-log10(q)]\",  # 图例标题 / Legend title\n       pch=1,  # 使用空心圆圈作为图例符号 / Use open circles as symbols\n       pt.cex=s,  # 设置符号大小 / Set symbol sizes\n       bty='n',  # 不显示图例边框 / Omit legend box\n       horiz = TRUE)  # 水平排列图例项 / Arrange items horizontally\n\n# 恢复默认设置，禁止在绘图区域外绘制内容\n# Reset to default, disable drawing outside the plot region\npar(xpd = F)\n\n# 添加y=x参考线（虚线）\n# Add y=x reference line (dashed)\nabline(a = 0, b = 1, col = \"gray60\", lwd = 1, lty=2)\n\n# 在整体图中标记局部区域的位置，使用与局部图相同的背景颜色\n# Mark the location of the zoomed-in region in the overall plot with the same background color\nrect(par(\"usr\")[1]/4.6, par(\"usr\")[3]/4.6, par(\"usr\")[2]/4.6, par(\"usr\")[4]/4.6, col = gray.alpha, border=TRUE)\n# 保存当前图形状态，以便后续使用\n# Save the current plot for later use\nrecordedplot1 <- recordPlot()\n\n# 将图形保存为PDF文件\n# Save the plot to a PDF file\npdf(\"baseZoom.pdf\",10,5.5)\nrecordedplot1\ndev.off()\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa77baseZoom_FigureYa77baseZoom",
      "title": "FigureYa77baseZoom/FigureYa77baseZoom.html",
      "html": "FigureYa77baseZoom/FigureYa77baseZoom.html",
      "text": "texts/main_FigureYa77baseZoom_FigureYa77baseZoom.txt",
      "folder": "FigureYa77baseZoom",
      "thumb": "gallery_compress/FigureYa77baseZoom.webp"
    },
    "word_count": 1169,
    "lines_count": 223,
    "title": "FigureYa77baseZoom",
    "description": "用base plot画出C图这种zoom in效果的图。 Requirement description Use a base plot to draw a C chart with zoom in effect.",
    "input_data_types": [
      "突变数据"
    ],
    "output_types": [
      "散点图",
      "统计表格"
    ],
    "technical_methods": [],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "pos",
      "lwd",
      "ylim",
      "xlim",
      "side",
      "yaxt",
      "pvalue",
      "legend",
      "horiz"
    ]
  },
  {
    "id": "main_FigureYa53PPImodule_FigureYa53PPImodule-0527更新",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa53PPImodule_FigureYa53PPImodule-0527更新.txt",
    "content": "FigureYa53 PPImodule\nFigureYa53 PPImodule\nYangzhige He; Ying Ge, Yijing Chen\n2025-5-20\n需求描述\nrequirement description\n通过已知PPI数据库找到共表达蛋白中的module，输出到文件，用于下一步cytoscape展示。\nFind the module in co-expressed proteins through the known PPI\ndatabase and output it to a file for the next step of cytoscape\npresentation.\ndemo\n出自\nhttps://www.sciencedirect.com/science/article/pii/S1074761317300729?via%3Dihub\nfrom\nhttps://www.sciencedirect.com/science/article/pii/S1074761317300729?via%3Dihub\n应用场景\napplication scenario\n把自己的基因列表跟蛋白相互作用网络联系起来。\n例如RNA-seq获得的差异表达基因，看他们在蛋白相互作用网络中，哪些基因处于同一module。\nLink your gene list to the protein interaction network.\nFor example, differential expression genes obtained from RNA-seq, see\nwhich genes are in the same module within the protein interaction\nnetwork.\n环境设置\nenvironment setting\n安装需要的包\nInstall the required packages\n#使用国内镜像安装包\n#use the domestic mirror installation package\noptions(\"repos\"= c(CRAN=\"https://mirrors.tuna.tsinghua.edu.cn/CRAN/\"))\ninstall.packages(\"dynamicTreeCut\")\ninstall.packages(\"openxlsx\")\ninstall.packages(\"stringr\")\ninstall.packages(\"Matrix\")\ninstall.packages(\"WGCNA\")\n加载需要用到的包\nLoad the required packages\nlibrary(dynamicTreeCut)\nlibrary(openxlsx)\nlibrary(stringr)\nlibrary(Matrix)\nlibrary(WGCNA)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 display English error messages\noptions(stringsAsFactors = FALSE) #禁止chr转成factor prohibit the conversion of chr to factor\n输入文件\nInput file\n需要3个文件：\n共表达基因列表，此处用paper附件里的mm2.xlsx\nUniprot ID转换文件：\nftp://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/idmapping/by_organism/MOUSE_10090_idmapping_selected.tab.gz\n从STRING数据库下载PPI数据\nhttps://stringdb-static.org/download/protein.actions.v10.5/10090.protein.actions.v10.5.txt.gz\n。三个红框表示：数据库版本号，物种搜索框，相互作用数据（包含相互作用类型，如物理相互作用)。注意版本号，以及物种搜索框内为‘Mus\nmusculus’，下载第三个框内文件。\nThree files are required:\nCo-expressed gene list, using mm2.xlsx from the paper attachment\nhere.\nUniprot ID conversion file:\nftp://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/idmapping/by_organism/MOUSE_10090_idmapping_selected.tab.gz\nDownload PPI data from the STRING database\nhttps://stringdb-static.org/download/protein.actions.v10.5/10090.protein.actions.v10.5.txt.gz\n.\nThe three red boxes indicate: database version number, species search\nbox, interaction data (including interaction types, such as physical\ninteractions). Note the version number, and the species search box\nshould contain ‘Mus musculus’, download the file in the third box.\nSTRING\n！关于输入文件的更新\n! Update of the input file\n需要3个文件：\n！共表达基因列表，此处用paper附件里的\nmmc2.xlsx， Data S1.\nWhole Proteome and Phosphoproteome Analyses of WT and Rptor-Deficient T\nCells (1st experiment)\n.\nhttps://ars.els-cdn.com/content/image/1-s2.0-S1074761317300729-mmc2.xlsx，下载之后重命名为\nmmc2.xlsx\n！Uniprot ID转换文件：\n链接更新为：\nhttps://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/idmapping/by_organism/MOUSE_10090_idmapping_selected.tab.gz\n把ftp改为https。\n《\n对应的人的为https://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/idmapping/by_organism/HUMAN_9606_idmapping_selected.tab.gz\n》 《人和小鼠对应的版本号：HUMAN_9606，\nMOUSE_10090\n》\nMOUSE_10090_idmapping_selected.tab.gz下载之后解压。\n！从STRING数据库下载PPI数据：（此处更新较大！！）\n在https://string-db.org/cgi/download网站看左上角版本号：\nversion\n11.0\n，输人或者小鼠，左下角没有找到小丫代码里面的文件。（如下图示：）\nThree files are required:\n! Co-expressed gene list, use\nmmc2.xlsx in the paper\nattachment, Data S1. Whole Proteome and Phosphoproteome Analyses of WT\nand Rptor-Deficient T Cells (1st experiment)\n.\nhttps://ars.els-cdn.com/content/image/1-s2.0-S1074761317300729-mmc2.xlsx\n,\ndownload and rename to\nmmc2.xlsx\n.\n！Uniprot ID conversion file:\nLink updated to\nhttps://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/idmapping/by_organism/MOUSE_10090_idmapping_selected.tab.gz\n.\nchange ftp to https.\n《\nCorrespond to the human\nhttps://ftp.uniprot.org/pub/databases/uniprot/current_release/knowledgebase/idmapping/by_organism/HUMAN_9606_idmapping_selected.tab.gz\n》 《Version number corresponding to humans and mice: HUMAN_9606,\nMOUSE_10090\n》 MOUSE_10090_idmapping_selected.tab.gz\nUnzip after downloading.\n! Download PPI data from STRING database: (larger update\nhere!!)\nLook at the version number in the upper left corner of\nhttps://string-db.org/cgi/download\nwebsite:\nversion 11.0\n, type in human or mouse, and the file in\nthe Xiaoya code is not found in the lower left corner. (as shown\nbelow:)\nSTRINGv11-mm\nSTRINGv11-hg\n在https://stringdb-static.org/download/网站找到对应的\nprotein.actions.v11.0/\n路径，在此路径下找到\nHUMAN_9606和\nMOUSE_10090\n分别对应的文件9606.protein.actions.v11.0.txt.gz\nhttps://stringdb-static.org/download/protein.actions.v11.0/9606.protein.actions.v11.0.txt.gz\n、\n10090.protein.actions.v11.0.txt.gz\nhttps://stringdb-static.org/download/protein.actions.v11.0/10090.protein.actions.v11.0.txt.gz\n10090.protein.actions.v11.0.txt.gz下载之后解压，10090.protein.actions.v11.0.txt文件有318MB。\nFind the corresponding\nprotein.actions.v11.0/\npath\nin\nhttps://stringdb-static.org/download/\nwebsite, under\nthis path, find the corresponding file 9606.protein.actions.v11.0.txt.gz\nhttps://stringdb-static.org/download/protein.actions.v11.0/9606.protein.actions.v11.0.txt.gz\n,\n10090.protein.actions.v11.0.txt.gz\nhttps://stringdb-static.org/download/protein.actions.v11.0/10090.protein.actions.v11.0.txt.gz\nfor HUMAN_9606 and\nMOUSE_10090\nrespectively.\n10090.protein.actions.v11.0.txt.gz After downloading and unzipping\nthe file, 10090.protein.actions.v11.0.txt has 318MB.\n从paper附件获得WPC3基因及蛋白ID\nObtain WPC3 gene and protein ID from the paper attachment\nwpc <- read.xlsx(\"mmc2.xlsx\",cols=2:4,startRow = 3) #读入文件第一个sheet中的第2:4列，从第3行开始 read column 2:4 in the first sheet of the file, starting from the third line\nwpc3 <- wpc[wpc$WPC==3&!is.na(wpc$WPC),]\n\nuniprot_wpc3 <- str_split(wpc3$Protein.Accession,\"[|]\",3,simplify = T)[,2]\nuniprot_wpc3 <- str_split(uniprot_wpc3,\"[-]\",2,simplify = T)[,1]\nwpc3$uniprot <- uniprot_wpc3\n根据Uniprot ID提取ENSEMBLPROT ID\nExtract ENSEMBLPROT ID according to Uniprot ID\nidmapping<-read.table(\"MOUSE_10090_idmapping_selected.tab\",header = F,as.is=T,sep=\"\\t\")\nrownames(idmapping)<-idmapping$V1\nids_wpc3 <- idmapping[intersect(uniprot_wpc3,rownames(idmapping)),][,c(1,21)]\ndim(ids_wpc3)#由于uniprot版本问题会丢失1456-1415=41个蛋白 1456-1415=41 proteins will be lost due to the problem of uniprot version\nprots <- str_split(ids_wpc3$V21,\"; \")\nnames(prots)<- rownames(ids_wpc3)\nprots <- prots[prots!=\"\"]\nprots_tmp <- unlist(lapply(seq_along(prots), function(x) paste(names(prots)[x], prots[[x]],sep=\";\")))\nprots_mat <- data.frame(str_split(prots_tmp,\"[;]\",2,simplify = T),stringsAsFactors = F)\ncolnames(prots_mat) <- c(\"uniprot\",\"ensemblprot\")\nhead(prots_mat)\ngene_ensemblprot <- merge(wpc3,prots_mat,by=\"uniprot\")\ngene2ensemblprot <- gene_ensemblprot[,c(1,3,ncol(gene_ensemblprot))]\nhead(gene2ensemblprot)#后面会用到gene和ensemblprot id的对应关系 the correspondence between gene and ensemblprot id will be used later\nensemblprot_wpc3 <- unique(prots_mat$ensemblprot)\n从STRING数据库提取WPC3蛋白的PPI\nExtract PPI of WPC3 protein from STRING database\n从STRING数据库提取WPC3蛋白的PPI，把蛋白名转成基因名\nExtract PPI of WPC3 protein from STRING database, convert protein\nname to gene name\nSTRING数据文件10090.protein.actions.v10.5.txt有580M，我这里8G内存，读取它需要大概30s\nSTRING data file 10090.protein.actions.v10.5.txt is 580M, I have 8G\nRAM here, it takes about 30s to read it\n！更新后的STRING数据文件10090.protein.actions.v11.0.txt文件有318MB。\n! The updated STRING data file\n10090.protein.actions.v11.0.txt file has 318MB.\n#ppi <- read.table(\"10090.protein.actions.v10.5.txt\",header=T,sep = \"\\t\")\nppi <- read.table(\"10090.protein.actions.v11.0.txt\",header=T,sep = \"\\t\")\nhead(ppi)\nppi$item_id_a <- str_replace(ppi$item_id_a,\"10090.\",\"\")\nppi$item_id_b <- str_replace(ppi$item_id_b,\"10090.\",\"\")\nensemblprot_wpc3 <- sub(\"\\\\..*\", \"\", ensemblprot_wpc3)\nppi_wpc3 <- ppi[(ppi$item_id_a %in% ensemblprot_wpc3)&(ppi$item_id_b %in% ensemblprot_wpc3),]\nppi_wpc3 <- ppi_wpc3[!duplicated(paste0(ppi_wpc3$item_id_a,ppi_wpc3$item_id_b)),]#去掉重复行 remove duplicate rows\n\ncolnames(ppi_wpc3)[1]<-\"ensemblprot\"\ngene2ensemblprot$ensemblprot <- sub(\"\\\\..*\", \"\", gene2ensemblprot$ensemblprot)\nppi_gene1st <- merge(ppi_wpc3,gene2ensemblprot,by=\"ensemblprot\")\ncolnames(gene2ensemblprot)[3] <- \"item_id_b\"\nppi_gene2nd <- merge(ppi_gene1st,gene2ensemblprot,by=\"item_id_b\")\nppi_gene2nd <- ppi_gene2nd[!duplicated(paste0(ppi_gene2nd$Gene.Names.x,ppi_gene2nd$Gene.Names.y)),]\nppi_gene2nd <- na.omit(ppi_gene2nd)  #后面稀疏矩阵 NA's in (i,j) are not allowed the back sparse matrices NA's in (i,j) are not allowed\nhead(ppi_gene2nd)\ngenes <- sort(unique(union(ppi_gene2nd$Gene.Names.x,ppi_gene2nd$Gene.Names.y)))\n#保存到文件\n#save to the file\nwrite.csv(data.frame(genes),file=\"ppi_gene.csv\",row.names = F,quote = F)\n以对称矩阵的形式表示网络的边，0表示两点之间无连边，1表示有边\nThe edge of the network is represented in the form of a symmetric\nmatrix. 0 indicates that there is no connected edge between two points,\nand 1 indicates that there are edges\npos <- seq_along(genes)\nnames(pos) <- genes\nppi_gene2nd$posx <- pos[ppi_gene2nd$Gene.Names.x]\nppi_gene2nd$posy <- pos[ppi_gene2nd$Gene.Names.y]\n\n#构建稀疏矩阵\n#construct the sparse matrix\nppi_mat <- sparseMatrix(ppi_gene2nd$posx, ppi_gene2nd$posy, x = 1, dims = c(length(genes), length(genes)))\n#保存到文件\n#save to the file\nwrite.csv(as.matrix(ppi_mat),file=\"ppi_mat.csv\",row.names = F,quote = F)\n这时可以中场休息一下，下面继续\nAt this point you can take an intermission and continue below\nNodeNames <- read.csv(\"ppi_gene.csv\", header=T)\nNodeNames <- as.vector(NodeNames[,1])\nhead(NodeNames)\nADJ <- read.csv(\"ppi_mat.csv\", header=T)\nADJ <- as.matrix(ADJ)\nrownames(ADJ) <- NodeNames\ncolnames(ADJ) <- NodeNames\nADJ[1:3,1:3]\n计算TOM\nCalculate TOM\n用到函数TOMdist1，保存在TOMdist1.R文件中，位于当前文件夹。\n来自：\nhttps://horvath.genetics.ucla.edu/html/GeneralFramework/NetworkFunctions.txt\nUse the function TOMdist1 and save in the file TOMdist1.R, located in\nthe current folder.\nfrom:\nhttps://horvath.genetics.ucla.edu/html/GeneralFramework/NetworkFunctions.txt\nsource(\"TOMdist1.R\") #保存在当前文件夹 save in current folder\n\n# 我们使用TOM矩阵作为邻接矩阵的平滑版本。\n# We used the TOM matrix as a smoothed-out version of the adjacency matrix.\ndissTOM <- TOMdist1(as.matrix(ADJ))\ndissTOM[1:3, 1:3]\n通过cut tree找module\nFind module through cut tree\n用R包dynamicTreeCut实现。根据文章Supplemental Information描述：\n现在，我们用TOM矩阵进行分层聚类。聚类树的分支将用来定义基因模块。\nImplemented with R package dynamicTreeCut. According to the\ndescription of the article Supplemental Information:\nNow we carry out hierarchical clustering with the TOM matrix.\nBranches of the resulting clustering tree will be used to define gene\nmodules.\nlibrary(dynamicTreeCut)\n\n#基于TOM(topological overlap matrix)对基因进行层次聚类\n#可以通过设置method参数，使用不同方法进行层次聚类，如median,complete, centroid等\n#hierarchical clustering of genes based on TOM (topological overlap matrix)\n#by setting method parameters, you can use different methods for hierarchical clustering, such as median, complete, centroid, etc.\nhierTOM <- hclust(as.dist(dissTOM), method=\"average\")\nstr(hierTOM)\n#使用hybrid dynamic tree-cutting方法，将网络划分成模块\n#可以通过设置minClusterSize来调整模块的最小大小\n#minClusterSize的默认设置是20，因为通常太小的模块没有意义\n#由于文章中的最小模块是2，所以在此我们设置为2\n#use the hybrid dynamic tree-cutting method to divide the network into modules\n#the minimum size of a module can be adjusted by setting minClusterSize\n#the default setting for minClusterSize is 20, as it usually doesn't make sense to have a module that is too small\n#since the smallest module in the article is 2, we set it to 2 here\nmods <- cutreeDynamic(hierTOM, cutHeight = NULL, minClusterSize = 2,method = \"hybrid\", distM = dissTOM)\ntable(mods)\n# 将每个模块包含什么基因输出来，result_module.csv\n# output what genes each module contains, result_module.csv\nlist2<-c()\nfor (i in names(table(mods))){\n    a <- paste(NodeNames[which(mods==i)], sep=\"\", collapse=',')\n    list2 <- c(list2,a)\n}\nlist1 <- paste(\"Module_\",names(table(mods)), sep=\"\")\nout_df <- data.frame(list1,list2)\nwrite.csv(out_df,'result_module.csv',row.names=FALSE)\n\n# 转成cytoscape，为fig2.F和fig2.G做准备\n# convert to cytoscape in preparation for for fig2.F and fig2.G\nlibrary(WGCNA)\n#输出整个子网络的边和节点情况\n#output the edges and nodes of the entire subnetwork\nexportNetworkToCytoscape(ADJ,\nedgeFile = paste('./result_filtered_PPI_network_edge.txt'),\nnodeFile = paste('./result_filtered_PPI_network_node.txt'),\nweighted = TRUE,\nthreshold = 0.5,\nnodeNames = NodeNames,\naltNodeNames = NULL,\nnodeAttr = mods,\nincludeColNames = TRUE)\n这一步生成的两个文件，可以作为cytoscape的输入：\nresult_filtered_PPI_network_edge.txt\nresult_filtered_PPI_network_node.txt\nThis step generates two files that can be used as input for\ncytoscape:\nresult_filtered_PPI_network_edge.txt\nresult_filtered_PPI_network_node.txt\n参考文献\nReference\nDong J, Horvath S (2007) Understanding Network Concepts in Modules,\nBMC Systems Biology 2007, 1:24 PMID: 17547772 PMCID: PMC3238286\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa53PPImodule_FigureYa53PPImodule-0527更新",
      "title": "FigureYa53PPImodule/FigureYa53PPImodule-0527更新.html",
      "html": "FigureYa53PPImodule/FigureYa53PPImodule-0527更新.html",
      "text": "texts/main_FigureYa53PPImodule_FigureYa53PPImodule-0527更新.txt",
      "folder": "FigureYa53PPImodule",
      "thumb": "gallery_compress/FigureYa53PPImodule.webp"
    },
    "word_count": 1135,
    "lines_count": 314,
    "title": "FigureYa53 PPImodule",
    "description": "requirement description 通过已知PPI数据库找到共表达蛋白中的module，输出到文件，用于下一步cytoscape展示。 Find the module in co-expressed proteins through the known PPI",
    "input_data_types": [],
    "output_types": [
      "火山图",
      "统计表格",
      "网络图"
    ],
    "technical_methods": [
      "聚类分析",
      "网络分析",
      "差异表达分析"
    ],
    "biology_areas": [],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "edgeFile",
      "header",
      "nodeNames",
      "nodeFile",
      "dims",
      "method",
      "simplify",
      "nodeAttr",
      "is"
    ]
  },
  {
    "id": "main_FigureYa24ROC_FigureYa24ROC",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa24ROC_FigureYa24ROC.txt",
    "content": "FigureYa24 ROC\nFigureYa24 ROC\nAuthor(s)\n: yeoli; Ying Ge, Yijing Chen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n用R画出ROC曲线（receiver operating characteristic curve）。\nDraw the ROC curve in R（receiver operating characteristic\ncurve）\n应用场景\nApplication scenario\n在分类任务中，直观展示敏感性和特异性连续变量的综合指标。\n场景一：比较多个biomarker或临床参数的诊断表现\n场景二：比较多个算法的分类效果\nVisualize composite metrics of sensitivity and specificity continuous\nvariables in a classification task.\nScenario 1: Compare the diagnostic performance of multiple biomarkers\nor clinical parameters\nScenario 2: Compare the classification performance of multiple\nalgorithms\n输入文件\nInput data\n包含至少两列，第一列是分组，此处第二列至第五列是miRNA的表达量。\nIt contains at least two columns, the first column is the group, and\nhere the second to fifth columns are the miRNA expression.\nsource(\"install_dependencies.R\")\ndf <- read.table(\"easy_input.txt\",head=T,sep=\"\\t\",check.names = F)\nhead(df)\n开始画图\nStart drawing\n#install.packages(\"pROC\")\nlibrary(\"pROC\")\n\n#定义足够多的颜色，后面画线时从这里选颜色\n#define enough colors to choose from when drawing lines later.\nmycol <- c(\"slateblue\",\"seagreen3\",\"dodgerblue\",\"firebrick1\",\"lightgoldenrod\",\"magenta\",\"orange2\")\n\npdf(\"ROC.pdf\",height=6,width=6)\nauc.out <- c()\n\n\n#先画第一条线，此处是miRNA1\n#draw the first line first, here is miRNA1\nx <- plot.roc(df[,1],df[,2],ylim=c(0,1),xlim=c(1,0),\n              smooth=T, #绘制平滑曲线 draw smooth curve\n              ci=TRUE, \n              main=\"\",\n              #print.thres=\"best\", #把阈值写在图上，其sensitivity+ specificity之和最大 write the threshold on the graph with the sum of its sensitivity and specificity maximized\n              col=mycol[2],#线的颜色 color of the line\n              lwd=2, #线的粗细 thickness of the line\n              legacy.axes=T)#采用大多数paper的画法，横坐标是“1-specificity”，从0到1 adopt the way most papers are drawn, the horizontal coordinate is \"1-specificity\", from 0 to 1.\n\nci.lower <- round(as.numeric(x$ci[1]),3) #置信区间下限 lower bound of the confidence interval\nci.upper <- round(as.numeric(x$ci[3]),3) #置信区间上限 upper bound of the confidence interval\n\nauc.ci <- c(colnames(df)[2],round(as.numeric(x$auc),3),paste(ci.lower,ci.upper,sep=\"-\"))\nauc.out <- rbind(auc.out,auc.ci)\n\n\n#再用循环画第二条和后面更多条曲线\n#Then use the loop to draw the second curve and more curves after that\nfor (i in 3:ncol(df)){\n  x <- plot.roc(df[,1],df[,i],\n                add=T, #向前面画的图里添加 add to the previously drawn plot\n                smooth=T,\n                ci=TRUE,\n                col=mycol[i],\n                lwd=2,\n                legacy.axes=T)\n\n  ci.lower <- round(as.numeric(x$ci[1]),3)\n  ci.upper <- round(as.numeric(x$ci[3]),3)\n  \n  auc.ci <- c(colnames(df)[i],round(as.numeric(x$auc),3),paste(ci.lower,ci.upper,sep=\"-\"))\n  auc.out <- rbind(auc.out,auc.ci)\n}\n\n\n#对比多条曲线\n#在参数`method=`后面，有三种方法可选“delong”, “bootstrap”或“venkatraman”，计算p值\n#compare multiple curves\n#after the parameter `method=`, there are three methods to choose from \"delong\", \"bootstrap\" or \"venkatraman\", calculate p-value\np.out <- c()\nfor (i in 2:(ncol(df)-1)){\n  for (j in (i+1):ncol(df)){\n    p <- roc.test(df[,1],df[,i],df[,j], method=\"bootstrap\")\n    p.tmp <- c(colnames(df)[i],colnames(df)[j],p$p.value)\n    p.out <- rbind(p.out,p.tmp)\n  }\n}\n\n#输出p value到文件\n#output p value to file\np.out <- as.data.frame(p.out)\ncolnames(p.out) <- c(\"ROC1\",\"ROC2\",\"p.value\")\nwrite.table(p.out,\"pvalue_output.xls\",sep=\"\\t\",quote=F,row.names = F,col.names = T)\n\n#还可以把p value写在图上\n#这里有4条线，6组对比。太多，就不写了吧。\n#如果只对比两条线，就运行下面这行\n#Also write the p value on the plot\n#There are 4 lines and 6 sets of comparisons here. It's too much to write.\n#If you only compare two lines, run the following line\n#text(0.4, 0.3, labels=paste(\"miRNA1 vs. miRNA2\\np-value =\", p.out[1,3]), adj=c(0, .5))\n\n\n# 输出AUC、AUC CI到文件\n# output AUC, AUC CI to file\nauc.out <- as.data.frame(auc.out)\ncolnames(auc.out) <- c(\"Name\",\"AUC\",\"AUC CI\")\nwrite.table(auc.out,\"auc_output.xls\",sep=\"\\t\",quote = F,row.names = F,col.names = T)\n\n\n#绘制图例\n#draw legend\nlegend.name <- paste(colnames(df)[2:length(df)],\"AUC\",auc.out$AUC,sep=\" \")\nlegend(\"bottomright\", \n       legend=legend.name,\n       col = mycol[2:length(df)],\n       lwd = 2,\n       bty=\"n\")\ndev.off()\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa24ROC_FigureYa24ROC",
      "title": "FigureYa24ROC/FigureYa24ROC.html",
      "html": "FigureYa24ROC/FigureYa24ROC.html",
      "text": "texts/main_FigureYa24ROC_FigureYa24ROC.txt",
      "folder": "FigureYa24ROC",
      "thumb": "gallery_compress/FigureYa24ROC.webp"
    },
    "word_count": 458,
    "lines_count": 132,
    "title": "FigureYa24 ROC",
    "description": "Requirement description 用R画出ROC曲线（receiver operating characteristic curve）。 Draw the ROC curve in R（receiver operating characteristic",
    "input_data_types": [
      "临床数据"
    ],
    "output_types": [
      "统计表格"
    ],
    "technical_methods": [],
    "biology_areas": [],
    "complexity_level": "高级",
    "code_snippets": [],
    "key_parameters": [
      "add",
      "lwd",
      "width",
      "ylim",
      "xlim",
      "pvalue",
      "labels",
      "legend",
      "col",
      "method"
    ]
  },
  {
    "id": "main_FigureYa59volcanoV2_FigureYa59volcanoV2",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa59volcanoV2_FigureYa59volcanoV2.txt",
    "content": "FigureYa59volcanoV2\nFigureYa59volcanoV2\nAuthor(s)\n: Haitao Wang\nReviewer(s)\n: Ying Ge, Yijing Chen\nDate\n: 2025-10-25\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n画出像paper里这样美的火山图。\nDraw a beautiful volcano plot like this one in the paper.\n出自\nhttps://www.nature.com/articles/s41467-018-06944-1\nFrom\nhttps://www.nature.com/articles/s41467-018-06944-1\n应用场景\nApplication scenario\n展示两组之间总体的基因表达变化趋势。\nDemonstrate overall gene expression trends between the two\ngroups.\n环境设置\nEnvironment setting\nsource(\"install_dependencies.R\") #安装所需R包 | Install required R packages\nlibrary(ggplot2)   # 加载绘图核心库 | Core plotting library\nlibrary(ggrepel)   # 防止标签重叠的智能标注 | Smart label repulsion to avoid overlaps\nlibrary(ggthemes)  # 提供额外主题与配色 | Additional themes and color palettes\nlibrary(gridExtra) # 多图排版与网格布局 | Arrange multiple plots and grid layout\n\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 | Display English error messages\noptions(stringsAsFactors = FALSE) #禁止chr转成factor | prohibit the conversion of chr to factor\n输入文件\nInput file\neasy_input_limma.csv，此处用limma结果，还可以用EdgeR、DESeq2等工具获得的差异分析结果作为输入。\n至少包含三列：基因名、变化倍数（logFC）、P value(P.Value)或adjust\nPvalue(adj.P.Val)。\neasy_input_selected.csv，有时希望突出显示几个基因，例如后文进行功能验证的基因。会在突出显示的基因外面画黑色圆圈，并标出基因名。\n至少包含第一列：基因名。第二列是该基因所在的pathway，为可选项。\neasy_input_limma.csv, here using the limma results, differential\nanalysis results obtained from tools such as EdgeR and DESeq2 can also\nbe used as input.\nIt contains at least three columns: gene name, fold change (logFC), P\nvalue (P.Value) or adjust Pvalue (adj.P.Val).\neasy_input_selected.csv, sometimes it is desired to highlight\nseveral genes, such as genes that will undergo functional validation\nlater. Black circles will be drawn around the highlighted genes, and the\ngene names will be labeled.\nAt least include the first column: gene name. The second column is\nthe pathway of the gene, which is optional.\n# 全部基因差异表达分析结果\n# differential Expression Analysis Results of All Genes\nx <- read.csv(\"easy_input_limma.csv\")\nx$label<- x$X\nhead(x)\n# 突出展示感兴趣的基因\n# highlight genes of interest\nselectedGeneID <- read.csv(\"easy_input_selected.csv\")\nhead(selectedGeneID)\n# 提取感兴趣的基因的差异分析结果\n# extract the differential analysis results of the gene of interest\nx$gsym <- x$label\nselectgenes <- merge(selectedGeneID, x, by = \"gsym\")\nhead(selectgenes)\n参数设置\nParameter setting\n点的颜色和虚线的位置都由下面的阈值决定，\n根据具体需求调整\n。\nThe color of the points and the position of the dashed line are\ndetermined by the thresholds below,\nadjust according to specific\nneeds\n.\n#plot_mode <- \"classic\" #经典版 classic version\nplot_mode <- \"advanced\" #酷炫版 cool version\n\nlogFCcut <- 1.5 #log2-foldchange\npvalCut <- 0.05 #P.value\nadjPcut <- 0.05 #adj.P.value\n\n#用于高级模式\n#for advanced mode\nlogFCcut2 <- 2.5\nlogFCcut3 <- 5\npvalCut2 <- 0.0001\npvalCut3 <- 0.00001\n\n#置x，y軸的最大最小位置\n#set the maximum and minimum positions of the x and y axes\nxmin <- (range(x$logFC)[1]- (range(x$logFC)[1]+ 10))\nxmax <- (range(x$logFC)[1]+ (10-range(x$logFC)[1]))\nymin <- 0\nymax <- max(-log10(x$P.Value)) * 1.1\n\n# 基因名的颜色，需大于等于pathway的数量，这里自定义了足够多的颜色\n# the color of the gene name needs to be greater than or equal to the number of pathway, and here a sufficient number of colors have been customized\nmycol <- c(\"darkgreen\",\"chocolate4\",\"blueviolet\",\"#223D6C\",\"#D20A13\",\"#088247\",\"#58CDD9\",\"#7A142C\",\"#5D90BA\",\"#431A3D\",\"#91612D\",\"#6E568C\",\"#E0367A\",\"#D8D155\",\"#64495D\",\"#7CC767\")\n开始画图\nStart drawing\n此处纵坐标用P.value，根据需要，可以把P.Value换成adj.P.Val\nHere use P.value for the vertical coordinate, and replace P.Value\nwith adj.P.Val as needed\nif (plot_mode == \"classic\"){\n  # 簡單的setting for color\n  # simple setting for color\n  x$color_transparent <- ifelse((x$P.Value < pvalCut & x$logFC > logFCcut), \"red\", ifelse((x$P.Value < pvalCut & x$logFC < -logFCcut), \"blue\",\"grey\"))\n  # 簡單的setting for size\n  # simple setting for size\n  size <- ifelse((x$P.Value < pvalCut & abs(x$logFC) > logFCcut), 4, 2)\n  \n} else if (plot_mode == \"advanced\") {\n  # 複雜的的setting for color\n  # complex setting for Color\n  n1 <- length(x[, 1])\n  cols <- rep(\"grey\", n1)\n  names(cols)<- rownames(x)\n  \n  #不同阈值的点的颜色\n  #color of points with different thresholds\n  cols[x$P.Value < pvalCut & x$logFC >logFCcut]<- \"#FB9A99\"\n  cols[x$P.Value < pvalCut2 & x$logFC > logFCcut2]<- \"#ED4F4F\"\n  cols[x$P.Value < pvalCut & x$logFC < -logFCcut]<- \"#B2DF8A\"\n  cols[x$P.Value < pvalCut2 & x$logFC < -logFCcut2]<- \"#329E3F\"\n  color_transparent <- adjustcolor(cols, alpha.f = 0.5)\n  x$color_transparent <- color_transparent\n  \n  # 複雜的的setting for size\n  # complex setting for size\n  n1 <- length(x[, 1])\n  size <- rep(1, n1)\n  \n  #不同阈值的点的大小\n  #size of points with different thresholds\n  size[x$P.Value < pvalCut & x$logFC > logFCcut]<- 2\n  size[x$P.Value < pvalCut2 & x$logFC > logFCcut2]<- 4\n  size[x$P.Value < pvalCut3 & x$logFC > logFCcut3]<- 6\n  size[x$P.Value < pvalCut & x$logFC < -logFCcut]<- 2\n  size[x$P.Value < pvalCut2 & x$logFC < -logFCcut2]<- 4\n  size[x$P.Value < pvalCut3 & x$logFC < -logFCcut3]<- 6\n  \n} else {\n  stop(\"Unsupport mode\")\n}\n\n# 构建绘图对象\n# Construct the plot object\np1 <- ggplot(data=x, aes(logFC, -log10(P.Value), label = label, color = pathway)) +\n  geom_point(alpha = 0.6, size = size, colour = x$color_transparent) +\n\n  labs(x=bquote(~Log[2]~\"(fold change)\"), y=bquote(~-Log[10]~italic(\"P-value\")), title=\"\") + \n  ylim(c(ymin,ymax)) + \n  scale_x_continuous(\n    breaks = c(-10, -5, -logFCcut, 0, logFCcut, 5, 10), #刻度线的位置 position of the scale line\n    labels = c(-10, -5, -logFCcut, 0, logFCcut, 5, 10),\n    limits = c(-11, 11) #x轴范围，两侧对称才好看 x-axis range, symmetry on both sides looks good\n  ) +\n  #或用下面这行：\n  #or use the line below:\n  #xlim(c(xmin, xmax)) + \n\n  #画阈值分界线\n  #draw threshold boundary line\n  geom_vline(xintercept = c(-logFCcut, logFCcut), color=\"grey40\", \n             linetype=\"longdash\", lwd = 0.5) + #虚线的形状和粗细 shape and thickness of the dashed line\n  geom_hline(yintercept = -log10(pvalCut), color=\"grey40\", \n             linetype=\"longdash\", lwd = 0.5) +\n  \n  theme_bw(base_size = 12#, base_family = \"Times\" #修改字体 modify font\n           ) +\n  theme(panel.grid=element_blank())\n\nif (plot_mode == \"advanced\") {\n  p1 <- p1 + \n  geom_vline(xintercept = c(-logFCcut2, logFCcut2), color=\"grey40\", \n             linetype=\"longdash\", lwd = 0.5) +\n  geom_hline(yintercept = -log10(pvalCut2), color=\"grey40\", \n             linetype=\"longdash\", lwd = 0.5)\n}\np1\n# 显示 logFC > n 的基因的基因名\n# show gene names for genes with logFC > n\nn = 9\np1 + geom_text_repel(aes(x = logFC, y = -log10(P.Value), \n                               label = ifelse(logFC > n, rownames(x),\"\")),\n        colour=\"darkred\", size = 5, box.padding = unit(0.35, \"lines\"), \n        point.padding = unit(0.3, \"lines\"))\n# 突出显示候选基因\n# highlight candidate genes\np2 <- p1 + \n  # 在感兴趣的基因外面画个黑色圈\n  # draw a black circle around the gene of interest\n  geom_point(data = selectgenes, alpha = 1, size = 4.6, shape = 1, \n             stroke = 1, #圈粗细 thickness of circle\n             color = \"black\") +\n  \n  # 显示感兴趣的基因的基因名\n  # display the gene name of the gene of interest\n  scale_color_manual(values = mycol) + \n  geom_text_repel(data = selectgenes, \n                  show.legend = FALSE, #不显示图例 legend not displayed\n                  size = 5, box.padding = unit(0.35, \"lines\"), \n        point.padding = unit(0.3, \"lines\")) +\n  guides(color=guide_legend(title = NULL)) \n\np2\n# 显示pathway\n# show pathway\nnp <- length(unique(selectgenes$pathway))\n(labelsInfo <- data.frame(pathway = names(table(selectgenes$pathway)),\n                         col = mycol[1:np]))\np2 + annotation_custom(tableGrob(labelsInfo$pathway, rows = c(rep(\"\", np)), cols = \"\",\n                                 theme = ttheme_minimal(base_colour = labelsInfo$col)),\n                       ymin = ymax - 2, ymax = ymax, xmin = xmin - 1.5, xmax = xmin)\n# 保存到PDF文件\n# save to PDF file\nif (plot_mode == \"classic\"){\n  ggsave(\"volcano_classic.pdf\", width=6,height=5)\n} else if (plot_mode == \"advanced\") {\n  ggsave(\"Volcano_advanced.pdf\",width=6,height=5)\n} else {\n  stop(\"Unsupport mode\")\n}\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa59volcanoV2_FigureYa59volcanoV2",
      "title": "FigureYa59volcanoV2/FigureYa59volcanoV2.html",
      "html": "FigureYa59volcanoV2/FigureYa59volcanoV2.html",
      "text": "texts/main_FigureYa59volcanoV2_FigureYa59volcanoV2.txt",
      "folder": "FigureYa59volcanoV2",
      "thumb": "gallery_compress/FigureYa59volcanoV2.webp"
    },
    "word_count": 1030,
    "lines_count": 231,
    "title": "FigureYa59volcanoV2",
    "description": "Requirement description 画出像paper里这样美的火山图。 Draw a beautiful volcano plot like this one in the paper.",
    "input_data_types": [],
    "output_types": [
      "火山图",
      "统计表格"
    ],
    "technical_methods": [
      "通路分析",
      "差异表达分析"
    ],
    "biology_areas": [],
    "complexity_level": "高级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "colour",
      "values",
      "lwd",
      "pathway",
      "width",
      "xmin",
      "grid",
      "n"
    ]
  },
  {
    "id": "main_FigureYa292HCCsubtype_FigureYa292HCCsubtype",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa292HCCsubtype_FigureYa292HCCsubtype.txt",
    "content": "FigureYa292HCCsubtype\nFigureYa292HCCsubtype\nAuthor(s)\n: Xiaofan Lu; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-05-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirements Description\n主要是红框中的图，都是公共数据和已发表的文章。\n我们随后比较了基于TMDU和TCGA研究多平台数据的分类。\n根据以往的分子分型marker预测现有样本属于哪一类，再跟当前分型比较，计算p值。\nMainly the figures in the red box, which are all public data and\npublished articles.\nWe then compared our classification based on multi-platform data from\nthe TMDU and TCGA studies.\nUsing previous molecular subtype markers to predict which category\nthe existing samples belong to, and then comparing them with the current\nclassification to calculate the p-value.\n出自：\nhttps://linkinghub.elsevier.com/retrieve/pii/S2352396418306340\n图3. 肝细胞癌分子分型概述。(a)\nTMDU测试研究（上）和TCGA验证研究（下）中，基于既往定义的肝细胞癌分子分型相关基因集的综合评分比较。(b)\n分子亚型的示意图。\nSource:\nhttps://linkinghub.elsevier.com/retrieve/pii/S2352396418306340\nFig. 3. Summary ofmolecular classification of HCC. (a) Comparison of\naggregate scores with gene sets associated with the previously\ndefinedmolecular classifications of HCC in the TMDU test study (upper)\nand TCGA validation study (lower). (b) Schematic representation of\nmolecular subtypes.\n2017年的这篇Cell文章里就出现了类似的图：\nA similar figure appeared in this 2017 Cell paper:\n出自：\nhttps://linkinghub.elsevier.com/retrieve/pii/S0092867417306396\n图2. 肝癌呈现独特的基因高甲基化模式。 (A)\n基于肝癌组织相对于正常组织的基因高甲基化无监督聚类分析揭示了四个明显不同的亚群。研究人员分析了约15,000个在196名HCC患者中显示显著高甲基化的CpG位点，并以热图形式展示，其中正常组织和肿瘤样本按聚类分组排列在列中。每个CpG位点的甲基化强度通过行显示。热图上方标注了四个不同的高甲基化聚类群，下方条形图展示了各聚类群中个体肿瘤的临床和分子特征分布。右侧p值表示各特征的非随机分布具有统计学显著性。\nSource:\nhttps://linkinghub.elsevier.com/retrieve/pii/S0092867417306396\nFigure 2. Liver Cancers Show Distinct Gene Hypermethylation Patterns.\n(A) Unsupervised clustering analysis of gene hypermethylation in HCC\ntumor relative to normal tissue reveals four distinct subgroups. Roughly\n15,000 CpG sites showing significant hypermethylation in 196 HCC\npatients were analyzed and are shown in heatmap format with normal\ntissues and tumors organized in columns according to cluster\ndesignation. Intensity of methylation for each CpG site is indicated by\nrow. Above the heatmap the four distinct hypermethylation clusters are\nshown, and below are bars indicating the distribution of clinical and\nmolecular attributes of the individual tumors by cluster. To the right,\np values indicate significant non-random distributions for each\nattribute.\n应用场景\nApplication Scenario\n根据表达谱对HCC样本进行聚类，并和其他已有的分类器做比较。\nClustering of HCC samples based on expression profiles and comparison\nwith other existing classifiers.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\n# 用来实现nearest template prediction(NTP)\n# Implementation of Nearest Template Prediction (NTP)\nlibrary(CMScaller)\nlibrary(tidyverse)\nlibrary(clusterProfiler)\nlibrary(org.Hs.eg.db)\nlibrary(ClassDiscovery)\nlibrary(ComplexHeatmap)\nlibrary(gplots)\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character to factor conversion\noptions(stringsAsFactors = FALSE)\n自定义函数\nCustom Functions\nstandarize.fun <- function(indata=NULL, halfwidth=NULL, centerFlag=T, scaleFlag=T) {  \n  outdata=t(scale(t(indata), center=centerFlag, scale=scaleFlag))\n  if (!is.null(halfwidth)) {\n    outdata[outdata>halfwidth]=halfwidth\n    outdata[outdata<(-halfwidth)]= -halfwidth\n  }\n  return(outdata)\n}\n\nfpkmToTpm <- function(fpkm)\n{\n  exp(log(fpkm) - log(sum(fpkm)) + log(1e6))\n}\n输入文件\nInput Files\ndata_mutations.txt，突变数据，下载自cBioPortal\nhttps://www.cbioportal.org/\n。\nLIHC.htseq_fpkm.tsv.gz，表达谱数据FPKM，已经过\nlog2(fpkm+1)\n转换，下载地址：\nhttps://xenabrowser.net/datapages/?dataset=TCGA-LIHC.htseq_fpkm.tsv&host=https%3A%2F%2Fgdc.xenahubs.net&removeHub=https%3A%2F%2Fxena.treehouse.gi.ucsc.edu%3A443\ngencode.v22.annotation.gene.probeMap，ID/Gene\nMapping，下载地址同上。\ndata_mutations.txt，mutation data, downloaded from cBioPortal\nhttps://www.cbioportal.org/\n.\nTCGA-LIHC.star_fpkm.tsv.gz, expression profile data FPKM, already\nconverted by log2(fpkm+1), download link:\nhttps://xenabrowser.net/datapages/?dataset=TCGA-LIHC.star_fpkm.tsv&host=https%3A%2F%2Fgdc.xenahubs.net&removeHub=https%3A%2F%2Fxena.treehouse.gi.ucsc.edu%3A443\ngencode.v36.annotation.gtf.gene.probemap, ID/Gene Mapping, download\nlink same as above.\n# 读取突变数据\n# Read mutation data\nmaf <- read_tsv(\"data_mutations.txt\", comment = \"#\")\n# 把突变数据转成01矩阵（方法跟FigureYa288MutualExclusivity一样）\n# Convert mutation data to binary matrix (same method as FigureYa288MutualExclusivity)\nmut.binary <- matrix(0,nrow = length(unique(maf$Hugo_Symbol)),ncol = length(unique(maf$Tumor_Sample_Barcode)),dimnames = list(unique(maf$Hugo_Symbol),unique(maf$Tumor_Sample_Barcode)))\n\n# 填充突变矩阵(1表示存在突变)\n# Fill in mutation matrix (1=mutation present) \nfor (i in colnames(mut.binary)) {\n  tmp <- maf[which(maf$Tumor_Sample_Barcode == i),]\n  tmp <- tmp[which(tmp$Variant_Classification %in% c(\"Frame_Shift_Del\", \"Frame_Shift_Ins\", \"Splice_Site\", \"Translation_Start_Site\",\"Nonsense_Mutation\", \"Nonstop_Mutation\", \"In_Frame_Del\",\"In_Frame_Ins\", \"Missense_Mutation\")),]\n  for (j in tmp$Hugo_Symbol)\n    mut.binary[j,i] <- 1\n}\n\n# 转为数据框\n# Convert to dataframe \nmut.binary <- as.data.frame(mut.binary)\n\n# 读取表达谱数据\n# Read expression profiles\nfpkm <- read.delim(\"TCGA-LIHC.star_fpkm.tsv.gz\", sep = \"\\t\", row.names = 1, check.names = F, stringsAsFactors = F, header = T)\nfpkm <- 2^fpkm - 1\n\n# 把fpkms转为tpm\n# Convert FPKM to TPM\ntpm <- apply(fpkm, 2, fpkmToTpm)\ntpm <- as.data.frame(log2(tpm + 1))\nrm(fpkm); gc()\n# 加载基因注释\n# Load gene annotation\nGinfo <- read.delim(\"gencode.v36.annotation.gtf.gene.probemap\",row.names = 1,sep = \"\\t\",check.names = F,stringsAsFactors = F,header = T)\n\n# 匹配表达谱和注释的基因\n# Match genes between expression and annotation\ncomgene <- intersect(rownames(Ginfo), rownames(tpm))\nGinfo <- Ginfo[comgene,]\ntpm <- tpm[comgene,]\nidentical(rownames(tpm), rownames(Ginfo))\n# 按基因名聚合取表达中位数\n# Aggregate duplicate genes by median expression\ntpm$Gene <- Ginfo[rownames(tpm),\"gene\"]\ntpm <- as.data.frame(apply(tpm[,setdiff(colnames(tpm), \"Gene\")], 2, function(x) tapply(x, INDEX = factor(tpm$Gene), FUN=median, na.rm = TRUE))) \n\n# 截短样本ID\n# Trim sample IDs\ncolnames(tpm) <- substr(colnames(tpm),1,15)\n\nexpr <- tpm\n\n# 提取突变和表达的共同样本\n# Extract common samples between mutation and expression\ncomsam <- intersect(colnames(expr), colnames(mut.binary))\nmut.binary <- mut.binary[,comsam]\nexpr <- expr[,comsam]\n\n# 加载原文用于聚类的差异表达基因\n# Load DEGs for clustering from original paper\ndegs <- read.table(\"degs.txt\",sep = \"\\t\",row.names = NULL,header = T,check.names = F,stringsAsFactors = F)\ncomgene <- intersect(degs$Gene, rownames(expr))\n\n# 从论文中获取iCluster亚型：肝细胞癌的综合基因组特征分析\n# Get iCluster subtypes from paper: Comprehensive and Integrative Genomic Characterization of Hepatocellular Carcinoma\nicluster <- read.delim(\"icluster.txt\",sep = \"\\t\",row.names = 2,check.names = F,stringsAsFactors = F,header = T)\nrownames(icluster) <- substr(rownames(icluster),1,15)\nNearest template prediction\n加载不同HCC亚型签名并制作nearest template prediction所需的模版。\nLoading HCC subtype signatures and creating templates for nearest\ntemplate prediction.\nboyault <- read.delim(\"Boyault-marker-all.txt\",sep = \"\\t\",row.names = NULL,check.names = F,stringsAsFactors = F,header = T)\n\n# 将Entrez ID转换为基因符号\n# Convert Entrez IDs to gene symbols\ntmp <- bitr(boyault$`Gene ID #1`,fromType = \"ENTREZID\",toType = \"SYMBOL\",OrgDb = org.Hs.eg.db)\n# 提取关键列\n# Extract relevant columns \nboyault <- boyault[,c(2,4)]\ncolnames(boyault) <- c(\"ENTREZID\",\"class\")\n\n# 合并基因符号映射\n# Merge with symbol mapping \nboyault <- merge(tmp,boyault,by = \"ENTREZID\", all.x = T)\ncolnames(boyault)[2] <- \"probe\"\n\nchiang <- read.delim(\"Chiang-marker-all.txt\",sep = \"\\t\",row.names = NULL,check.names = F,stringsAsFactors = F,header = T)\nchiang <- chiang[,c(1,4)]\ncolnames(chiang) <- c(\"probe\",\"class\")\n\nhoshida <- read.delim(\"Hoshida-genelist.txt\",sep = \"\\t\",row.names = NULL,check.names = F,stringsAsFactors = F,header = T)\nhoshida <- hoshida[,c(1,2)]\ncolnames(hoshida) <- c(\"probe\",\"class\")\nhoshida$class <- paste0(\"C\",hoshida$class)\n\nlee <- read.delim(\"Lee-marker-all.txt\",sep = \"\\t\",row.names = NULL,check.names = F,stringsAsFactors = F,header = T)\nlee <- lee[,c(1,3)]\ncolnames(lee) <- c(\"probe\",\"class\")\n通过nearest template prediction获取其他亚型。\nObtaining other subtypes via nearest template prediction.\ntcga.boyault <- ntp(emat = t(scale(t(expr))),\n                    templates = boyault,\n                    doPlot = T,\n                    seed = 19991018)\ntcga.chiang <- ntp(emat = t(scale(t(expr))),\n                   templates = chiang,\n                   doPlot = T,\n                   seed = 19991018)\ntcga.lee <- ntp(emat = t(scale(t(expr))),\n                   templates = lee,\n                   doPlot = T,\n                   seed = 19991018)\ntcga.hoshida <- ntp(emat = t(scale(t(expr))),\n                    templates = hoshida,\n                    doPlot = T,\n                    seed = 19991018)\n开始画图\nPlotting\n# 构建样本注释\n# Construct sample annotation\nannCol <- data.frame(CTNNB1 = ifelse(as.numeric(mut.binary[\"CTNNB1\",]) == 0,\"WT\",\"MT\"),\n                     Lee = as.character(tcga.lee$prediction),\n                     Hoshida = as.character(tcga.hoshida$prediction),\n                     Boyault = as.character(tcga.boyault$prediction),\n                     Chiang = as.character(tcga.chiang$prediction),\n                     row.names = colnames(mut.binary),\n                     stringsAsFactors = F)\n\n# 整合iCluster亚型\n# Integrate iCluster subtypes\nannCol[intersect(rownames(annCol),rownames(icluster)),\"iCluster\"] <- icluster[intersect(rownames(annCol),rownames(icluster)), \"iCluster clusters (k=3, Ronglai Shen)\"]\n\n# 标记缺失数据\n# Mark missing data\nannCol[is.na(annCol$iCluster),\"iCluster\"] <- \"N/A\"\n\n# 标准化亚型标签\n# Standardize subtype labels\nannCol$Hoshida <- gsub(\"C\",\"S\",annCol$Hoshida)\nannCol$iCluster <- gsub(\"iCluster:\",\"iC\",annCol$iCluster)\n\n# 优化Chiang亚型标签\n# Refine Chiang subtype labels\nannCol[which(annCol$Chiang == \"interferon class\"), \"Chiang\"] <- \"INTERFERON\"\nannCol[which(annCol$Chiang == \"proliferation class\"), \"Chiang\"] <- \"PROLIFERATION\"\nannCol[which(annCol$Chiang == \"CTNNB1 class\"), \"Chiang\"] <- \"CTNNB1\"\nannCol[which(annCol$Chiang == \"unannotated class\"), \"Chiang\"] <- \"UNANNOTATED\"\nannCol[which(annCol$Chiang == \"chromosome 7 polysomy class\"), \"Chiang\"] <- \"POLYSOMY7\"\n\n# 设置注释列的因子水平\n# Set factor levels for annotation columns\nannCol$CTNNB1 <- factor(annCol$CTNNB1, levels = c(\"MT\",\"WT\"))\nannCol$Lee <- factor(annCol$Lee, levels = c(\"SURVIVAL_DN\",\"SURVIVAL_UP\"))\nannCol$Hoshida <- factor(annCol$Hoshida, levels = c(\"S1\",\"S2\",\"S3\"))\nannCol$Boyault <- factor(annCol$Boyault, levels = c(\"G12\",\"G3\",\"G56\"))\nannCol$Chiang <- factor(annCol$Chiang, levels = c(\"PROLIFERATION\",\"CTNNB1\",\"INTERFERON\",\"POLYSOMY7\",\"UNANNOTATED\"))\nannCol$iCluster <- factor(annCol$iCluster, levels = c(\"iC1\",\"iC2\",\"iC3\",\"N/A\"))\n\n# 创建注释颜色方案\n# Create color scheme for annotations\nannColors <- list()\nannColors[[\"CTNNB1\"]] <- c(\"WT\" = \"white\",\"MT\" = \"black\")\nannColors[[\"Lee\"]] <- c(\"SURVIVAL_DN\" = \"#E80035\",\"SURVIVAL_UP\" = \"#DBDEDD\")\nannColors[[\"Hoshida\"]] <- c(\"S1\" = \"#E8536B\",\"S2\" = \"#F6B879\",\"S3\" = \"#DFEBAF\")\nannColors[[\"Boyault\"]] <- c(\"G12\" = \"#E8536B\",\"G3\" = \"#F6B879\",\"G56\" = \"#DFEBAF\")\nannColors[[\"Chiang\"]] <- c(\"PROLIFERATION\" = \"#F2A1A2\",\"CTNNB1\" = \"#68BE8B\",\"INTERFERON\" = \"#2CA8E1\",\"POLYSOMY7\" = \"#A2D9F1\",\"UNANNOTATED\" = \"#BAC8E5\")\nannColors[[\"iCluster\"]] <- c(\"iC1\" = \"#A8BFDE\",\"iC2\" = \"#DA8A88\",\"iC3\" = \"#BCA3D6\",\"N/A\" = \"white\")\nannColors[[\"Group\"]] <- c(\"A\" = \"#FE0000\",\"B\" = \"black\")\nannColors[[\"MS\"]] <- c(\"MS1\" = \"#FE0000\", \"MS2\" = \"#00AF50\",\"MS3\" = \"#0071C0\")\n\n# 进行无监督聚类\n# Perform unsupervised clustering\nindata <- expr[comgene,]\nindata <- indata[rowSums(indata) > 0,]\n\n# 计算距离矩阵\n# Calculate distance matrices\nhcs <- hclust(distanceMatrix(as.matrix(indata), \"euclidean\"), \"ward.D\")\nhcg <- hclust(distanceMatrix(as.matrix(t(indata)), \"euclidean\"), \"ward.D\")\n\n# 将树切割为3类\n# Cut tree into 3 clusters\ngroup <- cutree(hcs, k = 3)\n\n# 检查样本分布和CTNNB1突变情况\n# Check sample distribution and CTNNB1 mutation\ntable(group, annCol$CTNNB1)\n# 分配亚型标签\n# Assign subtype labels\nannCol$MS <- ifelse(group == 1, \"MS2\", ifelse(group == 3, \"MS1\",\"MS3\")) # 由于1组有更多CTNNB1，所以是MS2，由于3组样本更少，所以是MS1\nannCol$Group <- ifelse(group == 3, \"A\", \"B\") # 由于3组是MS1所以为Group A\n\n# 准备热图数据\n# Prepare data for heatmap\nplotdata <- standarize.fun(indata, halfwidth = 2) # 数据标准化用于绘图\n\n# 生成热图\n# Generate heatmap\nhm <- pheatmap(plotdata,\n         color = bluered(64),\n         border_color = NA,\n         cluster_rows = hcg,\n         cluster_cols = hcs,\n         treeheight_row = 30,\n         treeheight_col = 30,\n         #cutree_cols = 3,\n         show_rownames = F,\n         show_colnames = F,\n         annotation_col = annCol[,c(\"iCluster\",\"Chiang\",\"Boyault\",\"Hoshida\",\"Lee\",\"CTNNB1\",\"MS\",\"Group\")],\n         annotation_colors = annColors,\n         cellwidth = 0.6,\n         cellheight = 0.2)\n\n# 保存热图\n# Save heatmap\npdf(\"heatmap.pdf\", width = 8,height = 6)\ndraw(hm, heatmap_legend_side = \"left\", annotation_legend_side = \"left\")\ninvisible(dev.off())\n计算group和其他类型的独立性\nTesting independence between groups and other types\n# 初始化输出表格\n# Initialize output tables\noutTabGroup <- outTabMS <- NULL\n\n# 检验Group/MS与其他分类的独立性\n# Perform independence tests between Group/MS and other classifications\nfor (i in c(\"iCluster\",\"Chiang\",\"Boyault\",\"Hoshida\",\"Lee\",\"CTNNB1\")) {\n  tmp <- annCol[,c(i,\"Group\")]\n  set.seed(123)\n  p <- fisher.test(table(tmp[,1],tmp[,2]), \n                   simulate.p.value = T)$p.value \n  \n  outTabGroup <- rbind.data.frame(outTabGroup,\n                                  data.frame(VarA = \"Group\",\n                                             VarB = i,\n                                             p = p),\n                                  stringsAsFactors = F)\n  \n  # 检验MS与当前分类的关系\n  # Test MS vs current classification \n  tmp <- annCol[,c(i,\"MS\")]\n  set.seed(123)\n  p <- fisher.test(table(tmp[,1],tmp[,2]),simulate.p.value = T)$p.value\n  outTabMS <- rbind.data.frame(outTabMS,\n                               data.frame(VarA = \"MS\",\n                                          VarB = i,\n                                          p = p),\n                               stringsAsFactors = F)\n}\n\n# 把p-values保存到文件\n# Save p-values to files\nwrite.table(outTabGroup, file = \"independent test between group and other classification.txt\",sep = \"\\t\",row.names = F,col.names = T,quote = F)\nwrite.table(outTabMS, file = \"independent test between ms and other classification.txt\",sep = \"\\t\",row.names = F,col.names = T,quote = F)\n\n# 保存工作镜像\n# Save workspace image\n#save.image(file = \"LIHC.RData\")\n后期加工\nPost-processing\n输出的PDF文件是矢量图，可以用Illustrator等矢量图编辑工具打开，添加p\nvalue。如果想用代码添加p-values，可参考FigureYa165heatmapPvalue或FigureYa280TMEofSTS\nThe output PDF files are vector graphics that can be opened and\nedited with vector graphic tools like Illustrator to add p-values. If\nyou prefer to add p-values programmatically, please refer to\nFigureYa165heatmapPvalue or FigureYa280TMEofSTS.\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa292HCCsubtype_FigureYa292HCCsubtype",
      "title": "FigureYa292HCCsubtype/FigureYa292HCCsubtype.html",
      "html": "FigureYa292HCCsubtype/FigureYa292HCCsubtype.html",
      "text": "texts/main_FigureYa292HCCsubtype_FigureYa292HCCsubtype.txt",
      "folder": "FigureYa292HCCsubtype",
      "thumb": "gallery_compress/FigureYa292HCCsubtype.webp"
    },
    "word_count": 1509,
    "lines_count": 384,
    "title": "FigureYa292HCCsubtype",
    "description": "Requirements Description 主要是红框中的图，都是公共数据和已发表的文章。 我们随后比较了基于TMDU和TCGA研究多平台数据的分类。",
    "input_data_types": [
      "生存数据",
      "临床数据",
      "DNA-seq",
      "突变数据"
    ],
    "output_types": [
      "火山图",
      "热图",
      "统计表格",
      "生存曲线"
    ],
    "technical_methods": [
      "聚类分析",
      "标准化",
      "差异表达分析"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "高级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "seed",
      "annotation_col",
      "center",
      "header",
      "cellheight",
      "width",
      "cluster_cols",
      "CTNNB1",
      "1"
    ]
  },
  {
    "id": "main_FigureYa193RiskTable_FigureYa193RiskTable",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa193RiskTable_FigureYa193RiskTable.txt",
    "content": "FigureYa193RiskTable\nFigureYa193RiskTable\nAuthor(s)\n: Xiaofan Lu\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement\n上半部分是TCGA数据，下半部分是用GEO数据集验证，riskscore用多因素cox或lasso都行。搞一个GEO验证集就好了，例文的两个GEO数据都是类似的，我们比葫芦画瓢。\nThe upper part is TCGA data, and the lower part is verified using the\nGEO dataset. riskscore can be achieved using either multivariate cox or\nlasso. Just set up a GEO validation set. The two GEO data in the example\nare similar. Let’s imitate them.\n出自\nhttps://translational-medicine.biomedcentral.com/articles/10.1186/s12967-019-1824-4\nfromhttps://translational-medicine.biomedcentral.com/articles/10.1186/s12967-019-1824-4\n应用场景\nApplication Scenarios\n训练集构建riskscore并验证，采用多变量回归检验预后独立性并绘制森林图。\nThe riskscore of the training set was constructed and verified.\nMultivariate regression was used to test the prognostic independence and\na forest map was drawn.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(survival) # 生存分析  # Survival Analysis\nlibrary(glmnet) # LASSO回归   # LASSO Regression\nlibrary(forestplot) # 绘制森林图   # Draw forest maps\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息  # displays an English error message\noptions(stringsAsFactors = FALSE) #禁止chr转成factor  # prohibit chr from being converted to factor\n自定义函数显示进程 Custom functions display processes\ndisplay.progress = function (index, totalN, breakN=20) {\n  if ( index %% ceiling(totalN/breakN)  ==0  ) {\n    cat(paste(round(index*100/totalN), \"% \", sep=\"\"))\n  }\n}\n输入文件\nInput File\n需要表达矩阵和生存信息 The matrix and survival information need to be\nexpressed.\n这里用TCGA数据做训练集，用从GEO数据库下载的一组表达数据做测试集。如果你用多组GEO数据或自己的表达数据做测试集，就依次添加。\nHere, TCGA data is used as the training set, and a set of expression\ndata downloaded from the GEO database is used as the test set. If you\nuse multiple sets of GEO data or your own expression data as test sets,\nadd them one by one.\ntcga.expr.txt，TCGA的表达矩阵； tcga.expr.txt, the expression matrix\nof TCGA.\ntcga.surv.txt，TCGA的生存数据。 tcga.surv.txt, survival data of\nTCGA.\ngse39582.expr.txt，GEO的表达矩阵； gse39582.expr.txt, the expression\nmatrix of GEO.\ngse39582.surv.txt，GEO的生存数据。 gse39582.surv.txt, survival data\nof GEO.\n# 加载TCGA训练集\n# Load the TCGA training set\ntcga.expr <- read.table(unz(\"tcga.expr.txt.zip\", \"tcga.expr.txt\"), \n                        row.names = 1, check.names = F, stringsAsFactors = F, header = T)\ntcga.expr[1:3, 1:3]\ntcga.surv <- read.table(\"tcga.surv.txt\", row.names = 1, check.names = F, stringsAsFactors = F, header = T)\ntcga.surv[1:3,]\n# 保留既有表达数据又有生存数据的sample\n# Retain samples that have both expressive data and survival data\ncomsam.tcga <- intersect(rownames(tcga.surv), colnames(tcga.expr))\ntcga.expr <- tcga.expr[,comsam.tcga]\ntcga.surv <- tcga.surv[comsam.tcga,]\n\n# 加载GEO测试集\n# Load the GEO test set\ngeo.expr <- read.delim(unz(\"gse39582.expr.txt.zip\", \"gse39582.expr.txt\"), \n                       row.names = 1, check.names = F, stringsAsFactors = F, header = T)\ngeo.surv <- read.table(\"gse39582.surv.txt\", row.names = 1, check.names = F, stringsAsFactors = F, header = T)\n# 保留既有表达数据又有生存数据的sample\n# Retain samples that have both expressive data and survival data\ncomsam.geo <- intersect(rownames(geo.surv), colnames(geo.expr))\ngeo.expr <- geo.expr[,comsam.geo]\ngeo.surv <- geo.surv[comsam.geo,]\n\n# 取交集基因并做数据标准化用于模型构建\n# Take the intersection genes and standardize the data for model construction\ncomgene <- intersect(rownames(tcga.expr), rownames(geo.expr))\ntcga.expr <- as.data.frame(t(scale(t(log2(tcga.expr[comgene,] + 1)))))\ngeo.expr <- as.data.frame(t(scale(t(geo.expr[comgene,]))))\n训练集用传统做法构建riskscore（单变量cox + 多变量cox +\nLASSO惩罚）\nThe training set was constructed with riskscore using the\ntraditional approach (univariate cox + multivariate cox + LASSO\npenalty).\n# 单变量cox\n# Univariate cox\nunicox <- data.frame()\nfor(i in 1:nrow(tcga.expr)){\n  \n  display.progress(index = i, totalN = nrow(tcga.expr))\n  gene <- rownames(tcga.expr)[i]\n  tmp <- data.frame(expr = as.numeric(tcga.expr[i,]),\n                    futime = tcga.surv$OS.time,\n                    fustat = tcga.surv$OS,\n                    stringsAsFactors = F)\n  \n  # 移除缺失值 | Remove missing values\n  tmp <- na.omit(tmp)\n  \n  # 检查是否有足够的数据进行cox分析 | Check if there is enough data for cox analysis\n  if (nrow(tmp) < 10) {  # 至少需要10个观测值 | Need at least 10 observations\n    cat(\"跳过基因\", gene, \": 观测值不足\\n\")\n    cat(\"Skipping gene\", gene, \": insufficient observations\\n\")\n    next\n  }\n  \n  # 检查表达值是否都是常数 | Check if expression values are all constant\n  if (sd(tmp$expr, na.rm = TRUE) == 0) {\n    cat(\"跳过基因\", gene, \": 表达值为常数\\n\")\n    cat(\"Skipping gene\", gene, \": constant expression values\\n\")\n    next\n  }\n  \n  # 检查是否有事件发生 | Check if any events occurred\n  if (sum(tmp$fustat) == 0) {\n    cat(\"跳过基因\", gene, \": 无事件发生\\n\")\n    cat(\"Skipping gene\", gene, \": no events occurred\\n\")\n    next\n  }\n  \n  tryCatch({\n    cox <- coxph(Surv(futime, fustat) ~ expr, data = tmp)\n    coxSummary <- summary(cox)\n    unicox <- rbind.data.frame(unicox,\n                               data.frame(gene = gene,\n                                          HR = as.numeric(coxSummary$coefficients[,\"exp(coef)\"])[1],\n                                          z = as.numeric(coxSummary$coefficients[,\"z\"])[1],\n                                          pvalue = as.numeric(coxSummary$coefficients[,\"Pr(>|z|)\"])[1],\n                                          lower = as.numeric(coxSummary$conf.int[,3][1]),\n                                          upper = as.numeric(coxSummary$conf.int[,4][1]),\n                                          stringsAsFactors = F),\n                               stringsAsFactors = F)\n  }, error = function(e) {\n    cat(\"跳过基因\", gene, \": Cox分析错误 -\", e$message, \"\\n\")\n    cat(\"Skipping gene\", gene, \": Cox analysis error -\", e$message, \"\\n\")\n  })\n}\n# 检查是否有成功的cox分析结果 | Check if any Cox analysis was successful\nif (nrow(unicox) == 0) {\n  stop(\"没有基因成功完成Cox分析，请检查数据质量\\nNo genes successfully completed Cox analysis, please check data quality\")\n}\n\n# 多变量cox+LASSO惩罚\n# Multivariate cox+LASSO punishment\nset.seed(2020821)\nselgene <- unicox[which(unicox$pvalue < 0.05), \"gene\"]\n\n# 检查是否有显著基因 | Check if there are significant genes\nif (length(selgene) == 0) {\n  stop(\"没有显著基因（p < 0.05），无法进行LASSO分析\\nNo significant genes (p < 0.05), cannot perform LASSO analysis\")\n}\n\ncvfit = cv.glmnet(t(tcga.expr[selgene,]), \n                  Surv(tcga.surv$OS.time, tcga.surv$OS),\n                  family = \"cox\",\n                  nfold = 10) \n\nmyCoefs <- coef(cvfit, s=\"lambda.min\");\nlasso_fea <- myCoefs@Dimnames[[1]][which(myCoefs != 0 )]\n\n# 检查LASSO是否选择了特征 | Check if LASSO selected any features\nif (length(lasso_fea) == 0) {\n  stop(\"LASSO没有选择任何特征，请调整参数\\nLASSO did not select any features, please adjust parameters\")\n}\n\n# 计算训练集riskscore（rs）\n# Calculate the riskscore (rs) of the Training Set\nrs.tcga <- apply(t(tcga.expr[lasso_fea,]), 1, function(x) {x %*% myCoefs@x})\n\n# 计算测试集riskscore\n# Calculate the riskscore of the test set\nrs.geo <- apply(t(geo.expr[lasso_fea,]), 1, function(x) {x %*% myCoefs@x})\n\n#--------------------#\n# 计算rs的预后独立性 #\n# Calculate the prognostic independence of rs #\n\n# 训练集预后独立性\n# Training set prognostic independence\ntcga.surv$riskscore <- rs.tcga[rownames(tcga.surv)]\nhead(tcga.surv)\n# 移除缺失值 | Remove missing values\ntcga.surv_complete <- na.omit(tcga.surv)\n\nmulcox.tcga <- summary(coxph(Surv(OS.time, OS) ~ ., data = tcga.surv_complete))\nmulcox.tcga <- data.frame(variable = rownames(mulcox.tcga$conf.int),\n                          HR = mulcox.tcga$conf.int[,1],\n                          lower.95CI = mulcox.tcga$conf.int[,3],\n                          upper.95CI = mulcox.tcga$conf.int[,4],\n                          p = mulcox.tcga$coefficients[,5],\n                          stringsAsFactors = F)\nrownames(mulcox.tcga) <- NULL\nhead(mulcox.tcga)\n# 测试集预后独立性\n# Test set prognostic independence\ngeo.surv$riskscore <- rs.geo[rownames(geo.surv)]\nhead(geo.surv)\ngeo.surv <- geo.surv[,c(\"Age\",\"Sex\",\"Stage\",\"OS\",\"OS.time\",\"riskscore\")] # 保持和训练集一样的顺序\n# Keep the same order as the training set\n\n# 移除缺失值 | Remove missing values\ngeo.surv_complete <- na.omit(geo.surv)\n\nmulcox.geo <- summary(coxph(Surv(OS.time, OS) ~ ., data = geo.surv_complete))\nmulcox.geo <- data.frame(variable = rownames(mulcox.geo$conf.int),\n                         HR = mulcox.geo$conf.int[,1],\n                         lower.95CI = mulcox.geo$conf.int[,3],\n                         upper.95CI = mulcox.geo$conf.int[,4],\n                         p = mulcox.geo$coefficients[,5],\n                         stringsAsFactors = F)\nrownames(mulcox.geo) <- NULL\nhead(mulcox.geo) # 该死，这个riskscore在测试集里不是独立预后因素，但nobody cares，继续画图\n# Damn it, this riskscore is not an independent prognostic factor in the test set, but nobody cares, keep plotting\n绘制森林图\nDraw a Forest Map\n注意！因为HR值太大了，画出来很丑，所以我把轴状的HR取了对数，此时log2(HR)范围在[-Inf,\nInf]，参考值为0（对应HR为1无意义的时候） Attention! Because the HR value\nis too large and looks ugly when drawn, I took the logarithm of the\naxially shaped HR. At this time, the log2(HR) range is [-Inf, Inf], and\nthe reference value is 0 (corresponding to when HR is 1 and\nmeaningless).\n取对数画图的做法，可参考我最新发表在Cell\nProliferation上的文章中的Figure 2B （RNA processing genes characterize\nRNA splicing and further stratify colorectal cancer）\nhttps://onlinelibrary.wiley.com/doi/full/10.1111/cpr.12861\nThe method of drawing graphs by taking logarithms You may refer to\nFigure 2B in my latest article published in Cell Proliferation (RNA\nprocessing genes characterize RNA splicing and further stratify\nColorectal cancer) <\nhttps://onlinelibrary.wiley.com/doi/full/10.1111/cpr.12861\nhrtable <- rbind(c(\"TCGA\",NA,NA,NA,NA),\n                 mulcox.tcga,\n                 c(\"GSE39582\",NA,NA,NA,NA),\n                 mulcox.geo)\ntabletext <- cbind(c(\"Variable\",hrtable$variable),\n                   c(\"HR\",format(round(as.numeric(hrtable$HR),3),nsmall = 3)),\n                   c(\"lower 95%CI\",format(round(as.numeric(hrtable$lower.95CI),3),nsmall = 3)),\n                   c(\"upper 95%CI\",format(round(as.numeric(hrtable$upper.95CI),3),nsmall = 3)),\n                   c(\"pvalue\",formatC(as.numeric(hrtable$p), format = \"e\", digits = 2)))\ntabletext\nnrow(tabletext) + 1 #把这个数字写入hrzl_lines参数的第四行   # Write this number to the fourth line of the hrzl_lines parameter\n# 按需设置，因为注意到第二行的NA变成了字符串，因此会显示在最终的森林图里，这里改为NA\n# Set as needed. Since it was noticed that the \"NA\" in the second line has become a string, it will be displayed in the final forest diagram. Here, it is changed to \"NA\"\ntabletext[2,] <- c(\"TCGA\",NA,NA,NA,NA) \n# 按需设置，因为注意到第九行的NA变成了字符串，因此会显示在最终的森林图里，这里改为NA\n# Set as needed. Since it was noticed that the \"NA\" in the ninth line has become a string, it will be displayed in the final forest diagram. Here, it is changed to \"NA\"\ntabletext[9,] <- c(\"GSE39582\",NA,NA,NA,NA) \n\npdf(\"forestplot of risk table.pdf\", width = 8, height = 5)\nforestplot(labeltext=tabletext,\n           mean=c(NA,log2(as.numeric(hrtable$HR))),#log2(HR)\n           lower=c(NA,log2(as.numeric(hrtable$lower.95CI))), #log2(95%置信区间下限)  #log2(Lower Limit of the 95% confidence interval)\n           upper=c(NA,log2(as.numeric(hrtable$upper.95CI))),#log2(95%置信区间上限)  #log2(upper limit of the 95% confidence interval)\n           graph.pos=6,#图在表中的列位置  # The column positions of the figure in the table\n           graphwidth = unit(.25,\"npc\"),#图在表中的宽度比  # the width ratio of the graph in the table\n           fn.ci_norm=\"fpDrawDiamondCI\",#box类型选择钻石   #select diamond as the box type\n           col=fpColors(box=\"#00A896\", lines=\"#02C39A\", zero = \"black\"),#box颜色  #box colors\n           boxsize=0.4,#box大小固定  #box size is fixed\n           lwd.ci=1,\n           ci.vertices.height = 0.1,ci.vertices=F,#不显示区间  # does not display intervals\n           zero=0,#zero线横坐标  #zero is the x-coordinate of the line\n           lwd.zero=2,#zero线宽  #zero line width\n           xticks = c(-1,0,1,2,3,4,5),#横坐标刻度根据需要可随意设置  # horizontal coordinate scale can be set freely as needed\n           lwd.xaxis=2,\n           xlab=expression(\"log\"[2]~\"HR\"),\n           hrzl_lines=list(\"1\" = gpar(lwd=2, col=\"black\"),#第二行顶部加黑实线  #Add a black solid line at the top of the second line\n                           \"2\" = gpar(lwd=1, col=\"grey50\", lty=2),#第二行顶部加灰色虚线  # add a gray dotted line at the top of the second line\n                           \"9\" = gpar(lwd=1, col=\"grey50\", lty=2),#第九行顶部加灰色虚线  # add a gray dotted line at the top of the ninth line\n                           \"16\" = gpar(lwd=2, col=\"black\")),#最后一行底部加黑线，\"\"中数字为nrow(tabletext) + 1  # with a black line at the bottom of the last line, and the number in \"\" is nrow(tabletext) + 1\n           txt_gp=fpTxtGp(label=gpar(cex=1.2),#各种字体大小设置  # Various font size Settings\n                          ticks=gpar(cex=0.85),\n                          xlab=gpar(cex=1),\n                          title=gpar(cex=1.5)),\n           lineheight = unit(.75,\"cm\"),#固定行高  # Fixed row height\n           colgap = unit(0.3,\"cm\"),\n           mar=unit(rep(1.5, times = 4), \"cm\"),\n           new_page = F\n)\ninvisible(dev.off())\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa193RiskTable_FigureYa193RiskTable",
      "title": "FigureYa193RiskTable/FigureYa193RiskTable.html",
      "html": "FigureYa193RiskTable/FigureYa193RiskTable.html",
      "text": "texts/main_FigureYa193RiskTable_FigureYa193RiskTable.txt",
      "folder": "FigureYa193RiskTable",
      "thumb": "gallery_compress/FigureYa193RiskTable.webp"
    },
    "word_count": 1417,
    "lines_count": 293,
    "title": "FigureYa193RiskTable",
    "description": "Requirement 上半部分是TCGA数据，下半部分是用GEO数据集验证，riskscore用多因素cox或lasso都行。搞一个GEO验证集就好了，例文的两个GEO数据都是类似的，我们比葫芦画瓢。 The upper part is TCGA data, and the lower part is verified using the",
    "input_data_types": [
      "表达矩阵",
      "生存数据"
    ],
    "output_types": [
      "统计表格",
      "生存曲线"
    ],
    "technical_methods": [
      "标准化",
      "生存分析",
      "质量控制"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "pos",
      "label",
      "gene",
      "ticks",
      "times",
      "hrzl_lines",
      "header",
      "lwd",
      "width"
    ]
  },
  {
    "id": "main_FigureYa165heatmapPvalue_FigureYa165heatmapPvalue",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa165heatmapPvalue_FigureYa165heatmapPvalue.txt",
    "content": "FigureYa165heatmapPvalue\nFigureYa165heatmapPvalue\nAuthor(s)\n: Xiaofan Lu\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement Description\n热图展示亚型表达谱，并给出表达谱组间比较p值。 A heatmap displays\nsubtype expression profiles and provides p-values for intergroup\ncomparisons.\n出自\nhttps://www.frontiersin.org/articles/10.3389/fonc.2019.01038\nFrom\nhttps://www.frontiersin.org/articles/10.3389/fonc.2019.01038\nFigure 1. Expression of m6A RNA methylation regulators in gliomas\nwith different clinicopathological features. (A-D) The expression levels\nof thirteen m6A RNA methylation regulators in gliomas with different WHO\ngrades.\n应用场景\nApplication Scenario\n针对两组或多组样本，做组间差异检验，提供4种常用非参或参数检验法：\nTest for intergroup differences between two or more groups of samples.\nFour common nonparametric or parametric tests are provided:\n两组，参数检验”t.test”, 非参数检验”wilcox”\n多组，参数检验”anova”, 非参数检验”kruskal”\nFor two groups, use the parametric test “t.test” and the\nnonparametric test “wilcox”\nFor multiple groups, use the parametric test “anova” and the\nnonparametric test “kruskal”\n用热图展示亚型表达谱，并给出每个基因对应的表达谱组间比较p值。 Display\nsubtype expression profiles using a heatmap and provide p-values for\nintergroup comparisons of expression profiles for each gene.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nLoad the package\nlibrary(stringr)\nlibrary(pheatmap)\nlibrary(gplots)\nlibrary(grid)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # Display English error messages\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # Disable conversion of chr to factors\n加载自定义函数 Load a custom function\n# 显示进程\n# Display progress\ndisplay.progress = function (index, totalN, breakN=20) {\n  \n  if ( index %% ceiling(totalN/breakN)  ==0  ) {\n    cat(paste(round(index*100/totalN), \"% \", sep=\"\"))\n  }\n  \n} \n\n# 计算组间统计差异\n# Calculate statistical differences between groups\ncross_subtype_compr <- function(expr = NULL,\n                                subt = NULL,\n                                subt.label = \"Subtype\",\n                                two_sam_compr_method = \"wilcox\",\n                                multi_sam_compr_method = \"kruskal\",\n                                res.path = NULL) {\n  \n  if (!is.element(two_sam_compr_method, c(\"t.test\", \"wilcox\"))) {stop(\"Two samples comparison should be t.test or wilcox!\\n\") }\n  if (!is.element(multi_sam_compr_method, c(\"anova\", \"kruskal\"))) {stop(\"multiple samples comparison should be kruskal or anova!\\n\") }\n  \n  subt.name <- unique(subt[,subt.label])\n  n.subt <- length(subt.name)\n  if(n.subt < 2) {stop(\"The number of subtype should be greater than 2!\\n\")}\n  \n  comprTab <- NULL\n  \n  # 两个亚型且为非参数检验\n  # Two subtypes and a non-parametric test \n  if(n.subt == 2 & two_sam_compr_method == \"wilcox\") {\n    for (i in 1:nrow(expr)) {\n      display.progress(index = i,totalN = nrow(expr))\n      tmp1 <- as.numeric(expr[i,rownames(subt[which(subt[,subt.label] == subt.name[1]),,drop = F])])\n      tmp2 <- as.numeric(expr[i,rownames(subt[which(subt[,subt.label] == subt.name[2]),,drop = F])])\n      wt <- wilcox.test(tmp1,tmp2)\n      comprTab <- rbind.data.frame(comprTab,\n                                   data.frame(gene = rownames(expr)[i],\n                                              nominal.p.value = wt$p.value,\n                                              stringsAsFactors = F),\n                                   stringsAsFactors = F)\n    }\n  }\n  \n  # 两个亚型且为参数检验\n  # Two subtypes and a non-parametric test\n  if(n.subt == 2 & two_sam_compr_method == \"t.test\") {\n    for (i in 1:nrow(expr)) {\n      display.progress(index = i,totalN = nrow(expr))\n      tmp1 <- as.numeric(expr[i,rownames(subt[which(subt[,subt.label] == subt.name[1]),,drop = F])])\n      tmp2 <- as.numeric(expr[i,rownames(subt[which(subt[,subt.label] == subt.name[2]),,drop = F])])\n      tt <- t.test(tmp1,tmp2)\n      comprTab <- rbind.data.frame(comprTab,\n                                   data.frame(gene = rownames(expr)[i],\n                                              nominal.p.value = tt$p.value,\n                                              stringsAsFactors = F),\n                                   stringsAsFactors = F)\n    }\n  }\n  \n  # 多个亚型且为非参数检验\n  # Two subtypes and a parametric test \n  if(n.subt > 2 & multi_sam_compr_method == \"kruskal\") {\n    for (i in 1:nrow(expr)) {\n      display.progress(index = i,totalN = nrow(expr))\n      tmp.list <- list()\n      for (n in 1:n.subt) {\n        tmp.list[[n]] <- data.frame(value = as.numeric(expr[i,rownames(subt[which(subt[,subt.label] == subt.name[n]),,drop = F])]),\n                                    subt = subt.name[n],\n                                    stringsAsFactors = F)\n      }\n      tmp <- do.call(rbind,tmp.list)\n      kt <- kruskal.test(value ~ subt,data = tmp)\n      comprTab <- rbind.data.frame(comprTab,\n                                   data.frame(gene = rownames(expr)[i],\n                                              nominal.p.value = kt$p.value,\n                                              stringsAsFactors = F),\n                                   stringsAsFactors = F)\n    }\n  }\n  \n  # 多个亚型且为参数检验\n  # Multiple subtypes and non-parametric test \n  if(n.subt > 2 & multi_sam_compr_method == \"anova\") {\n    for (i in 1:nrow(expr)) {\n      display.progress(index = i,totalN = nrow(expr))\n      tmp.list <- list()\n      for (n in 1:n.subt) {\n        tmp.list[[n]] <- data.frame(value = as.numeric(expr[i,rownames(subt[which(subt[,subt.label] == subt.name[n]),,drop = F])]),\n                                    subt = subt.name[n],\n                                    stringsAsFactors = F)\n      }\n      tmp <- do.call(rbind,tmp.list)\n      at <- summary(aov(value ~ subt,data = tmp))\n      comprTab <- rbind.data.frame(comprTab,\n                                   data.frame(gene = rownames(expr)[i],\n                                              nominal.p.value = at[[1]][1,5],\n                                              stringsAsFactors = F),\n                                   stringsAsFactors = F)\n    }\n  }\n  \n  # 调整p值\n  # Adjust p-value\n  comprTab$adjusted.p.value = p.adjust(comprTab$nominal.p.value,method = \"BH\")\n  # 按p值排序\n  # Sort by p-value\n  #comprTab <- comprTab[order(comprTab$adjusted.p.value, decreasing = F),] \n  \n  write.table(comprTab,file.path(res.path,\"comprTab.txt\"),sep = \"\\t\",row.names = F,quote = F)\n  return(comprTab)\n}\n输入文件\nInput File\n如果你自己的数据已经整理成easy_input\n文件的格式，就直接跳到“差异表达分析”。\nIf your data has already been organized into easy_input\nfile\nformat, skip directly to “Differential Expression Analysis.”\n输入文件的下载\nDownload Input File\n基因表达矩阵，CGGA.mRNA_array_301_gene_level.20191128.txt，每行一个基因，每列一个sample。从CGGA下载：\nExpression\nData (gene level)\n，解压； Gene expression matrix,\nCGGA.mRNA_array_301_gene_level.20191128.txt, one gene per row, one\nsample per column. Download\nExpression\nData (gene level)\nfrom CGGA and unzip it.\n分组信息，CGGA.mRNA_array_301_clinical.20191128.txt，至少包含CGGA_ID和Grade两列，这里用Grade为LGG和GBM分组。从CGGA下载：\nClinical\nData\n，解压； Grouping information,\nCGGA.mRNA_array_301_clinical.20191128.txt, contains at least two\ncolumns: CGGA_ID and Grade. Here, Grade is used to group LGG and GBM.\nDownload\nClinical\nData\nfrom CGGA and unzip.\n读取基因表达矩阵\nRead the gene expression matrix\n#exp_data <- read.table(\"CGGA.mRNA_array_301_gene_level.20191128.txt\", header=T, row.names=1, sep=\"\\t\")\n# 为方便传输，只保留小数点后1位\n# For ease of transmission, only one decimal place is retained.\n#write.csv(round(exp_data,1), \"easy_input_expr_ori.csv\", quote = F)\nexp_data <- read.csv(\"easy_input_expr_all.csv\", row.names = 1)\nexp_data[1:3,1:3]\n读取分组信息\nRead group information\n用到两列：CGGA_ID和Grade Use two columns: CGGA_ID and Grade\nclinical_data <- read.table(\"CGGA.mRNA_array_301_clinical.20191128.txt\", header=T, sep=\"\\t\")\nclinical_data <- clinical_data[!is.na(clinical_data$Grade), ]\nclinical_data[1,]\nSubtype <- data.frame(Subtype = clinical_data$Grade)\nrow.names(Subtype) <- clinical_data$CGGA_ID\n# 保存到文件，便于模仿格式\n# Save to a file for easy formatting\nwrite.csv(Subtype, \"easy_input_group.csv\", quote = F)\n提取感兴趣的基因的表达矩阵\nExtract the expression matrix of the gene of interest\n# 读取基因名\n# Read gene name\nmygene <- read.table(\"easy_input_gene.txt\")$V1\n\n# 获取感兴趣的基因表达谱\n# Obtain expression profile of the gene of interest\nmygene_data <- exp_data[mygene, ]\nmygene_data[1:5, 1:5]\n# 保存到文件\nwrite.csv(mygene_data, \"easy_input_expr.csv\", quote = F)\n差异表达分析\nDifferential expression analysis\n# 用全部基因来画\n# Plot all genes\nn.show_top_gene <- nrow(mygene_data)\n# 或者取top 20个基因来画\n# Or plot the top 20 genes\n#n.show_top_gene <- 20 \n\n# 按分组排序\n# Sort by group\nsubt.order <- Subtype[order(Subtype$Subtype),,drop = F]\nindata <- mygene_data[comprTab$gene[1:n.show_top_gene],rownames(subt.order)]\n开始画图\nStart plotting\n# 数据标准化和边界设置\n# Normalize data and set boundaries\nplotdata <- t(scale(t(indata)))\nplotdata[plotdata > 2] <- 2\nplotdata[plotdata < -2] <- -2\n\n# 调整行名\n# Adjust row names\nblank <- \"    \" # 行名和p值之间的间隔 # Spacing between row names and p-values\np.value <- comprTab$adjusted.p.value[1:n.show_top_gene]\nsig.label <- ifelse(p.value < 0.001,\"****\",\n                    ifelse(p.value < 0.005,\"***\",\n                           ifelse(p.value < 0.01,\"**\",\n                                  ifelse(p.value < 0.05,\"*\",\"\"))))\np.label <- formatC(p.value, # 将p值变成保留两位小数的科学计数法 # Convert p-values to scientific notation with two decimal places\n                   format = \"e\",\n                   digits = 2)\n\nadd.label <- str_pad(paste0(rownames(plotdata),sig.label), # 固定行名宽度并再右侧补齐\" \"\n# Fix row name width and pad to the right. \" \"\n                     max(nchar(paste0(rownames(plotdata),sig.label))), \n                     side = \"right\")\n\nannCol <- subt.order # 获得排序后的亚型注释信息，这里只有一个变量需要注释\n# Get the sorted subtype annotation information. Here, only one variable needs to be annotated.\ncolnames(annCol)[1] <- paste(str_pad(colnames(annCol)[1], # 注释列名补上\"P-value\"，宽度和刚才一致\n# Add \"P-value\" to the annotation column name. The width is the same as before.\n                                     max(nchar(paste0(rownames(plotdata),sig.label))), \n                                     side = \"right\"),\n                             \"P-value\",\n                             sep = blank)\n\nannColors <- list(c(\"WHO II\"=\"lightblue\", \"WHO III\"=\"darkgreen\", \"WHO IV\"=\"pink\")) # 如果有多个变量要注释颜色请补充c() # If there are multiple variables to be annotated with color, please add c()\nnames(annColors) <- colnames(annCol)[1] # 如果有多个变量要注释颜色请补充每张list的name\n# If there are multiple variables to be annotated with color, please add the name of each list\n\n# 绘制热图\n# Draw a heat map\npheatmap(cellheight = 15, cellwidth = 1,\n         mat = plotdata, # 输入数据 # Input data\n         scale = \"none\", # 不标准化因为数据已经被标准化 # Not normalized because the data has been normalized\n         annotation_col = annCol, # 列注释信息 # column annotation information\n         annotation_colors = annColors, # 列注释对应的颜色 # color corresponding to column annotations\n         cluster_cols = F, # 列不聚类 # columns are not clustered\n         cluster_rows = F, # 行不聚类 # rows are not clustered\n         show_colnames = F, # 不显示列名 # do not display column names\n         show_rownames = T, # 显示基因名 # display gene names\n         #annotation_legend = F, # 不显示图例 # do not display legends\n         labels_row = paste(add.label, p.label, sep=blank), # 自定义样本名义blank作间隔 # custom sample name blank as interval\n         fontfamily = \"mono\", # 关键，使用fixed font而不是proportional font # key, use fixed font instead of proportional font\n         gaps_col = c(173), # 根据自己的数据设置空白间隔的位置 # set the position of the blank interval according to your own data\n         filename = \"heatmapPvalue.pdf\")\n后期处理\nPost-Processing\n输出的pdf文件是矢量图，可使用Illustrator等矢量图工具打开，仿照例文将各个亚型的名字添加在annotation\nbar的上方。 The output PDF file is a vector image. You can open it in a\nvector graphics tool like Illustrator and add the names of each subtype\nabove the annotation bar, following the example text.\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa165heatmapPvalue_FigureYa165heatmapPvalue",
      "title": "FigureYa165heatmapPvalue/FigureYa165heatmapPvalue.html",
      "html": "FigureYa165heatmapPvalue/FigureYa165heatmapPvalue.html",
      "text": "texts/main_FigureYa165heatmapPvalue_FigureYa165heatmapPvalue.txt",
      "folder": "FigureYa165heatmapPvalue",
      "thumb": "gallery_compress/FigureYa165heatmapPvalue.webp"
    },
    "word_count": 1268,
    "lines_count": 299,
    "title": "FigureYa165heatmapPvalue",
    "description": "Requirement Description 热图展示亚型表达谱，并给出表达谱组间比较p值。 A heatmap displays subtype expression profiles and provides p-values for intergroup",
    "input_data_types": [
      "临床数据",
      "表达矩阵"
    ],
    "output_types": [
      "火山图",
      "热图",
      "统计表格"
    ],
    "technical_methods": [
      "聚类分析",
      "生存分析",
      "标准化",
      "差异表达分析"
    ],
    "biology_areas": [],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "gene",
      "annotation_col",
      "header",
      "cluster_cols",
      "multi_sam_compr_method",
      "side",
      "cellwidth",
      "breakN"
    ]
  },
  {
    "id": "main_FigureYa194pySCENIC_FigureYa194pySCENIC",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa194pySCENIC_FigureYa194pySCENIC.txt",
    "content": "FigureYa194pySCENIC\nFigureYa194pySCENIC\nAuthor(s)\n: Jianing Gao\nDate\n: 2025-09-22\n需求描述\n这是一篇用SCENIC挖掘公共数据的文章，Figure2特别值得学习一下。\n上次FigureYa177RNAvelocity直播讲解时，小伙伴提出想请作者Jarning分享一下SCENIC的用法和经验。于是，邀请Jarning再次出马，建立专属讨论群，并开直播讲解，带小伙伴顺利用上SCENIC。\n出自\nhttps://linkinghub.elsevier.com/retrieve/pii/S2211124718316346\nFigure 2. Cell-Type-Specific Regulon Activity Analysis (A–D)\nErythroblast. (A) Rank for regulons in erythroblast cell based on\nregulon specificity score (RSS). (B) Erythroblast cells are highlighted\nin the t-SNE map (red dots). (C) Binarized regulon activity scores (RAS)\n(do Z score normalization across all samples, and set 2.5 as cutoff to\nconvert to 0 and 1) for top regulon Lmo2 on t-SNE map (dark green dots).\n(D) SEEK co-expression result for target genes of top regulon Lmo2 in\ndifferent GEO datasets. The x axis represents different datasets, and\nthe y axis represents the co-expression significance of target genes in\neach dataset. Erythroblast related datasets with significant correlation\n(p value < 0.01) are highlighted by yellow dots. (E–H) Same as\n(A)–(D) but for B cells. (I–L) Same as (A)–(D) but for oligodendrocytes.\n(M–P) Same as (A)–(D) but for alveolar type II cells.\n应用场景\n用单细胞转录组测序数据构建转录调控网络，鉴定cell-state。\n目前SCENIC支持\nhuman\n,\nmouse\nand\nfly\n(Drosophila melanogaster)这三个物种。\n下面开始复现文章中的Figure 1、2、3\n环境设置\n作者在发出文章的时候，pySCENIC还没有开发完成，作者应该是使用R-SCENIC分析的，R-SCENIC的性能远不如pySCENIC\n(a tenfold increase in\nspeed)，尤其是对于大数据集。故本教程以pySCENIC为主。\n官方参考资料：\nhttps://github.com/aertslab/pySCENIC\nhttps://www.nature.com/articles/s41596-020-0336-2\nSCENIC R\n见\nscripts/s0_createEnv.Rmd\nPySCENIC\n见\ncreateEnv\n输入文件\n所有文件已上传至百度云\nhttps://pan.baidu.com/s/1xtVejwVP8iiRJ4EqtfNpKA\n，提取码：tpf9\n下载后把本文档跟其他文件放在同一目录下即可。\n下载\n细胞注释\n和\n基因表达矩阵\n解压\nMCA_Figure2batchremoved.txt.tar.gz\n重新压缩为gz文件(节省硬盘空间)\ntar zxvf MCA_Figure2batchremoved.txt.tar.gz\ngzip Figure2-batch-removed.txt\n\n## 提取矩阵列名\nzcat Figure2-batch-removed.txt.gz | head -1 | tr \"\\t\" \"\\n\" | sed 's/\\\"//g' > Figure2-batch-removed.header.txt\nMCA_Figure2_Cell.Info.xlsx\n中有3个sheet，只有前两个对我们有用\n将\nMCA_Fig2_Cell\n中的内容复制到\nCell.Info.txt\n文件中\n将MCA_Fig2_Celltype中的内容复制到\nCellType.Info.txt\n文件中\n此时data目录下的文件组织如下：\n.\n├── cisTarget_databases\n│   ...\n├── data\n│   ├── Cell.Info.txt\n│   ├── CellType.Info.txt\n│   ├── Figure2-batch-removed.txt.gz\n│   ├── Figure2-batch-removed.header.txt\n│   └── test\n│       ...\n└── scripts\n    ...\nMCA2Avg20\n用SCENIC\nR对数据进行预处理，过滤掉不在\ncisTarget database\n有记录的基因，\n从MCA单细胞转录组数据自动随机生成Avg20，\n最后用\nSCopeLoomR\n将基因表达矩阵保存为loom文件。\ns1_subsampling.Rmd\nbrief intro: 定义了AvgN()函数，将基因表达矩阵(row=genes,\ncol=cells)变成pooling后的基因表达矩阵(row=genes,\ncol=Avg20-cells)。此外，将基因表达矩阵转变为loom格式（作为pySCENIC\nAUCell的输入，用于计算RAS矩阵）。\ninput:\nCell.Info.txt\nCellType.Info.txt\nFigure2-batch-removed.txt.gz\n(基因表达矩阵，行为基因，列为细胞)\nFigure2-batch-removed.header.txt\noutput：\ns1_avg20_rep1.loom\ns1_avg20_rep2.loom\ns1_avg20_rep3.loom\ns1_exprMat.loom\nSCENIC分析\nSCENIC的分析流程包括三个步骤：\nstep1 (GENIE3/GRNBoost)\n，通过基因共表达分析，建立基因共表达网络。\nstep2 (RcisTarget)\n，根据基因共表达网络，建立可能的TF-target调控关系。通过motif分析，建立其TF-target的直接调控关系。这样对每个TF，我们可能会找到若干个直接下游，这些基因我们将之命名为\nregulon\n。\n目前SCENIC只支持转录正调控分析。\nstep3 (AUCell)\n，基于step2的结果，对每个细胞计算regulon\nactivity score (RAS)。\nSCENIC有R（SCENIC）和python（pySCENIC）两种实现方式。pySCENIC相对于SCENIC(R)更快。\n我们后续的所有分析都基于pySCENIC\n。\npySCENIC的\nInput\n为\n行为gene symbols，列为cell\nID的基因表达矩阵\n。基因表达矩阵可以是UMI counts, normalized UMI\ncounts, TPM以及logged UMI counts。作者认为\n矩阵的正则化与否以及正则化的方式\n对SCENIC的结果影响不大。\ns2_cmd.sh\ns2_runPySCENIC.sh\nbrief intro:\n分别执行pySCENIC的三个步骤，\ngrnboost2\n、\nctx\n、\naucell\ngrnboost2\ninput:\ns1_avg20_rep1.loom\nreference:\nmm_mgi_tfs.txt\noutput：\ns2_avg20_rep1.adj.tsv\n（基因共表达网络的邻接矩阵）\nctx (cisTarget)\ninput:\ns2_avg20_rep1.adj.tsv\ns1_avg20_rep1.loom\nreference:\nmotifs-v9-nr.mgi-m0.001-o0.0.tbl\nmm10__refseq-r80__10kb_up_and_down_tss.mc9nr.feather\nmm10__refseq-r80__500bp_up_and_100bp_down_tss.mc9nr.feather\n注：后两个文件可以二选一，或者可以一块使用\noutput:\ns2_avg20_rep1.reg.tsv\n（记录了regulon的信息）\naucell\ninput:\ns1_exprMat.loom\ns2_avg20_rep1.reg.tsv\noutput:\ns2_avg20_rep1.pyscenic.loom\n利用RAS矩阵对单细胞数据进行降维\npySCENIC的结果解读\nscripts/s3_postSCENIC.py\nbrief intro: 解析pySCENIC的结果。\ninput\ns2_avg20_rep1.pyscenic.loom\ns2_avg20_rep1.reg.tsv\noutput\ns3_avg20_rep1.regulons.txt\ns3_avg20_rep1.regulons.gmt\n（gmt文件可以直接作为GSVA的输入，可以在bulk\nRNA-seq data中进一步探索单细胞数据的结论）\ns3_avg20_rep1.AUCell.txt\n（RAS矩阵）\ns3_avg20_rep1.auc_thresholds.txt\n（binary阈值）\ns3_avg20_rep1.binary_mtx.txt\n（binary RAS矩阵）\ns3_avg20_rep1.tsne.txt\n（利用RAS矩阵对细胞进行tSNE\nembedding)\ns3_avg20_rep1.umap.txt\n（利用RAS矩阵对细胞进行UMAP\nembedding)\nscripts/s3_postSCENIC.sh\nscripts/s4_Figure1.Rmd\n可视化pySCENIC的结果，绘制文章的Figure1 (1B, 1C 1D)\n计算Cell type specific regulon\nscripts/s5_Figure2.Rmd\n计算RSS(Regulon specific score)\nmatrix，寻找特定细胞特异的regulon，并利用SEEK进行验证。绘制文章的Figure2。\n如何用SEEK对cell\nspecific regulon进行验证\nCombinatorial Regulon Modules\nscripts/s6_Figure3.Rmd\n计算CSI（Connection Specificity Index）\nmatrix，基于CSI对regulon进行层次聚类，绘制Figure3A中的Heatmap。此外基于聚类结果，定义regulon\nmodule，得到regulon module和regulon的关系。对每个细胞计算regulon modeul\nactivity score（average RAS on regulons in each\nmodule）。对不同的cellType计算average regulon module activity\nscore的均值，寻找regulon module和Cell type的对应关系。\nscripts/s7_TFMotif.Rmd\n在\nJASPAR数据库\n中下载给定转录因子的motif矩阵，绘制motif\nlogo\nAI中精修Figure3A\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa194pySCENIC_FigureYa194pySCENIC",
      "title": "FigureYa194pySCENIC/FigureYa194pySCENIC.html",
      "html": "FigureYa194pySCENIC/FigureYa194pySCENIC.html",
      "text": "texts/main_FigureYa194pySCENIC_FigureYa194pySCENIC.txt",
      "folder": "FigureYa194pySCENIC",
      "thumb": "gallery_compress/FigureYa194pySCENIC.webp"
    },
    "word_count": 436,
    "lines_count": 220,
    "title": "FigureYa194pySCENIC",
    "description": "这是一篇用SCENIC挖掘公共数据的文章，Figure2特别值得学习一下。 上次FigureYa177RNAvelocity直播讲解时，小伙伴提出想请作者Jarning分享一下SCENIC的用法和经验。于是，邀请Jarning再次出马，建立专属讨论群，并开直播讲解，带小伙伴顺利用上SCENIC。 出自",
    "input_data_types": [
      "单细胞",
      "表达矩阵",
      "RNA-seq"
    ],
    "output_types": [
      "散点图",
      "热图",
      "PCA图",
      "网络图"
    ],
    "technical_methods": [
      "聚类分析",
      "标准化",
      "motif分析"
    ],
    "biology_areas": [],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "col",
      "row",
      "threshold"
    ]
  },
  {
    "id": "main_FigureYa14circos_FigureYa14circos",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa14circos_FigureYa14circos.txt",
    "content": "FigureYa14circos.Rmd\nFigureYa14Circos\nZhaodong Hao; Ying Ge, Yijing Chen\n2025-05-20\n需求描述\nrequirement description\n用Circos画出paper里的圆圈图，包括GC含量、gene密度、RPKM、SNP等。\nUse Circos to draw a circle plot from the paper, including GC content, gene density, RPKM, SNP, etc.\n如果要画直的染色体，可参考FigureYa10chromosome\nhttps://k.youshop10.com/k5BQBSoI\n，\n更多画染色体的工具看这里：\nhttps://mp.weixin.qq.com/s/M-W277k-h6zFJT-8fqekmA\nTo draw straight chromosomes, see FigureYa10chromosome\nhttps://k.youshop10.com/k5BQBSoI\n,\nSee here for more tools for drawing chromosomes:\nhttps://mp.weixin.qq.com/s/M-W277k-h6zFJT-8fqekmA\n应用场景\napplication scenario\n场景一\n：展示基因组上多条染色体、单条染色体、或多个基因上的特征。\n场景二\n：展示不同细胞类型或人群的特征。\n特征包括但不限于\n：GC含量差异、基因密度差异、基因表达量、染色质开放程度、DNA甲基化、SNP等等。\nScenario 1\n: demonstrate features on multiple chromosomes, a single chromosome, or multiple genes on a genome.\nScenario 2\n: demonstrate features on different cell types or populations.\nFeatures include, but are not limited to\n: GC content differences, gene density differences, gene expression, chromatin openness, DNA methylation, SNP, etc.\n运行环境的准备\nPreparation of the operating environment\n1. 安装perl\n1. Install perl\nCircos是用perl写成的，在装有perl的任何操作系统上都可以运行。\nMac和Linux系统自带perl；Windows系统需要到\nhttp://downloads.activestate.com/ActivePerl/releases/\n下载安装ActivePerl。\n注意\n：在终端（Terminal）运行Circos，不需要R。\nCircos is written in perl and run on any operating system with perl.\nMac and Linux systems come with perl; Windows systems need to download and install ActivePerl from\nhttp://downloads.activestate.com/ActivePerl/releases/\n.\nNOTE\n: Running Circos in the Terminal does not require R.\n2. 安装Circos\n2. Install Circos\n到\nhttp://circos.ca/software/download/circos/\n下载circos-0.69-6.tgz，解压缩到哪里就相当于安装到哪个文件夹了。\nGo to\nhttp://circos.ca/software/download/circos/\nto download circos-0.69-6.tgz, wherever you unzip it is equivalent to installing it in any folder.\n3. 安装perl模块（module）\n3. Install the perl module\n先在终端（Terminal）输入下面的命令\nFirst, enter the following command in the terminal\nxxxxxxxxxx\n.\n/\nbin\n/\ncircos\n-\nmodules\n运行结果像这样：\nThe result of the operation looks like this:\nok\n：电脑上已经有了哪些模块\nmissing\n：需要安装哪些模块\n然后在终端输入下面的命令，进入cpan\nok\n: which modules are already on the computer\nmissing\n: which modules need to be installed\nThen enter the following command in the terminal to enter cpan\nxxxxxxxxxx\nsudo\ncpan\n用cpan安装missing的module，在\n>\n后面输入install + module的名字\n安装完，在键盘上按下\nq\n+ 会车，就退出了cpan\nInstall the missing module with cpan by typing install + module name after\n>\n.\nAfter installing, press\nq\n+ enter on your keyboard to exit cpan.\nGD模块的安装方法\nInstallation method of GD module\n先安装GD所需的模块，下载链接\nhttps://www.jb51.net/os/RedHat/1286.html\n然后安装GD：\nhttp://www.zxzyl.com/archives/712\n在终端运行以下命令，就安装好了gd：\nFirst install the modules needed for GD, download link\nhttps://www.jb51.net/os/RedHat/1286.html\nThen install GD:\nhttp://www.zxzyl.com/archives/712\nRun the following command in the terminal, and gd is installed:\nxxxxxxxxxx\ncd\ngd\nsudo\n.\n/\ninstall\n来到circos-0.69-6的目录下，在终端（Terminal）输入下面的命令，检查一下是不是都是\nok\n了\nGo to the circos-0.69-6 directory and check that it's all\nok\nby typing the following command in Terminal\nxxxxxxxxxx\n/\nbin\n/\ncircos\n-\nmodules\n4. 测试\n4. Test\n进入circos-0.69-6/example目录，用测试数据做正对照，看看能否跑出图\nGo into the circos-0.69-6/example directory and use the test data as a positive control to see if you can run the graphs\nxxxxxxxxxx\ncd\ncircos\n-\n0.69\n-\n6\n/\nexample\n..\n/\nbin\n/\ncircos\n-\nconf\netc\n/\ncircos.conf\n会产生circos.svg和circos.png两个文件。\n打开circos.png，欣赏Circos的强大。\nTwo files, circos.svg and circos.png, will be generated.\nOpen circos.png and enjoy the power of Circos.\n最短的时间画出自己的图\nDraw your own diagram in the shortest time\n现在你已经装好了系统，只要按照以下四步操作，就可以直接跳到“开始画图”部分，用自己的数据画出文档开头那样的图：\n去circos-0.69-6/data/karyotype目录找你需要的物种，记住文件名；\n把Mydata文件夹放到circos-0.69-6主目录下，然后把Mydata/etc/circos.conf文件中的\nkaryotype.species.txt\n改成你需要的物种的文件名；\n打开circos-0.69-6/Mydata/etc/data/文件夹，挑你感兴趣的数据类型，看懂格式，用你自己的数据替换原有的数据。\n把circos-0.69-6/Mydata/etc/circos.conf文件中你不需要的数据对应的段落删掉。\nNow that you have installed the system, just follow the four steps below to jump directly to the “Start Drawing” section and use your own data to draw a diagram like the one at the beginning of the document:\nGo to the circos-0.69-6/data/karyotype directory and look for the species you need, remembering the filename;\nPut the Mydata folder in the circos-0.69-6 main directory, then change the\nkaryotype.species.txt\nin the Mydata/etc/circos.conf file to the filename of the species you need;\nOpen the circos-0.69-6/Mydata/etc/data/ folder, pick the type of data you're interested in, read the format, and replace the original data with your own.\nDelete the paragraphs in the circos-0.69-6/Mydata/etc/circos.conf file that correspond to the data you don't need.\n​\nx\n## track for GC content  #这是段落的开头 This is the beginning of the paragraph\n<\nplot\n>\nshow\n=\nconf\n(\nshow_lines\n)\ntype\n=\nline\nfile\n=\ndata\n/\nGC_content.txt\nthickness\n=\n1\ncolor\n=\n247\n,\n104\n,\n161\nmin\n=\n32\nmax\n=\n43\nr0\n=\n1.05\nr\nr1\n=\n1.08\nr\nfill_color\n=\n247\n,\n104\n,\n161\n</\nplot\n>\n#这是段落的结尾 This is the end of the paragraph\n下面开始按部就班的讲解各个文件是干啥用的，懒人可跳过，直接进入“开始画图”。\nBelow, we will explain step by step what each file is used for. If you are lazy, you can skip this and go directly to “Start Drawing.”\n需要准备的文件\nDocuments to be prepared\n需要三种文件：karyotype、配置文件和输入数据。\nThree types of files are required: karyotype, configuration file, and input data.\nkaryotype\ncircos-0.69-6/data/karyotype目录下已经有很多物种的karyotype文件。\n你也可以自己写karyotype文件，例如karyotype.species.txt，把它放到circos-0.69-6/data/karyotype目录下。\nThere are already many karyotype files for various species in the circos-0.69-6/data/karyotype directory.\nYou can also write your own karyotype files, such as karyotype.species.txt, and place them in the circos-0.69-6/data/karyotype directory.\nxxxxxxxxxx\nchr - Chr1 CHR1 0 118073833 chr1\nchr - Chr2 CHR2 0 98364873 chr2\nchr - Chr3 CHR3 0 207093695 chr3\nchr - Chr4 CHR4 0 50051714 chr4\nchr - Chr5 CHR5 0 45443526 chr5\nchr - Chr6 CHR6 0 35772468 chr6\nchr - Chr7 CHR7 0 28624509 chr7\nchr - Chr8 CHR8 0 195669025 chr8\nchr - Chr9 CHR9 0 55551413 chr9\n配置文件\nconfiguration file\n配置文件，也就是画图的参数，保存在circos-0.69-6/Mydata/etc/下面的*.conf文件中，其中circos.conf是必需的。\n整个图里的信息，例如圈要画多大、颜色、哪里有连线、哪里画曲线、哪里画柱形图、以及调用哪个文件里的数据，全靠conf文件来告诉Circos。\n复杂的图参数也多，于是，就把参数分门别类的保存在多个配置文件中。在circos.conf文件里统一通过\ninclude + conf文件名\n来调用其余的conf文件，因此其余conf的文件名在circos.conf文件中都能找到。\nThe configuration file, that is, the parameters of the drawing, are saved in the *.conf file below circos-0.69-6/Mydata/etc/, where circos.conf is required.\nAll the information in the graph, such as the size and color of the circles, where to draw lines, where to draw curves, where to draw bar charts, and which file to call for data, is communicated to Circos through the conf files.\nComplex diagrams have many parameters, so the parameters are categorized and stored in multiple configuration files. In the circos.conf file, all other conf files are called using\ninclude + conf filename\n, so the filenames of the other conf files can be found in the circos.conf file.\n注意\nNote\n你会发现：有些include后面跟了当前文件夹里不存在的conf文件。\nYou will find that some includes are followed by conf files that do not exist in the current folder.\nxxxxxxxxxx\n<<include etc/image.conf>>\n<<include etc/colors_fonts_patterns.conf>>\n<<include etc/housekeeping.conf>>\n这些是保存在circos-0.69-6/etc下面的配置文件，是必须导入的。\ncircos-0.69-6/etc下面的配置文件我们都不要改动。\n我们自己写的文件只保存在Mydata下面，随便你怎么改。\nThese are configuration files stored in circos-0.69-6/etc, which must be imported.\nDo not modify any configuration files in circos-0.69-6/etc.\nFiles you write yourself should only be stored in Mydata, and you can modify them as you like.\n读懂配置文件\nUnderstand configuration files\nCircos网站的tutorial教程很好用，\nhttp://circos.ca/documentation/tutorials/quick_start/\n，下面三个例子让你用3分钟get到配置文件怎么看：\nThe tutorial on the Circos website is very useful,\nhttp://circos.ca/documentation/tutorials/quick_start/\n. The following three examples will help you understand how to read the configuration file in three minutes:\n例子一：QUICK START中的1.Hellow World\nExample 1: 1.Hellow World in QUICK START\n点开看：\nhttp://circos.ca/documentation/tutorials/quick_start/hello_world/configuration\nCIRCOS.CONF负责告诉Circos，染色体要画多大（半径radius）、多粗（thickness）等等。\n只靠karyotype.human.txt和一个简单的配置文件CIRCOS.CONF，就画出了这样的一圈染色体：\nClick to view:\nhttp://circos.ca/documentation/tutorials/quick_start/hello_world/configuration\nCIRCOS.CONF tells Circos how large (radius) and how thick the chromosomes should be drawn.\nWith just karyotype.human.txt and a simple configuration file CIRCOS.CONF, a circle of chromosomes like this is drawn:\n例子二：QUICK START中的2.Ticks And Lables\nExample 2: 2. Ticks And Lables in QUICK START\n点开看：\nhttp://circos.ca/documentation/tutorials/quick_start/ticks_and_labels/configuration\n在segment（此处是染色体）上添加刻度和lable（标签，此处是染色体名），写在3个配置文件里：CIRCOS.CONF、IDEOGRAM.CONF（染色体和标签）、TICKS.CONF（刻度）。就画出了这样的一圈带刻度和标签的染色体：\nClick to view:\nhttp://circos.ca/documentation/tutorials/quick_start/ticks_and_labels/configuration\nAdd tick marks and labels (chromosome names) to the segment (chromosome), and write them in three configuration files: CIRCOS.CONF, IDEOGRAM.CONF (chromosomes and labels), and TICKS.CONF (tick marks). This will draw a circle of chromosomes with tick marks and labels:\n例子三：菜谱中的CELL CYCLE — PART 1\nExample 3: CELL CYCLE in the menu — PART 1\nCircos网站给出了很多现成的菜谱，\nhttp://circos.ca/documentation/tutorials/recipes/\nConfiguration里面都是搭配好的conf文件，复制粘贴到记事本里，保存成.conf为扩展名的文件。用户只要提供自己的数据（见后面的“输入数据”部分），就可以画出像菜谱中那样的图了。\n点开看\nhttp://circos.ca/documentation/tutorials/recipes/cell_cycle_part_1/configuration\n这个图复杂，配置文件也多：CIRCOS.CONF、IDEOGRAM.CONF、IDEOGRAM.LABEL.CONF、IDEOGRAM.POSITION.CONF、TICKS.CONF\nThe Circos website provides many ready-made recipes,\nhttp://circos.ca/documentation/tutorials/recipes/\nConfiguration is full of matched conf files, copied and pasted into Notepad, and saved as a file with the extension of .conf. Users only need to provide their own data (see the \"Input Data\" section later), and they can draw a diagram like in the recipe.\nClick to view\nhttp://circos.ca/documentation/tutorials/recipes/cell_cycle_part_1/configuration\nThis diagram is complex and has multiple configuration files: CIRCOS.CONF, IDEOGRAM.CONF, IDEOGRAM.LABEL.CONF, IDEOGRAM.POSITION.CONF, TICKS.CONF\n最实用的配置文件，自己paper里能用到\nThe most practical configuration file that can be used in your own paper\n本文档开头秀出的图就是用circos-0.69-6/Mydata/etc/文件夹里的三个conf画出的。\n可以用文本编辑器（例如Notepad++）查看、编辑。\n包括3个配置文件：\nideogram.conf，染色体想画成什么样\nticks.conf，染色体上的刻度和标签\ncircos.conf，我的输入数据文件以及另外两个配置文件都挂在这个circos.conf文件里，因此，后面画图时，只需要告诉Circos，circos.conf在哪里。\ncircos.conf的开头就定义好了这个圈里要画哪几种类型的图：\nThe figure shown at the beginning of this document was drawn using the three conf files in the circos-0.69-6/Mydata/etc/ folder.\nYou can view and edit them using a text editor (such as Notepad++).\nIncluding 3 configuration files:\nideogram.conf, which defines how the chromosomes are to be drawn\nticks.conf, which defines the tick marks and labels on the chromosomes\ncircos.conf, which contains my input data file and the other two configuration files. Therefore, when creating the diagram later, you only need to tell Circos where the circos.conf file is located.\nThe beginning of the circos.conf file defines the types of diagrams to be drawn within the circle:\nxxxxxxxxxx\nshow_links      = yes\nshow_heatmaps   = yes\nshow_lines      = yes\nshow_histograms = yes\n然后告诉Circos，karyotype文件在哪里，用哪个。\n接下来就是各个输入数据在圈上要展示成什么样子的具体参数，重点看\n#\n后面的注释，标出了重要参数的解释。\nThen tell Circos where the karyotype file is located and which one to use.\nNext is the specific parameters of what each input data should be displayed in the circle. Focus on the annotation after\n#\n, which marks the explanation of important parameters.\n输入数据\nInput data\n要在圈上展示的数据都保存到circos-0.69-6/Mydata/data文件夹下，想画几个圈就存几个文件。\nMydata文件夹放在Circos主目录下，跟circos-0.69-6/Mydata/etc/文件夹里的三个conf、以及karyotype.species.txt文件是一套的。\n第一列是片段（segment）ID，此处是染色体；\n第二列和第三列是片段上的起止位置，此处是碱基的位置；\n第四列是信号值，例如GC含量、基因表达量RPKM等。\nThe data to be displayed on the circle is saved to the circos-0.69-6/Mydata/data folder. If you want to draw a few circles, save a few files.\nThe Mydata folder is placed in the Circos main directory, which is a set with the three conf in the circos-0.69-6/Mydata/etc/ folder, and the karyotype.species.txt file.\nThe first column is the segment ID, which represents the chromosome;\nThe second and third columns are the start and end positions on the segment, which represent the base positions;\nThe fourth column is the signal value, such as GC content, gene expression level RPKM, etc.\nxxxxxxxxxx\nChr1    0   999999  39.07\nChr1    1000000 1999999 36.13\nChr1    2000000 2999999 38.18\nChr1    3000000 3999999 39.49\nChr1    4000000 4999999 37.42\nChr1    5000000 5999999 36.98\nChr1    6000000 6999999 38.2\nChr1    7000000 7999999 38.65\nChr1    8000000 8999999 39.18\nChr1    9000000 9999999 37.54\n开始画图\nStart drawing\n输入数据文件以及其他配置文件都挂在circos-0.69-6/Mydata/etc/circos.conf文件里，因此画图时，只需要告诉Circos，circos.conf在哪里。\n在终端里，进入Mydata目录，输入命令：\nThe input data file and other configuration files are stored in the circos-0.69-6/Mydata/etc/circos.conf file, so when drawing, you only need to tell Circos where circos.conf is located.\nIn the terminal, enter the Mydata directory and enter the command:\nxxxxxxxxxx\n../bin/circos -conf etc/circos.conf\n会在当前文件夹产生circos.svg和circos.png两个文件。\ncircos.svg是矢量图，可以用illustrator或inkscape打开、编辑、保存成pdf等文件。\nTwo files, circos.svg and circos.png, will be generated in the current folder.\ncircos.svg is a vector image that can be opened, edited, and saved as a PDF file using Illustrator or Inkscape.\nFigure legend通用格式\nFigure legend general format\nFigure 1\n*\n*(species name) genome overview.\na. GC content (30.86-40.82 per Mb). (b) Pseudomolecules of **. (c) TEs content (42.38-75.59% per Mb for heatmap) and TEs number (128-3266 per Mb for line). (d) Gene content (0-41.23% per Mb for heatmap) and gene number (0-53 per Mb for line). (e) Average expression state (reads per kilobase of exon per million sequences mapped, RPKM) for RKAM_3 (-0.19-2.48 per gene per Mb). (f) Average expression state for RKAM_2 (-0.11-4.06 per gene per Mb). (g) Average expression state for RKAM_1 (-0.08-4.22 per gene per Mb). (h) Heterozygous and homozygous SNPs identified by resequencing the sample_2. (i) Heterozygous and homozygous SNPs identified by resequencing the sample_1. (j) Synthetic blocks.\n画非染色体\nDraw non-chromosomes\n读懂了上面画染色体的配置文件和输入数据，就可以灵活运用Circos画各种各样的图了。\n无非是把karyotype和chromosome换成segment set和segment来理解，segment可以是染色体，也可以是基因、一种细胞系、一个人群。\nAfter reading the configuration file and input data of the chromosomes on it, you can flexibly use Circos to draw a variety of diagrams.\nSimply replace karyotype and chromosome with segment set and segment. A segment can be a chromosome, a gene, a cell line, or a population.",
    "chapter_info": {
      "id": "main_FigureYa14circos_FigureYa14circos",
      "title": "FigureYa14circos/FigureYa14circos.html",
      "html": "FigureYa14circos/FigureYa14circos.html",
      "text": "texts/main_FigureYa14circos_FigureYa14circos.txt",
      "folder": "FigureYa14circos",
      "thumb": "gallery_compress/FigureYa14circos.webp"
    },
    "word_count": 1806,
    "lines_count": 388,
    "title": "FigureYa14circos.Rmd",
    "description": "requirement description 用Circos画出paper里的圆圈图，包括GC含量、gene密度、RPKM、SNP等。 Use Circos to draw a circle plot from the paper, including GC content, gene density, RPKM, SNP, etc.",
    "input_data_types": [
      "DNA-seq"
    ],
    "output_types": [
      "热图"
    ],
    "technical_methods": [],
    "biology_areas": [],
    "complexity_level": "高级",
    "code_snippets": [],
    "key_parameters": [
      "min",
      "show_heatmaps",
      "show",
      "r0",
      "fill_color",
      "color",
      "show_lines",
      "thickness",
      "type",
      "show_histograms"
    ]
  },
  {
    "id": "main_FigureYa128Prognostic_FigureYa128Prognostic",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa128Prognostic_FigureYa128Prognostic.txt",
    "content": "FigureYa128Prognostic\nFigureYa128Prognostic\nAuthor(s)\n: Xiaofan Lu, Taojun Ye\nReviewer(s)\n: Ying Ge\nDate\n: 2025-09-30\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n文章中的那7个基因咋选出来的？\n出自\nhttps://clincancerres.aacrjournals.org/content/18/21/6001\n这里有文章解读：\nhttps://www.jianshu.com/p/58eab0d8ac22?from=singlemessage&isappinstalled=0\nRequirement description\nHow were the 7 genes selected in the article?\nFrom<\nhttps://clincancerres.aacrjournals.org/content/18/21/6001\n>\nHere is an article interpretation:<\nhttps://www.jianshu.com/p/58eab0d8ac22?from=singlemessage&isappinstalled=0\n>\n应用场景\n找marker基因。\n通过迭代LASSO产生“共识”下被保留的基因，进一步通过AUC选择与生存相关的最小基因组合。\n小伙伴跟作者间的问答记录：\n问：迭代lasso的原理是什么？\n答：lasso在允许的时候高度依赖种子，因为你需要交叉验证，而交叉验证的过程是随机选取样本的。所以一旦你更换了种子，最优lambda就会改变，最终得到的特征就会改变。共识就是在多次运行lasso（不依赖种子）后，那么高频次被保留下的特征，可以认为是对感兴趣话题最有影响的。因为如果我运行500次，A特征出现了300次，和B特征出现了30次，它们的重要程度肯定是不同的。不是选共同的，是对频次排序，这是我的理解。频次的顺序代表了这些特征的影响程度，然后依次把这些特征纳入cox模型，当AUROC达到峰值的时候停止纳入，此时模型最优，并且所含特征最少。\nApplication scenarios\nFind marker genes.\nBy iterating LASSO to generate genes that are retained under the\nconsensus, the minimum gene combination related to survival is further\nselected through AUC.\nQ&A record between the friend and the\nauthor:\nQ: What is the principle of iterating lasso?\nAnswer: lasso heavily relies on seeds when allowed, as you need cross\nvalidation, which involves randomly selecting samples. So once you\nchange the seed, the optimal lambda will change, and the final features\nobtained will change. Consensus is that after running lasso multiple\ntimes (without relying on seeds), the high-frequency features preserved\ncan be considered the most influential on the topic of interest. Because\nif I run it 500 times and feature A appears 300 times and feature B\nappears 30 times, their importance levels will definitely be different.\nIt’s not about choosing common ones, it’s about sorting by frequency,\nthat’s my understanding. The order of frequency represents the degree of\ninfluence of these features, and then these features are sequentially\nincluded in the Cox model. When the AUROC reaches its peak, the\ninclusion stops, and the model is optimal with the least number of\nfeatures.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nlibrary(survival)\nlibrary(survivalROC)\n# 设置环境语言为英文，确保报错信息为英文\n# Set environment language to English to ensure error messages are in English\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止字符串自动转换为因子，提高数据处理稳定性\n# Disable automatic conversion of strings to factors for more stable data processing\noptions(stringsAsFactors = FALSE)\n自定义函数\nCustom functions\n# 显示进程\n# Display progress\ndisplay.progress = function (index, totalN, breakN=20) {\n  # index: 当前迭代索引\n  # index: Current iteration index\n  # totalN: 总迭代次数\n  # totalN: Total number of iterations\n  # breakN: 控制进度显示的频率，将总次数分成breakN份显示\n  # breakN: Controls the frequency of progress display, divides total iterations into breakN parts\n  \n  if ( index %% ceiling(totalN/breakN)  ==0  ) {\n    # 当迭代次数达到指定间隔时显示进度百分比\n    # Display progress percentage when current iteration reaches specified interval\n    cat(paste(round(index*100/totalN), \"% \", sep=\"\"))\n  }\n}    \n\n# lasso回归\n# LASSO regression for survival analysis\nsurv_lasso <- function(iter.times = NULL, surv.obj = NULL, expr.obj = NULL, nfolds = 10, alpha = 1, family = \"cox\") {\n  # iter.times: pblapply的传入参数，用于迭代次数\n  # iter.times: Input parameter for pblapply, used for iteration count\n  # surv.obj: surv对象，由Surv()函数得到；\n  # surv.obj: Survival object created by Surv() function\n  # expr.obj: 表达谱对象，注意行为特征，列为样本\n  # expr.obj: Expression profile object, note rows are features, columns are samples\n  # nfolds：筛选最优lambda时的交叉验证次数，默认为10\n  # nfolds: Number of cross-validation folds for selecting optimal lambda, default is 10\n  # alpha： 默认为1表示LASSO回归\n  # alpha: Default is 1, representing LASSO regression\n  # family： 默认为\"cox\"\n  # family: Default is \"cox\" for Cox proportional hazards model\n\n  cvfit = cv.glmnet(x = t(as.matrix(expr.obj)), \n                    y = surv.obj, \n                    nfolds = nfolds, # 10折交叉验证选取最优lambda\n                    # 10-fold cross-validation to select optimal lambda\n                    alpha = alpha, # alpha = 1 意味着 lasso\n                    # alpha = 1 indicates LASSO regression\n                    family = family) # 依赖cox模型\n                    # Based on Cox proportional hazards model\n  \n  # 取出最优lambda对应的系数\n  # Extract coefficients corresponding to optimal lambda\n  myCoefs <- coef(cvfit, s=\"lambda.min\");\n  lasso_fea <- myCoefs@Dimnames[[1]][which(myCoefs != 0 )] \n  # Extract non-zero features (those retained by LASSO)\n  \n  return(lasso_fea)\n}\n输入文件的准备\n如果你的文件已经整理成easy_input_expr.csv和easy_input_cli.csv的格式，就可以跳过这步，直接进入“筛选基因”。\nPreparation of input files\nIf your file has already been organized into the formats of\neasy_input-expr.csv and easy_input_cli.csv, you can skip this step and\ngo directly to “Filter Genes”.\n输入文件的下载\n需要表达矩阵和带followup的临床数据。\nCOAD_TPM.txt，表达矩阵，这里用的是COAD的TPM。从XENA\npan-cancer表达数据中提取某种癌症的TPM的方法可参考FigureYa56Immune_inflitration；或者直接下载某个癌症的表达矩阵，方法可参考FigureYa23count2TPM、FigureYa34count2FPKMv2。\nclinical_PANCAN_patient_with_followup.tsv，带followup的临床信息，从这个页面下载\nhttps://gdc.cancer.gov/about-data/publications/PanCanStemness-2018\n，下载地址：\nhttps://api.gdc.cancer.gov/data/0fc78496-818b-4896-bd83-52db1f533c5c\nDownload of input files\nNeed to express matrix and clinical data with followup.\nCOAD_TPM.txt， The expression matrix used here is COAD’s TPM. The\nmethod for extracting TPM of a certain cancer from XENA pan cancer\nexpression data can refer to FigureYa56Immune_infliction; Alternatively,\nyou can directly download the expression matrix of a certain cancer\nusing the methods shown in FigureYa23count2TPM and\nFigureYa34count2FPKMv2.\nclinical_PANCAN_patient_with_followup.tsv， Download clinical\ninformation with follow up from this page<\nhttps://gdc.cancer.gov/about-data/publications/PanCanStemness-2018\n>Download link:<\nhttps://api.gdc.cancer.gov/data/0fc78496-818b-4896-bd83-52db1f533c5c\n>\n#读取表达矩阵\n# Read expression matrix\nexpr <- read.table(\"COAD_TPM.txt\",sep = \"\\t\",check.names = F,stringsAsFactors = F,header = T,row.names = 1)\n\n#根据TCGA的sample ID编码提取肿瘤样本\n# Extract tumor samples based on TCGA sample ID encoding\nexpr <- expr[,substr(colnames(expr),11,12) == \"01\"] \n# 01 indicates tumor samples\ncolnames(expr) <- substr(colnames(expr),1,9)  \n# Simplify sample names to first 9 characters\nexpr[1:3,1:3]\n#读取临床数据\n# Read clinical data\nSinfo <- read.table(\"clinical_PANCAN_patient_with_followup.tsv\",sep = \"\\t\",check.names = F,header = T,stringsAsFactors = F,quote = \"\")\nunique(Sinfo$acronym)  # 查看包含的癌症类型\n# Check included cancer types\nSinfo <- Sinfo[which(Sinfo$acronym %in% \"COAD\"),]  \n# Keep only colon adenocarcinoma (COAD) data\nrownames(Sinfo) <- paste0(\"COAD-\",substr(Sinfo$bcr_patient_barcode,9,12))  # 构建样本ID\n# Construct sample IDs\nSinfo[1:3,1:3]\ndim(Sinfo)\n输入数据预处理\n# 生存数据预处理（请根据自己的数据特点修改）###\n# Survival data preprocessing (modify according to your data characteristics) ###\nSinfo <- Sinfo[,c(\"vital_status\",\"days_to_death\",\"days_to_last_followup\")]  # 选取需要的生存相关列\n# Select survival-related columns\n\nSinfo$OS <- ifelse(Sinfo$vital_status == \"Dead\", 1,0)  # 将生存状态转换为二元数值变量(1=死亡,0=存活)\n# Convert vital status to binary variable (1=Dead, 0=Alive)\n\nSinfo$OS.time <- ifelse(grepl(\"Not\", Sinfo$days_to_death), Sinfo$days_to_last_followup, Sinfo$days_to_death)  # 根据两个变量生成最终生存时间\n# Generate overall survival time based on death or last follow-up time\n\nSinfo <- Sinfo[-grep(\"Dis\", Sinfo$OS.time), ]  # 移除包含无效生存时间的样本\n# Remove samples with invalid survival time\n\nSinfo$OS.time <- as.numeric(Sinfo$OS.time)  # 转换生存时间为数值型\n# Convert survival time to numeric type\n\nSinfo <- Sinfo[Sinfo$OS.time > 0,]  # 移除生存时间为0的无效样本\n# Remove samples with survival time <= 0\n\nSinfo[1:3,1:4]  # 查看处理后的数据前几行\n# 筛选既有表达矩阵又有随访信息的样本\n# Filter samples with both expression data and follow-up information\ncom_sam <- intersect(rownames(Sinfo),colnames(expr))  # 找出交集样本\n\n# 产生最终数据\n# Generate final datasets\nexpr <- expr[,com_sam]  # 筛选表达矩阵\n# Filter expression matrix\nSinfo <- Sinfo[com_sam,]  # 筛选临床数据\n# Filter clinical data\n\n#保存到文件\n# Save to files\nwrite.csv(round(expr, 1), \"easy_input_expr.csv\", quote = F)  # 保存表达矩阵，保留1位小数\n# Save expression matrix with 1 decimal place\nwrite.csv(Sinfo, \"easy_input_cli.csv\", quote = F)  # 保存临床数据\n# Save clinical data\n筛选基因\n# 读取预处理后的表达矩阵和临床数据\n# Read preprocessed expression matrix and clinical data\nexpr <- read.csv(\"easy_input_expr.csv\", check.names = F, row.names = 1)\nexpr[1:3,1:3]  # 查看数据前几行几列\nSinfo <- read.csv(\"easy_input_cli.csv\", check.names = F, row.names = 1)\nSinfo[1:3,1:3]  # 查看数据前几行几列\n# 过滤出方差>var.cutoff的基因\n# Filter genes with variance > var.cutoff\nvar.cutoff <- 5  # 例文中为GEO数据，阈值设为0.2\n# Example uses 0.2 for GEO data, here using 5 for TCGA data\nvar <- apply(expr, 1, sd)  # 计算每个基因的标准差\n# Calculate standard deviation for each gene\nexpr.filtered <- expr[var > var.cutoff,]  # 因为这里是TCGA数据，所以设置的大一些\n# Keep genes with variance exceeding cutoff\n\n# 过滤出与总生存(OS)有关的基因\n# Filter genes associated with overall survival (OS)\ncox.cutoff <- 0.1  # 例文中阈值设为0.5\n# Example uses 0.5, here using 0.1\nCoxoutput.OS <- NULL  # 初始化结果数据框\n# Initialize results data frame\n\n# 遍历筛选后的基因进行单变量Cox回归分析\n# Iterate through filtered genes for univariate Cox regression\nfor (i in 1:nrow(expr.filtered)) {\n  display.progress(index = i,totalN = nrow(expr.filtered))  # 显示进度\n  # Display progress\n  \n  # 产生临时变量存储生存以及变量表达值\n  # Create temporary data frame with gene expression and survival data\n  tmp <- data.frame(gene = as.numeric(expr.filtered[i,]),\n                    OS.time = Sinfo[,\"OS.time\"],\n                    OS = Sinfo[,\"OS\"],\n                    stringsAsFactors = F)\n  \n  # 单变量Cox比例风险模型\n  # Univariate Cox proportional hazards model\n  cox <- coxph(Surv(OS.time, OS) ~ gene, data = tmp)\n  coxSummary = summary(cox)\n  \n  # 生成Cox结果数据框，包括基因名，风险比，z值，Wald检验p值，以及HR置信区间\n  # Generate Cox results data frame with gene name, hazard ratio, z-value, p-value, and CI\n  Coxoutput.OS=rbind.data.frame(Coxoutput.OS,data.frame(gene=rownames(expr.filtered)[i],\n                                                        HR=as.numeric(coxSummary$coefficients[,\"exp(coef)\"]),\n                                                        z=as.numeric(coxSummary$coefficients[,\"z\"]),\n                                                        pvalue=as.numeric(coxSummary$coefficients[,\"Pr(>|z|)\"]),\n                                                        lower=as.numeric(coxSummary$conf.int[,3]),\n                                                        upper=as.numeric(coxSummary$conf.int[,4]),\n                                                        stringsAsFactors = F),\n                                stringsAsFactors = F)\n}\nwrite.table(Coxoutput.OS,\"Coxoutput.OS.txt\",sep = \"\\t\",row.names = F,quote = F)  # 保存结果\n\n### 根据cox.cutoff筛选基因\n### Filter genes by cox.cutoff p-value\nif(!identical(rownames(expr.filtered),Coxoutput.OS$gene)) {stop(\"Error! Gene name is mismatched!\\n\")}  # 确保基因名匹配\n# Ensure gene names match between expression matrix and Cox results\nsurv.expr <- expr.filtered[Coxoutput.OS$pvalue < cox.cutoff,]  # 筛选p值小于阈值的基因\n# Keep genes with p-value < cutoff\ndim(surv.expr)  # 查看筛选后的基因数量\n开始画图\n用base plot画图\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa128Prognostic_FigureYa128Prognostic",
      "title": "FigureYa128Prognostic/FigureYa128Prognostic.html",
      "html": "FigureYa128Prognostic/FigureYa128Prognostic.html",
      "text": "texts/main_FigureYa128Prognostic_FigureYa128Prognostic.txt",
      "folder": "FigureYa128Prognostic",
      "thumb": "gallery_compress/FigureYa128Prognostic.webp"
    },
    "word_count": 1255,
    "lines_count": 274,
    "title": "FigureYa128Prognostic",
    "description": "文章中的那7个基因咋选出来的？ 出自 https://clincancerres.aacrjournals.org/content/18/21/6001",
    "input_data_types": [
      "表达矩阵",
      "临床数据",
      "DNA-seq",
      "生存数据"
    ],
    "output_types": [
      "统计表格",
      "生存曲线"
    ],
    "technical_methods": [
      "生存分析"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "gene",
      "times",
      "header",
      "1",
      "pvalue",
      "breakN",
      "cvfit",
      "obj",
      "totalN"
    ]
  },
  {
    "id": "main_FigureYa124AssociationHeatmap_FigureYa124AssociationHeatmap",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa124AssociationHeatmap_FigureYa124AssociationHeatmap.txt",
    "content": "FigureYa124AssociationHeatmap\nFigureYa124AssociationHeatmap\nAuthor(s)\n: Xiaofan Lu, Taojun Ye\nReviewer(s)\n: Ying Ge\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n将感兴趣变量和亚型（分组）之间的独立性用“热图”方式展现出来。\nRequirement description\nPresent the independence between the variables of interest and\nsubtypes (groups) using a heatmap.\n出自\nhttps://www.cell.com/cell/fulltext/S0092-8674(17)30815-2\nfrom\nhttps://www.cell.com/cell/fulltext/S0092-8674(17)30815-2\nFigure S1. (B) Comparing tumor size, positive or negative serosal\ninvasion, and AJCC stage between F. nucleatum high-expression and\nlow-expression tumors of Cohort 2. The heatmap illustrates the\nassociation of different clinical characters with F. nucleatum high- and\nlow-expression tumors. Statistical significance was performed by\nChi-square test.\n应用场景\n已知分组的样本，想同时展示每个样本多个层面的特征，并标出两组间差异显著性P\nvalue。\n其实个人感觉，这样的“关系”图可以作为热图的Annotation\nbar，绘制起来简单方便，没有必要单独画出来。不过这张图还是蛮精美的，所以我还是采用base\nplot来和大家玩一玩这一张“热图”。\n注意：\n本人能力有限没有办法在这份代码的基础上尽可能多地考虑其他情况（输入数据类型），因此如果输入数据结构发生较大变化，代码本身需要做比较大的改动，代码的注释应该比较全面，希望大家在理解的基础上运行此代码，学习base\nplot的画图思路。\nApplication scenarios\nGiven the grouped samples, we want to display multiple levels of\nfeatures for each sample simultaneously and indicate the significant P\nvalue of the differences between the two groups.\nIn my personal opinion, such a “relationship” diagram can be used as\nan annotation bar for heat maps, which is simple and convenient to draw,\nand there is no need to draw it separately. However, this image is quite\nexquisite, so I will still use the base plot to play with everyone on\nthis’ heat map ’.\n**Attention: * * Due to my limited abilities, I am unable to consider\nas many other situations (input data types) as possible on the basis of\nthis code. Therefore, if there are significant changes in the input data\nstructure, the code itself needs to be significantly modified, and the\ncomments on the code should be comprehensive. I hope everyone can run\nthis code on the basis of understanding and learn the drawing ideas of\nbase plot.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\n# 设置系统环境语言为英文，用于显示英文报错信息\n# Set system environment language to English for displaying error messages in English\nSys.setenv(LANGUAGE = \"en\") \n\n# 配置选项，禁止将字符型向量自动转换为因子类型\n# Configure option to disable automatic conversion of character vectors to factors\noptions(stringsAsFactors = FALSE)\n输入文件\neasy_input.txt，每行一个样本，第一列为分组（被画在图的第一行），第二列往后是其他信息（被画在图的第二行以后），用yes和no记录。\nInput file\neasy_input.txt， Each row contains one sample, with the first column\nrepresenting the grouping (shown in the first row of the graph) and the\nsecond column followed by other information (shown in the second row of\nthe graph), recorded with ‘yes’ and’ no ’.\n# 从easy_input.txt文件读取表格数据\n# 分隔符设为制表符，禁止自动修正列名，禁止将字符串转为因子，指定包含表头行，不设置行名\n# Read tabular data from easy_input.txt file\n# Set delimiter as tab, disable automatic column name correction, disable string-to-factor conversion, specify header row, do not set row names\ndat <- read.table(\"easy_input.txt\",sep = \"\\t\",check.names = F,stringsAsFactors = F,header = T,row.names = NULL)\n\n# 查看数据集行数和列数\n# View the number of rows and columns in the dataset\nrows_cols <- dim(dat)\n\n# 查看数据集前几行，行数为数据集行数和6的较小值\n# View the first few rows of the dataset, with the number of rows being the smaller value between the dataset's row count and 6\nhead(dat, min(6, rows_cols[1]))\n# 查看数据集后几行，行数为数据集行数和6的较小值\n# View the last few rows of the dataset, with the number of rows being the smaller value between the dataset's row count and 6\ntail(dat, min(6, rows_cols[1]))\n独立性检验，计算P value，用于标注在图的右侧\nIndependence test, calculate P value, used for labeling on the right\nside of the graph\n# 初始化存储卡方检验p值的向量\n# Initialize vector to store p-values from chi-square tests\np.chisq <- c()\n\n# 对数据框从第3列至最后一列进行循环（第1列是亚型，第2列不参与独立性检验）\n# Loop through columns from 3 to the last column (skip first two columns)\nfor (i in 3:ncol(dat)) { \n  # 创建第1列(亚型)与当前列的列联表\n  # Create contingency table between subtype (col1) and current column\n  tmp <- table(dat[,1],dat[,i])\n  # 执行卡方检验并将p值保留3位小数后添加到结果向量\n  # Perform chi-square test and append p-value (rounded to 3 decimals) to results\n  p.chisq <- c(p.chisq,round(chisq.test(tmp)$p.value,3)) \n}\n\n# 查看前几个卡方检验结果\n# View the first few chi-square test results\nhead(p.chisq)\n# 生成右侧注释标签，根据检验结果格式化显示\n# Generate right-side annotation labels with formatted p-values\nann_labels <- paste0(c(\"AJCC stage(III)\", \"Tumor size (>15cm3)\",\"Penetration (Serosa)\"),\n                     \"\\nP\",ifelse(p.chisq < 0.001,\" < 0.001\",paste0(\" = \",p.chisq)))\n\n# 补全标签向量，第一列留空(由图例占据)，第二列指定为\"F.nucleatum\"\n# Complete label vector: first position NA (for legend), second for \"F.nucleatum\"\nann_labels <- c(NA,\"F.nucleatum\",ann_labels)\n开始画图\n下面感受一下用base plot像画笔一样画出图中的每一个元素：\nStart drawing\nHere’s how to use base plot to draw every element in the graph like a\npaintbrush:\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa124AssociationHeatmap_FigureYa124AssociationHeatmap",
      "title": "FigureYa124AssociationHeatmap/FigureYa124AssociationHeatmap.html",
      "html": "FigureYa124AssociationHeatmap/FigureYa124AssociationHeatmap.html",
      "text": "texts/main_FigureYa124AssociationHeatmap_FigureYa124AssociationHeatmap.txt",
      "folder": "FigureYa124AssociationHeatmap",
      "thumb": "gallery_compress/FigureYa124AssociationHeatmap.webp"
    },
    "word_count": 665,
    "lines_count": 123,
    "title": "FigureYa124AssociationHeatmap",
    "description": "将感兴趣变量和亚型（分组）之间的独立性用“热图”方式展现出来。 Requirement description Present the independence between the variables of interest and",
    "input_data_types": [
      "临床数据"
    ],
    "output_types": [
      "热图",
      "统计表格"
    ],
    "technical_methods": [],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "LANGUAGE",
      "stringsAsFactors",
      "header",
      "names"
    ]
  },
  {
    "id": "main_FigureYa156enrichSimulation_FigureYa156enrichSimulation",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa156enrichSimulation_FigureYa156enrichSimulation.txt",
    "content": "FigureYa156enrichSimulation\nFigureYa156enrichSimulation\nAuthor(s)\n: Zongcheng Li\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement\n作者前面找到两个cohort共有的58个差异表达RBPs，其中21个过表达跟预后差有关。\n那么，这21个RBPs是不是随机也能出现？有统计学意义吗？ The authors\npreviously identified 58 differentially expressed RBPs shared by two\ncohorts, 21 of which were overexpressed and associated with poor\nprognosis. Could these 21 RBPs have appeared randomly? Are they\nstatistically significant?\n重复文章中的这段方法，提供一个统计学上的结果，支持说他选择的基因集有生物学意义。\nRepeat the method in the article and provide statistical results to\nsupport the biological significance of the gene set they selected.\n出自\nhttps://link.springer.com/article/10.1186%2Fs13059-016-0990-4\nFrom\nhttps://link.springer.com/article/10.1186%2Fs13059-016-0990-4\n应用场景\nApplication Scenario\n通过（蒙特卡洛）随机模拟计算观测事件发生的经验性概率。 Calculate the\nempirical probability of an observed event through (Monte Carlo) random\nsimulation.\n该方法可以从统计学角度帮助判断观测事件是否为小概率事件。 This method\ncan help determine whether an observed event is a low-probability event\nfrom a statistical perspective.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(cgdsr)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # Display English error messages\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # Disable conversion of chr to factor\n输入文件\nInput File\nGet RBP genes\nget rbp gene list from\nGerstberger S, Hafner M, Tuschl T. A census of human RNA-binding proteins. Nat Rev Genet. 2014;15:829–45.\nhttps://www.nature.com/articles/nrg3813/#supplementary-information\nrbplist <- readxl::read_excel(path = \"nrg3813-s3.xls\", sheet = 2)\nUse CGDS-R to get Genetic Data (mutation and CNA)\n原文用CGDS-R包从cBioPortal下载数据，我们重复原文，体验一下CGDS-R包的用法。\nThe original article used the CGDS-R package to download data from\ncBioPortal. We will repeat the original article to experience the use of\nthe CGDS-R package.\n# Create CGDS object\nmycgds <- CGDS(\"https://www.cbioportal.org/\")\ntest(mycgds)\n\n# Get list of cancer studies at server\nlcs <- getCancerStudies(mycgds)\nView(lcs) #查看表格，找到你要的癌症，记下cancer_study_id，这里选gbm_tcga\n# View the table, find the cancer you want, and note the cancer_study_id. Here, select gbm_tcga\n# cancer_study_id: gbm_tcga\nmycancerstudy = \"gbm_tcga\"\n\ncl <- getCaseLists(mycgds, mycancerstudy)\nView(cl) #查看表格，找到你要的数据类型，记下case_list_id，这里选gbm_tcga_cnaseq\n# View the table, find the type of cancer you want, and note the case_list_id. Here, select \n# case_list_id: gbm_tcga_cnaseq. Samples with mutation and CNA data (273 samples)\nmycaselist <- \"gbm_tcga_cnaseq\"\n\n# Get available genetic profiles\ngp <- getGeneticProfiles(mycgds, mycancerstudy)\nmygeneticprofile1 <- \"gbm_tcga_gistic\"\nmygeneticprofile2 <- \"gbm_tcga_mutations\"\nmygeneticprofile3 <- \"gbm_tcga_linear_CNA\"\n\n# Get data slices for a specified list of genes, genetic profile and case list\n# 下载1542个基因有点多，我们拆成500个/次，然后用cbind合并\n# Downloading 1542 genes is a bit too much, so we split it into 500 slices and merge them using cbind\ngistic <- cbind(getProfileData(mycgds, rbplist$`gene name`[1:500], mygeneticprofile1, mycaselist),\n                getProfileData(mycgds, rbplist$`gene name`[501:1000], mygeneticprofile1, mycaselist),\n                getProfileData(mycgds, rbplist$`gene name`[1001:1542], mygeneticprofile1, mycaselist))\n\nmutation <- cbind(getProfileData(mycgds, rbplist$`gene name`[1:500], mygeneticprofile2, mycaselist),\n                  getProfileData(mycgds, rbplist$`gene name`[501:1000], mygeneticprofile2, mycaselist),\n                  getProfileData(mycgds, rbplist$`gene name`[1001:1542], mygeneticprofile2, mycaselist))\n\ncna <- cbind(getProfileData(mycgds, rbplist$`gene name`[1:500], mygeneticprofile3, mycaselist),\n             getProfileData(mycgds, rbplist$`gene name`[501:1000], mygeneticprofile3, mycaselist),\n             getProfileData(mycgds, rbplist$`gene name`[1001:1542], mygeneticprofile3, mycaselist))\n\nidentical(dimnames(gistic), dimnames(cna))\nidentical(dimnames(gistic), dimnames(mutation))\n#save(gistic, mutation, file = \"alteration_data.Rdata\")\n\n# Get clinical data for the case list\n# myclinicaldata = getClinicalData(mycgds,mycaselist)\n\n# documentation\n# help('cgdsr')\n# help('CGDS')\nThe 21 RBPs list\n作者前面找到两个cohort共有的58个差异表达RBPs，其中21个过表达跟预后差有关。接下来对这21个基因做统计检验。\nThe authors previously identified 58 differentially expressed RBPs\nshared by the two cohorts, of which 21 were overexpressed and associated\nwith poor prognosis. Next, we performed statistical tests on these 21\ngenes.\nCopy from Table 1\nCorrea et al. Genome Biology (2016) 17:125 DOI 10.1186/s13059-016-0990-4\nrbp21 <- strsplit(\"AIMP2 ALYREF CALR EXO1 ISG20 MAGOH MAGOHB MRPS12 MRPS33 NIP7 NXT1 OAS3 PPIH RBMS1 RNASEH2A RNASET2 RUVBL1 SNRPB SNRPG YBX3 XRN2\", split = \" \")[[1]]\n评价\nEvaluate\nDo simulation\n(load(\"alteration_data.Rdata\"))\nmutation_binary <- 0+!(mutation == \"NaN\" | is.na(mutation))\ngistic_binary <- 0+(abs(gistic) == 2)\n\nrbpall <- colnames(mutation)\n# repeat 100,000 times\nsimulations <- rep(0, 1e5)\nset.seed(666)\nfor(i in 1:1e5){\n  sim_genes <- sample(rbpall, size = length(rbp21), replace = F)\n  countAlteration_bysample <- sum((rowSums(mutation_binary[,sim_genes], na.rm = T) +\n                                  rowSums(gistic_binary[,sim_genes], na.rm = T)) > 0)\n  simulations[i] <- countAlteration_bysample\n}\nPlot empirical probability distribution\nhist(simulations, breaks = 100)\n\nsim_genes <- rbp21\ncountAlteration_bysample <- sum((rowSums(mutation_binary[,sim_genes], na.rm = T) +\n                                  rowSums(gistic_binary[,sim_genes], na.rm = T)) > 0)\nabline(v = countAlteration_bysample, col = 'red')\nCalculate Probability\nthe probability of less alterations occuring in the 21-RBPs than\nthose in randomly selected 21 RBPs\np <- sum(countAlteration_bysample > simulations)/length(simulations)\np\n结论：\nConclusion:\n大于0.05不是小概率事件，所以接受零假设。\n选的21个跟随机选取21基因没有统计学差异。\nA probability greater than 0.05 is not a small probability event, so\nthe null hypothesis is accepted.\nThere is no statistical difference between the 21 selected genes and\nthe randomly selected 21 genes.\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa156enrichSimulation_FigureYa156enrichSimulation",
      "title": "FigureYa156enrichSimulation/FigureYa156enrichSimulation.html",
      "html": "FigureYa156enrichSimulation/FigureYa156enrichSimulation.html",
      "text": "texts/main_FigureYa156enrichSimulation_FigureYa156enrichSimulation.txt",
      "folder": "FigureYa156enrichSimulation",
      "thumb": "gallery_compress/FigureYa156enrichSimulation.webp"
    },
    "word_count": 693,
    "lines_count": 152,
    "title": "FigureYa156enrichSimulation",
    "description": "Requirement 作者前面找到两个cohort共有的58个差异表达RBPs，其中21个过表达跟预后差有关。 那么，这21个RBPs是不是随机也能出现？有统计学意义吗？ The authors",
    "input_data_types": [
      "突变数据"
    ],
    "output_types": [
      "火山图",
      "统计表格"
    ],
    "technical_methods": [
      "差异表达分析"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "LANGUAGE",
      "stringsAsFactors",
      "col",
      "file",
      "myclinicaldata",
      "size",
      "replace",
      "rm",
      "mycancerstudy"
    ]
  },
  {
    "id": "main_FigureYa22FPKM2TPM_FigureYa22FPKM2TPM",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa22FPKM2TPM_FigureYa22FPKM2TPM.txt",
    "content": "FigureYa22 FPKM2TPM\nFigureYa22 FPKM2TPM\nAuthor(s)\n: Ying Ge; Yijing Chen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n把RNA-seq的FPKM转换成TPM。\nConvert FPKM from RNA-seq to TPM\n应用场景\nApplication scenario\nRNA-seq基因表达量是FPKM，想转变成TPM。不仅限于TCGA数据。\nFPKM跟TPM的计算都考虑了基因长度，因此相对于read\ncount转TPM来说，从FPKM转TPM最方便快捷。\n如果你需要从read count转TPM，请购买FigureYa23count2TPM；从read\ncount转FPKM，请购买FigureYa34count2FPKM。\nThe RNA-seq gene expression is in FPKM and needs to be converted to\nTPM. This is not limited to TCGA data.\nBoth FPKM and TPM calculations consider gene length, making the\nconversion from FPKM to TPM more convenient and faster than from read\ncount to TPM.\nIf you need to convert from read count to TPM, please purchase\nFigureYa23count2TPM; to convert from read count to FPKM, please purchase\nFigureYa34count2FPKM.\n下载TCGA RNA-seq的FPKM数据\nDownload FPKM data for TCGA RNA-seq\n此处以TCGA的数据为例。\n如果你自己的RNA-seq数据已经保存成\neasy_input.txt\n的格式，就跳过这步，直接进入“输入数据”\nThis is an example of TCGA data.\nIf you have saved your own RNA-seq data in\neasy_input.txt\nformat, skip this step and go directly to\n“Input data”.\nsource(\"install_dependencies.R\")\n#source(\"https://bioconductor.org/biocLite.R\")\n#biocLite(\"TCGAbiolinks\")\nlibrary(TCGAbiolinks)\nexpquery <- GDCquery(project = \"TCGA-LIHC\", \n                data.category = \"Transcriptome Profiling\",\n                data.type = \"Gene Expression Quantification\",\n                workflow.type = \"STAR - Counts\" \n                )\nGDCdownload(expquery)\nexpquery2 <- GDCprepare(expquery)\nexpMatrix <- TCGAanalyze_Preprocessing(expquery2)\n\n#运行下面这行，会把FPKM保存到文件里，用来做其他的分析。\n#running the following line will save the FPKM to a file to be used for additional analysis.\n#write.table(expMatrix, \"easy_input.txt\", sep=\"\\t\", quote=F, row.names=T)\n#此处为了发邮件方便，只保存前4个sample\n#Here, only the first 4 samples are saved for emailing convenience\nwrite.table(expMatrix[,1:4], \"easy_input.txt\", sep=\"\\t\", quote=F, row.names=T)\n输入数据\nInput data\n第一列是基因ID，第一行是sample ID。\n一个单元格内是一个基因在一个sample中的read count。\nThe first column is the gene ID and the first row is the sample\nID.\nInside a cell is the read count of a gene in a sample.\nexpMatrix<-read.table(\"easy_input.txt\",header = T,row.names = 1)\n#查看前三个基因的FPKM值\n#view FPKM values for the first three genes\nexpMatrix[1:3,]\nFPKM转TPM\nFPKM to TPM\nrsem作者Bo Li的文字描述：\nhttps://groups.google.com/forum/#!topic/rsem-users/uajT7gnTj-0\n将FPKM/RPKMs转换为TPMs非常简单。首先将所有基因的FPKM归一化，使其总和等于1，然后将每个归一化值乘以 1e6，即可得到TPMs。\n先写个函数，来源 ：\nhttps://haroldpimentel.wordpress.com/2014/05/08/what-the-fpkm-a-review-rna-seq-expression-units/\nText description by rsem author Bo Li:\nhttps://groups.google.com/forum/#!topic/rsem-users/uajT7gnTj-0\nIt is very easy to convert FPKM/RPKMs to TPMs. You first normalize your FPKMs from all genes so that their sum is equal to 1. Then you product 1e6 to each normalized value and you will obtain TPMs.\nWrite a function first , source :\nhttps://haroldpimentel.wordpress.com/2014/05/08/what-the-fpkm-a-review-rna-seq-expression-units/\nfpkmToTpm <- function(fpkm)\n{\n    exp(log(fpkm) - log(sum(fpkm)) + log(1e6))\n}\n计算TPM值，保存到tpms里\nCalculate TPM value, save to tpms\ntpms <- apply(expMatrix,2,fpkmToTpm)\n\n#查看前三个基因的TPM值\n#view TPM values for the first three genes\ntpms[1:3,]\n#检查一下，是不是每列的总和都是1\n#check to see if the sum of each column is 1\ncolSums(tpms)\n#把TPM值保存到文件\n#save TPM values to file\nwrite.table(tpms,\"TCGA_FPKM2TPM.genes.txt\",quote = F)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa22FPKM2TPM_FigureYa22FPKM2TPM",
      "title": "FigureYa22FPKM2TPM/FigureYa22FPKM2TPM.html",
      "html": "FigureYa22FPKM2TPM/FigureYa22FPKM2TPM.html",
      "text": "texts/main_FigureYa22FPKM2TPM_FigureYa22FPKM2TPM.txt",
      "folder": "FigureYa22FPKM2TPM",
      "thumb": "gallery_compress/FigureYa22FPKM2TPM.webp"
    },
    "word_count": 422,
    "lines_count": 104,
    "title": "FigureYa22 FPKM2TPM",
    "description": "Requirement description 把RNA-seq的FPKM转换成TPM。 Convert FPKM from RNA-seq to TPM",
    "input_data_types": [],
    "output_types": [
      "统计表格"
    ],
    "technical_methods": [],
    "biology_areas": [],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "quote",
      "header",
      "names",
      "type",
      "category",
      "project"
    ]
  },
  {
    "id": "main_FigureYa111markerGene_FigureYa111markerGene_step1",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa111markerGene_FigureYa111markerGene_step1.txt",
    "content": "FigureYa111markerGene_step1\nFigureYa111markerGene_step1\nZhougeng Xu, Taojun Ye\n2025-5-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n用Seurat找marker基因，用scanpy画出文章里这种热图，中间顺利衔接。\nRequirement description\nUse Seurat to find marker genes, and use scanpy to draw this heatmap\nin the article, smoothly connecting the middle.\n出自\nhttps://www.nature.com/articles/s41586-019-0933-9\nfrom\nhttps://www.nature.com/articles/s41586-019-0933-9\nFig. 2d, Heat map illustrating the row-normalized mean expression of\nmarker genes for each maturing gut cluster.\n应用场景\n本文档用Seurat进行单细胞上游分析，得到聚类信息和聚类注释信息，使用我写的函数保存结果，然后打开FigureYa111markerGene.ipynb文件，用Scanpy画美图。\n这里是前面用Seurat，后面只是用scanpy的画图功能。当然你也可以从头到尾都用Scanpy来做，这个不包含在本文档范围内。\nApplication scenarios\nThis document uses Seurat for single-cell upstream analysis to obtain\nclustering information and cluster annotation information. Use the\nfunction I wrote to save the results, then open the\nFigureYa111markerGene.ipynb file and draw a beautiful image using\nScanpy.\nHere, Seurat was used earlier, and only the drawing function of\nscanpy was used later. Of course, you can also use Scanpy from start to\nfinish, which is not included in the scope of this document.\n环境设置\n要求:\n操作系统: Windows10（内存64G)的运行环境是WSL，\nMacOS，Linux(Ubuntu/CentOS)，\n电脑内存: 最低8G， 推荐16G起步，上不封顶\n掌握shell的基本使用方法\n安装Seurat包\nEnvironment settings\nrequirement:\n-Operating System: The operating environment for Windows 10 (64GB of\nmemory) is WSN, MacOS, Linux (Ubuntu/CentOS), -Computer memory: minimum\n8GB, recommended starting at 16GB, with no upper limit -Master the basic\nusage of shell\nsource(\"install_dependencies.R\")\n# 加载dplyr包，提供数据处理和转换的函数\n# Load the dplyr package, which provides functions for data manipulation and transformation\nlibrary(dplyr)\n# 加载Seurat包，用于单细胞RNA测序数据分析\n# Load the Seurat package, which is used for single-cell RNA sequencing data analysis\nlibrary(Seurat)\n# 设置环境变量，使R显示英文错误信息，便于统一错误排查的语言\n# Set the environment variable to display error messages in English for consistency in troubleshooting\nSys.setenv(LANGUAGE = \"en\")\n\n# 设置选项，禁止将字符型变量自动转换为因子类型，避免意外的数据转换\n# Set an option to prevent automatic conversion of character variables to factors, \n# avoiding unexpected data type conversions\noptions(stringsAsFactors = FALSE)\n输入文件\n示例文件保存在当前文件夹下的filtered_gene_bc_matrices/hg19/文件夹里\nInput file\nThe example file is saved in the filtered_gene-bc_tricks/hg19/folder\nin the current folder\n# 从指定目录读取10X Genomics单细胞RNA测序数据\n# Read 10X Genomics single-cell RNA sequencing data from the specified directory\npbmc.data <- Read10X(data.dir = \"filtered_gene_bc_matrices/hg19/\")\n\n# 创建Seurat对象，这是单细胞数据分析的核心数据结构\n# Create a Seurat object, which is the core data structure for single-cell data analysis\npbmc <- CreateSeuratObject(\n  counts = pbmc.data,  # 输入的基因表达矩阵数据\n                      # Input gene expression matrix data\n  project = \"pbmc3k\",  # 项目名称，用于标识该数据集\n                      # Project name used to identify this dataset\n  min.cells = 3,       # 保留至少在3个细胞中表达的基因\n                      # Keep genes expressed in at least 3 cells\n  min.features = 200   # 保留至少检测到200个基因的细胞\n                      # Keep cells with at least 200 detected genes\n)\nSeurat聚类分析\n下面的步骤是常规的单细胞数据处理流程, 主要是将细胞进行聚类分析,\n从而知道每个细胞属于哪一类, 同时根据差异分析结果, 选择标记基因。\n数据预处理\nSeurat clustering analysis\nThe following steps are the conventional single-cell data processing\nflow, mainly clustering analysis of cells to determine which category\neach cell belongs to, and selecting marker genes based on the results of\ndifferential analysis.\nData preprocessing\n# 计算线粒体基因表达比例，线粒体高比例可能表示细胞质量不佳\n# Calculate the percentage of mitochondrial gene expression. High mitochondrial percentage may indicate poor cell quality\npbmc[[\"percent.mt\"]] <- PercentageFeatureSet(pbmc, pattern = \"^MT-\")\n# 基于特征基因数和线粒体基因比例过滤细胞，保留高质量细胞\n# Filter cells based on the number of detected features and mitochondrial gene percentage to retain high-quality cells\npbmc <- subset(pbmc, subset = nFeature_RNA > 200 &  # 保留检测到至少200个基因的细胞\n                              nFeature_RNA < 2500 &  # 排除检测到过多基因的可能为多核或破碎的细胞\n                              percent.mt < 5)        # 保留线粒体基因比例低于5%的细胞\n\n# 对基因表达数据进行归一化处理，默认使用LogNormalize方法\n# Normalize the gene expression data using the default LogNormalize method\npbmc <- NormalizeData(pbmc, \n                      normalization.method = \"LogNormalize\",  # 对数归一化方法\n                      scale.factor = 10000)                   # 缩放因子\n# 识别高变基因，这些基因在细胞间差异表达，对聚类和细胞类型鉴定很重要\n# Identify highly variable genes, which show significant expression differences between cells and are crucial for clustering and cell type identification\npbmc <- FindVariableFeatures(pbmc, \n                             selection.method = \"vst\",  # 使用方差稳定变换方法\n                             nfeatures = 2000)         # 保留前2000个高变基因\n\n# 获取所有基因名称，用于后续数据缩放\n# Get all gene names for subsequent data scaling\nall.genes <- rownames(pbmc)\n\n# 对所有基因表达数据进行缩放，使不同基因间具有可比性\n# Scale the expression data of all genes to make them comparable across different genes\npbmc <- ScaleData(pbmc, features = all.genes)\n# 执行主成分分析(PCA)降维，使用之前识别的高变基因\n# Perform principal component analysis (PCA) dimensionality reduction using the previously identified highly variable genes\npbmc <- RunPCA(pbmc, features = VariableFeatures(object = pbmc))\n# 构建细胞间的K近邻图，基于前10个主成分计算细胞相似性\n# Construct a K-nearest neighbor graph based on the first 10 principal components to compute cell-cell similarities\npbmc <- FindNeighbors(pbmc, dims = 1:10)\n聚类分析\ncluster analysis\n# 基于之前构建的K近邻图对细胞进行聚类，识别具有相似表达模式的细胞群体\n# Cluster cells based on the previously constructed K-nearest neighbor graph to identify cell populations with similar expression patterns\npbmc <- FindClusters(pbmc, \n                    resolution = 0.5)  # 聚类分辨率参数，值越大产生的聚类越多\n# Clustering resolution parameter; higher values result in more clusters\n定义cluster\nDefine cluster\n# 创建新的聚类ID名称向量，用于将聚类结果注释为具体的细胞类型\n# Create a vector of new cluster ID names to annotate clustering results with specific cell types\nnew.cluster.ids <- c(\"Naive CD4 T\",       # 初始CD4阳性T细胞\n                     \"Memory CD4 T\",      # 记忆CD4阳性T细胞\n                     \"CD14+ Mono\",        # CD14阳性单核细胞\n                     \"B\",                 # B细胞\n                     \"CD8 T\",             # CD8阳性T细胞\n                     \"FCGR3A+ Mono\",      # FCGR3A阳性单核细胞\n                     \"NK\",                # 自然杀伤细胞\n                     \"DC\",                # 树突状细胞\n                     \"Platelet\")          # 血小板\n\n# 将新的聚类ID名称与当前聚类水平一一对应\n# Map the new cluster ID names to the current cluster levels\nnames(new.cluster.ids) <- levels(pbmc)\n\n# 重命名Seurat对象中的聚类标识，使用新的细胞类型名称替换原聚类ID\n# Rename the cluster identities in the Seurat object with the new cell type names\npbmc <- RenameIdents(pbmc, new.cluster.ids)\n这里可以接UMAP看聚类结果，关于UMAP的安装和详细用法，可参考FigureYa93UMAP。\nHere, UMAP can be connected to view the clustering results. For\ninstallation and detailed usage of UMAP, please refer to\nFigureYa93UMAP.\npbmc <- RunUMAP(pbmc, dims = 1:10)\nDimPlot(pbmc, reduction = \"umap\", label = T)\n开始画图\n用Seurat展示标记基因\nStart drawing\nDisplay marker genes using Seurat\n定义基因\nDefine genes\n# 定义标记基因向量，用于后续的细胞类型鉴定和可视化\n# Define a vector of marker genes for subsequent cell type identification and visualization\nmarker_gene <- c(\n  \"IL7R\", \"CCR7\",       # Naive CD4 T细胞的标记基因（初始CD4+ T细胞）\n                    # Marker genes for Naive CD4 T cells (naive CD4+ T cells)\n  \"S100A4\",            # Memory CD4 T细胞的标记基因（记忆CD4+ T细胞）\n                    # Marker gene for Memory CD4 T cells (memory CD4+ T cells)\n  \"CD14\", \"LYZ\",       # CD14+ Mono细胞的标记基因（CD14+单核细胞）\n                    # Marker genes for CD14+ Mono cells (CD14+ monocytes)\n  \"MS4A1\",             # B细胞的标记基因\n                    # Marker gene for B cells\n  \"CD8A\",              # CD8 T细胞的标记基因（CD8+ T细胞）\n                    # Marker gene for CD8 T cells (CD8+ T cells)\n  \"FCGR3A\", \"MS4A7\",   # FCGR3A+ Mono细胞的标记基因（FCGR3A+单核细胞）\n                    # Marker genes for FCGR3A+ Mono cells (FCGR3A+ monocytes)\n  \"GNLY\", \"NKG7\",      # NK细胞的标记基因（自然杀伤细胞）\n                    # Marker genes for NK cells (natural killer cells)\n  \"FCER1A\", \"CST3\",    # DC细胞的标记基因（树突状细胞）\n                    # Marker genes for DC cells (dendritic cells)\n  \"PPBP\"               # Platelet细胞的标记基因（血小板）\n                    # Marker gene for Platelet cells (platelets)\n)\n热图\nHeat map\n# 绘制热图展示标记基因在不同细胞聚类中的表达模式\n# Generate a heatmap to visualize the expression patterns of marker genes across different cell clusters\nDoHeatmap(pbmc, \n          features = marker_gene)  # 指定要展示的特征基因为之前定义的标记基因向量\n# Specify the features to plot using the previously defined marker gene vector\n小提琴图\nViolin Diagram\n# 绘制小提琴图展示IL7R和CCR7基因在各细胞聚类中的表达分布\n# Generate violin plots to show the expression distribution of IL7R and CCR7 genes across cell clusters\nVlnPlot(pbmc, \n        features = marker_gene[1:2])  # 选取marker_gene向量中的前两个基因(IL7R和CCR7)\n# Select the first two genes (IL7R and CCR7) from the marker_gene vector\n除了这两种，还能不能有更加好看的展现方式？\nScanpy提供了许多种好看的展示方式，见\nhttps://scanpy-tutorials.readthedocs.io/en/latest/visualizing-marker-genes.html\n那么如何将Seruat的结果和Scanpy进行结合呢？我们首先需要把结果输出到文件，然后用Scanpy画美图。\n输出Seurat结果\nSeurat的表达量数据存放在\n@assays$RNA\n下,\ncounts: TPM或者UMI信息, 最初的输入信息\ndata: 标准化结果\nscale.data: scale后的数据\nSeurat的细胞的各种元信息在\n@meta.data\n下\nSeurat定义后细胞类型的数据在\n@active.ident\n下,\n我写了一个函数\nseurat2scanpy\n,\n将上面信息保存在同一个文件夹下\nCan there be a more visually appealing way of presenting besides\nthese two?\nScanpy provides many visually appealing display options, see<\nhttps://scanpy-tutorials.readthedocs.io/en/latest/visualizing-marker-genes.html\n>\nSo how to combine the results of Seruat with Scanpy? We first need to\noutput the results to a file, and then use Scanpy to draw beautiful\nimages.\nOutput Seurat results\nThe expression level data of Seurat is stored under ‘@ assay\n$RNA’,\n-Counts: TPM or UMI information, initial input information -Data:\nStandardized results -Scale.data: scaled data\nThe various meta information of Seurat’s cells can be found under ‘@\nmeta. data’\nThe data of cell types defined by Seurat can be found under ‘@\nactive. dent’,\nI wrote a function called ‘seurat2scanpy’ and saved the above\ninformation in the same folder\n# 导入自定义函数脚本，该脚本包含将Seurat对象转换为Scanpy兼容格式的功能\n# Source a custom function script that contains functions to convert Seurat objects to Scanpy-compatible formats\nsource(\"seurat2scanpy.R\")\n\n# 调用seurat2scanpy函数将处理好的pbmc Seurat对象转换为AnnData格式\n# 以便后续使用Scanpy(Python)进行下游分析，如轨迹推断、RNA速度等\n# Convert the processed Seurat object 'pbmc' into AnnData format\n# for downstream analysis using Scanpy (Python), such as trajectory inference or RNA velocity analysis\nseurat2scanpy(x = pbmc)  # x = 需要转换的Seurat对象\n                         # x = Seurat object to be converted\n后续的操作在Jupyter notebook进行。你需要：\n下载并安装Anaconda发行版，\nhttps://www.anaconda.com/distribution/#download-section\n用Jupyter\nnotebook打开FigureYa111markerGene_step2_linuxMAC.ipynb或FigureYa111markerGene_step2_win10.ipynb文档继续画图。\nipynb文档的用法参考这篇：\nhttps://mp.weixin.qq.com/s/G-CQhNEJBmMRuDe2kxND_w\n参考资料\nhttps://scanpy.readthedocs.io/\nThe subsequent operations will be carried out in the Jupyter\nnotebook. You need:\n-Download and install the Anaconda distribution,\nhttps://www.anaconda.com/distribution/#download\n-section\n-Open the FigureYa111markerGene_step2.nuxmAC.ipynb or\nFigureYa111markerGene_step2w_in10.ipynb document with Jupyter notebook\nto continue drawing. -The usage of the ipynb document can be found in\nthis article:\nhttps://mp.weixin.qq.com/s/G-CQhNEJBmMRuDe2kxND_w\nReference materials\n<\nhttps://scanpy.readthedocs.io/\n>\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa111markerGene_FigureYa111markerGene_step1",
      "title": "FigureYa111markerGene/FigureYa111markerGene_step1.html",
      "html": "FigureYa111markerGene/FigureYa111markerGene_step1.html",
      "text": "texts/main_FigureYa111markerGene_FigureYa111markerGene_step1.txt",
      "folder": "FigureYa111markerGene",
      "thumb": "gallery_compress/FigureYa111markerGene.webp"
    },
    "word_count": 1352,
    "lines_count": 277,
    "title": "FigureYa111markerGene_step1",
    "description": "用Seurat找marker基因，用scanpy画出文章里这种热图，中间顺利衔接。 Requirement description Use Seurat to find marker genes, and use scanpy to draw this heatmap",
    "input_data_types": [
      "表达矩阵",
      "单细胞"
    ],
    "output_types": [
      "箱线图",
      "火山图",
      "热图",
      "PCA图"
    ],
    "technical_methods": [
      "聚类分析",
      "标准化",
      "主成分分析",
      "差异表达分析",
      "质量控制"
    ],
    "biology_areas": [],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "LANGUAGE",
      "dims",
      "stringsAsFactors",
      "label",
      "method",
      "subset",
      "x",
      "dir",
      "nfeatures"
    ]
  },
  {
    "id": "main_FigureYa78gganatogram_FigureYa78gganatogram",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa78gganatogram_FigureYa78gganatogram.txt",
    "content": "FigureYa78gganatogram\nFigureYa78gganatogram\nYing Ge, Taojun Ye\n2025-5-20\n需求描述\n用FigureYa55panCancer输出的基因在TCGA +\nGTEx的表达量TPM值（easy_input.csv文件）作为输入，用gganatogram画出感兴趣的基因在各个器官里的表达分布。\n##Requirement description\nUse the TPM values of the expression levels of the genes output by\nFigureYa55panCancer in TCGA+GTEx (easy_input. csv file) as input, and\nplot the expression distribution of the genes of interest in various\norgans using gganatogram.\n应用场景\ngganatogramR包介绍：\nhttps://github.com/jespermaag/gganatogram\n，\nhttps://mp.weixin.qq.com/s/BlRT8I0RB1o-Mi4TEWhFrQ\n文章里类似的图举例：\nhttps://mp.weixin.qq.com/s/Uc6syOjFTOduxZfVaZRPqw\n在小丫画图公众号回复“器官”，查看更多介绍。\n##Application scenarios\nIntroduction to the GGanatoramR package:<\nhttps://github.com/jespermaag/gganatogram\n>，<\nhttps://mp.weixin.qq.com/s/BlRT8I0RB1o-Mi4TEWhFrQ\n>\nExamples of similar images in the article:<\nhttps://mp.weixin.qq.com/s/Uc6syOjFTOduxZfVaZRPqw\n>\nReply to “organ” on Xiaoya Pictorial official account for more\ninformation.\n环境设置\n##Environment settings\n# 安装gganatogram包（从GitHub安装，当前行被注释掉） | Install the gganatogram package (from GitHub, current line is commented out)\n#devtools::install_github(\"jespermaag/gganatogram\")\n\n# 加载gganatogram包，用于绘制器官图 | Load the gganatogram package for plotting anatomical diagrams\nlibrary(gganatogram)\n# 加载stringr包，提供字符串处理函数 | Load the stringr package for string manipulation functions\nlibrary(stringr)\n\n# 加载gridExtra包，用于组合多个图形 | Load the gridExtra package for arranging multiple plots\nlibrary(gridExtra)\n\n# 设置环境语言为英文，使报错信息显示为英文 | Set the environment language to English to display error messages in English\nSys.setenv(LANGUAGE = \"en\")\n\n# 禁止将字符向量自动转换为因子类型 | Disable automatic conversion of character vectors to factors\noptions(stringsAsFactors = FALSE)\n输入文件预处理\n如果你的数据已经整理成very_easy_input.csv的格式，就可以跳过这步，进入“开始画图”。\n此处以FigureYa55panCancer输出的的基因在TCGA +\nGTEx的表达量TPM值（easy_input.csv文件）为例，需要把TCGA的癌症名称跟包里的organ对应上。\n参照GEPIA help的Differential analysis：\nhttp://gepia.cancer-pku.cn/help.html\n，在此基础上添加gganatogram包的organ，整理成TCGA_organ.txt文件，欢迎来小丫画图群里探讨这些对应关系。\n##Input file preprocessing\nIf your data has already been organized into the format of very easy\ninput. csv, you can skip this step and enter “Start Drawing”.\nTaking the TPM value of gene expression in TCGA+GTEx output from\nFigureYa55panCancer as an example (easy_input. csv file), it is\nnecessary to match the cancer name in TCGA with the ‘organ’ in the\npackage.\nRefer to GEPIA help’s differential analysis:<\nhttp://gepia.cancer-pku.cn/help.html\n>On this basis,\nadd the GAN of the gganatogram package and organize it into a\nTCGA_organ. txt file. Welcome to explore these corresponding\nrelationships in the Xiaoya drawing group.\n# 读取包含TCGA和GTEx的肿瘤(tumor)和正常(normal)样本TPM值的CSV文件 | Read CSV file containing TPM values for TCGA and GTEx tumor/normal samples\ndf <- read.csv(\"easy_input.csv\", row.names = 1)\n\n# 查看数据前几行，确认数据结构 | View the first few rows to confirm data structure\nhead(df)\n# 创建组合列，格式为\"组织_样本类型\" | Create a combined column in format \"tissue_sampleType\"\ndf$tt <- paste(df$tissue, df$type2, sep = \"_\")\n\n# 按组合列分组，计算TPM值的中位数 | Group by combined column and calculate median TPM values\ndf.median <- aggregate(.~tt, df[,3:4], median)\n\n# 从组合列中提取TCGA癌症缩写 | Extract TCGA cancer abbreviations from combined column\ndf.median$TCGA <- str_split_fixed(df.median$tt, \"_\",2)[,1]\n\n# 从组合列中提取样本类型 | Extract sample type from combined column\ndf.median$type <- str_split_fixed(df.median$tt, \"_\",2)[,2]\n\n# 删除临时组合列 | Remove temporary combined column\ndf.median$tt <- NULL\n\n### 将TCGA癌症缩写映射为gganatogram包中的器官名称\n# 已根据背景知识整理映射关系至TCGA_organ文件\n# 名称翻译来源：https://cn.bing.com/translator\nTCGA.organ <- read.table(\"TCGA_organ.txt\", sep = \"\\t\", header = T)\n\n# 查看映射表关键列 | View key columns of the mapping table\nTCGA.organ[,c(1:2,4)]\n# 合并映射表与中位数数据，关联TCGA缩写与器官名称 | Merge mapping table with median data to link TCGA abbreviations to organs\nTCGA.organ.tpm <- merge(TCGA.organ[,c(1,4)], df.median, by = \"TCGA\")\n\n# 删除TCGA缩写列，不再需要 | Remove TCGA abbreviation column, no longer needed\nTCGA.organ.tpm$TCGA <- NULL\n\n# 过滤掉器官名称为空的行 | Filter out rows with empty organ names\nTCGA.organ.tpm <- TCGA.organ.tpm[TCGA.organ.tpm$organ != \"\",]\n\n# 准备男性器官图谱数据\n# 合并男性器官模板与TPM数据 | Merge male organ template with TPM data\nhgMale_key_tpm <- merge(hgMale_key, TCGA.organ.tpm, by = \"organ\")\n\n# 用TPM值替换模板中的value列，用于图谱着色 | Replace template's value column with TPM values for coloring\nhgMale_key_tpm$value <- hgMale_key_tpm$tpm\n\n# 删除原始TPM列 | Remove original TPM column\nhgMale_key_tpm$tpm <- NULL\n\n# 导出男性图谱输入文件 | Export input file for male organogram\nwrite.csv(hgMale_key_tpm,\"very_easy_input_Male.csv\", quote = F, row.names = F)\n\n# 准备女性器官图谱数据\n# 合并女性器官模板与TPM数据 | Merge female organ template with TPM data\nhgFemale_key_tpm <- merge(hgFemale_key, TCGA.organ.tpm, by = \"organ\")\n\n# 用TPM值替换模板中的value列，用于图谱着色 | Replace template's value column with TPM values for coloring\nhgFemale_key_tpm$value <- hgFemale_key_tpm$tpm\n\n# 删除原始TPM列 | Remove original TPM column\nhgFemale_key_tpm$tpm <- NULL\n\n# 导出女性图谱输入文件 | Export input file for female organogram\nwrite.csv(hgFemale_key_tpm,\"very_easy_input_Female.csv\", quote = F, row.names = F)\n附：\n查看gganatogram包里的organ：\n**Attachment: * * View the organ in the gganatoram package:\n# 查看男性人体器官图谱支持的器官列表 | View organs supported in the male human organogram\nhgMale_key$organ\n# 查看女性人体器官图谱支持的器官列表（当前行被注释） | View organs supported in the female human organogram (current line is commented)\n#hgFemale_key$organ\n\n# 找出男性特有、女性没有的器官 | Find organs specific to males (not present in females)\nsetdiff(hgMale_key$organ, hgFemale_key$organ)\n# 查看雄性小鼠器官图谱支持的器官列表（当前行被注释） | View organs supported in the male mouse organogram (current line is commented)\n#mmMale_key$organ\n\n# 查看雌性小鼠器官图谱支持的器官列表（当前行被注释） | View organs supported in the female mouse organogram (current line is commented)\n#mmFemale_key$organ\n\n# 查看细胞图谱支持的\"器官\"（亚细胞结构）列表（当前行被注释） | View \"organs\" (subcellular structures) supported in the cell organogram (current line is commented)\n#cell_key[['cell']]$organ\n\n# 查看支持的其他物种列表 | View list of other supported species\nnames(other_key)\n# 以拟南芥为例，查看其支持的器官/组织列表（当前行被注释） | View organs/tissues supported in Arabidopsis thaliana (current line is commented)\n#other_key[[\"arabidopsis_thaliana\"]]$organ\n开始画图\nvery_easy_input.csv，organ对应的数值。\n第一列是组织器官名，必须跟包里的organ一致\n第二列color，每种organ给一种颜色\n第三列组织所在的系统\n第四列数值，可以是基因表达量，或者其他临床指标。\n第五列tumor和normal\n其中第一列和第四列为必需\n此处以人类为例，分别画男人和女人，对比tumor和normal。\n还可以男女都画，然后ps成一半男一半女。\n其他物种按照very_easy_input_*.csv的格式整理好数据，就可以套用了\n##Start drawing\nThe value corresponding to ‘very easy input. csv’ and ‘organ’.\n-The first column is the name of the tissue and organ, which must be\nconsistent with the organ in the package -In the second column, each\ntype of organ is assigned a color -The system in which the third column\norganization is located -The fourth column of values can be gene\nexpression levels or other clinical indicators. -Column 5: Tumor and\nNormal\nThe first and fourth columns are mandatory\nTaking humans as an example, draw men and women separately to compare\ntumor and normal.\nYou can also draw for both men and women, and then photoshop it as\nhalf male and half female.\nOther species can organize their data in the format of very easy\ninput *. csv and apply it\n# 加载女性器官表达数据 | Load expression data for female organs\nhgFemale_tpm <- read.csv(\"very_easy_input_Female.csv\")\n\n# 查看数据结构 | View data structure\nhead(hgFemale_tpm)\n# 选择用于分组的列（type.y或type.x取决于对比需求） | Select column for grouping (type.y or type.x based on comparison needs)\nhgFemale_tpm$type <- hgFemale_tpm$type.y\n\n# 注意事项：\n# fill参数必须与数据中的列名匹配（color或value）\n# facet_wrap中的分组变量必须命名为type\nhgFemale <- gganatogram(data=hgFemale_tpm, \n                        fillOutline='white',    # 无数据器官区域用白色填充 | Fill non-data organs with white\n                        organism='human',       # 物种：人类 | Species: Human\n                        sex='female',           # 性别：女 | Gender: Female\n                        fill=\"value\") +         # 用表达值填充颜色 | Color by expression value\n  facet_wrap(~type) +            # 按样本类型分面展示 | Facet by sample type\n  scale_fill_gradient(low = \"white\", high = \"red\") +  # 设置渐变色：从白到红 | Set color gradient from white to red\n  labs(fill = \"Log2(TPM + 1)\") +  # 设置图例标题 | Set legend title\n  coord_cartesian(ylim = c(-120, 0)) +  # 限制Y轴范围（不显示小腿） | Limit Y-axis (exclude lower legs)\n  theme_void()  # 隐藏坐标轴 | Hide axes\n\n# 显示女性器官表达图谱 | Display female organ expression map\nhgFemale\n# 加载男性器官表达数据 | Load expression data for male organs\nhgMale_tpm <- read.csv(\"very_easy_input_Male.csv\")\n\n# 查看数据结构 | View data structure\nhead(hgMale_tpm)\n# 选择用于分组的列 | Select column for grouping\nhgMale_tpm$type <- hgMale_tpm$type.y\n\n# 绘制男性器官表达图谱 | Plot male organ expression map\nhgMale <- gganatogram(data=hgMale_tpm, fillOutline='white', organism='human', sex='male', fill=\"value\") + \n  facet_wrap(~type) +\n  scale_fill_gradient(low = \"white\", high = \"green\") +  # 设置渐变色：从白到绿 | Set color gradient from white to green\n  labs(fill = \"Log2(TPM + 1)\") + \n  coord_cartesian(ylim = c(-120, 0)) +\n  theme_void()\n\n# 显示男性器官表达图谱 | Display male organ expression map\nhgMale\n# 将男女图谱组合并保存为PDF文件 | Combine male and female plots and save as PDF\npdf(\"gganatogram.pdf\")\ngrid.arrange(hgFemale, hgMale, ncol=1)  # 垂直排列两个图谱 | Arrange plots vertically\ndev.off()  # 关闭PDF设备 | Close PDF device\n上图有些组织被盖住了，分开画更清晰。\nSome of the organizations in the above picture are covered, drawing\nthem separately makes them clearer.\n# 使用type.x列作为分组变量（可能代表不同的分类系统） | Use type.x column as grouping variable (may represent different classification system)\nhgFemale_tpm$type <- hgFemale_tpm$type.x\n\n# 绘制女性器官图谱，使用预定义的颜色值填充 | Plot female organogram with predefined color values\ngganatogram(data=hgFemale_tpm, \n            fillOutline='white',    # 无数据器官区域用白色填充 | Fill non-data organs with white\n            organism='human',       # 物种：人类 | Species: Human\n            sex='female',           # 性别：女 | Gender: Female\n            fill=\"color\") +         # 用color列中的颜色值直接填充 | Fill with color values from 'color' column\n  facet_wrap(~type) +            # 按type列分面展示 | Facet by 'type' column\n  theme_void()                   # 隐藏坐标轴和背景 | Hide axes and background\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa78gganatogram_FigureYa78gganatogram",
      "title": "FigureYa78gganatogram/FigureYa78gganatogram.html",
      "html": "FigureYa78gganatogram/FigureYa78gganatogram.html",
      "text": "texts/main_FigureYa78gganatogram_FigureYa78gganatogram.txt",
      "folder": "FigureYa78gganatogram",
      "thumb": "gallery_compress/FigureYa78gganatogram.webp"
    },
    "word_count": 1204,
    "lines_count": 240,
    "title": "FigureYa78gganatogram",
    "description": "用FigureYa55panCancer输出的基因在TCGA + GTEx的表达量TPM值（easy_input.csv文件）作为输入，用gganatogram画出感兴趣的基因在各个器官里的表达分布。 Use the TPM values of the expression levels of the genes output by",
    "input_data_types": [
      "临床数据"
    ],
    "output_types": [
      "统计表格"
    ],
    "technical_methods": [],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "LANGUAGE",
      "quote",
      "stringsAsFactors",
      "data",
      "low",
      "header",
      "sex",
      "ncol",
      "by"
    ]
  },
  {
    "id": "main_FigureYa184ranger_FigureYa184ranger",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa184ranger_FigureYa184ranger.txt",
    "content": "FigureYa184ranger\nFigureYa184ranger\nAuthor(s)\n: Xiaofan Lu\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement\n实现随机森林滑动窗口法。 Implement the random forest sliding window\nmethod.\n出自\nhttps://www.tandfonline.com/doi/full/10.1080/15592294.2019.1573066\nfromhttps://www.tandfonline.com/doi/full/10.1080/15592294.2019.1573066\nFigure 2. Ranger provides variable importance score (VIS) for each\nCpG probe for lung adenocarcinoma (LUAD) patients only in the discovery\nphase and the validation phase. “Out of bag (OOB)” error rate of top CpG\nprobes in the model, when probes were included one by one based on their\nVIS ranks in the discovery (A) and the validation phase (B).\n应用场景\nApplication Scenarios\n使用加权随机森林对生存数据降维，根据sliding windows sequential\nforward feature selection法筛选变量 The weighted random forest was used\nto reduce the dimension of the survival data, and the variables were\nscreened according to the sliding windows sequential forward feature\nselection method\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(ranger)\nlibrary(randomForest)\nlibrary(survival)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息  # Display an English error message\noptions(stringsAsFactors = FALSE) #禁止chr转成factor  # prohibit chr from being converted to factor\n自定义函数 Custom function\n# 显示进程\n# Show Process\ndisplay.progress = function (index, totalN, breakN=20) {\n  if ( index %% ceiling(totalN/breakN)  ==0  ) {\n    cat(paste(round(index*100/totalN), \"% \", sep=\"\"))\n  }\n}\n输入文件\nInput File\neasy_input_expr.csv，表达矩阵。 easy_input_expr.csv, expressing\nmatrix.\neasy_input_cli.csv，临床信息。这两个文件跟FigureYa128Prognostic、FigureYa182RFSurv的一样，可以对比感受一下筛选效果。\neasy_input_cli.csv, clinical information. These two documents are the\nsame as those of FigureYa128Prognostic and FigureYa182RFSurv. You can\ncompare them to get a sense of the screening effect.\nexp <- read.csv(\"easy_input_expr.csv\",header = T,row.names = 1,check.names = F,stringsAsFactors = F)\ncli <- read.csv(\"easy_input_cli.csv\",header = T,row.names = 1,check.names = F,stringsAsFactors = F)\n\n# 提取既有表达数据又有临床数据的样本\n# Extract samples that have both expressive data and clinical data\ncom_sam <- intersect(colnames(exp),rownames(cli))\nexp <- exp[,com_sam]\ncli <- cli[com_sam,]\n\n# 去除无表达的基因\n# Remove unexpressed genes\nexp <- exp[rowSums(exp) > 0,]\n\n# 去除超过10%的样本表达量为0的基因\n# Remove genes with expression levels of 0 from more than 10% of the samples\nexp <- exp[rowSums(exp == 0) < 0.1 * ncol(exp),]\n\n# 对数转化\n# Logarithmic Transformation\nexp <- log(exp + 1)\n单变量cox模型筛选预后基因\nUnivariate cox model for screening prognostic genes\n理论上表达谱会优先进行一些筛选避免增加运算时间，如使用单变量cox模型筛选预后基因(P\n< 0.01) Theoretically, the expression profile would prioritize some\nscreenings to avoid increasing the operation time, such as using a\nunivariate cox model to screen prognostic genes (P < 0.01).\n# 过滤出与OS有关的基因\n# Filter out genes related to OS\ncox.pcutoff <- 0.001\nCoxoutput.OS <- NULL\nfor (i in 1:nrow(exp)) {\n  display.progress(index = i,totalN = nrow(exp)) # 显示进度   # shows progress\n\n\n  \n  # 产生临时变量存储生存以及变量表达值\n  # Generate temporary variables to store survival and variable expression values\n  tmp <- data.frame(gene = as.numeric(exp[i,]),\n                    OS.time = cli[,\"OS.time\"],\n                    OS = cli[,\"OS\"],\n                    stringsAsFactors = F)\n  \n  # 单变量cox比例风险模型\n  # Univariate cox proportional hazards model\n  cox <- coxph(Surv(OS.time, OS) ~ gene, data = tmp)\n  coxSummary = summary(cox)\n  \n  # 生成cox结果数据框，包括基因名，风险比，z值，waldtest p值，以及HR置信区间\n  # Generate cox result data frames, including gene names, hazard ratios, Z-values, waldtest P-values, and HR confidence intervals\n  Coxoutput.OS=rbind.data.frame(Coxoutput.OS,data.frame(gene=rownames(exp)[i],\n                                                        HR=as.numeric(coxSummary$coefficients[,\"exp(coef)\"]),\n                                                        z=as.numeric(coxSummary$coefficients[,\"z\"]),\n                                                        pvalue=as.numeric(coxSummary$coefficients[,\"Pr(>|z|)\"]),\n                                                        lower=as.numeric(coxSummary$conf.int[,3]),\n                                                        upper=as.numeric(coxSummary$conf.int[,4]),\n                                                        stringsAsFactors = F),\n                                stringsAsFactors = F)\n}\nwrite.csv(Coxoutput.OS,\"univariate cox regression for gene filtering.csv\",row.names = F,quote = F)\n前面跟FigureYa182RFSurv的相同，下面就不一样了。 The front part is the\nsame as that of Figure A182 RFSURV, but the bottom part is\ndifferent.\n加权随机森林进一步降维\nWeighted random forests further reduce dimensions\ngene.sel <- Coxoutput.OS[which(Coxoutput.OS$pvalue < cox.pcutoff),\"gene\"]\ntmp <- exp[gene.sel,]\nrownames(tmp) <- gsub(\"-\",\"_\",rownames(tmp)) # 防止出现“-”导致程序报错  # Prevent the occurrence of \"-\" from causing program errors\ndt.rf <- cbind.data.frame(cli,t(tmp))\ndt.rf <- dt.rf[,setdiff(colnames(dt.rf),\"OS.time\")] # 二分类分类树，结局考虑overall survival  # binary classification tree, with overall survival as the outcome\n\nntree <- 500\nmtry <- floor(sqrt(length(gene.sel)))\nweight <- 0.999999 # 算法要求无法取1但无限接近1，该参数表示变量被选择的概率，原文为100%。 #The algorithm requires that it cannot take 1 but is infinitely close to 1. This parameter represents the probability of the variable being selected, which is 100% in the original text.\nseed <- 001\n\nset.seed(seed) # 设置外部种子保证结果可重复 # Sets an external seed to ensure repeatability of the result\nsurv.rf <- ranger(formula = OS ~ ., \n                  data = dt.rf,\n                  num.trees = ntree,\n                  mtry = mtry,\n                  importance = \"impurity\",\n                  split.select.weights = rep(weight,length(gene.sel)))\n# 变量重要性按照降序排列\n# Variable importance is arranged in descending order\nvar.imp <- sort(ranger::importance(surv.rf),decreasing = T)\n逐步回归筛选变量\nStepwise regression screens for variables\n例文采用sliding windows sequential forward feature selection The\nexample text adopts sliding windows sequential forward feature\nselection\n简单思路为，根据重要性逐步纳入基因，每一次做当前基因组合下的随机森林并计算oob，取oob达到最小时的组合。\nThe simple idea is to gradually incorporate genes based on their\nimportance. Each time, create a random forest under the current gene\ncombination and calculate the oob. Take the combination with the\nsmallest oob.\nntree <- 500 # 树的数目，一般为500 #The number of trees is generally 500\nnPerm <- 50 # 扰动次数，一般为50 # The number of disturbances is generally 50\nvar.now <- oob <- c()\nfor (var in names(var.imp)) {\n  cat(var,\"\\n\")\n  set.seed(seed)\n  var.now <- c(var.now,var)\n  swsfs.dt <- dt.rf[,c(\"OS\",var.now)]\n  swsfs.dt$OS <- factor(swsfs.dt$OS)\n  model_RF <- randomForest(OS ~ ., \n                           data = swsfs.dt,\n                           ntree = ntree, \n                           nPerm = nPerm, \n                           mtry = floor(sqrt(ncol(swsfs.dt))), \n                           proximity = T,\n                           importance = F)\n  oob <- c(oob,model_RF$err.rate[ntree,1])\n}\nnames(oob) <- names(var.imp)\nsignature <- var.imp[1:which.min(oob)] # 取oob达到最小时候的gene组合作为最终signature  # Take the gene combination when oob reaches its minimum as the final signature\nwrite.table(data.frame(signature = names(signature),importance = as.numeric(signature),stringsAsFactors = F),\n            \"signature with importance.txt\",sep = \"\\t\",row.names = F,quote = F)\n开始画图\nStart drawing\n#pdf(\"oob from swsfs.pdf\",width = 6,height = 5.5)\npar(bty = \"o\", mgp = c(1.5,.33,0), mar = c(3,4,1,2),las = 1, tcl = -.25)\nplot(1:length(gene.sel),oob,\n     xlab = \"Number of Genes\",\n     ylab = \"\",\n     type = \"l\",\n     lty = 4,\n     col = \"red\", # 可修改线的颜色 # The color of the line can be modified\n     cex = 1.5)\nmtext(\"OOB error rate\",side = 2,line = 2.5,las = 3) # 添加y标签 # Add the y tag\npoints(1:length(gene.sel),oob,# 加圆圈 # with circles\n       col = \"red\", # 可修改圆圈颜色   # can modify the color of the circle\n       pch = 19)\nabline(v = which.min(oob),lty = 2, col = \"red\") # 找到oob最小的位置添加垂直虚线  # Find the position where oob is the smallest and add a vertical dotted line\n#invisible(dev.off())\n\n# save.image(\"ranger.RData\")\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa184ranger_FigureYa184ranger",
      "title": "FigureYa184ranger/FigureYa184ranger.html",
      "html": "FigureYa184ranger/FigureYa184ranger.html",
      "text": "texts/main_FigureYa184ranger_FigureYa184ranger.txt",
      "folder": "FigureYa184ranger",
      "thumb": "gallery_compress/FigureYa184ranger.webp"
    },
    "word_count": 966,
    "lines_count": 196,
    "title": "FigureYa184ranger",
    "description": "Requirement 实现随机森林滑动窗口法。 Implement the random forest sliding window method.",
    "input_data_types": [
      "表达矩阵",
      "临床数据",
      "DNA-seq",
      "生存数据"
    ],
    "output_types": [
      "统计表格",
      "PCA图",
      "生存曲线"
    ],
    "technical_methods": [
      "生存分析"
    ],
    "biology_areas": [],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "gene",
      "trees",
      "header",
      "width",
      "importance",
      "signature",
      "ntree",
      "pvalue",
      "nPerm"
    ]
  },
  {
    "id": "main_FigureYa57profile_1bw_FigureYa57profile_1bw",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa57profile_1bw_FigureYa57profile_1bw.txt",
    "content": "FigureYa57 profile_1bw\nFigureYa57 profile_1bw\nWen Wang, Taojun Ye\n2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n输入1个bw，多个bed，画出paper里的图。\nRequirement description\nEnter 1 BW, multiple beds, and draw the image in the paper.\n出自\nhttps://www.nature.com/articles/nature19362\nfrom\nhttps://www.nature.com/articles/nature19362\n应用场景\n对比多个region在同一个sample里的信号特征。例如展示高CpG、低CpG区域的ChIP-seq信号强度差异。\n如果需要对比不同的样品在某一区域的信号特征，请看FigureYa44profile。\nApplication scenarios\nCompare the signal characteristics of multiple regions in the same\nsample. For example, showing the difference in ChIP seq signal strength\nbetween high CpG and low CpG regions.\nIf you need to compare the signal characteristics of different\nsamples in a certain area, please refer to Figure Ya44 profile.\n参数设置\n在这里修改常见的需要调整的参数\nParameter settings\nModify common parameters that need to be adjusted here\nsource(\"install_dependencies.R\")\n# 需要`corelib.R`文件里的函数提取bw文件里的信号\n# Requires functions from `corelib.R` to extract signals from bigWig files\nsource(\"./corelib.R\") # 位于当前文件夹 # Located in the current directory\n# 输出的pdf文件名\n# Output PDF file name\noutputName <- \"multiSitepro_example.pdf\" \n\n# bw文件，位于当前文件夹\n# BigWig files located in the current directory\nbigWigFile <- c(\"8cell.K4me3.bw\") \n\n# bed文件，位于当前文件夹\n# BED files located in the current directory\nbedFiles <- c(\"mm9_HCP_tss.bed\",\"mm9_ICP_tss.bed\",\"mm9_LCP_tss.bed\") \n\n# 图例标签，跟bed数量一致\n# Legend labels, corresponding to the number of BED files\nlabels <- c(\"HCP\",\"ICP\",\"LCP\") \n\n# 位点类型\n# Site type\nsiteType <- \"TSS\"\n\n# 分辨率，数值越低，画出来的曲线越平滑，运行时间越长\n# Resolution: smaller values result in smoother curves but longer computation time\nresolution <- 10 \n\n# gene body normalization length，需要是resolution的整数倍\n# Gene body normalization length, must be an integer multiple of resolution\nspan <- 2000 \n\n# 留出一个核用来干别的事情\n# Number of CPU cores to use (leaving one core available for other tasks)\ncoreNumber <- detectCores() - 1 \n\n# 均一化的系数，根据展示所需信号值刻度调整\n# Normalization constant to adjust signal intensity scaling\nnormalization_constant <- 1 \n\n# 线的颜色，跟bed数量一致\n# Line colors, corresponding to the number of BED files\ncolors <- c(\"darkorange\",\"navy\",\"darkgreen\") \n\n# 如果对自己的电脑有信心，就改为0，不sampling\n# Sampling configuration: 0 for no sampling, otherwise sample size per BED file\nsampling_number <- 5000 # 0 for no sampling, smaller than each bed rows\n输入文件\n8cell.K4me3.bw：ChIP/DNase/ATAC-seq的bw文件\nmm9_HCP_tss.bed, mm9_ICP_tss.bed,\nmm9_LCP_tss.bed：用来提取bw信号的指定区域。其中第1、2、3、6列必需。\nInput file\n8cell.K4me3.bw: bw file for ChIP/DNase/ATAC seq\nMm9HCP_tss.bed, mm9_iCP_tss.bed, mm9_LCP_tss.bed: Used to extract the\ndesignated area of the BW signal. The first, second, third, and sixth\ncolumns are required.\n信号提取\nSignal extraction\n# 初始化平均信号存储向量\n# Initialize vector to store average signals\naverage_signal <- c()\n\n# 循环处理每个BED文件\n# Loop through each BED file\nfor(i in 1:length(bedFiles)){\n  \n  # 加载BED文件\n  # Load BED file\n  bed <- read.table(bedFiles[i])\n  \n  # 过滤非标准染色体（如包含\"_\"的contig）\n  # Filter out non-standard chromosomes (e.g., contigs containing \"_\")\n  isNormalChrosome <- !grepl(\"_\",bed$V1)\n  bed <- bed[isNormalChrosome,]\n  \n  # 随机抽样（如果需要）\n  # Random sampling (if required)\n  if(sampling_number != 0){\n    set.seed(6666)  \n    idx <- sample(1:nrow(bed),size=sampling_number)  \n    bed <- bed[idx,]  \n  }\n\n  # 捕获位点周围的信号值\n  # Capture signal values around sites\n  average_signal <- rbind(average_signal,signal_caputer_around_sites(bigWigFile,bed,resolution=resolution,span=span,cores=as.integer(coreNumber)))\n}\n\n# 应用归一化系数\n# Apply normalization constant\naverage_signal <- average_signal / normalization_constant\n\n# 这步比较耗时，我们把抽取的信号保存到`average_signal.txt`文件里。\n# This step is time-consuming. Save extracted signals to `average_signal.txt`.\nwrite.table(average_signal,\"average_signal.txt\",quote = F,row.names = F,col.names = F)\n开始画图\nStart plot\n# 从文件读取预处理好的平均信号数据\n# Read preprocessed average signal data from file\naverage_signal <- read.table(\"average_signal.txt\", header = F, as.is = T)\n\n# 计算Y轴显示范围，添加适当边距\n# Calculate Y-axis display range with padding\nminimum <- min(average_signal) - (max(average_signal) - min(average_signal)) * 0.1\nmaximum <- max(average_signal) + (max(average_signal) - min(average_signal)) * 0.1 * length(bedFiles)\n\n# 计算数据点数量（区域长度/分辨率）\n# Calculate number of data points (region length/resolution)\ndatapoints <- span / resolution\n\n# 打开PDF设备（取消注释以保存图表到文件）\n# Open PDF device (uncomment to save plot to file)\n#pdf(outputName,width = 4, height = 4)\n\n# 绘制第一条曲线作为基础\n# Plot the first curve as baseline\nplot(1:(datapoints * 2 + 1), average_signal[1,], \n     type = \"l\", lwd = 3, col = colors[1],\n     xaxt = \"n\", \n     xlab=\"Distance to TSS\", ylab=\"Normalized signal\", \n     ylim = c(minimum, maximum))\n\n# 循环添加其余曲线\n# Loop to add remaining curves\nfor(i in 2:length(bedFiles)){\n  lines(1 : (datapoints*2+1), average_signal[i,], \n        lwd = 3, col = colors[i]) \n}\n\n# 添加图例（右上角，无边框）\n# Add legend (top-right corner, no border)\nlegend(\"topright\", col=colors, \n       legend = labels, lty = 1, lwd = 3,\n       bty = \"n\") \n\n# 添加边框（调整粗细）\n# Add plot border (adjust thickness)\nbox(lwd = 2) \n\n# 自定义X轴刻度（显示为相对于TSS的距离）\n# Customize X-axis ticks (show as distance relative to TSS)\naxis(side=1, at=c(0, datapoints, datapoints*2) + 1, labels = c(paste(-1*span/1000, \"kb\"), siteType, paste(span/1000, \"kb\")))\n# 关闭PDF设备（取消注释以保存图表）\n# Close PDF device (uncomment to finalize saving)\n#dev.off()\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa57profile_1bw_FigureYa57profile_1bw",
      "title": "FigureYa57profile_1bw/FigureYa57profile_1bw.html",
      "html": "FigureYa57profile_1bw/FigureYa57profile_1bw.html",
      "text": "texts/main_FigureYa57profile_1bw_FigureYa57profile_1bw.txt",
      "folder": "FigureYa57profile_1bw",
      "thumb": "gallery_compress/FigureYa57profile_1bw.webp"
    },
    "word_count": 692,
    "lines_count": 178,
    "title": "FigureYa57 profile_1bw",
    "description": "输入1个bw，多个bed，画出paper里的图。 Requirement description Enter 1 BW, multiple beds, and draw the image in the paper.",
    "input_data_types": [],
    "output_types": [
      "统计表格"
    ],
    "technical_methods": [
      "标准化"
    ],
    "biology_areas": [],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "span",
      "header",
      "lwd",
      "width",
      "ylim",
      "side",
      "labels",
      "legend",
      "col",
      "at"
    ]
  },
  {
    "id": "main_FigureYa130coxSVM_FigureYa130coxSVM_step12",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa130coxSVM_FigureYa130coxSVM_step12.txt",
    "content": "FigureYa130SVM_step12\nFigureYa130SVM_step12\nYufang Wang, Dongqiang Zeng\n2025-5-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement Description\n筛选差异基因后，用cox\nregression、SVM-RFE和FW-SVM算法进一步筛选有预后意义的基因，组成基因甲基化位点或表达的signature。\nAfter filtering differential genes, use Cox regression, SVM-RFE, and\nFW-SVM algorithms to further select prognostic genes to construct a gene\nmethylation site or expression signature.\n出自\nhttps://onlinelibrary.wiley.com/doi/full/10.1111/jcmm.14231\nSource:\nhttps://onlinelibrary.wiley.com/doi/full/10.1111/jcmm.14231\n主要分四步来实现，其中前两步在R里实现，后两步在python里实现，运行完本文档FigureYa130coxSVM_step12.Rmd之后，运行FigureYa130coxSVM_step34.ipynb：\nThe process consists of four main steps. The first two steps are\nimplemented in R, and the latter two in Python. After running this\ndocument FigureYa130coxSVM_step12.Rmd, proceed with\nFigureYa130coxSVM_step34.ipynb:\n第一步，正常人与癌症患者差异化比较 Step 1: Differential analysis\nbetween normal and cancer samples\n第二步，寻找相关矩阵，并生成下游数据 Step 2: Identify correlation\nmatrix and generate downstream data\n第三步，REF-SVM寻找合适的特征范围 Step 3: Use REF-SVM to find the\noptimal feature range\n第四步，FW-SVM进一步喜欢特征数目 Step 4: Use FW-SVM to further\nselect feature numbers\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(tidyverse)\nlibrary(ChAMP)\nlibrary(minfi)\nlibrary(RColorBrewer)\nlibrary(survival)\n\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 Display error messages in English\noptions(stringsAsFactors = FALSE) #禁止chr转成factor Prevent automatic conversion of character to factor\n输入文件下载\nInput File Download\n从XENA\nhttps://xenabrowser.net/datapages/\n下载两类数据，以GDC\nTCGA Liver Cancer (LIHC) (14 datasets)为例： Download two types of data\nfrom XENA using the GDC TCGA Liver Cancer (LIHC) (14 datasets) as an\nexample:\n甲基化数据DNA methylation - Methylation450k，地址：\nhttps://xenabrowser.net/datapages/?dataset=TCGA-LIHC.methylation450.tsv&host=https%3A%2F%2Fgdc.xenahubs.net&removeHub=https%3A%2F%2Fxena.treehouse.gi.ucsc.edu%3A443\n，下载链接：\nhttps://gdc.xenahubs.net/download/TCGA-LIHC.methylation450.tsv.gz\nDNA methylation data - Methylation450k, location:\nhttps://xenabrowser.net/datapages/?dataset=TCGA-LIHC.methylation450.tsv&host=https%3A%2F%2Fgdc.xenahubs.net&removeHub=https%3A%2F%2Fxena.treehouse.gi.ucsc.edu%3A443\n,\nDownload link:\nhttps://gdc.xenahubs.net/download/TCGA-LIHC.methylation450.tsv.gz\n生存数据phenotype, survival data (n=463) GDC Hub，\nhttps://xenabrowser.net/datapages/?dataset=TCGA-LIHC.survival.tsv&host=https%3A%2F%2Fgdc.xenahubs.net&removeHub=https%3A%2F%2Fxena.treehouse.gi.ucsc.edu%3A443\n，下载链接：\nhttps://gdc.xenahubs.net/download/TCGA-LIHC.survival.tsv.gz\nSurvival data: phenotype, survival data (n=463) from GDC Hub,\nhttps://xenabrowser.net/datapages/?dataset=TCGA-LIHC.survival.tsv&host=https%3A%2F%2Fgdc.xenahubs.net&removeHub=https%3A%2F%2Fxena.treehouse.gi.ucsc.edu%3A443\n,\nDownload link:\nhttps://gdc.xenahubs.net/download/TCGA-LIHC.survival.tsv.gz\n# 读入甲基化数据\n# Read methylation data\nnor_methy <- read_tsv(\"TCGA-LIHC.methylation450.tsv\")\nnor_methy <- column_to_rownames(nor_methy, var = \"Composite Element REF\")\nnor_methy <- na.omit(nor_methy)\n\n#########################\nnor_methy[1:5,1:5]\ndim(nor_methy)\ncolnames(sur_data) <- c(\"sample\", \"OS_status\", \"ID\", \"OS_time\")\nsur_data <- sur_data[!is.na(sur_data$OS_time),]\nsur_data <- sur_data[!is.na(sur_data$OS_status),]\nsur_data <- sur_data[,c(\"ID\",\"OS_time\",\"OS_status\")]\n#去除急性进展患者对生存分析的影响\n# Remove rapidly progressing patients to avoid bias in survival analysis\nsur_data <- sur_data[sur_data$OS_time>30,]\ndim(sur_data)\n第一步，正常人与癌症患者差异化比较\nStep 1: Differential analysis between normal and tumor samples\n# 根据TCGA的barcode构建癌和癌旁的分类信号\n# Use TCGA barcode to classify tumor and normal samples\nsampleid <- colnames(nor_methy)\npdata <- data.frame(ID = sampleid,tissue_type = substring(sampleid,14,16))\nhead(pdata)\nsummary(as.factor(pdata$tissue_type))\npdata <- pdata[!pdata$tissue_type==\"01B\",]\npdata <- pdata[!pdata$tissue_type==\"02B\",]\npdata$group <- ifelse(pdata$tissue_type==\"11A\",\"normal\",\"tumor\")\nsummary(as.factor(pdata$group))\npdata <- pdata[match(colnames(nor_methy),pdata$ID),]\ndata.frame(pdata$ID,colnames(nor_methy))\n#从结果来看UCSC这个标准化做的并不好\n# The UCSC normalization seems suboptimal\n#########################\n\n# 正常人与癌症患者差异化比较\n# Identify differential methylation between tumor and normal\n#' @find-Differential-Methylation-Probes\nmyDMP <- champ.DMP(beta = nor_methy,pheno=pdata$group)\nhead(myDMP[[1]])\ndmp <- myDMP[[1]]\ndmp <- dmp[dmp$adj.P.Val<0.05 & abs(dmp$deltaBeta)>0.2,]\ndim(dmp)\ntumor_methy <- nor_methy[dmp,colnames(nor_methy)%in%tumor_id]\ndim(tumor_methy)\n#把前面的运行结果保存一下\n# Save the tumor methylation matrix\nsave(tumor_methy,file = \"TCGA-LIHC-Tumor-dmp-matrix.RData\")\n第二步，寻找相关矩阵，并生成下游数据\nStep 2: Build correlation matrix and generate downstream data\n#读入第一步的运行结果\n# Load tumor methylation matrix\n(load(\"TCGA-LIHC-Tumor-dmp-matrix.RData\"))\ncolnames(tumor_methy) <- substring(colnames(tumor_methy),1,12)\ntumor_methy <- as.data.frame(t(tumor_methy))\ntumor_methy[1:5,1:6]\ntumor_methy <- rownames_to_column(tumor_methy,var = \"ID\")\ntumor_methy$ID <- gsub(tumor_methy$ID,pattern = \"\\\\.\",replacement = \"-\")\ntumor_methy <- tumor_methy[!duplicated(tumor_methy$ID),]\n\nsummary(tumor_methy$ID%in%sur_data$ID)\n如果想要获得HR和可信区间，使用批量生存分析，运行时间较长-patience To\nobtain HR and confidence intervals, run batch survival analysis. This\nmay take time – be patient\nCoxoutput=data.frame()\nfor(i in colnames(sur_meth[,4:ncol(sur_meth)])){\n  cox <- coxph(Surv(OS_time,OS_status) ~ sur_meth[,i], data = sur_meth)\n  coxSummary = summary(cox)\n  Coxoutput=rbind(Coxoutput,cbind(gene=i,HR=coxSummary$coefficients[,\"exp(coef)\"],\n                                  z=coxSummary$coefficients[,\"z\"],\n                                  pvalue=coxSummary$coefficients[,\"Pr(>|z|)\"],\n                                  lower=coxSummary$conf.int[,3],\n                                  upper=coxSummary$conf.int[,4]))\n}\nfor(i in c(2:6)){\n  Coxoutput[,i] <- as.numeric(as.vector(Coxoutput[,i]))\n}\nCoxoutput <- arrange(Coxoutput,pvalue)  %>% #用pvalue筛选\n  filter(pvalue < 0.05)\ndim(Coxoutput)\nhead(Coxoutput)\n进一步筛选tumor_methy-矩阵文件-用于向量机的进一步筛选 Further filter\nthe tumor methylation matrix – to be used for SVM-based feature\nselection\nrownames(tumor_methy) <- NULL\ntumor_methy <- column_to_rownames(tumor_methy,var = \"ID\")\ntumor_methy <- tumor_methy[rownames(tumor_methy)%in%sur_meth$ID,colnames(tumor_methy)%in%sig_dmp]\ntumor_methy <- rownames_to_column(tumor_methy,var = \"ID\")\ndim(tumor_methy)\ntumor_methy[1:5,1:5]\n患者风险分析 Patient risk classification\nsur_data <- sur_data[sur_data$ID%in%sur_meth$ID,]\nsur_data <- within(sur_data, {\n  subtype <- NA\n  subtype[(OS_time <= 12) & (OS_status == 1)] <- \"High_risk\" \n  subtype[(OS_time >= 60) ] <- \"Low_risk\"\n})\n\nsur_data$subtype[is.na(sur_data$subtype)] <- \"Inter_risk\"\nsummary(as.factor(sur_data$subtype))\ntumor_subtype_methy <- merge(sur_data[,c(\"ID\",\"subtype\")],tumor_methy,by.x=\"ID\",by.y=\"ID\",all.x=F,all.y=F)\ntumor_subtype_methy[1:5,1:10]\nsave(tumor_subtype_methy,file = \"TCGA-LIHC-survival-relevant-DMP-matrix.RData\")\nwrite.csv(tumor_subtype_methy,\"TCGA-LIHC-survival-relevant-DMP-matrix.csv\")\n接下来将进入第三和第四步，请打开FigureYa130coxSVM_step34.ipynb文件，以第二步生成的TCGA-LIHC-survival-relevant-DMP-matrix.csv文件作为输入。\nNext, proceed to Steps 3 and 4. Open the FigureYa130coxSVM_step34.ipynb\nnotebook and use the CSV file TCGA-LIHC-survival-relevant-DMP-matrix.csv\ngenerated in Step 2 as input.\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa130coxSVM_FigureYa130coxSVM_step12",
      "title": "FigureYa130coxSVM/FigureYa130coxSVM_step12.html",
      "html": "FigureYa130coxSVM/FigureYa130coxSVM_step12.html",
      "text": "texts/main_FigureYa130coxSVM_FigureYa130coxSVM_step12.txt",
      "folder": "FigureYa130coxSVM",
      "thumb": "gallery_compress/FigureYa130coxSVM.webp"
    },
    "word_count": 603,
    "lines_count": 182,
    "title": "FigureYa130SVM_step12",
    "description": "Requirement Description 筛选差异基因后，用cox regression、SVM-RFE和FW-SVM算法进一步筛选有预后意义的基因，组成基因甲基化位点或表达的signature。",
    "input_data_types": [
      "生存数据"
    ],
    "output_types": [
      "散点图",
      "生存曲线"
    ],
    "technical_methods": [
      "生存分析",
      "标准化"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "gene",
      "n",
      "pvalue",
      "beta",
      "ID",
      "upper",
      "coxSummary",
      "LANGUAGE",
      "data"
    ]
  },
  {
    "id": "main_FigureYa160scGSVA_FigureYa160scGSVA",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa160scGSVA_FigureYa160scGSVA.txt",
    "content": "FigureYa160scGSVA\nFigureYa160scGSVA\nAuthor(s)\n: Jinen Song\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement\n对单细胞亚群进行功能注释后，如何求每群细胞某条pathway的gene set score\nAfter functionally annotating single-cell subpopulations, how can I\ncalculate the gene set score for a specific pathway in each\nsubpopulation?\n出自\nhttps://www.ahajournals.org/doi/10.1161/CIRCULATIONAHA.118.038362\nFrom\nhttps://www.ahajournals.org/doi/10.1161/CIRCULATIONAHA.118.038362\nFigure 5. Pathway analysis of endothelial cell (EC) subpopulations.\nB, Functional gene sets identified from Reactome pathway enrichment and\nsubpopulation markers differentiate the 2 major EC populations EC 1 and\nEC 2.\n应用场景\nApplication Scenario\n单细胞数据，从matrix到分组，用GSVA计算pathway的表达量，然后比较pathway在组间的差异，画图。\nSingle-cell data: From matrix to grouping, calculate pathway expression\nusing GSVA, then compare pathway differences between groups and\nplot.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(dplyr)\nlibrary(Seurat)\nlibrary(ComplexHeatmap)\nlibrary(GSVA)\nlibrary(GSEABase)\nlibrary(limma)\nlibrary(ggplot2)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # Display English error messages\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # Disable conversion of chr to factor\n加载自定义函数 Loading custom functions\n做单细胞分析时，代码会非常多而且繁杂，为了脚本的整洁简短，我们把这些函数单独放在一个文件里，使用时导入就可以了。\nSingle-cell analysis can be quite complex and tedious. To keep the\nscript concise, we’ll place these functions in a separate file and\nimport them when needed.\nsource(\"seurat_pipeline.R\")\n输入文件\nInput files\n输入文件位于文件夹：pbmc3k_filtered_gene_bc_matrices/filtered_gene_bc_matrices/hg19/，包括raw\ngene expression matrix、barcode和gene annotation。 The input files are\nlocated in the folder:\npbmc3k_filtered_gene_bc_matrices/filtered_gene_bc_matrices/hg19/ and\ninclude the raw gene expression matrix, barcodes, and gene\nannotations.\n数据来源：\nhttps://s3-us-west-2.amazonaws.com/10x.files/samples/cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz\nData source:\nhttps://s3-us-west-2.amazonaws.com/10x.files/samples/cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz\npbmc.data <- Read10X(data.dir = \"pbmc3k_filtered_gene_bc_matrices/filtered_gene_bc_matrices/hg19/\")\n# Initialize the Seurat object with the raw (non-normalized data).\npbmc <- CreateSeuratObject(counts = pbmc.data, project = \"pbmc3k\", min.cells = 3, min.features = 200)\npbmc\n主要步骤： Main steps:\nSTEP 1 : 对单细胞数据进行分组，获得分组信息\nSTEP 2 : 进行GSVA分析、差异表达分析\nSTEP 3 : 根据已经得到的分组信息，挑选感兴趣的通路，画图\nSTEP 1: Group the single-cell data and obtain group information\nSTEP 2: Perform GSVA analysis and differential expression\nanalysis\nSTEP 3: Based on the obtained grouping information, select the\npathway of interest and draw a graph\nSTEP 1: 对单细胞数据进行分组，获得分组信息\nSTEP 1: Group the single-cell data and obtain grouping\ninformation\n用于从raw gene expression matrix开始。 Used to start from the raw\ngene expression matrix.\n如果已经完成了聚类，请移动到STEP 2。 If clustering has been\ncompleted, please move to STEP 2.\n使用seurat分析单细胞数据需要注意的几个地方: Several points to note\nwhen using Seurat to analyze single-cell data:\n1. 数据过滤\n1. Data filtering\n细胞内表达基因个数 <200 或 >\n7500的过滤掉。这里过滤的上限和下限自己把控，没有固定值。过滤掉基因表达高的是为了减少多细胞比例\nFilter out cells with <200 or >7500 expressed genes. The\nupper and lower limits of the filter are controlled by yourself and\nthere is no fixed value. Filtering out genes with high expression is to\nreduce the proportion of multiple cells\n在 <3\n个细胞内有表达的基因，过滤掉。因为很多基因的表达值都是0，这种可以过滤掉很多表达全为0的基因\nFilter out genes that are expressed in <3 cells. Because many\ngenes have an expression value of 0, this method can filter out many\ngenes with all zero expressions\n线粒体基因比例，一定程度上代表这建库时细胞的完整性。如果线粒体基因比例太高，说明细胞非常有可能破损了，在油包水时就不完整了\nThe proportion of mitochondrial genes, to a certain extent,\nrepresents the integrity of the cells when the library was built. If the\nmitochondrial gene ratio is too high, it’s very likely that the cells\nare damaged and incomplete during the oil-water mixture.\nMT genes% < 20%\n左右，根据自己的数据把控。就算这里过滤的不严格，也没有关系，后面聚类时，这些高线粒体基因比例的细胞都会聚到一类。\nMT genes% < 20% or so. This should be controlled based on your data.\nEven if the filtering here is not strict, it doesn’t matter; cells with\na high mitochondrial gene ratio will be clustered together during\nsubsequent clustering.\n后续分析时排除这些细胞就可以了。一般外周血数据中线粒体基因比例都很低。\nThese cells can simply be excluded from subsequent analysis.\nMitochondrial gene ratios are generally very low in peripheral blood\ndata.\n2 聚类和降维可视化\n2 Clustering and Dimensionality Reduction Visualization\n这里有两个参数不好把控，一个是选择PCA结果中的PC个数，另一个就是resolution。\nThere are two parameters that are difficult to control: the number of\nPCs in the PCA results and the resolution.\nPC个数选择，可以根据ElbowPlot(拐点图)，选择拐点出现位置附近的PC数即可。这个参数会影响聚类的结果已经后续降维图形的。\nresolution：这个参数相对的不那么重要，只是会影响分出的cluster的数目多少。当resolution选的比较大，cluster分的很多，后续分析也可以\nFor the number of PCs, select the number of PCs near the inflection\npoint using the ElbowPlot (inflection point plot). This parameter\naffects the clustering results and subsequent dimensionality reduction\ngraphs.\nResolution: This parameter is relatively unimportant and only\naffects the number of clusters generated. A high resolution will result\nin a large number of clusters, which can be useful in subsequent\nanalysis.\n根据marker\ngenes等，对细胞类型进行定义，然后人为的把相同细胞类型的cluster合并。\nDefine cell types based on marker genes and other factors, and then\nmanually merge clusters of the same cell type.\n一般细胞数目 5000 - 10000 左右时，选择 resolution = 1\n都是可以的，细胞数量更多时可以选择2。自己根据分出的效果来调控，这个不影响大局。\nGenerally, for cells between 5,000 and 10,000, selecting resolution = 1\nis sufficient. For larger cell numbers, you can choose 2. Adjust this\nsetting based on the desired resolution; it does not affect the overall\nresult.\n用自定义函数\nSeurat.pipeline\n做预处理\nPreprocessing with the Custom\nSeurat.pipeline\nFunction\n整个过程中需要调整的就只有这几个参数了： The only parameters that\nneed to be adjusted during the entire process are:\nSeurat.pipeline(RdsName = pbmc, outputname = \"PBMC\", MTfraction = 0.05, pc = 10, res = 0.6)\n# 这里需要运行几分钟\n# 经过这一步的处理，现在在pbmc这个seurat object 的assays中存储了三种基因表达数据，保存在PBMC_pc10_res0.6.rds里\n# (1) pbmc@assays$RNA@counts : raw count\n# (2) pbmc@assays$RNA@data : Normalized data\n# (3) pbmc@assays$RNA@scale.data: scaled之后的data\n# 做GSVA分析时，使用normalized data就可以了.\n# This will take several minutes to run\n# After this step, three types of gene expression data are now stored in the assays of the seurat object pbmc, saved in PBMC_pc10_res0.6.rds\n# (1) pbmc@assays$RNA@counts : raw counts\n# (2) pbmc@assays$RNA@data : Normalized data\n# (3) pbmc@assays$RNA@scale.data: scaled data\n# When performing GSVA analysis, use normalized data.\n提取出每个细胞的基因表达量和对应的分组信息。 Extract the gene\nexpression level of each cell and the corresponding group\ninformation.\n查看生成的\nPBMC_pc10_res0.6.pdf\n文件，分成了9个cluster\nView the generated\nPBMC_pc10_res0.6.pdf\nfile, which is\ndivided into 9 clusters.\n如何鉴定每个cluster是什么细胞类型？经典的做法是找出每个cluster中的高表达的基因，然后根据经典的细胞marker来确定细胞类型，需要查找文献。方法见官网\nhttps://satijalab.org/seurat/v3.1/pbmc3k_tutorial.html\nHow do you identify the cell type of each cluster? The classic approach\nis to identify the most highly expressed genes in each cluster and then\ndetermine the cell type based on classic cell markers. This requires\nresearch. For methods, see the official website\nhttps://satijalab.org/seurat/v3.1/pbmc3k_tutorial.html\nSTEP 2 : GSVA 分析和差异表达分析\nSTEP 2: GSVA Analysis and Differential Expression Analysis\n选择感兴趣的两个细胞亚群（cluster），用GSVA算出pathway的表达量，然后对比，画出感兴趣的pathway的图。\nSelect two cell subpopulations (clusters) of interest, calculate pathway\nexpression using GSVA, compare them, and plot the pathway of\ninterest.\n# 加载 STEP 1 获得的pbmc / Load PBMC obtained in Step 1\npbmc <- readRDS(\"PBMC_pc10_res0.6.rds\")\n\n# 导入gmt文件 / Import gmt file\ngenesets <- getGmt(\"h.all.v7.0.symbols.gmt\")\n\n### 1. 找到感兴趣的细胞组别，两者间进行比较 / Find cell groups of interest and compare them\nsubcluster <- c(6, 8)\nsub <- subset(pbmc, idents = subcluster)\ndf.data <- GetAssayData(object = sub, slot = \"data\")\n\n# 将细胞所属的group信息保存起来 / Save cell group information\ndf.group <- data.frame(\n  umi = names(Idents(sub)), \n  cluster = as.character(sub@meta.data$RNA_snn_res.0.6), \n  stringsAsFactors = FALSE\n)\n\n### 2. 做gsva - 修复参数传递问题 / Perform GSVA - fix parameter passing issues\n# 确保数据格式正确 / Ensure correct data format\nexpr_data <- as.matrix(df.data)\n\n# 转换genesets为gsva需要的格式 / Convert genesets to the format required by gsva\n# GSEABase::getGmt()返回的是GeneSetCollection对象，需要转换为列表\ngeneset_list <- lapply(genesets, function(gs) {\n  GSEABase::geneIds(gs)\n})\nnames(geneset_list) <- names(genesets)\n\n# 使用正确的参数格式调用gsva / Call gsva with correct parameter format\nparam <- gsvaParam(\n  exprData = expr_data,\n  geneSets = geneset_list,\n  kcdf = \"Gaussian\"\n)\n\ngsvascore <- gsva(\n  param,\n  verbose = TRUE\n)\n# 查看结果 / Check results\nprint(\"GSVA score dimensions: / GSVA得分维度:\")\nprint(dim(gsvascore))\nprint(gsvascore[1:5, 1:5])\nSTEP 3：根据已经得到的分组信息，挑选出需要的通路，画图\nSTEP 3: Based on the obtained grouping information, select the\ndesired pathways and plot them.\n从sigPathways中挑选一个gene\nset来展示例图的画法。你也可以写成循环，画多个。 Select a gene set from\nsigPathways to demonstrate how to plot an example plot. You can also\ncreate a loop to plot multiple plots.\n# 这里选第一个pathway画图\n# Select the first pathway to plot\ncount <- gsvascore[rownames(sigPathways)[1], , drop = FALSE]\ncount <- as.data.frame(t(count))\ncolnames(count) <- \"geneset\"\ncount$cluster <- as.character(Idents(sub))\n# 用通路的名称作为图形标题\n# Use the name of the pathway as the graph title\ntitle.name = rownames(sigPathways)[1]\n\n# 添加P值\n# 得到cluster6和cluster10中的gsva score 最大值\n# Add P value\n# Get the maximum gsva score in cluster6 and cluster10\ncount.geneset.group1 <- count$geneset[count$cluster == subcluster[1]]\ncount.geneset.group2 <- count$geneset[count$cluster == subcluster[2]]\n\n# 确定P值添加的位置\n# Determine the position to add the P value\nysegment1 <- max(count.geneset.group1)\nysegment2 <- max(count.geneset.group2)\nysegment.max <- max(ysegment1, ysegment2)\n\n# 根据P值确定加几颗星\n# Add stars based on P value\npval <- sigPathways$P.Value[1]\n\nif (pval < 0.001) {\n  pval.label = \"***\"\n} else if (pval < 0.005) {\n  pval.label = \"**\"\n} else if (pval < 0.05) {\n  pval.label = \"*\"\n} else if (pval >= 0.05) {\n  pval.label = \"non.sig\"\n}\n\n# 自定义颜色\n# Custom color\nblue <- \"#619CD6\"\ngreen <- \"#89C32E\"\np <- ggplot(count, aes(x = cluster, y = geneset, fill = cluster)) +\n  geom_violin() +\n  scale_fill_manual(values = c(blue, green)) + # 用自定义颜色填充 # Fill with custom color\n  theme_classic() +\n  theme(panel.grid = element_blank(), \n        plot.margin = margin(0.5, 0.5, 0.5, 0.5, \"cm\"), \n        axis.title.x = element_text(color = \"black\", size = 20), \n        axis.title.y = element_blank(), \n        axis.text = element_text(color = \"black\", size = 16), \n        axis.line = element_line(colour = \"black\", size = 0.6), \n        plot.title = element_text(size = 20, hjust = 0.5)) + \n  # 添加图形标题 # Add graph title\n  ggtitle(title.name) +\n  guides(fill = F)\np\n# 前面已经得到了pvalue,添加上去就可以了\n# We already got the pvalue, so just add it.\np + \n  # 图形中的一个横线和两个竖线 # One horizontal line and two vertical lines in the graph\n  annotate(\"segment\", x = 1, xend = 2, y = ysegment.max + 0.02, yend = ysegment.max + 0.02) + \n  annotate(\"segment\", x = 1, xend = 1, y = ysegment1 + 0.01, yend = ysegment.max + 0.02) +\n  annotate(\"segment\", x = 2, xend = 2, y = ysegment2 + 0.01, yend = ysegment.max + 0.02) +\n  # 添加P值对应的星号 # Add asterisks for P values\n  annotate(\"text\", \n           size = 12, # *的大小 # Size of the *\n           x = 1.5, \n           y = ysegment.max - 0.03, #可以微调*所在的位置 # You can fine-tune the position of the *\n           label = pval.label)\nggsave(\"PBMC_DE_genesets_hallmarker_cluster6_vs_8.pdf\", width = 5.5, height = 5)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa160scGSVA_FigureYa160scGSVA",
      "title": "FigureYa160scGSVA/FigureYa160scGSVA.html",
      "html": "FigureYa160scGSVA/FigureYa160scGSVA.html",
      "text": "texts/main_FigureYa160scGSVA_FigureYa160scGSVA.txt",
      "folder": "FigureYa160scGSVA",
      "thumb": "gallery_compress/FigureYa160scGSVA.webp"
    },
    "word_count": 1525,
    "lines_count": 307,
    "title": "FigureYa160scGSVA",
    "description": "Requirement 对单细胞亚群进行功能注释后，如何求每群细胞某条pathway的gene set score After functionally annotating single-cell subpopulations, how can I",
    "input_data_types": [
      "表达矩阵",
      "单细胞"
    ],
    "output_types": [
      "箱线图",
      "火山图",
      "热图",
      "PCA图"
    ],
    "technical_methods": [
      "聚类分析",
      "通路分析",
      "差异表达分析"
    ],
    "biology_areas": [],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "colour",
      "values",
      "res",
      "width",
      "grid",
      "xend",
      "pvalue",
      "object"
    ]
  },
  {
    "id": "main_FigureYa178receptorLigand_FigureYa178receptorLigand",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa178receptorLigand_FigureYa178receptorLigand.txt",
    "content": "FigureYa178receptorLigand\nFigureYa178receptorLigand\nAuthor(s)\n: Xiao Gu\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement\n用本地CellPhoneDB分析配体-受体，用ggplot2重新画图。 Ligand-receptor\nanalysis was performed using local CellPhoneDB, and the plot was redrawn\nusing ggplot2.\n出自\nhttps://www.nature.com/articles/s41586-018-0698-6\nfrom\nhttps://www.nature.com/articles/s41586-018-0698-6\nWe next used\nCellPhoneDB\nto identify the expression\nof cytokines and chemokines by dNKs, and to predict their interactions\nwith other cells at the maternal–fetal interface.\nFig. 5 | Multiple regulatory immune responses at the site of\nplacentation. a, Overview of selected ligand–receptor interactions; P\nvalues indicated by circle size, scale on right (permutation test, see\nMethods). The means of the average expression level of interacting\nmolecule 1 in cluster 1 and interacting molecule 2 in cluster 2 are\nindicated by colour. Only droplet data were used (n = 6 deciduas).\nAngio., angiogenesis. Assays were carried out at the mRNA level, but are\nextrapolated to protein interactions.\n出自\nhttps://science.sciencemag.org/content/365/6460/1461.full\nfromhttps://science.sciencemag.org/content/365/6460/1461.full\nFig. 4. Spatial topology of myeloid cell populations in the mature\nkidney. (A) Heat map of chemokine ligandreceptor interactions between\nmature myeloid and nephron cell types arranged by proximal to distal\nnephron organization. Point size indicates permutation p value\n(CellPhoneDB). Color indicates the scaled mean expression level of\nligand and receptor (Mol1/2).\n应用场景\nApplication Scenarios\n适用于单细胞转录组数据。跟网页版相比，本地安装运行CellPhoneDB更加灵活。\nApplicable to single-cell transcriptome data. Compared with the web\nversion, installing and running CellPhoneDB locally is more\nflexible.\n可参考CellPhoneDB的作者发表的这篇Nature Protocol\nhttps://doi.org/10.1038/s41596-020-0292-x\nRefer to the\nauthor published this Nature CellPhoneDB Protocol <\nhttps://doi.org/10.1038/s41596-020-0292-x\n环境设置\nEnvironment Setup\nLoad the R package\nsource(\"install_dependencies.R\")\nlibrary(data.table)\nlibrary(tidyverse)\nlibrary(dplyr)\nlibrary(ggplot2)\n\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息\noptions(stringsAsFactors = FALSE) #禁止chr转成factor\nCellPhoneDB需要在终端（Linux、MAC系统）安装和运行。Windows用户用wsl\nhttps://docs.microsoft.com/en-us/windows/wsl/install-win10\nCellPhoneDB needs to be installed and run on the terminal (Linux or MAC\nsystem). Windows users with WSL <\nhttps://docs.microsoft.com/en-us/windows/wsl/install-win10\n>\n安装CellPhoneDB，参考\nhttps://github.com/Teichlab/cellphonedb\nInstall\nCellPhoneDB, reference <\nhttps://github.com/Teichlab/cellphonedb\n>\n#Installing CellPhoneDB\npython -m venv cpdb-venv\n\n#Activate virtualenv\nsource cpdb-venv/bin/activate\n\n#Install CellPhoneDB\npip install cellphonedb\n输入文件\nInput File\nCellPhoneDB需要两个文件： CellPhoneDB requires two files:\ntest_meta.txt，两列，一列是每个细胞的barcode，一列是对应的细胞类型。\ntest_meta.txt, two columns, one for the barcode of each cell and the\nother for the corresponding cell type.\ntest_counts.txt，表达矩阵。 test_counts.txt, expression matrix.\n文章中raw data下载地址：表达矩阵\nhttps://www.ebi.ac.uk/arrayexpress/files/E-MTAB-6701/E-MTAB-6701.processed.1.zip\nArticle raw data download address: expressing matrix <\nhttps://www.ebi.ac.uk/arrayexpress/files/E-MTAB-6701/E-MTAB-6701.processed.1.zip\n>\nmeta文件\nhttps://www.ebi.ac.uk/arrayexpress/files/E-MTAB-6701/E-MTAB-6701.processed.2.zip\nMeta files <\nhttps://www.ebi.ac.uk/arrayexpress/files/E-MTAB-6701/E-MTAB-6701.processed.2.zip\n>\n经过以下处理，获得test_meta.txt和test_counts.txt文件。 After the\nfollowing processing, the test_meta.txt and test_counts.txt files were\nobtained.\n# test count\nsystem.time(test_counts <- fread(input=\"raw_data_10x.txt\", stringsAsFactors = T))\ntest_counts <- as.data.frame(test_counts)\ntest_counts <- separate(data = test_counts, col=Gene, into = c(\"gene\", \"Gene\"), sep = \"_\")\ntest_counts <- test_counts[,-1]\nfwrite(test_counts, file = \"./test_counts.txt\", sep = \"\\t\")\n\n# test meta\nsystem.time(test_meta <- fread(input=\"meta_10x.txt\", stringsAsFactors = T))\ntest_meta <- as.data.frame(test_meta)\ncolnames(test_meta)[1] <- \"Cell\"\ncolnames(test_meta)[dim(test_meta)[2]] <- \"CellType\"\ntest_meta <- test_meta[,c(\"Cell\",\"CellType\")]\nfwrite(test_meta, file = \"./test_meta.txt\", sep = \"\\t\")\n由于文章raw data太大且没有normalized，因此下面使用小数据演示。 Since\nthe raw data of the article is too large and not normalized, small data\nwill be used for demonstration below.\nRunning CellPhoneDB\ncellphonedb method statistical_analysis test_meta.txt test_counts.txt --iterations=1000 --threads=10\n\n#参数说明：\n#Parameter description\n#--iterations: Number of iterations for the statistical analysis [1000]\n#--threads: Number of threads to use. >=1\n#--counts-data: [ensembl | gene_name | hgnc_symbol] Type of gene identifiers in the counts data，表达矩阵中基因的identifier（identifier of genes in the expression matrix）\n执行完，会在该文件夹下产生一个out文件夹，里面有四个文件means.txt、pvalues.txt、significant_means.txt、deconvoluted.txt\nAfter execution, an “out” folder will be generated under this folder,\nwhich contains four files: means.txt, pvalues.txt,\nsignificant_means.txt, and deconvoluted.txt\n用CellPhoneDB自带的函数画图\nDraw the graph using the built-in functions of CellPhoneDB\ncellphonedb plot dot_plot --output-name dotplot.pdf\n\n#参数说明：\n#--output-path: Output folder [./out]\n#--output-name: Filename of the output plot [plot.pdf]\n直接运行上面命令会画出所有细胞类型之间配体受体对的dotplot，对结果有一个总体的把握。\nRunning the above command directly will draw the dotplot of\nligand-receptor pairs among all cell types, providing an overall grasp\nof the results.\n放到文章里时，只绘制所需的行/列(受体配体对/细胞类型)。一般根据pvalue筛选，结合背景知识选择感兴趣的受体配体对。把希望呈现在图中的受体配体对/细胞类型保存在两个文件中：\nWhen placed in the article, only draw the required rows/columns\n(receptor-ligand pairs/cell types). Generally, based on P-value\nscreening, and in combination with background knowledge, select the\nreceptor and ligand pairs of interest. Save the receptor-ligand\npairs/cell types that you wish to present in the figure in two\nfiles:\neasy_input_rows.txt：选择的受体配体对 easy_input_rows.txt: Selected\nreceptor-ligand pair\neasy_input_columns.txt：选择的互作的细胞类型。\neasy_input_columns.txt: Selected interacting cell type.\n新建in文件夹，将这两个文件夹放置在in文件夹中。 Create a new “in”\nfolder and place these two folders in it.\ncellphonedb plot dot_plot --rows in/easy_input_rows.txt --columns in/easy_input_columns.txt --output-name dotplot_select.pdf\n\n# 也可以只选择受体配体对，画出全部互作的细胞类型\n# It is also possible to select only the receptor-ligand pairs and draw all the interacting cell types\ncellphonedb plot dot_plot --rows in/easy_input_rows.txt --output-name dotplot_select.pdf\ncellphonedb自带的画图函数用了R的ggplot2，我们把画图部分拿出来，根据自己的审美调整更多细节，例如配色。甚至可以加入更多特征。也不拘泥于点图，可顺利对接其他类型的图，可参考FigureYa97correlation的展示方式和画图代码。\nThe built-in plotting function of cellphonedb uses R’s ggplot2. We take\nout the plotting part and adjust more details according to our own\naesthetic preferences, such as color matching. Even more features can be\nadded. It is not limited to point-based graphs and can be smoothly\nintegrated with other types of graphs. You can refer to the display\nmethod and drawing code of FigureYa97correlation.\n提取要画的受体配体对和互作的细胞类型\nExtract the receptor-ligand pairs to be drawn and the cell types\ninteracting with them\n# 加载要画的受体配体对\n# Load the receptor-ligand pairs to be drawn\nselected_rows <- read.table(\"in/easy_input_rows.txt\", header=F, sep=\"\\t\")\nselected_rows <- as.vector(selected_rows$V1)\n\n# 加载要画的互作的细胞类型\n# Load the interacting cell types to be drawn\nselected_columns <- read.table(\"in/easy_input_columns.txt\", header=F,sep=\"\\t\")\nselected_columns <- as.vector(selected_columns$V1)\n\n# 加载受体配体分析结果\n# Loading receptor ligand analysis results\nall_pval = read.table(\"out/pvalues.txt\", header=T, stringsAsFactors = F, sep = '\\t', comment.char = '', check.names=F)\nall_means = read.table(\"out/means.txt\", header=T, stringsAsFactors = F, sep = '\\t', comment.char = '', check.names=F)\n\n# 提取要画的受体配体对和互作的细胞类型\n# Extract the receptor-ligand pairs to be drawn and the cell types interacting with them\nintr_pairs = all_pval$interacting_pair\nall_pval = all_pval[,-c(1:11)]\nall_means = all_means[,-c(1:11)]\nsel_pval = all_pval[match(selected_rows, intr_pairs), selected_columns]\nsel_means = all_means[match(selected_rows, intr_pairs), selected_columns]\n\ndf_names = expand.grid(selected_rows, selected_columns)\npval = unlist(sel_pval)\npval[pval==0] = 0.0009\nplot.data = cbind(df_names,pval)\npr = unlist(as.data.frame(sel_means))\npr[pr==0] = 1\nplot.data = cbind(plot.data,log2(pr))\ncolnames(plot.data) = c('pair', 'clusters', 'pvalue', 'mean')\nhead(plot.data)\n有了plot.data，就可以顺利对接ggplot2，画各种类型的图。 With\nplot.data, it is possible to smoothly connect with ggplot2 and draw\nvarious types of graphs.\n修改自带函数画点图\nModify the built-in function to draw a dot graph\n# 配色\n# Color Matching\nmy_palette <- colorRampPalette(c(\"black\", \"blue\", \"yellow\", \"red\"), alpha=TRUE)(n=399)\n\npdf(\"receptorLigand.pdf\", width = 8, height = 5)\nggplot(plot.data, aes(x=clusters,y=pair)) +\n  geom_point(aes(size=-log10(pvalue),color=mean)) +\n  scale_color_gradientn('Log2 mean (Molecule 1, Molecule 2)', \n                        colors=my_palette) + # 用自定义颜色画点  # Draw dots with custom colors\n  theme_bw() +\n  theme(panel.grid.minor = element_blank(), #不画网格  # No grids\n        panel.grid.major = element_blank(),\n        axis.text=element_text(size=14, colour = \"black\"),\n        axis.text.x = element_text(angle = 90, hjust = 1),\n        axis.text.y = element_text(size=12, colour = \"black\"),\n        axis.title = element_blank(),\n        panel.border = element_rect(size = 0.7, linetype = \"solid\", colour = \"black\")) #边框 # Border\ndev.off()\n用plot.data对接更多类型的图\nConnect more types of graphs with plot.data\n目前展示receptor-ligand结果的经典方式是例文那种点图，其实你也可以结合自己的数据特点，画出更适合自己的图。\nThe classic way to present the results of receptor-ligand at present is\nthe dot graph in the example text. In fact, you can also draw a graph\nthat suits you better based on the characteristics of your own data.\n下面画热图，用’*和**‘标注pvalue。上面得到的’plot.data’可以跟ggplot2顺利对接。画图代码在FigureYa97correlation的基础上修改而来。\nDraw a heat map below and mark the p-value with’* ‘and’* *‘. The\n’plot.data’ obtained above can be smoothly integrated with ggplot2. The\ndrawing code is modified based on FigureYa97correlation.\n# 增加一列，区分p值的大小。\n# Add a column to distinguish the magnitude of the p-value.\n# 使用两个ifelse实现三分类\n# Implement three-category using two if-else statements\nplot.data$pstar <- ifelse(plot.data$pvalue < 0.05,\n                     ifelse(plot.data$pvalue < 0.01,\"**\",\"*\"),\n                     \"\")\nplot.data$pstar[1:20]\nggplot(plot.data, aes(clusters, pair)) + \n  geom_tile(aes(fill = mean), colour = \"white\",size=1)+\n  scale_fill_gradientn(colours = my_palette) + #用例文的配色 # Use the color scheme of the example text\n  geom_text(aes(label=pstar),col =\"black\",size = 5)+\n  theme_minimal()+ #不要背景  # No background Required\n  theme(axis.title.x=element_blank(), #不要title  # No title\n        axis.ticks.x=element_blank(), #不要x轴  # do not use the X-axis\n        axis.title.y=element_blank(), #不要y轴  # do not use the Y-axis\n        axis.text.x = element_text(angle = 45, hjust = 1), #调整x轴文字 # Adjust the text on the X-axis\n        axis.text.y = element_text(size = 8))+ #调整y轴文字 # Adjust the Y-axis text\n  #调整legend \n  # Adjust legend\n  labs(fill =paste0(\" * p < 0.05\",\"\\n\\n\",\"** p < 0.01\",\"\\n\\n\",\"Log2 mean (Molecule 1, Molecule 2)\"))\n#保存到文件 \n# Save to file\nggsave(\"receptorLigand_plus.pdf\", width = 8, height = 4)\n后期处理\nPost-processing\n输出的pdf文件是矢量图，可以用Illustrator等工具打开，添加虚线，修改受体配体文字的颜色。\nThe output pdf file is a vector graphic, which can be opened with tools\nsuch as Illustrator, dotted lines can be added, and the color of the\nreceptor and ligand text can be modified.\n图中两种细胞类型之间用’|‘分隔，可以参考例文的方式手动修改。 The two\ncell types in the figure are separated by’/’, which can be manually\nmodified by referring to the example text.\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa178receptorLigand_FigureYa178receptorLigand",
      "title": "FigureYa178receptorLigand/FigureYa178receptorLigand.html",
      "html": "FigureYa178receptorLigand/FigureYa178receptorLigand.html",
      "text": "texts/main_FigureYa178receptorLigand_FigureYa178receptorLigand.txt",
      "folder": "FigureYa178receptorLigand",
      "thumb": "gallery_compress/FigureYa178receptorLigand.webp"
    },
    "word_count": 1335,
    "lines_count": 276,
    "title": "FigureYa178receptorLigand",
    "description": "Requirement 用本地CellPhoneDB分析配体-受体，用ggplot2重新画图。 Ligand-receptor analysis was performed using local CellPhoneDB, and the plot was redrawn",
    "input_data_types": [
      "单细胞",
      "突变数据",
      "表达矩阵",
      "RNA-seq"
    ],
    "output_types": [
      "散点图",
      "热图",
      "统计表格",
      "网络图"
    ],
    "technical_methods": [],
    "biology_areas": [
      "免疫学"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "colour",
      "header",
      "width",
      "n",
      "pvalue",
      "colours",
      "sel_means",
      "col"
    ]
  },
  {
    "id": "main_FigureYa311PAM50Heatmap_FigureYa311PAM50Heatmap",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa311PAM50Heatmap_FigureYa311PAM50Heatmap.txt",
    "content": "FigureYa311PAM50Heatmap\nFigureYa311PAM50Heatmap\nAuthor(s)\n: Xiaofan Lu; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-10-04\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\nIf you use circlize in published research, please cite:\nGu, Z. circlize implements and enhances circular visualization in R.\nBioinformatics 2014.\n需求描述\nDemand description\n作者根据PAM50乳腺癌分子分型方法进行了改良，在分类前从训练集和质心分数中移除\nHer2 和 Normal 样本，从而将分类限制为 LumA、LumB 和\nBasal。同时比较了这三个亚型在雄激素受体（AR）,神经内分泌（NE）得分，CCP，FGF-MEK签名，以及作者之前建立有关神经内分泌前列腺癌的6种分型（phenotype）间的差异热图。\nThe authors modified the PAM50 molecular subtyping method for breast\ncancer by removing Her2 and Normal samples from the training set and\ncentroid scores before classification, thereby restricting the\nclassification to LumA, LumB, and Basal subtypes. They also compared the\ndifferences among these three subtypes in terms of androgen receptor\n(AR) expression, neuroendocrine (NE) scores, CCP, FGF-MEK signature, and\nthe previously established six phenotypes related to neuroendocrine\nprostate cancer through a heatmap analysis.\n出自：\nhttps://aacrjournals.org/clincancerres/article/28/14/3127/706873/Therapeutic-Implications-for-Intrinsic-Phenotype\n图1.\n转移性前列腺癌的PAM50分型与雄激素受体（AR）活性、增殖及基因型相关。 A.\nPAM50分型将SU2C队列中的mCRPC（转移性去势抵抗性前列腺癌）肿瘤划分为LumA、LumB和Basal亚型。倍数差异标度反映RNA测序（RNAseq）的均值中心化log2\nFPKM值。分子特征评分及表型显示在图表顶部，并依据右侧图例进行颜色标注。\nSource:\nhttps://aacrjournals.org/clincancerres/article/28/14/3127/706873/Therapeutic-Implications-for-Intrinsic-Phenotype\nFigure 1. PAM50 classification of metastatic prostate cancer\nassociates with AR activity, proliferation, and genotype. A, PAM50\nclassification partitions mCRPC tumors from the SU2C cohort into LumA,\nLumB, and Basal subtypes. Fold difference scale reflects mean-centered\nlog2 FPKM values from RNAseq. Molecular signature scores and phenotypes\nshown at the top of plot and colored according to legends at the right\nside.\n应用场景\nApplication scenarios\nPAM50分型原本有5个，例文作者根据自己的研究对象的特点，仅用其中三类：LumA、LumB和\nBasal，从训练集和质心分数中移除了另外两类：Her2和Normal的样本。你也可以根据自己的研究兴趣灵活取舍。\n我们有7个FigureYa用到过PAM50分型: FigureYa284pairwiseLogrank,\nFigureYa151pathifier, FigureYa277Immunomodulator, FigureYa219GMM,\nFigureYa169sigHeatmap, FigureYa229PCOA, FigureYa287L2logV2\nThe PAM50 classification originally includes five subtypes, but the\nauthors of the example study tailored it to their research focus by\nusing only three subtypes—LumA, LumB, and Basal—while removing the other\ntwo (Her2 and Normal) from both the training set and centroid scores.\nYou can also flexibly select subtypes based on your research\ninterests.\nWe have previously applied the PAM50 classification in seven of our\nFigureYa analyses: FigureYa284pairwiseLogrank, FigureYa151pathifier,\nFigureYa277Immunomodulator, FigureYa219GMM, FigureYa169sigHeatmap,\nFigureYa229PCOA, FigureYa287L2logV2\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\n# 用于获取乳腺癌PAM50分型\n# For breast cancer PAM50 subtyping\nlibrary(genefu)\n# 用于获得ENTREZID\n# For ENTREZID conversion\nlibrary(AnnotationDbi)\n# 人类基因组注释数据库\n# Human genome annotation database\nlibrary(org.Hs.eg.db) \n\n# 基因集变异分析 (signature scoring)\n# Gene Set Variation Analysis (signature scoring)\nlibrary(GSVA) \n\n# 热图可视化\n# Heatmap visualization\nlibrary(ComplexHeatmap) # 用于画图\n# 用它的配色方案\n# Color scheme utilities\nlibrary(circlize)\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n输入文件\nInput Files\ndata_mrna_seq_fpkm_polya.txt，表达矩阵。\neasyinput_signature.txt，基因签名，用于计算图中的Molecular signature\nscores\n，即AR、NE、CCP、FGF-MEK签名。出自ccr-21-4289_supplementary_tables_ts1-13_suppts1-13.xlsx里的Table\nS13。可以替换成自己感兴趣的签名。\neasyinput_clin.txt，样本分组信息，对应图中的Phenotype。其中Sample列里是样本名，跟表达矩阵的列名一致。出自ccr-21-4289_supplementary_tables_ts1-13_suppts1-13.xlsx里的Table\nS1。可以替换成自己想要对比展示的注释信息。\ndata_mrna_seq_fpkm_polya.txt - Expression matrix.\neasyinput_signature.txt - Gene signatures used to calculate the\nMolecular signature scores (AR, NE, CCP, FGF-MEK signatures) in the\nfigures. Derived from Table S13 in\nccr-21-4289_supplementary_tables_ts1-13_suppts1-13.xlsx. Can be replaced\nwith signatures of interest.\neasyinput_clin.txt - Sample grouping information, corresponding to\nthe Phenotype in the figures. The Sample column contains sample names,\nmatching the column names in the expression matrix. Derived from Table\nS1 in ccr-21-4289_supplementary_tables_ts1-13_suppts1-13.xlsx. Can be\nreplaced with custom annotation data for comparative analysis.\n# 读取原文表达谱\n# Load original expression matrix\n#eset <- read.table(\"data_mrna_seq_fpkm_polya.txt\", header = T, sep = \"\\t\", check.names = F)\neset <- read.table(unz(\"data_mrna_seq_fpkm_polya.txt.zip\", \"data_mrna_seq_fpkm_polya.txt\"), \n                   header = TRUE, sep = \"\\t\", check.names = FALSE)\n\n# 去掉重名基因\n# Remove duplicate genes\neset <- eset[!duplicated(eset$Hugo_Symbol), ] \n\nrownames(eset) <- eset$Hugo_Symbol; eset$Hugo_Symbol <- NULL\n\n# 表达谱Log2转化\n# Log2-transform expression values\neset <- log2(eset + 1) \n\n# 读取基因签名\n# Load gene signatures\nsignature <- read.table(\"easyinput_signature.txt\", header = T, sep = \"\\t\")\nsignature <- split(signature$Gene.Symbol, signature$Signature)\n\n# 加载临床注释数据\n# Load clinical annotation data\nclin <- read.table(\"easyinput_clin.txt\", header = T, sep = \"\\t\")\nclin <- clin[match(colnames(eset), clin$Sample) , ]\nPAM50分型\nPAM50 Classification\n使用genefu包进行PAM50分型，并只保留LumA，LumB和Basal亚型。\nThe genefu R package was used to perform PAM50 molecular subtyping,\nwith only the LumA, LumB, and Basal subtypes retained for downstream\nanalysis.\nsubtype.to.predict <- c(\"LumA\", \"LumB\", \"Basal\")\ndata(pam50.robust)\n\n#过滤质心矩阵，只保留目标子类型\n# Filter centroids matrix to retain only target subtypes  \npam50.robust$centroids <- pam50.robust$centroids[, subtype.to.predict] \n\n# 构建注释\n# Create annotation dataframe  \neannot <- data.frame( \n  row.names = rownames(eset),\n  \"probe\" = rownames(eset),\n  \"Gene.Symbol\" = rownames(eset)\n)\n\n# 检索获得Gene Symbol对应的ENTREZID\n# Map Gene Symbols to ENTREZ IDs  \ntmp <- AnnotationDbi::select(x = org.Hs.eg.db, keys = rownames(eset), columns = \"ENTREZID\", keytype = \"SYMBOL\")\neannot$EntrezGene.ID <- tmp$ENTREZID[match(eannot$Gene.Symbol, tmp$SYMBOL)]\n\n# 采用单样本预测器(SSP)方法鉴定乳腺癌分子亚型\"\n# identify breast cancer molecular subtypes using the Single Sample Predictor (SSP)\npam50.predict <- intrinsic.cluster.predict(sbt.model = pam50.robust, \n                                           data = t(eset), \n                                           annot = eannot, \n                                           do.mapping = T)\n\n# 计算Molecular signature scores\n# Calculate molecular signature scores  \nparam <- gsvaParam(\n  exprData = as.matrix(eset),  \n  geneSets = signature        \n)\n\ngs.score <- gsva(param)\n开始画图\nPlotting\n# 构建样本信息注释\n# Create sample annotation metadata\nsampleInfo <- data.frame(\n  row.names = colnames(eset),\n  \"PAM50\" = pam50.predict$subtype,\n  \"AR.signature\" = gs.score[\"AR\", ],\n  \"NE.signature\" = gs.score[\"NE\", ],\n  \"CCP.signature\" = gs.score[\"CCP\", ],\n  \"FGF-MEK.signature\" = gs.score[\"FGF-MEK\", ],\n  \"Phenotype\" = clin$polyA_phenotype\n)\n\n# 绘制热图\n# Generate heatmap visualization\npam50.gene <- pam50.robust$centroids.map$probe\nplot.data <- t(scale(t(eset[intersect(pam50.gene, rownames(eset)), ]), center = T, scale = F)) \nplot.data[plot.data > 4] = 4; plot.data[plot.data< (-4) ] = -4 \n\nsampleInfo$PAM50 <- factor(sampleInfo$PAM50, levels = c(\"LumA\", \"LumB\", \"Basal\"))\n\ncell.col = c(\"#ADD9E3\", \"#3B5CCC\", \"#000000\", \"#C6C706\", \"#FDFB0B\")\nPAM50.col = c(\"LumA\" = \"#395790\", \"LumB\" = \"#6BBD2A\", \"Basal\" = \"#FFA652\")\ngsva.col = colorRamp2(breaks = c(-1, 0, 1), colors = c(\"#170B88\", \"#FFFFFF\", \"#D23C30\"))\npheno.col = c(\"ARlow_NEneg\" = \"#8029CE\", \"ARneg_NElow\" = \"#07C7CF\", \"ARneg_NEneg\" = \"#3D62CD\",\n              \"ARneg_NEpos\" = \"#EDAE11\", \"ARpos_NEneg\" = \"#478D06\", \"ARpos_NEpos\" = \"#CE0706\")\n\ncol_ha <- columnAnnotation(\n  df = sampleInfo,\n  col = list(\"PAM50\" = PAM50.col, \n             \"AR.signature\" = gsva.col,\n             \"NE.signature\" = gsva.col,\n             \"CCP.signature\" = gsva.col,\n             \"FGF.MEK.signature\" = gsva.col,\n             \"Phenotype\" = pheno.col),\n  annotation_name_side = \"left\"\n)\n\nhm = Heatmap(plot.data, \n             col = cell.col, \n             name = \"Fold Change\", \n             cluster_columns = F, \n             cluster_rows = T, \n             cluster_column_slices = F,\n             column_split = sampleInfo$PAM50,\n             show_column_names = F, \n             show_row_names = T, \n             row_names_side = \"left\",\n             show_column_dend = F, \n             show_row_dend = F,\n             top_annotation = col_ha)\n\ndraw(hm)\n# 保存热图\n# Export heatmap to PDF\npdf(\"logFC.PAM50Heatmap.pdf\", width = 10, height = 8)\ndraw(hm)\ninvisible(dev.off())\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa311PAM50Heatmap_FigureYa311PAM50Heatmap",
      "title": "FigureYa311PAM50Heatmap/FigureYa311PAM50Heatmap.html",
      "html": "FigureYa311PAM50Heatmap/FigureYa311PAM50Heatmap.html",
      "text": "texts/main_FigureYa311PAM50Heatmap_FigureYa311PAM50Heatmap.txt",
      "folder": "FigureYa311PAM50Heatmap",
      "thumb": "gallery_compress/FigureYa311PAM50Heatmap.webp"
    },
    "word_count": 940,
    "lines_count": 240,
    "title": "FigureYa311PAM50Heatmap",
    "description": "Demand description 作者根据PAM50乳腺癌分子分型方法进行了改良，在分类前从训练集和质心分数中移除 Her2 和 Normal 样本，从而将分类限制为 LumA、LumB 和",
    "input_data_types": [
      "表达矩阵",
      "临床数据",
      "DNA-seq"
    ],
    "output_types": [
      "热图",
      "统计表格"
    ],
    "technical_methods": [
      "生存分析"
    ],
    "biology_areas": [
      "癌症研究",
      "神经科学"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "keytype",
      "annot",
      "header",
      "center",
      "show_row_dend",
      "show_row_names",
      "cluster_column_slices",
      "width",
      "cluster_columns"
    ]
  },
  {
    "id": "main_FigureYa224scMarker_FigureYa224scMarker",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa224scMarker_FigureYa224scMarker.txt",
    "content": "FigureYa224scMarker\nFigureYa224scMarker\nYangding Zheng\n2025-5-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n这篇NC单细胞展示比例和marker基因的图很好看啊\nRequirement Description\nThis diagram of NC single-cell display ratio and marker gene is very\ngood.\n出自\nhttps://www.nature.com/articles/s41467-020-16164-1\nfrom\nhttps://www.nature.com/articles/s41467-020-16164-1\nFig. 3 Tumor endothelial cells and myofibroblasts promoting\nangiogenesis and tissue remodeling. a tSNE plot of endothelial cells,\ncolor-coded by clusters and cell subsets as indicated. EPCs: endothelial\nprogenitor cells. b Three-layered complex heatmap of\nselected\nendothelial cell marker genes\nin each cell cluster. Top: Mean\nexpression of known lineage markers. Middle: Tissue preference of each\ncluster; Bottom: Relative expression map of known marker genes\nassociated with each cell subset. Mean expression values are scaled by\nmean-centering, and transformed to a scale from -2 to 2. c\nAverage cell number and relative proportion\nof EC\nsubsets from tissues of each origin. nLung, n = 11 samples; tLung, n =\n11 samples; tL/B, n = 3 samples; mLN, n = 2 samples; mBrain, n = 9\nsamples.\n应用场景\n单细胞数据展示细胞比例和marker基因。\nApplication Scenarios\nSingle-cell data showing cell ratios and marker genes.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nlibrary(dplyr)\nlibrary(Seurat)\nlibrary(patchwork)\nlibrary(reshape2)\nlibrary(RColorBrewer)\nlibrary(scales)\nlibrary(ggplot2)\nlibrary(ggpubr)\nlibrary(ggplotify)\nlibrary(pheatmap)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # error messages are displayed in English\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # chr is not allowed to be converted to factor\n输入文件及预处理\n以Seurat官网PBMC数据为例，跟FigureYa111markerGene和FigureYa160scGSVA用的是同一套数据，出自不同作者之手，可相互参考。\n下载\nhttps://cf.10xgenomics.com/samples/cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz\n，解压到当前文件夹。\n预处理过程参考\nhttps://satijalab.org/seurat/v3.2/pbmc3k_tutorial.html\nInput files and preprocessing\nTaking the PBMC data on the official website of Seurat as an example,\nit uses the same set of data as FigureYa111markerGene and\nFigureYa160scGSVA, which are from different authors and can be\ncross-referenced.\nDownload the\nhttps://cf.10xgenomics.com/samples/cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz\nand extract it to the current folder.\nRefer to\nhttps://satijalab.org/seurat/v3.2/pbmc3k_tutorial.html\nfor the pretreatment process\ntar -zxvf pbmc3k_filtered_gene_bc_matrices.tar.gz\nplot_wd <- \"plot_result/\"\ndir.create(plot_wd)\n# Load the PBMC dataset\npbmc.data <- Read10X(data.dir = \"filtered_gene_bc_matrices/hg19/\")\n# Initialize the Seurat object with the raw (non-normalized data).\npbmc <- CreateSeuratObject(counts = pbmc.data, project = \"pbmc3k\", min.cells = 3, min.features = 200)\npbmc\n# 进行QC\n# 计算mitochondria基因比例\n# Perform QC\n# Calculate the mitochondria gene ratio\npbmc[[\"percent.mt\"]] <- PercentageFeatureSet(pbmc, pattern = \"^MT-\")\n\n# Visualize QC metrics as a violin plot\nVlnPlot(pbmc, features = c(\"nFeature_RNA\", \"nCount_RNA\", \"percent.mt\"), ncol = 3)\nplot1 <- FeatureScatter(pbmc, feature1 = \"nCount_RNA\", feature2 = \"percent.mt\")\nplot2 <- FeatureScatter(pbmc, feature1 = \"nCount_RNA\", feature2 = \"nFeature_RNA\")\nplot1 + plot2\n# Normalizing the data\npbmc <- NormalizeData(pbmc, normalization.method = \"LogNormalize\", scale.factor = 10000)\n#Identification of highly variable features\npbmc <- FindVariableFeatures(pbmc, selection.method = \"vst\", nfeatures = 2000)\n# Identify the 10 most highly variable genes\n# top10 <- head(VariableFeatures(pbmc), 10)\n# plot variable features with and without labels\n# plot1 <- VariableFeaturePlot(pbmc)\n# plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)\n# plot1 + plot2\n\n# Scale the data\nall.genes <- rownames(pbmc)\npbmc <- ScaleData(pbmc, features = all.genes)\n# Perform linear dimensional reduction\npbmc <- RunPCA(pbmc, features = VariableFeatures(object = pbmc))\n#print(pbmc[[\"pca\"]], dims = 1:5, nfeatures = 5)\nVizDimLoadings(pbmc, dims = 1:2, reduction = \"pca\")\nDimPlot(pbmc, reduction = \"pca\")\nDimHeatmap(pbmc, dims = 1:15, cells = 500, balanced = TRUE)\n# NOTE: This process can take a long time for big datasets, comment out for expediency. More\n# approximate techniques such as those implemented in ElbowPlot() can be used to reduce\n# computation time\n\n##以下酌情运行，比较耗时，可以不运行，直接看ElbowPlot\n## The following is run as appropriate, it is more time-consuming, you can not run it, and directly look at ElbowPlot\n#pbmc <- JackStraw(pbmc, num.replicate = 100)\n#pbmc <- ScoreJackStraw(pbmc, dims = 1:20)\n#JackStrawPlot(pbmc,dims = 1:20)\nElbowPlot(pbmc)\nElbowPlot对主要PC进行排序，“拐弯”处之前的PC均可被选择，这里看到第10个PC处出现拐点，所以后续选择前10个PC进行降维\nElbowPlot sorts the main PCs, and the PCs before the “bend” can be\nselected, and here we see that there is an inflection point at the 10th\nPC, so the first 10 PCs are selected for dimensionality reduction\n# Cluster the cells\npbmc <- FindNeighbors(pbmc, dims = 1:10)\npbmc <- FindClusters(pbmc, resolution = 0.5)\n#Run non-linear dimensional reduction (UMAP/tSNE)\npbmc <- RunUMAP(pbmc, dims = 1:10)\npA1 <- DimPlot(pbmc, reduction = \"umap\", label=T)+ NoLegend()\nggsave(paste0(plot_wd,\"plotA_1_UMAP_cluster.pdf\"), plot = pA1, width = 6, height = 6)\n# Finding differentially expressed features (cluster biomarkers)\n# find markers for every cluster compared to all remaining cells, report only the positive ones\npbmc.markers <- FindAllMarkers(pbmc, only.pos = TRUE, min.pct = 0.25, logfc.threshold = 0.25)\n# pbmc.markers %>% group_by(cluster) %>% top_n(n = 2, wt = avg_logFC)\n\n# 查看top10 marker gene\n# View the top 10 marker gene\ntop10 <- pbmc.markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_log2FC)\nDoHeatmap(pbmc, features = top10$gene) + NoLegend()\n结合每个cluster的marker基因和生物学知识确定细胞类型，顺便画图A\n为了接近真实情况并结合示例数据，这里不将细胞类型划分得这么详细，进行以下更改：\nDetermine the cell type by combining the marker gene and biological\nknowledge of each cluster, and draw Figure A by the way\nIn order to get close to the real situation and combine the example\ndata, the cell types are not divided into such details here, and the\nfollowing changes are made:\n# 给每个cluster标注细胞类型\n# Label each cluster with cell types\nnew.cluster.ids <- c(\"T\", \"Mono\", \"T\", \"B\", \"T\", \"Mono\", \"NK\", \"DC\", \"Platelet\")\nnames(new.cluster.ids) <- levels(pbmc)\npbmc <- RenameIdents(pbmc, new.cluster.ids)\n\n# 添加细胞类型至meta data\n# Add cell types to meta data\npbmc@meta.data$celltype <- pbmc@active.ident\nDimPlot(pbmc, reduction = \"umap\", label = TRUE, pt.size = 0.5) + NoLegend()\npA2 <-  pA2 <- DimPlot(pbmc, reduction = \"umap\", label=F,group.by=\"celltype\")\nggsave(paste0(plot_wd,\"plotA_1_UMAP_celltype.pdf\"), plot = pA2, width = 6, height = 6)\n\n# 自定义颜色\n# Custom colors\ncolourCount = length(unique(pbmc@meta.data$celltype))\ngetPalette = colorRampPalette(brewer.pal(8, \"Dark2\"))\ncelltype_colors <- getPalette(colourCount)\n\npA2 <-  pA2 <- DimPlot(pbmc, reduction = \"umap\", label=F,group.by=\"celltype\",cols=celltype_colors)\nggsave(paste0(plot_wd,\"plotA_1_UMAP_celltype_color.pdf\"), plot = pA2, width = 6, height = 6)\n\n## 拼图\n## Puzzles\npA_all <- pA1 + pA2 + plot_layout(ncol = 2, widths=c(1, 1))\nggsave(paste0(plot_wd,\"plotA_all.pdf\"), plot = pA_all, width = 12, height = 6)\n\ncelltype <- c(\"T\",\"Mono\",\"B\",\"NK\",\"DC\",\"Platelet\")\npbmc@meta.data$celltype <- factor(pbmc@meta.data$celltype, levels = celltype)\n\n## 为了符合真实情况（大多数数据来自多个样本）和原文数据中的sample type，这里模拟一个数据，为pbmc数据中加入sample信息\n## In order to match the real situation (most of the data comes from multiple samples) and the sample type in the article data, here simulate a data and add sample information to the PBMC data\nsample_type <- c(\"nLung\",\"tLung\",\"tL/B\",\"mLN\",\"mBrain\")\n\n### 设置set.seed方便重复\n### Set set.seed for easy repetition\nset.seed(1)\npbmc@meta.data$sample <- sample(sample_type,  nrow(pbmc@meta.data), replace = TRUE)\npbmc@meta.data$sample <- factor(pbmc@meta.data$sample, levels = sample_type)\n\n## 从上述标注细胞类型信息可知0,2,4属于T，1,5属于Mono，3属于B，6属于NK，7属于DC，8属于Platelet\n## 所以设定cluster为factor，levels=c(0,2,4,1,5,3,6,7,8)\n## From the above annotated cell type information, it can be seen that 0,2,4 belong to T, 1,5 belong to Mono, 3 belong to B, 6 belong to NK, 7 belong to DC, and 8 belong to Platelet\n## So set cluster to factor,levels=c(0,2,4,1,5,3,6,7,8)\ncluster <- c(0,2,4,1,5,3,6,7,8)\npbmc@meta.data$seurat_clusters <- factor(pbmc@meta.data$seurat_clusters,levels=cluster)\nsaveRDS(pbmc, \"pbmc_test_final.rds\")\n画图B - marker gene\n图B主要由三部分组成，最上部的克利夫兰图（棒棒糖图），中部的bar图和下部的热图\n先画上部棒棒糖图，用来展示Mean expression of known lineage\nmarkers\nDraw B - marker gene\nFigure B is mainly composed of three parts, the uppermost Cleveland\ndiagram (lollipop diagram), the middle bar diagram, and the lower heat\nmap\nDraw the upper lollipop diagram to show the Mean expression of known\nlineage markers\n#选择四个基因进行平均表达量展示\n# Four genes were selected for average expression\n\nselect_gene <- c(\"CD3E\",\"MS4A1\",\"GNLY\",\"CD14\")\nIdents(pbmc) <- \"seurat_clusters\"\nAveExpression <- AverageExpression(pbmc, assays = \"RNA\", features = select_gene,verbose = TRUE) %>% .$RNA\nAve_df <- melt(AveExpression,id.vars= \"Gene\")\ncolnames(Ave_df) <- c(\"Gene\", \"Cluster\", \"Expression\")\nAve_df$Group <- paste(Ave_df$Cluster,Ave_df$Gene,sep = \"_\")\nAve_df$Expression[which(Ave_df$Expression>10)] <- 10 ####设置平均表达量大于10的值为10，放置画出来的bar太高，按照自己数据情况设定\n#### Set the average expression value greater than 10 to 10, and place the drawn bar too high, set it according to your own data\n\npB1 <- ggplot(Ave_df,aes(x=rownames(Ave_df), y=Expression))+\n  geom_hline(yintercept = seq(0, 10, 2.5),linetype = 2, color = \"lightgray\",size=1)+\n  geom_line()+\n  geom_segment(aes(x=rownames(Ave_df),xend=rownames(Ave_df),y=0,yend=Expression),color=\"lightgray\",size = 1.5)+\n  geom_point(size=3,aes(color=rownames(Ave_df)))+\n  scale_color_manual(values=c(\"#00AFBB\", \"#E7B800\", \"#FC4E07\", \"#41ab5d\")) +\n  theme_bw()+\n  theme(panel.grid =element_blank()) +\n  labs(x=\"\",y=\"Gene exp.\")\npB1 <- facet(pB1, facet.by = \"Cluster\",ncol = length(unique(Ave_df$Cluster)),panel.labs.font = list(size = 12),panel.labs.background = list(fill = \"#a6cee3\"))\n\npB1 <- pB1 + scale_y_continuous(position = \"right\")+  ####用来将y轴移动位置 #### Used to move the y-axis in position\n  theme(axis.text.y = element_text(size=12, colour = \"black\"))+\n  theme(axis.text.x = element_blank())+ ## 删去所有刻度标签# theme(axis.text.y = element_blank())   ## 设置 axis.text.y 则只删去 Y 轴的刻度标签，X 轴同理。 ## If you set axis.text.y, only the tick label for the Y axis will be removed, and the same will be true for the X axis.\n  theme(axis.title.y = element_text(size=12, colour = \"black\"))+\n  theme(axis.title.x = element_blank())+\n  theme(legend.position = \"right\",\n        panel.border = element_blank(),## 去掉最外层的正方形边框 ## Remove the outermost square border\n        axis.ticks.x = element_line(color =  NA))\n\npB1\n下面来画中部的bar图，用来展示Tissue preference of each cluster\nLet’s draw a bar diagram in the middle to show the Tissue preference\nof each cluster\npB2_df <- table(pbmc@meta.data$seurat_clusters,pbmc@meta.data$sample) %>% melt()\ncolnames(pB2_df) <- c(\"Cluster\",\"Sample\",\"Number\")\npB2_df$Cluster <- factor(pB2_df$Cluster,levels = cluster)\n\nsample_color <- c(\"#d95f02\",\"#66a61e\",\"#1b9e77\",\"#e7298a\",\"#386cb0\")\npB2 <- ggplot(data = pB2_df, aes(x = Cluster, y = Number, fill = Sample)) +\n  geom_bar(stat = \"identity\", width=0.8,position=\"fill\")+\n  scale_fill_manual(values=sample_color) +\n  theme_bw()+\n  theme(panel.grid =element_blank()) +\n  labs(x=\"\",y=\"Ratio\")+\n  scale_y_continuous(position = \"right\",labels = percent)+  ####用来将y轴移动位置\n  theme(axis.text.y = element_text(size=12, colour = \"black\"))+\n  theme(axis.text.x = element_text(size=12, colour = \"black\"))\npB2\n接下来用pheatmap绘制下部热图，展示Relative expression map of known\nmarker genes associated with each cell subset.\nNext, the lower heat map is drawn with pheatmap to show the Relative\nexpression map of known marker genes associated with each cell\nsubset.\nrequire(ggplotify)\npB3 = as.ggplot(ph3) ### 将pheatmap对象转为ggplot对象，便于后续拼图 ### Convert the pheatmap object to a ggplot object for easy follow-up puzzles\n拼图 puzzle\npB_1_2 <- pB1 + pB2 + plot_layout(ncol = 1, heights = c(1, 2))\n## 尝试将热图也拼在一起，发现并不能完全对，后期用AI拼效果更好\n## I tried to put the heat map together, but I found that it was not completely right, and it was better to use AI to spell it later\n## pB_all <- pB1 + pB2 + pB3 + plot_layout(ncol = 1, heights = c(1, 2,3))\npB_1_2\nggsave(paste0(plot_wd,\"plotB_3_heatmap.pdf\"), plot = pB3, width = 8, height = 7)\n后期用AI拼效果更好。输出到pdf文件都是矢量图，可以用Illustrator等矢量图软件打开，编辑文字、图形等。\n画图C - Average cell number and relative proportion\nIn the later stage, it is better to use AI to spell the effect. The\noutput to pdf files is all vector graphics, which can be opened with\nvector software such as Illustrator to edit text, graphics, etc.\nPaint C - Average cell number and relative proportion\ndata_plotC <- table(pbmc@meta.data$sample, pbmc@meta.data$celltype) %>% melt()\ncolnames(data_plotC) <- c(\"Sample\", \"CellType\",\"Number\")\n\npC1 <- ggplot(data = data_plotC, aes(x = Sample, y = Number, fill = CellType)) +\n  geom_bar(stat = \"identity\", width=0.8,aes(group=CellType),position=\"stack\")+\n  scale_fill_manual(values=celltype_colors) +\n  theme_bw()+\n  theme(panel.grid =element_blank()) +\n  labs(x=\"\",y=\"Average number\")+\n  theme(axis.text = element_text(size=12, colour = \"black\"))+\n  theme(axis.title.y = element_text(size=12, colour = \"black\"))+\n  theme(panel.border = element_rect(size = 1, linetype = \"solid\", colour = \"black\"))+\n  theme(axis.text.x = element_text(angle = 45,hjust = 0.8,  vjust = 0.6))\npC2 <- ggplot(data = data_plotC, aes(x = Sample, y = Number, fill = CellType)) +\n  geom_bar(stat = \"identity\", width=0.8,aes(group=CellType),position=\"fill\")+\n  scale_fill_manual(values=celltype_colors) +\n  theme_bw()+\n  theme(panel.grid =element_blank()) +\n  labs(x=\"\",y=\"Cell proportion\")+\n  scale_y_continuous(labels = percent)+  ####用来将y轴移动位置 #### Used to move the y-axis in position\n  theme(axis.text = element_text(size=12, colour = \"black\"))+\n  theme(axis.title.y = element_text(size=12, colour = \"black\"))+\n  theme(panel.border = element_rect(size = 1, linetype = \"solid\", colour = \"black\"))+\n  theme(axis.text.x = element_text(angle = 45,hjust = 0.8,  vjust = 0.6))      #让横轴上的标签倾斜45度 # Tilt the label on the horizontal axis 45 degrees\n\npC <- pC1 + pC2 + plot_layout(ncol = 2, widths = c(1,1),guides = 'collect')\n\npC\nggsave(paste0(plot_wd,\"plotC.pdf\"), plot = pC, width = 7, height = 5)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa224scMarker_FigureYa224scMarker",
      "title": "FigureYa224scMarker/FigureYa224scMarker.html",
      "html": "FigureYa224scMarker/FigureYa224scMarker.html",
      "text": "texts/main_FigureYa224scMarker_FigureYa224scMarker.txt",
      "folder": "FigureYa224scMarker",
      "thumb": "gallery_compress/FigureYa224scMarker.webp"
    },
    "word_count": 1777,
    "lines_count": 308,
    "title": "FigureYa224scMarker",
    "description": "这篇NC单细胞展示比例和marker基因的图很好看啊 Requirement Description This diagram of NC single-cell display ratio and marker gene is very",
    "input_data_types": [
      "临床数据",
      "单细胞"
    ],
    "output_types": [
      "箱线图",
      "热图",
      "统计表格",
      "PCA图",
      "散点图"
    ],
    "technical_methods": [
      "标准化"
    ],
    "biology_areas": [
      "癌症研究",
      "药物研究",
      "神经科学"
    ],
    "complexity_level": "高级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "pos",
      "colour",
      "values",
      "width",
      "grid",
      "n",
      "xend",
      "heights"
    ]
  },
  {
    "id": "main_FigureYa176BlandAltman_FigureYa176BlandAltman",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa176BlandAltman_FigureYa176BlandAltman.txt",
    "content": "FigureYa176BlandAltman\nFigureYa176BlandAltman\nAuthor(s)\n: Xiaofan Lu\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement\n作者用Bland-Altman的方法比较了自己建立的模型和传统的模型的一致性。网上找了下，好像没有可以重复这个的代码。\nThe author compared the consistency between the model he established and\nthe traditional model using the Bland-Altman method. I searched online\nand it seems there’s no code that can repeat this.\n出自\nhttps://www.sciencedirect.com/science/article/pii/S2352396420300992\nfromhttps://www.sciencedirect.com/science/article/pii/S2352396420300992\nFigure S1. Bland-Altman plots reveal consistency between the V-Net\nderived segmentation and the gold standard. The differences (y-axis) are\nplotted versus the average (x-axis) of two appraisers (i.e., the\nposition of the plan-box in the testing set and gold standard) for\npulmonary apex, basis, left and right boundary in Bland-Altman plot a)\nto d), respectively. Slopes are calculated by linear regression of\ndifferences on average and the corresponding statistical P values are\nprovided for testing a constant difference based on a null\nhypothesis—the slope equals to 0. Critical difference is ‘two’ times\nstandard deviation of differences, equals half the difference of lower\nand upper limit.\n应用场景\nApplication Scenarios\nBland-Altman\nplot用于比较不同evaluation之间的agreement，并进行一致性(斜率)检验。 The\nBland-Altman plot was used to compare the agreements among different\nevaluations and to conduct consistency (slope) tests.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(BlandAltmanLeh)\nlibrary(MethComp)\nlibrary(smatr)\n\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # Display an English error message\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # prohibit chr from being converted to factor\n自定义函数绘制BAplot并做斜率检验 A custom function is used to draw\nBAplot and perform slope tests\nBA.baseplot <- function(measurement1 = NULL, # 方法一的结果 # the result of Method one\n                        measurement2 = NULL, # 方法二的结果 # the result of Method Two\n                        slope.methed = c(\"OLS\",\"SMA\",\"MA\"), # 选择一种斜率检验方法，一般为OLS # Select a slope test method, usually OLS\n                        slope.test.value = 0, # 斜率检验值和0比较 # Compare the slope test value with 0\n                        xlab = \"Means\", # BA图的横轴名 # BA the name of the horizontal axis of the graph\n                        ylab = \"Differences\", # BA图的纵轴名 # BA the name of the vertical axis of the graph\n                        main = \"\", # BA图的主题 # BA the theme of the diagram\n                        point.color = NULL, # BA图离散点的颜色 # BA the color of discrete points in the graph\n                        refline.color = NULL, # 参考线的颜色（金标准线）# The color of the reference line (gold standard line)\n                        confline.color = NULL, # BA图置信区间的颜色 # BA the color of the confidence interval of the graph\n                        fig.label = NULL, # 最终出图的名称 # the name of the final output image\n                        width = 6, # 图像宽度 # image width\n                        height = 5) { # 图像高度 # image height\n\n  if(length(measurement1) != length(measurement2)) {stop(\"The length of measurements must be the same!\\n\")}\n  if(!is.element(slope.methed,c(\"OLS\",\"SMA\",\"MA\"))) {stop(\"The method for slope test must be one of OLS, SMA, MA!\\n\")}\n  \n  ba.stats <- bland.altman.stats(measurement1,measurement2) # 得到BA有关的统计量 # get ba related statistics\n  \n  meth <- ifelse(slope.methed == \"OLS\",0, \n                 ifelse(slope.methed == \"SMA\",1,2))\n  \n  # 进行斜率检验 \n  # Conduct the slope test\n  slope <- slope.test(y = ba.stats$diffs,\n                      x = ba.stats$means,\n                      test.value = slope.test.value,\n                      method = meth) # 根据选择的斜率检验方法设置meth值  # Set the meth value according to the selected slope test method\n  \n  # 绘图 \n  # Drawing\n  pdf(paste0(\"BAplot_\",fig.label,\".pdf\"), width = width, height = height)\n  par(bty=\"o\", mgp = c(2,0.5,0), mar = c(4.1,4.1,2.1,2.1), tcl=-.25, font.main=3, las=1)\n  par(xpd=F)\n  \n  # 设置坐标轴区间 \n  # Set the coordinate axis intervals\n  if(range(ba.stats$diffs)[1] > ba.stats$lines[1]) {\n    ylim1 <- ba.stats$lines[1] - ceiling(range(ba.stats$diffs)[2]-range(ba.stats$diffs)[1]/10)\n  } else {ylim1 <- range(ba.stats$diffs)[1]}\n  \n  if(range(ba.stats$diffs)[2] < ba.stats$lines[3]) {\n    ylim2 <- ba.stats$lines[3] + ceiling(range(ba.stats$diffs)[2]-range(ba.stats$diffs)[1]/10)\n  } else {ylim2 <- range(ba.stats$diffs)[2]}\n  \n  # 设置空画布（第一次）\n  # Set an Empty Canvas (First Time)\n  plot(NULL, NULL,ylim = c(ylim1,ylim2),xlim = range(ba.stats$means),\n       xlab = xlab,ylab = ylab,\n       main = main,\n       sub=paste(\"Critical difference is\", round(ba.stats$critical.diff,3)),\n       col=\"white\",yaxt=\"n\",xaxt=\"n\")\n  \n  axis(side = 2,at = pretty(c(ylim1,ylim2)),labels = pretty(c(ylim1,ylim2)))\n  axis(side = 1,at = pretty(ba.stats$means),labels = pretty(ba.stats$means))\n  \n  rect(par(\"usr\")[1],par(\"usr\")[3],par(\"usr\")[2],par(\"usr\")[4],col = \"#EAE9E9\",border = F) # 填充背景色（此时画布外缘黑线被遮盖） # fill the background color (the canvas covering the outer black line)\n  grid(col = \"white\", lty = 1, lwd = 1.5) # 添加网格 # Add grid\n  \n  # 添加非金标准的结果（散点）\n  # Add non-gold standard results (scattered points)\n  points(ba.stats$means, \n         ba.stats$diffs, \n         col = ggplot2::alpha(point.color,0.8), \n         pch = 19)\n  \n  # 添加置信区间\n  # Add confidence intervals\n  abline(h = ba.stats$lines, \n         lty=c(2,4,2), \n         lwd=c(1.5,2,1.5),\n         col=c(confline.color,refline.color,confline.color))\n  \n  # 重新创建空画布（第二次）还原外侧线\n  # Recreate an Empty canvas (Second Time) Restore the outer lines\n  par(new = T, bty=\"o\",xpd=F)\n  plot(NULL, NULL,\n       col = \"white\",\n       xlim = range(ba.stats$means), ylim = range(ba.stats$diffs),\n       xlab = \"\", ylab = \"\",\n       xaxt = \"n\", yaxt = \"n\")\n  \n  # 添加斜率检验结果\n  # Add the slope test result\n  legend(\"topright\",\n         legend = paste0(\"Slope\",ifelse(slope$b < 0.001,\" < 0.001\",paste0(\" = \",round(slope$b,3))),\"\\nP \",\n                         ifelse(slope$p < 0.001,\" < 0.001\",paste0(\" = \",round(slope$p,3)))),\n         border=NA,bty = \"n\", y.intersp=1,cex = 0.9)\n  \n  # 关闭图像句柄\n  # Close the image handle\n  invisible(dev.off())\n}\n输入文件\nInput File\neasy_input.csv，第一列error，第二列为分组信息，这里是测试结果和金标准结果。\neasy_input.csv, the first column is error and the second column is\ngrouping information. Here are the test results and the gold standard\nresults.\ndat <- read.table(\"easy_input.txt\", sep = \"\\t\", row.names = NULL, header = T, check.names = F, stringsAsFactors = F)\nhead(dat)\ntable(dat$dataset)\n分析并画图\nAnalyze and Draw Diagrams\n调用前面的自定义函数，检验和画图一步到位。 By calling the previous\ncustom function, verification and drawing can be accomplished in one\nstep.\n# 测试结果\n# Test Results\ntest <- abs(dat[which(dat$dataset == \"TEST\"),\"error\"]) \n\n# 金标准结果\n# Gold Standard Results\ngt <- abs(dat[which(dat$dataset == \"GT\"),\"error\"]) \n\nBA.baseplot(measurement1 = test, # 测试方法的结果 # test method result\n            measurement2 = gt, # 金标准结果  # Gold Standard result\n            slope.methed = \"OLS\", # 斜率方法选择OLS # select OLS for the slope method\n            xlab = \"Means of Dice error in Left\", # 添加x轴名 # add the X-axis name\n            ylab = \"Differences of Dice error in Left\", # 添加y轴名 # add the name of the Y-axis\n            point.color = \"#224A8D\", # 散点颜色  # scatter color\n            refline.color = \"#E53435\", # 参考线颜色 # reference line color\n            confline.color = \"grey30\", # 置信线颜色 # confidence line color\n            fig.label = \"example\") # 输出文件名  # Output file name\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa176BlandAltman_FigureYa176BlandAltman",
      "title": "FigureYa176BlandAltman/FigureYa176BlandAltman.html",
      "html": "FigureYa176BlandAltman/FigureYa176BlandAltman.html",
      "text": "texts/main_FigureYa176BlandAltman_FigureYa176BlandAltman.txt",
      "folder": "FigureYa176BlandAltman",
      "thumb": "gallery_compress/FigureYa176BlandAltman.webp"
    },
    "word_count": 940,
    "lines_count": 178,
    "title": "FigureYa176BlandAltman",
    "description": "Requirement 作者用Bland-Altman的方法比较了自己建立的模型和传统的模型的一致性。网上找了下，好像没有可以重复这个的代码。 The author compared the consistency between the model he established and",
    "input_data_types": [],
    "output_types": [
      "散点图",
      "统计表格"
    ],
    "technical_methods": [],
    "biology_areas": [],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "methed",
      "label",
      "intersp",
      "",
      "header",
      "lwd",
      "measurement1",
      "width",
      "ylim",
      "new"
    ]
  },
  {
    "id": "main_FigureYa44profile_FigureYa44profile",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa44profile_FigureYa44profile.txt",
    "content": "FigureYa44 profile\nFigureYa44 profile\nWen Wang; Ying Ge, Yijing Chen\n2025-5-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n用R画出两个样品对比的profile。\nUse R to draw a profile comparing the two samples.\n图 3 | DP 胸腺细胞中 Cxxc1 结合和 H3K4me3 修饰的全基因组图谱。\nCxxc1 结合峰在扩展基因体上的分布。计算了所有 RefSeq (mm9)\n基因的基因体（转录起始位点（TSS）和转录终止位点（TTS）之间）、TSS 上游 3\nkb 和 TTS 下游 3 kb 区域的 Cxxc1 结合标记密度。在启动子区域的 100-bp\n窗口和\n5%的基因体序列中汇总了独特的映射标签。所有窗口标签计数均按窗口中的碱基总数和给定样本的总读数进行归一化处理。\nCpG 岛（CpGI）上 Cxxc1 结合峰的富集。计算 CpG 岛和 5-kb\n侧翼区域的 Cxxc1 结合标记密度。\n出自\nhttps://www.nature.com/articles/ncomms11687\nFigure 3 | Genome-wide maps of Cxxc1 binding and H3K4me3 modification\nin DP thymocytes.\nDistribution of Cxxc1-binding peaks across extended gene bodies.\nThe tag density of Cxxc1 binding was calculated on gene bodies (between\ntranscription start site, TSS and transcription termination site, TTS),\nas well as 3-kb upstream of TSS and 3-kb downstream of TTS regions of\nall RefSeq (mm9) genes. Uniquely, mapped tags were summarized in 100-bp\nwindows for promoter regions and in 5% of gene body sequences. All\nwindow tag counts were normalized by the total number of bases in the\nwindows and the total read number of the given sample.\nEnrichment of Cxxc1-binding peaks on CpG islands (CpGI). The tag\ndensity of Cxxc1 binding was calculated on CpG islands and 5-kb flanking\nregions.\nfrom\nhttps://www.nature.com/articles/ncomms11687\n应用场景\nApplication scenario\n对比不同的样品在某一区域的信号特征，不仅限于ChIP-seq、DNase-seq、ATAC-seq数据。\n对比IP实验和input对照的信号强度，例如需求描述里的图：\n把基因压缩到统一长度，观察转录起始位点（TSS）、转录终止位点（TTS）、gene\nbody以及两侧的信号特征。\n观察某一功能区域，例如CpGi、TSS、TTS、peak\nsummits或enhancer区及其两侧的信号特征。\nCompare the signal characteristics of different samples in a certain\nregion, not limited to ChIP-seq, DNase-seq, ATAC-seq data.\nCompare the signal intensity of IP experiments and input controls,\ne.g., the figure in the requirement description:\nCompress genes to a uniform length and observe the signal\ncharacteristics at the transcription start site (TSS), transcription\ntermination site (TTS), gene body, and both sides.\nObserve a functional region, e.g., CpGi, TSS, TTS, peak summits,\nor enhancer regions, and signaling features on either side.\nb图\nFigure b\n为了提取bw文件里的信号，需要用到2个函数\nregionCapture\n、\nsignal_caputer_around_gene\n，保存在\ncorelib.R\n文件里\nIn order to extract the signals in the bw file, 2 functions\nregionCapture\n,\nsignal_caputer_around_gene\nare\nneeded, saved in the\ncorelib.R\nfile\nsource(\"install_dependencies.R\")\n#install.packages(\"rtracklayer\")\nsource(\"corelib.R\") #位于当前文件夹 it is located in the current folder\n参数设置\nParameter setting\n在这里修改常见的需要调整的参数\nModify common parameters that need to be adjusted here\noutputName <- \"geneBodyProfiler_example.pdf\" #输出的pdf文件名 output pdf file name\nbigWigFiles <- c(\"cxxc1.bw\",\"control.bw\") #bw文件，位于当前文件夹，可以>2个 bw file, located in the current folder, can be >2\nlabels <- c(\"Cxxc1\",\"Input\") #图例标签，跟bw数量一致 legend labels, consistent with bw numbers\ncolors <- c(\"navy\",\"firebrick\") #线的颜色，跟bw数量一致 color of line, same as bw quantity\n\nnormalization_constant <- 1 #均一化的系数，根据展示所需信号值刻度调整 normalization coefficient, adjusted according to the scale of the required signal value for display\ngenome <- \"mm9\" #跟bw文件一致的基因组版本 genome version consistent with bw file\nresolution <- 100 #分辨率，数值越低，画出来的曲线越平滑，运行时间越长 resolution, the lower the value, the smoother the curve drawn and the longer the run time\nspan <- 3000 #上下游展示范围，需要是resolution的整数倍 upstream and downstream display ranges, need to be an integer multiple of resolution\ngeneBodySpan <- 2000 #gene body normalization length，需要是resolution的整数倍 gene body normalization length, needs to be an integer multiple of resolution\ncoreNumber <- detectCores() - 1 #留出一个核用来干别的事情 set aside a core for something else\n输入文件\nInput file\ncxxc1.bw和control.bw：ChIP-seq样品及其contorl的bw文件。在生成bw时做过normalization。\neasy_input.txt：想要查看的基因的位置信息，至少包含4列：染色体、正负链、起始位点、终止位点。作者用的是refGene里所有经过验证的编码RNA（NM开头），此处考虑到运行时间，从中随机抽取5000个基因。\n如果你要提取的基因已经保存成类似easy_input.txt的格式，就可以跳过这步，直接进入“信号提取”。\ncxxc1.bw and control.bw: bw files for ChIP-seq samples and their\ncontorl. Normalization is done when generating the bw.\neasy_input.txt: location information of the gene you want to view,\ncontaining at least 4 columns: chromosome, positive and negative strand,\nstart site, and end site. The author used all the verified coding RNAs\n(starting with NM) in refGene, from which 5000 genes were randomly\nextracted considering the runtime.\nIf the genes you want to extract have already been saved in a format\nsimilar to easy_input.txt, you can skip this step and go directly to\n“Signal extraction”.\n#提前下载好refGene.gz文件\n#download the refGene.gz file in advance\n#download.file(paste0(\"http://hgdownload.soe.ucsc.edu/goldenPath/\",genome,\"/database/refGene.txt.gz\"),\"refGene.gz\")\nrefGene <- read.table(gzfile(\"refGene.gz\"))\n\nisNormalChrosome <- !grepl(\"_\",refGene$V3)    # 去除异常染色体 remove abnormal chromosome\nismRNA <- grepl(\"^NM\",refGene$V2)    # 只保留有效的mRNA only keep valid mRNAs\nisEnoughtLength <- (refGene[,6] - refGene[,5]) > geneBodySpan / resolution\n\nflag <- isNormalChrosome & ismRNA & isEnoughtLength\nrefGene <- refGene[flag,]\n\n# 取样，去掉这些部分以获得最终数据\n# sampling, remove these part for final figure\nset.seed(6666)\nidx <- sample(1:nrow(refGene), size = 5000)\nmyGene <- refGene[idx,]\nstr(myGene[1:6])\nwrite.table(myGene[1:6], \"easy_input.txt\", quote = F, sep = \"\\t\", row.names = F, col.names = F)\n#delete_result <- file.remove(\"refGene.gz\")\n信号提取\nSignal extraction\n提取的基因越多，运行的时间越长。\n此处提取了5000个基因的信号，需要十分钟左右\nThe more genes extracted, the longer the run time.\nHere the signals of 5000 genes are extracted, which takes about ten\nminutes\nmyGene <- read.table(\"easy_input.txt\", as.is = T)\nhead(myGene)\nstr(myGene)\naverage_signal <- c()\n\nfor(i in 1:length(bigWigFiles)){\n  average_signal <- rbind(average_signal,\n                          signal_caputer_around_gene(bigWigFiles[i], #要提取的bw文件 bw file to be extracted\n                                   myGene, #如果提取全部基因的信号，就换成refGene if the signal of all genes is extracted, switch to refGene\n                                   resolution = resolution,\n                                   span = span,\n                                   geneBodySpan = geneBodySpan,\n                                   cores = as.integer(coreNumber)))\n}\naverage_signal <- average_signal / normalization_constant #均一化的系数，根据测序深度调整 Normalized coefficient, adjust according to sequencing depth\n\n#这步比较耗时，我们把抽取的信号保存到`gene_average_signal.csv`文件里。\n#this step is more time-consuming, we save the extracted signals to the `gene_average_signal.csv` file.\nwrite.table(average_signal,\"gene_average_signal.txt\",quote = F,row.names = F,col.names = F)\n开始画图\nStart drawing\naverage_signal <- read.table(\"gene_average_signal.txt\", header = F, as.is = T)\nminimum <- min(average_signal) - (max(average_signal) - min(average_signal)) * 0.1\nmaximum <- max(average_signal) + (max(average_signal) - min(average_signal)) * 0.2\n\ndatapoint1 <- span / resolution\ndatapoint2 <- geneBodySpan / resolution\ntotal_length <- datapoint1 * 2 + datapoint2\n\n#pdf(outputName,width = 6,height = 4)\nplot(1:total_length, average_signal[1,], \n     type = \"l\", lwd = 3, tck = 0, #不显示刻度线 do not show scale lines\n     mgp = c(2,0.5,0), #坐标轴标题、刻度和坐标轴线跟作图区域的距离 the coordinate axis title, scale, and the distance between the axis line and the plotting area\n     col = colors[1],\n     xaxt = \"n\", #不显示x轴刻度 no x-axis scale is displayed\n     xlab = \"\", ylab = \"Normalized signal\",\n     ylim = c(minimum ,maximum))\nfor(i in 2:length(bigWigFiles)){\n    lines(1:total_length, average_signal[i,], col = colors[i], lwd = 3) #线的颜色、粗细 color and thickness of the line\n}\n\n#在TSS和TTS的位置画两条虚线\n#draw two dotted lines at the location of TSS and TTS\n#abline(v = c(datapoint1, datapoint1 + datapoint2) + 0.5, lty = 2)\n\nlegend(\"topright\", col = colors, ncol = 2,\n       legend = labels, lty = 1, lwd = 3,\n       bty = \"n\")#不显示图例边框 legend border not shown\n\nbox(lwd = 2) #边框粗细 border thickness\n\naxis(side = 1, tck = 0, #不显示刻度线 do not show scale lines\n     mgp = c(2,0.5,0),\n     at = c(0, datapoint1, datapoint1 + datapoint2/2, datapoint1 + datapoint2, total_length) + 0.5,\n     labels = c(paste(-1*span/1000, \"kb\"), \"TSS\", \"50%\", \"TTS\", paste(span/1000, \"kb\")))\n#dev.off()\nc图\nFigure c\n同样需要\ncorelib.R\n文件提取bw文件里的信号，用到2个函数：\nregionCapture\n、\nsignal_caputer_around_sites\nAlso need\ncorelib.R\nfile to extract signals from bw\nfile, use 2 functions:\nregionCapture\n,\nsignal_caputer_around_sites\n.\nsource(\"./corelib.R\") #位于当前文件夹 it is located in the current folder\n参数设置\nParameter setting\n在这里修改常见的需要调整的参数\nModify common parameters that need to be adjusted here\noutputName <- \"sitepro_example.pdf\"\nbigWigFiles <- c(\"cxxc1.bw\",\"control.bw\") \nlabels <- c(\"Cxxc1\",\"Input\")\ncolors <- c(\"navy\",\"firebrick\") \n\nbedFile <- \"zv9_CpG_islands.bed\" #要画的功能区域的bed文件 bed file of the functional area to be drawn\nsiteType <- \"CpG island\"\nresolution <- 100\nspan <- 5000\nnormalization_constant <- 1\ncoreNumber <- detectCores() - 1\n输入文件\nInput file\ncxxc1.bw和control.bw：ChIP-seq样品及其contorl的bw文件，在生成bw时做过normalization。\nzv9_CpG_islands.bed：想要查看的基因/功能区域的bed文件，此处是15000个CpGi。\ncxxc1.bw and control.bw: bw file for ChIP-seq samples and their\ncontorl, normalization was done when generating the bw.\nzv9_CpG_islands.bed: bed file for the gene/functional region you want\nto view, here 15000 CpGi.\n提取信号\nExtract signal\n15000个CpGi，运行时间是上一个图的2-3倍。\nWith 15000 CpGi, the run time is 2-3 times longer than the previous\nfigure.\naverage_signal <- c()\nfor(i in 1:length(bigWigFiles)){\n  average_signal <- rbind(average_signal,\n                          signal_caputer_around_sites(bigWigFiles[i], #要提取信号的bw文件 bw file to be extracted\n                                                      bedFile, #要提取的区域列表 list of areas to extract\n\n                                                      resolution=resolution,\n                                                      span=span,\n                                                      cores=as.integer(coreNumber)))\n}\naverage_signal <- average_signal / normalization_constant\n#这步比较耗时，我们把抽取的信号保存到`site_average_signal.csv`文件里。\n#this step is more time-consuming, we save the extracted signals to the `site_average_signal.csv` file\nwrite.table(average_signal,\"site_average_signal.txt\",quote = F,row.names = F,col.names = F)\n开始画图\nStart drawing\naverage_signal <- read.table(\"site_average_signal.txt\", header = F, as.is = T)\nminimum <- min(average_signal) - (max(average_signal) - min(average_signal)) * 0.1\nmaximum <- max(average_signal) + (max(average_signal) - min(average_signal)) * 0.2\n\ndatapoints <- span / resolution\n\n#pdf(outputName,width = 6,height = 4)\nplot(1:(datapoints*2+1), average_signal[1,], \n     type=\"l\", lwd = 3, tck = 0, #不显示刻度线 do not show scale lines\n     mgp = c(2,0.5,0), #坐标轴标题、刻度和坐标轴线跟作图区域的距离 the coordinate axis title, scale, and the distance between the axis line and the plotting area\n     col=colors[1],\n     xaxt = \"n\", #不显示x轴刻度 no x-axis scale is displayed\n     xlab=\"\",ylab=\"Normalized signal\",ylim=c(minimum,maximum))\nfor(i in 2:length(bigWigFiles)){\n    lines(1:(datapoints*2+1), average_signal[i,], col = colors[i], lwd = 3) #线的颜色、粗细 color and thickness of the line\n}\n\nlegend(\"topleft\", col = colors, legend = labels, lty = 1, lwd = 3,\n       bty = \"n\")#不显示图例边框 legend border not shown\n\nbox(lwd = 2) #边框粗细 border thickness\n\naxis(side = 1, tck = 0,\n     mgp = c(2,0.5,0),\n     at = c(0, datapoints, datapoints*2) + 1,\n     labels = c(paste(-1*span/1000, \"kb\"), siteType, paste(span/1000, \"kb\")))\n#dev.off()\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa44profile_FigureYa44profile",
      "title": "FigureYa44profile/FigureYa44profile.html",
      "html": "FigureYa44profile/FigureYa44profile.html",
      "text": "texts/main_FigureYa44profile_FigureYa44profile.txt",
      "folder": "FigureYa44profile",
      "thumb": "gallery_compress/FigureYa44profile.webp"
    },
    "word_count": 1393,
    "lines_count": 279,
    "title": "FigureYa44 profile",
    "description": "Requirement description 用R画出两个样品对比的profile。 Use R to draw a profile comparing the two samples.",
    "input_data_types": [
      "临床数据",
      "DNA-seq"
    ],
    "output_types": [
      "统计表格"
    ],
    "technical_methods": [
      "通路分析",
      "标准化"
    ],
    "biology_areas": [],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "geneBodySpan",
      "span",
      "header",
      "lwd",
      "width",
      "ylim",
      "side",
      "labels",
      "legend",
      "col"
    ]
  },
  {
    "id": "main_FigureYa175quadrant_FigureYa175quadrant",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa175quadrant_FigureYa175quadrant.txt",
    "content": "FigureYa175quadrant\nFigureYa175quadrant\nAuthor(s)\n: Bin Wei\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement\n画出文章中这种九宫格的散点图，在图中标出想突出显示的基因名。 Draw a\nscatter plot of the nine-square grid in the article and mark the names\nof the genes you want to highlight on the plot.\n出自<dx.doi.org/10.3390/ijms21051686>\nfrom<dx.doi.org/10.3390/ijms21051686>\nFigure 5. Relationship between mRNA and protein expression in TW/NW\n(A) and TW/OW (B).\n出自<www.nature.com/articles/nature21036>\nfrom<www.nature.com/articles/nature21036>\nFigure 1. The translational landscape of the epidermis during\npremalignant transformation. d, Transcriptional and translational\nchanges comparing SOX2 with wild-type P4 epidermis. Colour-coded are\ngenes with the adjusted P value < 0.05 (DESeq2; ref. 43; n = 3 per\ngroup for ribosome profiling; n =2 for RNA-seq).\n出自\nhttps://science.sciencemag.org/content/362/6413/eaav1898\nfromhttps://science.sciencemag.org/content/362/6413/eaav1898\n应用场景\nApplication Scenarios\n同时展示两种特征，尤其适合多组学关联的展示。 Simultaneously\npresenting two features is particularly suitable for the display of\nmulti-omics associations.\n像前两篇例文那样，RNA-seq跟蛋白质组数据，展示同一基因在两个维度的一致性。或者RNA-seq跟ATAC-seq，或者RNA-seq跟ChIP-seq，也是同样的道理。\nAs in the previous two sample articles, RNA-seq and proteomic data\ndemonstrate the consistency of the same gene in two dimensions. The same\nprinciple applies to RNA-seq and ATAC-seq, or RNA-seq and ChIP-seq.\n像第三篇例文那样，ATAC-seq数据，展示accessibility跟footprint\ndepth的关系。 As in the third example, the ATAC-seq data shows the\nrelationship between accessibility and footprint depth.\n展示同一样本的两种生物学/临床特征。 Display two biological/clinical\ncharacteristics of the same sample.\n另外可参考这两个FigureYa： In addition, you can refer to these two\nfigureYa:\n同时展示两组数据相关性的FigureYa163TwoVarCor； FigureYa163TwoVarCor\nsimultaneously presents the correlation between two sets of data;\n展示相关性的同时给出各区域点所占的比例的FigureYa143survCor。\nFigureYa143survCor shows the correlation while providing the proportion\nof each regional point.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nLoading package\n# 加载需要的包\n# Load the required packages\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(ggrepel)\nlibrary(cowplot)\n\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # displays an English error message\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # prohibit chr from being converted to factor\n输入文件\nInput File\neasy_input.txt，每行一个点，第一列为点的ID，第二列x作为横坐标，第三列y作为纵坐标。\neasy_input.txt, each line contains one point. The first column is the\npoint ID, the second column x serves as the abscissa, and the third\ncolumn y serves as the ordinate.\n示例数据每个点代表一个基因，x为该基因转录水平的变化倍数，y为蛋白水平变化倍数。\nEach point in the sample data represents a gene, where x is the multiple\nof change at the transcriptional level of the gene and y is the multiple\nof change at the protein level.\n# 读取数据 # Reading Data\ndata <- read.table(\"easy_input.txt\", header = T, row.names = 1)\nhead(data)\ntail(data)\n开始画图\nStart drawing\n# 要显示名称的点的ID\n# The ID of the point whose name is to be displayed\n# 一定要跟输入文件easy_input.txt文件中的第一行一致\n# It must be consistent with the first line in the input file easy_input.txt\ngenes_to_showname <- c(\"gene1\", \"gene2\", \"gene3\", \"gene114\", \"gene3552\")\n# 如果不想显示点的ID，就用下面这行\n# If you don't want to display the ID of the dot, use the following line\n#genes_to_showname <- \"\"\n\ndata$gene_label <- \"\"\ndata[genes_to_showname, ]$gene_label <- genes_to_showname\n\n# 设置常用变量，根据自己的数据调整\n# Set common variables and adjust them according to your own data\nxmin <- -1    # x轴用于数据划分象限最小值\n# The X-axis is used for the minimum value of the data partitioning quadrant\nxmax <- 1     # x轴用于数据划分象限最大值\n# The X-axis is used for the maximum value of the data partitioning quadrant\nymin <- -0.25 # y轴用于数据划分象限最小值\n # The Y-axis is used for the minimum value of the data partitioning quadrant\nymax <- 0.25  # y轴用于数据划分象限最大值\n# The Y-axis is used to divide the maximum value of the data quadrant\n\nx_axis_min <- -12  # 画图时x轴最小值 # minimum value on the X-axis when drawing\nx_axis_max <- 12   # 画图时x轴最大值 # is the maximum value of the X-axis when plotting\ny_axis_min <- -1   # 画图时y轴最小值 # minimum Y-axis when plotting\ny_axis_max <- 1    # 画图时y轴最大值  # the maximum value on the Y-axis when plotting\n\nxlab <- \"log2(ratio of mRNA)\"      # x轴标签名称 # X-axis label name\nylab <- \"log2(ratio of protein)\"   # y轴标签名称 # Y-axis label name\n\nx_tick_pos <- seq(x_axis_min, x_axis_max, 3)\ny_tick_pos <- seq(y_axis_min, y_axis_max, 0.5)\n\n# 点的颜色 \n# The color of the dot\npoint_color <- c(\"#0003f8\", \"#00c200\", \"#f4050b\", \"#d002ea\", \"#000000\", \"#ff7c00\", \"#710749\", \"#08048c\", \"#9b6815\") \nnames(point_color) <- c(\"Q1\", \"Q2\", \"Q3\", \"Q4\", \"Q5\", \"Q6\", \"Q7\", \"Q8\", \"Q9\")\n\n# 数据划分象限\n# Data Quadrant Division\ndata <- data %>% mutate(quadrant = case_when(\n    x > xmax & y > ymax ~ \"Q1\",\n    x > xmax & y <= ymax & y > ymin ~ \"Q2\",\n    x > xmax & y <= ymin ~ \"Q3\",\n    x <= xmax & x > xmin & y <= ymin ~ \"Q4\",\n    x <= xmax & x > xmin & y > ymin & y <= ymax ~ \"Q5\",\n    x <= xmax & x > xmin & y > ymax ~ \"Q6\",\n    x <= xmin & y > ymax ~ \"Q7\",\n    x <= xmin & y <= ymax & y > ymin ~ \"Q8\",\n    x <= xmin & y <= ymin ~ \"Q9\"))\nhead(data)\n# 象限名称准备\n# Quadrant Name Preparation\nannotate_x <- c(rep(x_axis_max, 3), rep((x_axis_min+x_axis_max)/2, 3), rep(x_axis_min, 3))\nannotate_y <- rep(c(y_axis_max, (y_axis_min+y_axis_max)/2, y_axis_min), 3)\nannotate_text_color <- c(rep(\"black\", 4), \"white\", rep(\"black\", 4))  #象限名称颜色 # quadrant name color\n\n# 画图\n# Drawing\np <- ggplot(data) + \n    geom_point(aes(x=x, y=y, color=quadrant), size=2) + \n    coord_cartesian(xlim=c(x_axis_min, x_axis_max), \n                    ylim=c(y_axis_min, y_axis_max)) + \n    \n    # 画虚线\n    # Draw a dotted line\n    geom_vline(xintercept=c(xmin, xmax), size=0.3, linetype=\"dashed\") + \n    geom_hline(yintercept=c(ymin, ymax), size=0.3, linetype=\"dashed\") +\n    \n    # 9个象限的名称\n    # Names of the 9 quadrants\n    annotate(\"text\", x=annotate_x, y=annotate_y, label=c(1,2,3,6,5,4,7,8,9), color=annotate_text_color) + \n    \n    labs(x=xlab, y=ylab) + \n    theme_bw() + \n    theme(legend.position=\"none\", panel.grid=element_blank()) + \n    scale_colour_manual(values=point_color) + \n    scale_x_continuous(breaks=x_tick_pos) +\n    scale_y_continuous(breaks=y_tick_pos)\np\nggsave(\"quadrant.pdf\", width = 7, height = 7)\n\n# 是否显示特定基因的名称\n# Whether to display the name of a specific gene\nif (length(genes_to_showname) > 0) {\n    p <- p + \n        geom_text_repel(aes(x=x, y=y, label=gene_label, color = quadrant), \n                        size=5, \n                        box.padding = unit(0.35, \"lines\"), \n                        point.padding = unit(0.3, \"lines\"))\n}\n\n# 在顶部和右侧添加x和y轴hist图\n# Add x and Y-axis hist diagrams at the top and on the right\nhist_x <- ggplot(data, aes(x=x)) + \n    geom_histogram(bins=100, \n                   color=\"black\", fill = \"#4BB33B\") +\n    coord_cartesian(xlim=c(x_axis_min, x_axis_max)) +\n    theme_bw() + \n    theme(panel.grid=element_blank(), \n          axis.text.x=element_blank(), \n          axis.ticks.x=element_blank(),\n          axis.title.x=element_blank()) +\n    xlab(NULL)\n#hist_x\n\nhist_y <- ggplot(data, aes(x=y)) + \n    geom_histogram(bins=100, \n                   color=\"black\", fill = \"#5981CE\") +\n    coord_flip(xlim=c(y_axis_min, y_axis_max)) + \n    theme_bw() + \n    theme(panel.grid=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank() ,axis.title.y=element_blank()) +\n    xlab(NULL)\n#hist_y\n\nempty <- ggplot() + theme_void()\n\n# 拼图\n# Jigsaw Puzzle\na  <- plot_grid(hist_x, p, ncol=1, rel_heights=c(1,6), align=\"v\")\nb  <- plot_grid(empty, hist_y, ncol=1, rel_heights=c(1,6))\np_final <- plot_grid(a, b, rel_widths=c(6,1))\np_final\n# 输出pdf\n# Output pdf\npdf(\"quadrant_plus.pdf\", height=7, width=7)\nprint(p_final)\ndev.off()\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa175quadrant_FigureYa175quadrant",
      "title": "FigureYa175quadrant/FigureYa175quadrant.html",
      "html": "FigureYa175quadrant/FigureYa175quadrant.html",
      "text": "texts/main_FigureYa175quadrant_FigureYa175quadrant.txt",
      "folder": "FigureYa175quadrant",
      "thumb": "gallery_compress/FigureYa175quadrant.webp"
    },
    "word_count": 1021,
    "lines_count": 215,
    "title": "FigureYa175quadrant",
    "description": "Requirement 画出文章中这种九宫格的散点图，在图中标出想突出显示的基因名。 Draw a scatter plot of the nine-square grid in the article and mark the names",
    "input_data_types": [
      "蛋白质组",
      "临床数据"
    ],
    "output_types": [
      "散点图",
      "统计表格"
    ],
    "technical_methods": [],
    "biology_areas": [],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "rel_heights",
      "label",
      "",
      "values",
      "rel_widths",
      "header",
      "width",
      "ylim",
      "n",
      "grid"
    ]
  },
  {
    "id": "main_FigureYa52GOplot_FigureYa52GOplot",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa52GOplot_FigureYa52GOplot.txt",
    "content": "FigureYa52 GOplot\nFigureYa52 GOplot\nAuthor(s)\n: Ying Ge, Guangchuang Yu, Taojun Ye\nReviewer(s)\n: Ying Ge\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n用GOplot展示clusterProfiler的富集分析结果，画出paper里的⭕️图\nRequirement description\nDisplay the enrichment analysis results of clusterProfiler using\nGOplot and draw the data in the paper ⭕ ️ Image\n出自\nhttps://www.nature.com/articles/s41467-017-01195-y\nfrom\nhttps://www.nature.com/articles/s41467-017-01195-y\n出自\nhttps://www.karger.com/Article/FullText/492519\nfrom\nhttps://www.karger.com/Article/FullText/492519\n应用场景\n适用于：既想用clusterProfiler做富集分析，又想用GOplot展示结果，但是不知道二者怎样衔接的小伙伴。\n此处以GO为例，获得clusterProfiler的富集分析结果，生成GOplot所需的格式，用GOplot画⭕️图。\nclusterProfiler除了擅长做GO富集分析以外，还可以用KEGG、Diseaes、Reactome、DAVID、MSigDB等注释库做富集分析。另外，enrichplot自带的gseaplot2函数可以生成GSEA结果的矢量图、多条pathway画到同一个图上，完美代替Java版本的GSEA，看这篇：\nhttps://mp.weixin.qq.com/s/AamfRz0BUENCi_1P0P-Ruw\n。\nApplication scenarios\nSuitable for: those who want to use clusterProfiler for enrichment\nanalysis and GOplot to display results, but do not know how to connect\nthe two.\nTaking GO as an example, obtain the enrichment analysis results of\nclusterProfiler, generate the required format for GOplot, and use GOplot\nto draw ⭕ Picture.\nIn addition to being proficient in GO enrichment analysis,\nclusterProfiler can also use annotation libraries such as KEGG,\nDisseales, Reactor, DAVID, MSigDB, etc. for enrichment analysis. In\naddition, enrichplot’s built-in gseaplot2 function can generate vector\ngraphs of GSEA results and draw multiple pathways onto the same graph,\nperfectly replacing the Java version of GSEA. See this article:<\nhttps://mp.weixin.qq.com/s/AamfRz0BUENCi_1P0P-Ruw\n>\n环境设置\n安装需要的包\nEnvironment settings\nsource(\"install_dependencies.R\")\n# 加载用于功能富集分析的包 | Load packages for functional enrichment analysis\nlibrary(clusterProfiler)\n# 加载用于生物信息学注释资源的包 | Load package for bioinformatics annotation resources\nlibrary(AnnotationHub)\n# 加载用于注释数据库接口的包 | Load package for annotation database interface\nlibrary(AnnotationDbi)\n# 加载用于基因本体可视化的包 | Load package for Gene Ontology visualization\nlibrary(GOplot)\n# 加载用于数据可视化的包 | Load package for data visualization\nlibrary(ggplot2)\nlibrary(org.Mm.eg.db)\n# 设置环境变量以显示英文报错信息 | Set environment variable to display English error messages\nSys.setenv(LANGUAGE = \"en\") \n# 设置选项禁止将字符向量自动转换为因子 | Set option to prevent automatic conversion of character vectors to factors\noptions(stringsAsFactors = FALSE)\n获取ENTREZ ID跟基因名的对应关系\n如果你的基因ID已经是ENTREZ\nID，并保存成\nvery_easy_input_**.csv\n的格式，就可以跳过这步，直接进入“富集分析”\n根据基因名gene symbol找到相应的ensembl\nID。模式生物和非模式生物的转换代码稍有不同，根据自己的物种，选择运行以下两段之一。\nObtain the correspondence between ENTREZ ID and gene name\nIf your gene ID is already ENTREZ ID and saved in the format of ’very\neasy input * *. csv’, you can skip this step and directly enter\n‘enrichment analysis’\nFind the corresponding ensembl ID based on the gene symbol name. The\nconversion code for model organisms and non model organisms is slightly\ndifferent. Depending on your species, choose to run one of the following\ntwo segments.\n人和模式生物ENTREZ ID的获取\n此处以例文中的小鼠数据为例，其他18个物种只需更改\nOrgDb = \"org.Mm.eg.db\"\n参数\n具体物种对应的R包名字看这页：\nhttp://bioconductor.org/packages/release/BiocViews.html#___OrgDb\n如果你关心的物种不在这个列表里，请跳过这步，直接进入“非模式生物ENTREZ\nID的获取”\nObtaining ENTREZ IDs for humans and model organisms\nTaking the mouse data in the example article as an example, the other\n18 species only need to change the ‘OrgDb=’ org. Mm. eg. db\n’parameter\nPlease refer to this page for the R package names corresponding to\nspecific species:<\nhttp://bioconductor.org/packages/release/BiocViews.html#___OrgDb\n>\nIf the species you are concerned about is not in this list, please\nskip this step and go directly to “Obtaining ENTREZ ID for Non model\nOrganisms”\n# 从CSV文件读取基因符号和表达量数据 | Read gene symbols and expression data from CSV file\ngsym.fc <- read.csv(\"easy_input_Mm.csv\", as.is = T)\n# 查看数据维度（行数和列数） | Check the dimensions (rows and columns) of the data\ndim(gsym.fc)\n# 查看可用的ID类型（此行为注释，未执行） | View available ID types (commented out)\n# keytypes(org.Mm.eg.db)\n\n# 将基因符号转换为ENTREZ ID | Convert gene symbols to ENTREZ IDs\ngsym.id <- bitr(gsym.fc$SYMBOL,         # 基因名列 | Gene symbol column\n                fromType = \"SYMBOL\",     # 输入ID类型为基因符号 | Input ID type: gene symbol\n                toType = \"ENTREZID\",     # 输出ID类型为ENTREZ ID | Output ID type: ENTREZ ID\n                OrgDb = \"org.Mm.eg.db\")  # 小鼠注释数据库 | Mouse annotation database\n# 查看转换结果前几行 | View first few rows of the conversion result\nhead(gsym.id)\n# 合并基因名、ENTREZ ID和表达量变化值 | Merge gene symbols, ENTREZ IDs and fold change values\nidvec <- gsym.id$ENTREZID  # 创建ENTREZ ID向量 | Create vector of ENTREZ IDs\nnames(idvec) <- gsym.id$SYMBOL  # 设置向量名称为基因符号 | Set vector names as gene symbols\ngsym.fc$ENTREZID <- idvec[gsym.fc$SYMBOL]  # 将ENTREZ ID匹配到原始数据 | Map ENTREZ IDs to original data\n# 查看合并后数据前几行 | View first few rows of merged data\nhead(gsym.fc)\n# 将处理后的数据保存为CSV文件 | Save processed data to CSV file\nwrite.csv(gsym.fc[,c(3,2)], \"very_easy_input_Mm.csv\",  # 选择第3列(ENTREZID)和第2列(表达量) | Select columns 3 (ENTREZID) and 2 (expression)\n          quote = F,          # 不使用引号包裹字段 | Do not quote fields\n          row.names = F)      # 不保存行名 | Do not save row names\n非模式生物ENTREZ ID的获取\n模式生物请跳过这段，直接进入“富集分析”。\n参考资料：\nGuangchuang Yu公众号biobabble：\nhttps://mp.weixin.qq.com/s/lHKZtzpN2k9uPN7e6HjH3w\nAnnotationHub包的说明文档：\nhttps://bioconductor.org/packages/release/bioc/vignettes/AnnotationHub/inst/doc/AnnotationHub.html\n准备工作：\n把基因名跟ENTREZ\nID对应关系的注释文件保存到本地文件，以后想要获取同一基因组版本的ENTREZ\nID时，直接导入这个“Zmays(物种名).AH66225(版本).sqlite”文件就可以了。此处以玉米为例：\nhub <- AnnotationHub() #大概需要2分钟，网速慢就要更久\n\n#查看AnnotationHub里有哪些物种，记住idx列里的AH***\n#d <- display(hub) \n\n#或者直接搜zea(玉米拉丁名的一部分)\nquery(hub, \"zea\") \n\nmaize_db_candidates <- query(hub, c(\"Zea mays\", \"OrgDb\"))\n\n#此处下载“AH61838”\nmaize.db <- hub[['AH117408']] #大概需要3分钟，网速慢就要更久\n\n#查看包含的基因数\nlength(keys(maize.db)) \n#查看包含多少种ID\ncolumns(maize.db)\n#查看前几个基因的ID长啥样\nselect(maize.db, keys(maize.db)[1:3], \n       c(\"REFSEQ\", \"SYMBOL\"), #你想获取的ID\n       \"ENTREZID\")\n\n#保存到文件\nsaveDb(maize.db, \"Zmays.AH66225.sqlite\")\n根据基因名gene symbol获取ENTREZ ID\nAcquisition of ENTREZ ID for non model organisms\nModel organisms, please skip this paragraph and proceed directly to\n“Enrichment Analysis”.\nreference material:\n-Guangchuang Yu’s official account:<\nhttps://mp.weixin.qq.com/s/lHKZtzpN2k9uPN7e6HjH3w\n>\n-AnnotationHub package documentation:<\nhttps://bioconductor.org/packages/release/bioc/vignettes/AnnotationHub/inst/doc/AnnotationHub.html\n>\nPreparation work:\nSave the annotation file of the correspondence between gene names and\nENTREZ IDs to a local file. In the future, when you want to obtain\nENTREZ IDs for the same genome version, simply import this’ Zmays’\n(species name) AH66225 (version). sqlite “file is sufficient. Taking\ncorn as an example:\nHub<- AnnotationHub() # It takes about 2 minutes, and if the internet speed is slow, it will take even longer\n\n#Check which species are in AnnotationHub and remember AH in column idx***\n#d <- display(hub) \n\n#Or simply search for 'zea' (a part of the Latin name for corn)\nquery(hub, \"zea\") \n\nmaize_db_candidates <- query(hub, c(\"Zea mays\", \"OrgDb\"))\n\n#Download \"AH61838\" here\nMaize.db<- hub [['AH117409 '] # It takes about 3 minutes, and if the internet speed is slow, it will take even longer\n\n#View the number of genes included\nlength(keys(maize.db)) \n#Check how many IDs are included\ncolumns(maize.db)\n#What do the IDs of the first few genes look like\nselect(maize.db, keys(maize.db)[1:3], \nc(\"REFSEQ\", \"SYMBOL\"), #The ID you want to obtain\n\"ENTREZID\")\n\n#Save to file\nsaveDb(maize.db, \"Zmays.AH66225.sqlite\")\nObtain ENTREZ ID based on gene symbol of gene name\n# 读入差异基因数据 | Read differentially expressed genes data\ngsym.fc <- read.csv(\"easy_input_Zm.csv\")\n# 查看数据前几行 | View the first few rows of the data\nhead(gsym.fc)\n# 查看数据维度 | Check the dimensions of the data\ndim(gsym.fc)\n\n# 加载本地保存的玉米注释数据库 | Load the locally saved maize annotation database\nmaize.db <- loadDb(\"Zmays.AH66225.sqlite\")\n\n# 将基因符号转换为ENTREZ ID | Convert gene symbols to ENTREZ IDs\ngsym.id <- bitr(gsym.fc$SYMBOL,     # 基因名所在的列 | Column containing gene symbols\n                \"SYMBOL\",           # 输入ID类型为基因符号 | Input ID type: gene symbol\n                \"ENTREZID\",         # 输出ID类型为ENTREZ ID | Output ID type: ENTREZ ID\n                maize.db)           # 玉米注释数据库 | Maize annotation database\n# 查看转换结果前几行 | View the first few rows of the conversion result\nhead(gsym.id)\n# 查看转换结果维度 | Check the dimensions of the conversion result\ndim(gsym.id)\n\n# 合并基因名、ENTREZ ID和表达量变化值 | Merge gene symbols, ENTREZ IDs and fold change values\nidvec <- gsym.id$ENTREZID           # 创建ENTREZ ID向量 | Create a vector of ENTREZ IDs\nnames(idvec) <- gsym.id$SYMBOL      # 设置向量名称为基因符号 | Set names of the vector to gene symbols\ngsym.fc$ENTREZID <- idvec[gsym.fc$SYMBOL]  # 将ENTREZ ID匹配到原始数据 | Map ENTREZ IDs to the original data\n# 查看合并后数据前几行 | View the first few rows of the merged data\nhead(gsym.fc)\n# 查看合并后数据维度 | Check the dimensions of the merged data\ndim(gsym.fc)\n\n# 将处理后的数据保存为CSV文件 | Save the processed data to a CSV file\nwrite.csv(gsym.fc[,c(3,2)], \"very_easy_input_Zm.csv\",  # 选择第3列(ENTREZID)和第2列(表达量) | Select column 3 (ENTREZID) and column 2 (expression value)\n          quote = F,          # 不使用引号包裹字段 | Do not quote fields\n          row.names = F)      # 不保存行名 | Do not save row names\n富集分析\n参考资料：\nhttp://bioconductor.org/packages/release/bioc/vignettes/clusterProfiler/inst/doc/clusterProfiler.html#supported-organisms\n如果你已经做好了富集分析，并且保存成“enrichGO_output.csv”的格式，就可以跳过这部分，直接进入“把clusterProfiler输出的富集分析结果转成GOplot所需的格式”\nEnrichment analysis\nReference materials:<\nhttp://bioconductor.org/packages/release/bioc/vignettes/clusterProfiler/inst/doc/clusterProfiler.html#supported\n-organisms>\nIf you have already completed the enrichment analysis and saved it in\nthe format of “enrichGO_output. csv”, you can skip this part and\ndirectly enter “Convert the enrichment analysis results output by\nclusterProfiler to the format required by GOplot”\n# 读取ENTREZ ID和log2折叠变化数据 | Read ENTREZ ID and log2 fold change data\n# 假设ENTREZ ID位于第一列，log2foldchange位于第二列 | Assume ENTREZ ID is in the first column and log2foldchange in the second column\nid.fc <- read.csv(\"very_easy_input_Mm.csv\", as.is = T)\n# 查看数据前几行 | View the first few rows of the data\nhead(id.fc)\n# 查看数据维度 | Check the dimensions of the data\ndim(id.fc)\n# 进行基因本体论(GO)富集分析 | Perform Gene Ontology (GO) enrichment analysis\nego <- enrichGO(gene = id.fc$ENTREZID,         # 输入的基因列表(ENTREZ ID) | Input gene list (ENTREZ IDs)\n                # 选择物种注释数据库 - 小鼠使用此行 | Select species annotation database - use this line for mouse\n                OrgDb = org.Mm.eg.db,\n                # 人类使用此行 | Use this line for human\n                #OrgDb = org.Hs.eg.db,\n                # 非模式生物使用此行，例如玉米 | Use this line for non-model organisms like maize\n                #OrgDb = maize.db,\n                ont = \"BP\",                   # 选择GO分类: BP(生物学过程)、MF(分子功能)或CC(细胞组分) | Select GO ontology: BP (Biological Process), MF (Molecular Function), or CC (Cellular Component)\n                pAdjustMethod = \"BH\",         # p值校正方法为Benjamini-Hochberg | P-value adjustment method: Benjamini-Hochberg\n                #pvalueCutoff  = 0.001,      # 原始p值阈值(注释掉未使用) | Raw p-value cutoff (commented out)\n                qvalueCutoff  = 0.01)        # 校正后q值阈值 | Adjusted q-value cutoff\n# 查看富集结果的维度 | Check the dimensions of the enrichment results\ndim(ego)\n# 将富集分析结果保存为CSV文件 | Save the enrichment analysis results to a CSV file\nwrite.csv(ego, \"enrichGO_output.csv\", quote = F)  # 不使用引号包裹字段 | Do not quote fields\n富集的GO term有些是相似的，可以用语义学方法，合并相似的GO\nterm。需要较长时间。\n参考资料：\nhttps://guangchuangyu.github.io/2015/10/use-simplify-to-remove-redundancy-of-enriched-go-terms/\nSome enriched GO terms are similar, and semantic methods can be used\nto merge similar GO terms. It takes a long time.\nReference materials:<\nhttps://guangchuangyu.github.io/2015/10/use-simplify-to-remove-redundancy-of-enriched-go-terms/\n>\n# 可选：简化富集结果，减少冗余 | Optional: Simplify enrichment results to reduce redundancy\n# ego2 <- simplify(ego, cutoff = 0.7, by = \"p.adjust\", select_fun = min)\n# 查看简化后的结果维度 | Check dimensions of simplified results\n# dim(ego2)\n# 将简化后的富集分析结果保存为CSV文件 | Save simplified enrichment results to CSV file\n# write.csv(ego2, \"enrichGO_simplify_output.csv\", quote = F)\n用enrichplot自带的函数画⭕️\n参考资料：\nhttps://bioconductor.org/packages/release/bioc/vignettes/enrichplot/inst/doc/enrichplot.html\nDraw using the built-in functions of enrichplot ⭕ ️\nReference materials:<\nhttps://bioconductor.org/packages/release/bioc/vignettes/enrichplot/inst/doc/enrichplot.html\n>\n# 将ENTREZ ID转换为基因符号，提高结果可读性 | Convert ENTREZ IDs to gene symbols for better readability\negox <- setReadable(ego, 'org.Mm.eg.db', # 选择物种注释数据库 | Select species annotation database\n                    'ENTREZID')           # 指定输入的ID类型为ENTREZ ID | Specify input ID type as ENTREZ ID\n\n# 准备基因表达量数据，用于可视化 | Prepare gene expression data for visualization\ngeneList <- id.fc$log2fc                  # 提取log2折叠变化值 | Extract log2 fold change values\nnames(geneList) <- id.fc$ENTREZID         # 设置基因列表的名称为ENTREZ ID | Set names of the gene list to ENTREZ IDs\n\n# 绘制基因-功能富集网络环形图 | Plot circular gene-function enrichment network\ncnetplot(egox, \n         foldChange = geneList,           # 显示基因表达量变化 | Show gene expression fold change\n         #foldChange = NULL,             # 不展示表达量变化(注释掉) | Do not show fold change (commented out)\n         circular = TRUE,                 # 设置为环形布局 | Set circular layout\n         #node_label = FALSE,            # 如果基因太多，可关闭基因名显示(注释掉) | Hide gene names if too many (commented out)\n         showCategory = 4,                # 显示富集的term数量 | Number of enriched terms to display\n         colorEdge = TRUE)                # 按关系类型着色边 | Color edges by relationship type\n# 将环形图保存为PDF文件 | Save circular plot to PDF file\nggsave(\"clusterProfiler_circle.pdf\", width = 8, height = 5)\n\n# 绘制基因-功能富集网络图(非环形) | Plot non-circular gene-function enrichment network\ncnetplot(egox, \n         foldChange = geneList,           # 显示基因表达量变化 | Show gene expression fold change\n         #foldChange = NULL,             # 不展示表达量变化(注释掉) | Do not show fold change (commented out)\n         #circular = TRUE,               # 关闭环形布局(注释掉) | Disable circular layout (commented out)\n         #node_label = FALSE,            # 不显示基因名(注释掉) | Hide gene names (commented out)\n         showCategory = 4,                # 显示富集的term数量 | Number of enriched terms to display\n         colorEdge = TRUE)                # 按关系类型着色边 | Color edges by relationship type\n# 将非环形图保存为PDF文件 | Save non-circular plot to PDF file\nggsave(\"clusterProfiler_not_circle.pdf\", width = 8, height = 5)\n把clusterProfiler输出的富集分析结果转成GOplot所需的格式\nConvert the enrichment analysis results output by clusterProfiler\ninto the format required by GOplot\n# 读取富集分析结果 | Read enrichment analysis results\nego <- read.csv(\"enrichGO_output.csv\", header = T)\n# 查看第一行数据 | View the first row of data\nego[1,]\n# 准备GO富集结果数据框 | Prepare data frame for GO enrichment results\ngo <- data.frame(Category = \"BP\",               # 设置类别为生物学过程(Biological Process) | Set category to Biological Process\n                 ID = ego$ID,                    # GO条目ID | GO term ID\n                 Term = ego$Description,         # GO条目描述 | GO term description\n                 Genes = gsub(\"/\", \", \", ego$geneID), # 将基因ID分隔符从斜杠改为逗号 | Replace gene ID separator from '/' to ', '\n                 adj_pval = ego$p.adjust)        # 校正后的p值 | Adjusted p-value\n\n# 读取基因表达量变化数据 | Read gene expression fold change data\nid.fc <- read.csv(\"very_easy_input_Mm.csv\", as.is = T)\n# 查看数据前几行 | View the first few rows of data\nhead(id.fc)\n# 创建基因表达量数据框 | Create data frame for gene expression\ngenelist <- data.frame(ID = id.fc$ENTREZID, logFC = id.fc$log2fc)             \n\n# 整合富集分析结果与表达量变化数据 | Integrate enrichment results with expression data\ncirc <- circle_dat(go, genelist)\n# 查看整合后数据前几行 | View the first few rows of integrated data\nhead(circ)\n# 将ENTREZ ID转换为基因符号 | Convert ENTREZ IDs to gene symbols\nid.gsym <- bitr(circ$genes,                    # 基因ID列 | Gene ID column\n                fromType = \"ENTREZID\",          # 输入ID类型为ENTREZ ID | Input ID type: ENTREZ ID\n                toType = \"SYMBOL\",             # 输出ID类型为基因符号 | Output ID type: gene symbol\n                OrgDb = \"org.Mm.eg.db\")        # 小鼠注释数据库 | Mouse annotation database\n# 将整合数据中的ENTREZ ID替换为基因符号 | Replace ENTREZ IDs with gene symbols in integrated data\nrownames(id.gsym) <- id.gsym$ENTREZID          # 设置行名为ENTREZ ID | Set row names to ENTREZ IDs\ncirc.gsym <- circ                               # 创建副本 | Create a copy\ncirc.gsym$genes <- id.gsym[circ$genes,]$SYMBOL # 替换基因为符号 | Replace genes with symbols\n# 查看替换后数据前几行 | View the first few rows of updated data\nhead(circ.gsym)\n# 使用GOplot包进行可视化（示例代码，未执行） | Visualization examples using GOplot (not executed)\n# GOBar(subset(circ, category == 'BP'))         # 绘制BP类别的柱状图 | Bar plot for BP category\n# GOBubble(circ, labels = 3)                    # 绘制气泡图 | Bubble plot\n# GOCircle(circ)                                 # 绘制环形图 | Circular plot\n用GOplot画⭕️图\n参考资料：\nhttp://wencke.github.io/\n准备画⭕️图所需的数据格式\n##Draw with GOplot ⭕ ️ Image\nReference materials:<\nhttp://wencke.github.io/\n>\nPrepare to draw ⭕ The required data format for the image\n# 参数设置 | Parameter settings\nn = 5 # 圈图需要选定term，这里画前面5个 | Select the top 5 enriched terms for chord diagram\n\n# 准备弦图数据 | Prepare data for chord diagram\nchord <- chord_dat(circ, genelist, go$Term[1:n])\n# 查看数据前几行 | View the first few rows of the data\nhead(chord)\n# 将ENTREZ ID转换为基因符号 | Convert ENTREZ IDs to gene symbols\nid.gsym <- bitr(row.names(chord),          # 基因ID列 | Column containing gene IDs\n                fromType = \"ENTREZID\",      # 输入ID类型为ENTREZ ID | Input ID type: ENTREZ ID\n                toType = \"SYMBOL\",         # 输出ID类型为基因符号 | Output ID type: gene symbol\n                OrgDb = \"org.Mm.eg.db\")    # 小鼠注释数据库 | Mouse annotation database\n# 将chord数据框中的ENTREZ ID行名替换为基因符号 | Replace row names (ENTREZ IDs) with gene symbols\nrownames(id.gsym) <- id.gsym$ENTREZID      # 设置行名为ENTREZ ID | Set row names to ENTREZ IDs\n# 查看转换结果前几行 | View the first few rows of the conversion result\nhead(id.gsym)\nchord.gsym <- chord                        # 创建数据框副本 | Create a copy of the data frame\nrow.names(chord.gsym) <- id.gsym[row.names(chord),]$SYMBOL  # 替换行为基因符号 | Replace row names with gene symbols\n# 查看替换后数据前几行 | View the first few rows of the updated data\nhead(chord.gsym)\n用⭕️图展示每个term里的基因及其变化倍数\nuse ⭕ The figure displays the genes and their fold changes in each\nterm\n# 绘制基因与GO术语关联的弦图 | Plot chord diagram showing gene-GO term associations\nGOChord(chord.gsym, \n        space = 0.02,           # 基因方块之间的间隙大小 | Gap between gene blocks\n        gene.order = 'logFC',   # 按log2折叠变化值排序基因 | Order genes by log2 fold change\n        lfc.col = c('darkgoldenrod1', 'black', 'cyan1'),  # 自定义表达量变化的颜色映射 | Custom color palette for fold change\n        gene.space = 0.25,      # 基因名称与圆环的相对距离 | Distance between gene names and circle\n        gene.size = 8,          # 基因名称的字体大小 | Font size for gene names\n        border.size = 0.1,      # 中间连接线黑色边框的粗细 | Thickness of black border for connections\n        process.label = 8)      # GO术语标签的字体大小 | Font size for GO term labels\n# 将弦图保存为PDF文件 | Save chord diagram to PDF file\nggsave(\"GOChord.pdf\", width = 12, height = 14)\n用⭕️聚类图展示相似变化趋势的基因所在的term\nuse ⭕ The clustering chart displays the terms of genes with similar\ntrends of change\n# 定义颜色向量，用于后续可视化 | Define color palette for visualization\nmycol <- c(\"#223D6C\",\"#D20A13\",\"#FFD121\",\"#088247\",\"#58CDD9\",\"#7A142C\",\"#5D90BA\",\"#431A3D\",\"#91612D\",\"#6E568C\",\"#E0367A\",\"#D8D155\",\"#64495D\",\"#7CC767\")\n\n# 绘制基因富集聚类图 | Plot gene enrichment cluster diagram\nGOCluster(circ.gsym, go$Term[1:n],              # 使用前n个富集的GO term | Use top n enriched GO terms\n          clust.by = 'logFC',                   # 按表达量变化值聚类基因 | Cluster genes by log2 fold change\n          #clust.by = 'term',                   # 按富集的term聚类基因(注释掉) | Cluster genes by enriched terms (commented out)\n          lfc.col = c('darkgoldenrod1', 'black', 'cyan1'), # 自定义表达量变化的颜色映射 | Custom color palette for fold change\n          lfc.space = 0.05,                     # 表达量变化与树形图之间的间距 | Space between fold change and tree\n          lfc.width = 0.01,                     # 表达量变化圆圈的宽度 | Width of fold change circles\n          term.col = mycol[1:n],                # 为每个term指定颜色 | Assign colors to terms\n          term.space = 0.05,                    # term与表达量变化之间的间距 | Space between terms and fold change\n          term.width = 0.15)                    # term圆圈的宽度 | Width of term circles\n# 将聚类图保存为PDF文件 | Save cluster diagram to PDF file\nggsave(\"GOCluster.pdf\", width = 12, height = 14)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa52GOplot_FigureYa52GOplot",
      "title": "FigureYa52GOplot/FigureYa52GOplot.html",
      "html": "FigureYa52GOplot/FigureYa52GOplot.html",
      "text": "texts/main_FigureYa52GOplot_FigureYa52GOplot.txt",
      "folder": "FigureYa52GOplot",
      "thumb": "gallery_compress/FigureYa52GOplot.webp"
    },
    "word_count": 2601,
    "lines_count": 425,
    "title": "FigureYa52 GOplot",
    "description": "用GOplot展示clusterProfiler的富集分析结果，画出paper里的⭕️图 Requirement description Display the enrichment analysis results of clusterProfiler using",
    "input_data_types": [
      "DNA-seq"
    ],
    "output_types": [
      "热图",
      "统计表格",
      "网络图"
    ],
    "technical_methods": [
      "聚类分析",
      "网络分析",
      "通路分析"
    ],
    "biology_areas": [],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "gene",
      "ont",
      "showCategory",
      "header",
      "width",
      "circular",
      "n",
      "pvalue"
    ]
  },
  {
    "id": "main_FigureYa256Plus_panelLink_FigureYa256Plus-panelLink_ori",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa256Plus_panelLink_FigureYa256Plus-panelLink_ori.txt",
    "content": "低氧相关基因分析 - Hypoxia-related Gene Analysis\n低氧相关基因分析 - Hypoxia-related Gene\nAnalysis\nYour Name\n2025-10-21\n图表说明 | Figure Legend:\nA 面板 | Panel A\n:\n展示了31个低氧相关基因在6个样品中的表达水平热图。颜色从蓝色（低表达）到红色（高表达）变化。样品按条件分组（正常氧气、低氧、高度低氧）。\nB 面板 | Panel B\n:\n散点图显示了每个基因与低氧评分的皮尔逊相关系数和对应的-log10\np值。横线代表0.05显著性水平。\nC 面板 | Panel C\n:\n按功能通路分组展示的基因表达情况，包括转录因子、血管生成、代谢重编程等关键通路。\nD 面板 | Panel D\n:\n基于表达相关性（>0.6）构建的基因调控网络。\n1. 生成示例数据 | Generate Sample Data\n# 设置随机种子以保证可重复性 | Set seed for reproducibility\nset.seed(2025)\n\n# 生成基因表达数据 | Generate gene expression data\ngenes <- c(\n  \"HIF1A\", \"HIF2A\", \"HIF3A\", \"VEGFA\", \"VEGFB\", \"VEGFC\",\n  \"EPO\", \"BNIP3\", \"BNIP3L\", \"CAIX\", \"PHD1\", \"PHD2\", \"PHD3\",\n  \"PGK1\", \"LDHA\", \"SLC16A1\", \"GLUT1\", \"GLUT3\", \"ENO1\",\n  \"PFKFB3\", \"PFKFB4\", \"PKM2\", \"PDK1\", \"PDK3\", \"GBE1\",\n  \"NDRG1\", \"ANKRD37\", \"KDM4A\", \"LOX\", \"SERPINE1\", \"CTGF\"\n)\n\n# 创建样品名称 | Create sample names (6个细胞系 | 6 cell lines)\nsamples <- paste0(\"Cell_\", 1:6)\nconditions <- c(\"Normoxia\", \"Normoxia\", \"Hypoxia\", \"Hypoxia\", \"Hypoxia_High\", \"Hypoxia_High\")\n\n# 生成表达矩阵 | Generate expression matrix\nn_genes <- length(genes)\nn_samples <- length(samples)\n\n# 正常氧气条件下的基线表达 | Baseline expression under normoxia\nbaseline_expr <- rnorm(n_genes, mean = 5, sd = 1.5)\n\n# 创建表达数据矩阵 | Create expression data matrix\nexpr_matrix <- matrix(0, nrow = n_genes, ncol = n_samples)\nrownames(expr_matrix) <- genes\ncolnames(expr_matrix) <- samples\n\nfor (i in 1:n_genes) {\n  for (j in 1:n_samples) {\n    if (j <= 2) {\n      # 正常氧气条件 | Normoxia condition\n      expr_matrix[i, j] <- baseline_expr[i] + rnorm(1, mean = 0, sd = 0.5)\n    } else if (j <= 4) {\n      # 低氧条件 | Hypoxia condition (增加表达 | increased expression)\n      expr_matrix[i, j] <- baseline_expr[i] + rnorm(1, mean = 3, sd = 1)\n    } else {\n      # 高度低氧条件 | High hypoxia condition (进一步增加 | further increased)\n      expr_matrix[i, j] <- baseline_expr[i] + rnorm(1, mean = 5, sd = 1.2)\n    }\n  }\n}\n\n# 确保没有负值 | Ensure no negative values\nexpr_matrix[expr_matrix < 0] <- 0.1\n\n# 计算低氧评分 | Calculate hypoxia scores\nhypoxia_cores <- c(\n  \"HIF1A\", \"VEGFA\", \"EPO\", \"CAIX\", \"PHD2\", \"LDHA\", \"GLUT1\", \"PGK1\"\n)\n\nhypoxia_score <- colMeans(expr_matrix[rownames(expr_matrix) %in% hypoxia_cores, ])\n\n# 创建元数据 | Create metadata\nsample_info <- data.frame(\n  sample = samples,\n  condition = conditions,\n  hypoxia_score = hypoxia_score,\n  stringsAsFactors = FALSE\n)\n\nhead(expr_matrix)\nhead(sample_info)\n2. 基因与低氧评分的关联分析 | Gene-Hypoxia Score Association\nAnalysis\n# 计算每个基因与低氧评分的相关系数 | Calculate correlation between genes and hypoxia scores\ncorrelations <- apply(expr_matrix, 1, function(x) {\n  cor(x, sample_info$hypoxia_score)\n})\n\n# 计算p值 | Calculate p-values\np_values <- apply(expr_matrix, 1, function(x) {\n  cor.test(x, sample_info$hypoxia_score)$p.value\n})\n\n# 创建结果数据框 | Create results dataframe\ngene_hypoxia_assoc <- data.frame(\n  gene = names(correlations),\n  correlation = correlations,\n  p_value = p_values,\n  log10_pval = -log10(p_values),\n  stringsAsFactors = FALSE\n) %>%\n  arrange(desc(abs(correlation)))\n\nhead(gene_hypoxia_assoc, 10)\n3. 左侧：基因表达热图与散点图 | Left Panel: Heatmap and\nScatterplot\n# 标准化表达矩阵用于热图 | Normalize expression matrix for heatmap\nexpr_scaled <- t(scale(t(expr_matrix)))\n\n# 准备绘图数据 | Prepare plotting data\nheatmap_data <- expr_scaled %>%\n  as.data.frame() %>%\n  rownames_to_column(\"gene\") %>%\n  pivot_longer(-gene, names_to = \"sample\", values_to = \"expression\")\n\n# 添加条件信息 | Add condition information\nheatmap_data <- heatmap_data %>%\n  left_join(sample_info, by = c(\"sample\" = \"sample\"))\n\n# 创建热图 | Create heatmap\np_heatmap <- ggplot(heatmap_data, aes(x = sample, y = gene, fill = expression)) +\n  geom_tile(color = \"white\", size = 0.5) +\n  scale_fill_gradient2(\n    low = \"blue\", mid = \"white\", high = \"red\",\n    name = \"表达量\\n(Expression)\"\n  ) +\n  facet_grid(. ~ condition, scales = \"free_x\", space = \"free_x\") +\n  theme_minimal() +\n  theme(\n    axis.text.x = element_text(angle = 45, hjust = 1, size = 10),\n    axis.text.y = element_text(size = 8),\n    legend.position = \"bottom\"\n  ) +\n  labs(\n    title = \"A. 基因表达热图 | Gene Expression Heatmap\",\n    x = \"样品 | Sample\",\n    y = \"基因 | Gene\"\n  )\n\nprint(p_heatmap)\n4. 散点图：相关性分析 | Scatterplot: Correlation Analysis\n# 绘制基因与低氧评分的相关性 | Plot gene-hypoxia correlation\np_scatter <- ggplot(gene_hypoxia_assoc, aes(x = correlation, y = -log10(p_value))) +\n  geom_point(aes(color = correlation, size = abs(correlation)), alpha = 0.7) +\n  scale_color_gradient2(\n    low = \"blue\", mid = \"gray\", high = \"red\",\n    name = \"相关系数\\n(Correlation)\"\n  ) +\n  scale_size_continuous(name = \"绝对值\\n(|correlation|)\") +\n  geom_hline(yintercept = -log10(0.05), linetype = \"dashed\", color = \"black\", alpha = 0.5) +\n  geom_vline(xintercept = 0, linetype = \"dashed\", color = \"black\", alpha = 0.5) +\n  # 标注关键基因 | Annotate key genes\n  ggrepel::geom_text_repel(\n    data = gene_hypoxia_assoc %>% head(10),\n    aes(label = gene),\n    size = 3\n  ) +\n  theme_minimal() +\n  labs(\n    title = \"B. 基因与低氧评分的相关性 | Gene-Hypoxia Score Correlation\",\n    x = \"皮尔逊相关系数 | Pearson Correlation Coefficient\",\n    y = \"-log10(p值) | -log10(p-value)\"\n  ) +\n  theme(\n    legend.position = \"right\",\n    plot.title = element_text(hjust = 0.5, size = 12, face = \"bold\")\n  )\n\nprint(p_scatter)\n5. 右侧：通路与靶点分析 | Right Panel: Pathway and Target\nAnalysis\n# 定义低氧响应通路与基因 | Define hypoxia response pathways and genes\npathways <- list(\n  \"转录因子\" = c(\"HIF1A\", \"HIF2A\", \"HIF3A\"),\n  \"血管生成\" = c(\"VEGFA\", \"VEGFB\", \"VEGFC\", \"ANGPT1\"),\n  \"造血\" = c(\"EPO\"),\n  \"代谢重编程\" = c(\"LDHA\", \"PKM2\", \"PFKFB3\", \"GLUT1\", \"PGK1\"),\n  \"缺氧标志\" = c(\"CAIX\", \"BNIP3\", \"BNIP3L\"),\n  \"原癌基因激活\" = c(\"MYC\", \"KRAS\", \"BRAF\"),\n  \"免疫检查点\" = c(\"PD-L1\", \"PD-L2\", \"LAG3\"),\n  \"治疗靶点\" = c(\"EGFR\", \"ALK\", \"ROS1\", \"BRAF\", \"KRAS\")\n)\n\n# Transcription factors\n# Angiogenesis\n# Hematopoiesis\n# Metabolic reprogramming\n# Hypoxia markers\n# Oncogene activation\n# Immune checkpoints\n# Therapeutic targets\n\n# 创建通路数据 | Create pathway data\npathway_data <- data.frame(\n  gene = character(),\n  pathway = character(),\n  expression_mean = numeric(),\n  target_type = character(),\n  stringsAsFactors = FALSE\n)\n\nfor (pathway in names(pathways)) {\n  genes_in_pathway <- pathways[[pathway]]\n  for (gene in genes_in_pathway) {\n    if (gene %in% rownames(expr_matrix)) {\n      expr_mean <- mean(expr_matrix[gene, 3:6])  # 低氧条件的平均表达\n    } else {\n      expr_mean <- runif(1, 3, 8)  # 为不在矩阵中的基因生成随机值\n    }\n    \n    target_type <- ifelse(\n      pathway %in% c(\"免疫检查点\", \"治疗靶点\"),\n      \"Drug Target\",\n      \"Biomarker\"\n    )\n    # Drug Target | Biomarker\n    \n    pathway_data <- rbind(pathway_data, data.frame(\n      gene = gene,\n      pathway = pathway,\n      expression_mean = expr_mean,\n      target_type = target_type,\n      stringsAsFactors = FALSE\n    ))\n  }\n}\n\n# 按通路和表达量排序 | Sort by pathway and expression\npathway_data <- pathway_data %>%\n  arrange(pathway, desc(expression_mean))\n\n# 绘制通路图 | Create pathway visualization\np_pathway <- ggplot(pathway_data, aes(x = expression_mean, y = reorder(gene, expression_mean))) +\n  geom_point(aes(color = pathway, size = expression_mean), alpha = 0.8) +\n  geom_segment(aes(xend = 0, yend = gene, color = pathway), alpha = 0.3) +\n  facet_wrap(~pathway, scales = \"free_y\", ncol = 1) +\n  scale_color_brewer(palette = \"Set2\", name = \"通路 | Pathway\") +\n  scale_size_continuous(name = \"平均表达量\\n(Mean Expression)\") +\n  theme_minimal() +\n  theme(\n    strip.text = element_text(size = 10, face = \"bold\"),\n    axis.text.y = element_text(size = 9),\n    legend.position = \"bottom\"\n  ) +\n  labs(\n    title = \"C. 低氧响应通路与基因 | Hypoxia Response Pathways and Genes\",\n    x = \"平均表达量 | Mean Expression (Hypoxia)\",\n    y = \"基因 | Gene\"\n  )\n\nprint(p_pathway)\n6. 综合分析：基因调控网络 | Integrated Analysis: Gene Regulatory\nNetwork\n# 创建基因相互作用网络 | Create gene interaction network\n# 基于表达相关性 | Based on expression correlation\n\n# 计算基因之间的相关性 | Calculate correlations between genes\ngene_cor <- cor(t(expr_matrix[1:15, ]))  # 使用前15个基因 | Use first 15 genes\n\n# 转换为网络数据 | Convert to network data\ngene_cor[lower.tri(gene_cor, diag = TRUE)] <- 0\nnetwork_edges <- which(abs(gene_cor) > 0.6, arr.ind = TRUE) %>%\n  as.data.frame() %>%\n  setNames(c(\"from\", \"to\")) %>%\n  mutate(\n    from = rownames(gene_cor)[from],\n    to = rownames(gene_cor)[to]\n  )\n\n# 创建图对象 | Create igraph object\nif (nrow(network_edges) > 0) {\n  g <- graph_from_data_frame(network_edges, directed = FALSE)\n  \n  p_network <- ggraph(g, layout = \"fr\") +\n    geom_edge_link(alpha = 0.3, color = \"gray\") +\n    geom_node_point(aes(size = 8), color = \"steelblue\", alpha = 0.8) +\n    geom_node_text(aes(label = name), repel = TRUE, size = 4) +\n    theme_graph() +\n    labs(title = \"D. 基因调控网络 | Gene Regulatory Network\")\n  \n  print(p_network)\n}\n7. 汇总统计 | Summary Statistics\n# 汇总信息 | Summary information\ncat(\"=== 数据统计摘要 | Data Summary ===\\n\")\ncat(\"基因数量 | Number of genes:\", nrow(expr_matrix), \"\\n\")\ncat(\"样品数量 | Number of samples:\", ncol(expr_matrix), \"\\n\")\ncat(\"条件类型 | Conditions:\", paste(unique(sample_info$condition), collapse = \", \"), \"\\n\\n\")\ncat(\"=== 前10个与低氧评分最相关的基因 | Top 10 Genes Correlated with Hypoxia Score ===\\n\")\nprint(head(gene_hypoxia_assoc, 10))\ncat(\"\\n=== 表达变异分析 | Expression Variance Analysis ===\\n\")\ncat(\"平均基因表达 | Mean gene expression:\", round(mean(expr_matrix), 2), \"\\n\")\ncat(\"基因表达标准差 | SD of gene expression:\", round(sd(expr_matrix), 2), \"\\n\")\ncat(\"低氧评分范围 | Hypoxia score range:\", \n    round(min(sample_info$hypoxia_score), 2), \"-\", \n    round(max(sample_info$hypoxia_score), 2), \"\\n\")\nSession Info\nsessionInfo()",
    "chapter_info": {},
    "word_count": 1216,
    "lines_count": 300,
    "title": "Analysis",
    "description": "低氧相关基因分析 - Hypoxia-related Gene Analysis Your Name",
    "input_data_types": [
      "表达矩阵"
    ],
    "output_types": [
      "散点图",
      "热图",
      "统计表格",
      "网络图"
    ],
    "technical_methods": [
      "网络分析",
      "通路分析",
      "标准化",
      "motif分析"
    ],
    "biology_areas": [
      "免疫学",
      "药物研究",
      "代谢疾病"
    ],
    "complexity_level": "高级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "to",
      "gene",
      "pathway",
      "sd",
      "directed",
      "p_value",
      "xend",
      "xintercept"
    ]
  },
  {
    "id": "main_FigureYa108RNAseqChIP_FigureYa108RNAseqChIP",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa108RNAseqChIP_FigureYa108RNAseqChIP.txt",
    "content": "FigureYa108RNAseqChIP\nFigureYa108RNAseqChIP\n¶\ntitle: \"FigureYa108RNAseqChIP\"\nauthor: \"Long Zhao, Taojun Ye\"\nreviewer: \"Ying Ge\"\ndate: \"2025-5-20\"\noutput: html_document\n需求描述\n¶\n已知RNA-seq表达谱聚类的顺序，按这个顺序排列，画出基因启动子区的ChIP-seq信号。\n出自：\nhttp://genesdev.cshlp.org/content/32/2/96.long\n对这篇文章的解读：\nhttps://mp.weixin.qq.com/s/zmf0GMdGZqNxseFZKHooOw\nRequirement description\n¶\nGiven the clustering order of RNA seq expression profiles, arrange them in this order and draw the ChIP seq signal of the gene promoter region.\nFrom:<\nhttp://genesdev.cshlp.org/content/32/2/96.long\n>\nInterpretation of this article:<\nhttps://mp.weixin.qq.com/s/zmf0GMdGZqNxseFZKHooOw\n>\n应用场景\n¶\n不仅限于按RNA-seq的聚类顺序排ChIP-seq，还可以按其他分组来排ATAC-seq或ChIP-seq，进而发现规律。\n如果自己只测了RNA-seq数据，还可以找些ChIP-seq/ATAC-seq的公共数据来丰富文章内容，按这个画法，能深挖出更多规律。\nApplication scenarios\n¶\nNot limited to sorting ChIP seq according to the clustering order of RNA seq, ATAC seq or ChIP seq can also be sorted according to other groups to discover patterns.\nIf you only test RNA seq data, you can also find some public ChIP seq/ATAC seq data to enrich the content of the article. Using this method, you can dig out more patterns.\n环境设置\n¶\n下载并安装Anaconda发行版，\nhttps://www.anaconda.com/distribution/#download-section\n用Jupyter notebook打开FigureYa107ChIPheatmap.ipynb文档\n用法参考这篇：\nhttps://mp.weixin.qq.com/s/G-CQhNEJBmMRuDe2kxND_w\n通过conda安装deeptools：\nEnvironment settings\n¶\nDownload and install the Anaconda distribution,\nhttps://www.anaconda.com/distribution/#download\n-section\nOpen the FigureYa107ChIPheatmap.ipynb document with Jupyter notebook\nRefer to this article for usage:\n<\nhttps://mp.weixin.qq.com/s/G-CQhNEJBmMRuDe2kxND_w\n>\nInstall Deeptools through conda:\nIn [ ]:\n!\nconda\ninstall\n-c\nbioconda\ndeeptools\n输入数据的准备\n¶\n需要准备以下文件：\nbw，此处以例文的ChIP-seq为例，还可以是ATAC-seq、DNase-seq、MNase-seq等等\npeak.bed，每个bw对应的peak，前第三列代表peak的位置，第四列代表peak的长度。\njoin.txt，分组信息，此处按基因表达模式分类，根据例文的TABLE S1整理而成。第一列为原文中的cluster，还可以是其他有意义的分类；第二列为基因ID，无所谓什么ID，只要唯一就行。\ngene.bed，每个基因在染色体上的位置，根据例文的TABLE S1整理而成。前三列为基因染色体位置，第四列是cluster，第五列是基因名。\nbw文件跟FigureYa107ChIPheatmap的输入相同。如果你的ChIP-seq数据已经保存为bw文件，并且有相应的peak.bed文件，就可以跳过这步，直接进入“把peak注释到基因上”。\nPreparation of input data\n¶\nThe following documents need to be prepared:\nbw， Here, taking ChIP seq from the example text as an example, it can also be ATAC seq, DNase seq, MNase seq, and so on\npeak.bed， The peak corresponding to each BW, with the first third column representing the position of the peak and the fourth column representing the length of the peak.\njoin.txt， Grouping information, classified by gene expression patterns here, organized according to Table S1 in the example text. The first column is the cluster in the original text, which can also be other meaningful classifications; The second column is the gene ID, it doesn't matter what ID it is, as long as it is unique.\ngene.bed， The position of each gene on the chromosome is organized according to Table S1 in the example text. The first three columns represent the chromosomal positions of genes, the fourth column represents clusters, and the fifth column represents gene names.\nThe bw file has the same input as FigureYa107ChIPheatmap. If your ChIP seq data has already been saved as a bw file and there is a corresponding peak.bed file, you can skip this step and directly enter \"Annotate Peaks to Genes\".\n数据下载\n¶\n测序数据在发表文章时，作者会把数据上传到GEO/SRA数据库，GEO里除了原始的fastq文件外，往往还会提供bigwig（bw）文件、或bedGraph文件，以及peak.bed文件等等。\n哪些数据更靠谱？\n推荐首选高影响因子的文章里的数据，快速查询高分数据的方式，可参考FigureYa104GEOmining。\n例文的数据链接：\nhttps://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE107242\n，点击Download中的(custom)，选择以下文件下载：\nData Download\n¶\nWhen publishing sequencing data, authors will upload the data to the GEO/SRA database. In addition to the original fastq file, GEO often provides bigwig (bw) files, bedGraph files, peak.bed files, and so on.\n**Which data is more reliable? **Recommend selecting data from articles with high impact factors, and refer to Figure Ya104 GEOmining for a quick way to query high scoring data.\nData link for example text:<\nhttps://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE107242\n>Click on (custom) in Download and select the following file to download:\nGSM2863142_Input_NO14_24_mm9.bedGraph.gz\nGSM2863147_EBF1_NO14_24_mm9.bedGraph.gz\nGSM2863148_EBF1_NO14_72_mm9.bedGraph.gz\nGSM2863149_EBF1_NO14_cd19pos_mm9.bedGraph.gz\n转换bedgraph到bigwig文件\n¶\n原文给出的是bedgraph文件，需要转换成bigwig文件。用的是UCSC的bedGraphToBigWig，用法参考这里的Example 3：\nhttp://genome.ucsc.edu/goldenPath/help/bigWig.html\n下载工具：bedGraphToBigWig，根据自己的系统选择合适的版本\nConvert bedgraph to bigwig file\n¶\nThe original text provides a bedgraph file, which needs to be converted into a bigwig file. I am using UCSC's bedGraphToBigWig, refer to Example 3 for usage here:<\nhttp://genome.ucsc.edu/goldenPath/help/bigWig.html\n>\nDownload tool: bedGraphToBigWig, choose the appropriate version according to your own system\nIn [ ]:\n#我用wget下载，你也可以复制粘贴地址，直接从浏览器下载\n#I downloaded it using wget, but you can also copy and paste the address and download it directly from the browser\n!\nwget\nhttp://hgdownload.soe.ucsc.edu/admin/exe/linux.x86_64/bedGraphToBigWig\n!\nwget\nhttp://hgdownload.soe.ucsc.edu/admin/exe/macOSX.x86_64/bedGraphToBigWig\n!\nchmod\n775\nbedGraphToBigWig\n有可能需要添加环境变量\n下载mm9的染色体长度的文件\nIt may be necessary to add environment variables\nDownload the file of chromosome length for mm9\nIn [ ]:\n!\nwget\nhttp://hgdownload.cse.ucsc.edu/goldenPath/mm9/bigZips/mm9.chrom.sizes\n现在就可以把ChIP-seq的bedGraph文件转成bw了：\nNow you can convert the ChIP seq bedGraph file to bw:\nIn [ ]:\n!\nfor\nfile\nin\n*.bedGraph\n;\ndo\nsort\n-k1,1\n-k2,2n\n$file\n>\n$file\n.sorted.bedGraph\n;\nbedGraphToBigWig\n$file\n.sorted.bedGraph\nmm9.chrom.sizes\n$file\n.bw\n;\nrm\n$file\n.sorted.bedGraph\n;\ndone\n获得peak.bed\n¶\n可以跳过这步，直接用我跑好的peak.bed文件\n文章没有提供每个样品的peak文件，找peak不是这里的重点，就不从头跑了。仅从文章提供的bedgraph文件开始做，定义EBF1 ChIP-seq较高的位置为peak，作为示例文件。有点粗糙，但足够用于展示需求描述所需解决的问题。\nGet peak.bed\n¶\nYou can skip this step and directly use the peak.bed file that I have run\nThe article did not provide a peak file for each sample, so finding the peak is not the focus here, so we won't start from scratch. Starting from the bedgraph file provided in the article, define the higher position of EBF1 ChIP seq as peak as an example file. A bit rough, but sufficient to demonstrate the problem that needs to be solved in the requirement description.\nIn [ ]:\n!\nfor\nfile\nin\nGSM*_EBF1_*.bedGraph\n;\ndo\nawk\n'$4> 30 {print}'\nOFS\n=\n\"\\t\"\n$file\n|\nsort\n-k1,1V\n-k2,2n\n-k3,3n\n|\nbedtools\nmerge\n-i\n-\n|\nawk\n'{print $1,$2,$3,$3-$2}'\nOFS\n=\n\"\\t\"\n|\nawk\n'$4<4000{ print }'\nOFS\n=\n\"\\t\"\n>\n$file\n.peak.bed\n;\ndone\n附：\n正常的做法是用MACS从每个样本的bam文件里call出peak.bed，例如：\n**Attachment: * * The normal practice is to use MACS to call peak.bed from the BAM file of each sample, for example:\nmacs2\ncallpeak\n-c\nInput.bam\n-t\ntreatment.bam\n-q\n0\n.05\n-f\nBAM\n-g\nmm\n-n\ntreatment\n2\n>\ntreatment.macs2.log\n把peak注释到基因上\n¶\nAnnotate peak onto genes\n¶\nIn [ ]:\n# 通过conda安装bedtools\n#Installing Bedtools through Conda\n!\nconda\ninstall\n-c\nbioconda\nbedtools\n!\nfor\nfile\nin\nGSM*_EBF1_*.bedGraph.peak.bed\n;\ndo\nwindowBed\n-a\ngene.bed\n-b\n$file\n-w\n3000\n-sm\n|\nsort\n-k9,9nr\n|\nsort\n-k5,5n\n-u\n|\nawk\n'{print $6,$7,$8,$4,$5}'\nOFS\n=\n\"\\t\"\n>\n$file\n.gene.bed\n;\ndone\n对上面这行命令的说明：\nwindowBed -a gene.bed -b 24_EBF1.bed -w 3000 -sm：这一步用于把和目的基因上下游3K的peak找出来。\nsort -k9,9nr 24_gene.bed |sort -k5,5n -u ：这一步是对找到的peak进行排序，并保留每个基因peak长度最长的peak。\nawk '{print $6,$7,$8,$4,$5}' OFS=\"\\t\" ：这一步是输出peak的位置。\n由于个人习惯，所以添加的管道“|”较多，练习时可以拆分出来，一步生成一个中间文件，这样就可以查看每一步骤的作用。\n输出文件的前三列为目的peak的位置，第四列为该peak靶基因的cluster，第五列为靶基因的基因名。\nExplanation of the above command:\nWindowBed - a gene.bed - b 24-EBF1. bed-w 3000 sm: This step is used to find the peak upstream and downstream 3K of the target gene.\nSort-k9,9nr 24_gene.bed | sort-k5,5n-u: This step is to sort the found peaks and retain the longest peak length for each gene peak.\nAwk '{print $6, $7, $8, $4, $5}' OFS=\"\\ t\": This step is to output the position of the peak.\nDue to personal habits, there are many pipelines' | 'added. During practice, they can be separated to generate an intermediate file in one step, so that the purpose of each step can be viewed.\nThe first three columns of the output file are the location of the target peak, the fourth column is the cluster of the target gene for that peak, and the fifth column is the gene name of the target gene.\nIn [ ]:\n!\nhead\nGSM2863149_EBF1_NO14_cd19pos_mm9.bedGraph.peak.bed.gene.bed\nIn [ ]:\n## 把三个样品的peak merge到一起，并且保证每个基因只有一个peak保留下来\n##Merge the peaks of the three samples together and ensure that only one peak is retained for each gene\n!\ncat\nGSM*_EBF1_*.bedGraph.peak.bed.gene.bed\n|\nsort\n-k1,1V\n-k2,2n\n-k3,3n\n|\nbedtools\nmerge\n-i\n-\n-c\n5\n-o\ncollapse\n|\nawk\n-F\n\",\"\n'{print $1}'\nOFS\n=\n\"\\t\"\n|\nsort\n-k4,4n\n-u\n>\nall.unique.bed\n对上面这行命令的说明：\ncat 24.bed 72.bed prob.bed | sort -k1,1V -k2,2n -k3,3n：把三个样品的peak cat起来并排序（因为bedtools要输入sorted bed）。\nbedtools merge -i - -c 5 -o collapse ：把三个样品的peak merge到一起（-c 5 -o collapse，输出基因名）\nawk -F \",\" '{print $1}' OFS=\"\\t\" |  sort -k4,4n -u ：输出基因唯一的peak，并按照基因名排序。\n输出文件的前三列为基因的蛋白结合位点，第四列为基因名。\nExplanation of the above command:\nCat 24. bed 72. bed prob.bed | sort-k1,1V - k2,2n - k3,3n: Cat the peaks of the three samples and sort them (because bedtools needs to input sorted bed).\nBedtools merge - i -- c 5- o collapse: Merge the peaks of three samples together (- c 5- o collapse, output gene name)\nAwk-F \",\" {print $1} 'OFS=\"\\ t\" | sort k4,4n-u: Output the unique peak of the gene and sort it by gene name.\nThe first three columns of the output file are the protein binding sites of the gene, and the fourth column is the gene name.\nIn [ ]:\n!\nhead\nall.unique.bed\n准备deeptools 输入bed文件\n¶\nPrepare Deeptools to input the bed file\n¶\nIn [ ]:\n!\nawk\n'{print $1,$2,$3,$4,\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\",\".\"}'\nOFS\n=\n\"\\t\"\nall.unique.bed\n>\nall.new.bed\n!\ncomputeMatrix\nreference-point\n--referencePoint\ncenter\n-b\n3000\n-a\n3000\n--missingDataAsZero\n--skipZeros\n-p\n40\n-R\nall.new.bed\n-S\nGSM2863142_Input_NO14_24_mm9.bedGraph.bw\nGSM2863147_EBF1_NO14_24_mm9.bedGraph.bw\nGSM2863148_EBF1_NO14_72_mm9.bedGraph.bw\nGSM2863149_EBF1_NO14_cd19pos_mm9.bedGraph.bw\n-o\nnom.gz\n!\nplotHeatmap\n-m\nnom.gz\n-out\nheatmap-pre.pdf\n--kmeans\n5\n--outFileSortedRegions\nHeatmap1sortedRegions.bed\n忽略输出的heatmap-pre.pdf。我们要的是输出的Heatmap1sortedRegions.bed文件。\nIgnore the output heatmap-pre.gdf. What we need is the output Heatmap1sortedRegions.bed file.\nIn [ ]:\n!\nhead\nHeatmap1sortedRegions.bed\n把Heatmap1sortedRegions.bed文件中的deepTools_group一列替换成例文中基因的cluster，即D1,D2,D3,D4。\n这里用R的merge函数完成替换，把命令写进R脚本mergeInR.R文件里，位于当前文件夹。\n当然你可也可通过linux自带的函数join来实现（join对文件顺序要求比较高，而且容易有bug）。\nReplace the deepTools_group column in the Heatmap1sortedRegions.bed file with the gene clusters in the example text, namely D1, D2, D3, D4.\nHere, use R's merge function to complete the replacement, write the command into the R script merge in R.R file, located in the current folder.\nOf course, you can also implement it through the Linux built-in function 'join' (which requires high file order and is prone to bugs).\nIn [ ]:\n!\nhead\nmergeInR.R\nIn [ ]:\n# 运行上面的R脚本\n#Run the R script above\n!\nR\nCMD\nBATCH\nmergeInR.R\n最后把Heatmap1sortedRegions.bed的第一行粘上去。\nFinally, paste the first line of Heatmap1sortedRegions.bed.\nIn [ ]:\n!\nhead\n-1\nHeatmap1sortedRegions.bed\n|\ncat\n-\nxx.bed\n>\nyy.bed\n开始画图\n¶\n按join.txt里的基因的分类（已经保存在yy.bed文件中）给ChIP-seq信号分类，每类内部再聚类。\n具体参数的调整看这里：\nhttps://deeptools.readthedocs.io/en/develop/content/tools/plotHeatmap.html?highlight=plotHeatmap\nStart drawing\n¶\nClassify ChIP seq signals according to the gene classification in join.txt (already saved in the yy.bed file), and then cluster within each category.\nSpecific parameter adjustments can be found here:<\nhttps://deeptools.readthedocs.io/en/develop/content/tools/plotHeatmap.html?highlight=plotHeatmap\n>\nIn [ ]:\n!\ncomputeMatrix\nreference-point\n--referencePoint\ncenter\n-b\n3000\n-a\n3000\n--missingDataAsZero\n--skipZeros\n-p\n40\n-R\nyy.bed\n-S\nGSM2863142_Input_NO14_24_mm9.bedGraph.bw\nGSM2863147_EBF1_NO14_24_mm9.bedGraph.bw\nGSM2863148_EBF1_NO14_72_mm9.bedGraph.bw\nGSM2863149_EBF1_NO14_cd19pos_mm9.bedGraph.bw\n-o\nnom.gz\n!\nplotHeatmap\n-m\nnom.gz\n-out\nheatmap.pdf\n--heatmapWidth\n4\n--heatmapHeight\n10\n--whatToShow\n\"heatmap and colorbar\"\n--zMax\n100\n--samplesLabel\n0hrs\n24hrs\n72hrs\npro-B\n#如果想画average profile，就删掉：--whatToShow \"heatmap and colorbar\"\n#如果想保留基因在gene.bed文件中的顺序，就加上：--sortRegions keep\n#If you want to draw an average profile, delete: -- whatoShow \"heatmap and colorbar\"\n# If you want to preserve the order of genes in the gene.bed file, add: -- sortRegions keep\n生成的图在heatmap.pdf文件里，是矢量图，可以用Illustrator等软件编辑图形、文字等。\nThe generated image is in the heatmap.ddf file and is a vector image that can be edited with software such as Illustrator for graphics, text, etc.\nIn [ ]:\nimport\nIPython\nprint\n(\nIPython\n.\nsys_info\n())\n!\njupyter\nnbconvert\n--to\nhtml\nFigureYa108RNAseqChIP.ipynb\nIn [ ]:",
    "chapter_info": {
      "id": "main_FigureYa108RNAseqChIP_FigureYa108RNAseqChIP",
      "title": "FigureYa108RNAseqChIP/FigureYa108RNAseqChIP.html",
      "html": "FigureYa108RNAseqChIP/FigureYa108RNAseqChIP.html",
      "text": "texts/main_FigureYa108RNAseqChIP_FigureYa108RNAseqChIP.txt",
      "folder": "FigureYa108RNAseqChIP",
      "thumb": "gallery_compress/FigureYa108RNAseqChIP.webp"
    },
    "word_count": 1618,
    "lines_count": 493,
    "title": "FigureYa108RNAseqChIP",
    "description": "¶ 已知RNA-seq表达谱聚类的顺序，按这个顺序排列，画出基因启动子区的ChIP-seq信号。 出自：",
    "input_data_types": [
      "临床数据"
    ],
    "output_types": [
      "热图",
      "统计表格"
    ],
    "technical_methods": [
      "聚类分析"
    ],
    "biology_areas": [
      "药物研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "acc",
      "highlight"
    ]
  },
  {
    "id": "main_FigureYa1survivalCurve_update_FigureYa1survivalCurve_update",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa1survivalCurve_update_FigureYa1survivalCurve_update.txt",
    "content": "FigureYa1SurvivalCurve_update\nFigureYa1SurvivalCurve_update\nAuthor(s)\n: Dekang Lv; Ying Ge, Yijing Chen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n网上搜到过代码，但是都是用TCGA自己带的肺癌数据画的，我需要用自己的数据绘制。\n两组或多组对比。\nI’ve searched the internet for code, but it’s all drawn with TCGA’s\nown lung cancer data that it comes with, and I need to draw it with my\nown data.\nTwo or more groups are compared.\n使用场景\nUsage scenario\n需要至少两列信息：结局和结局的发生时间。如果还要做组间对比就再来一列分组信息。\n用于展示分类样本的生存曲线，或其他有结局和结局发生时间的数据。\n更多应用和背景知识可参考“小白学统计”的生存分析系列：\n生存分析（一）生存分析方法，你听说过几种？\nhttps://mp.weixin.qq.com/s/pAVzfPLfGmnaxQ93IQgmjw\n生存分析（二）中位生存时间和中位随访时间，\nhttps://mp.weixin.qq.com/s/I_sHAz-RP5s7z1-75nIFSg\n生存分析（三）log-rank检验在什么情况下失效？\nhttps://mp.weixin.qq.com/s/XpPpOpeNcIDXbd6es5VnvA\n生存分析（四）我们的生命，能否如指数分布般平稳？\nhttps://mp.weixin.qq.com/s/NsMX3U_Bcmyn7u6NFGIaBw\n生存分析（五）实用的（却又被忽略的）Weibull回归，\nhttps://mp.weixin.qq.com/s/RsVaqu3p9SXNICWaxaPbeQ\n生存分析（六）如何判断你的生存数据能否用cox回归——等比例风险假定判断，\nhttps://mp.weixin.qq.com/s/7lCRmezb0yw1JewHBw0ZrQ\nAt least two columns of information are needed: the ending and when\nthe ending occurred. If you also want to do a comparison between groups\nhave another column for grouping information.\nUsed to present survival curves for categorized samples, or other\ndata with endpoints and time of occurrence of endpoints.\nMore applications and background knowledge can be found in the\nsurvival analysis series of “Xiaobai Learning Statistics”:\nSurvival Analysis (I) Survival analysis methods, how many have\nyou heard of?\nhttps://mp.weixin.qq.com/s/pAVzfPLfGmnaxQ93IQgmjw\nSurvival Analysis (II) Median survival time and median follow-up\ntime,\nhttps://mp.weixin.qq.com/s/I_sHAz-RP5s7z1-75nIFSg\nSurvival Analysis (III) Under what circumstances does the\nlog-rank test fail?\nhttps://mp.weixin.qq.com/s/XpPpOpeNcIDXbd6es5VnvA\nSurvival Analysis (IV) Our lives, can they be as smooth as an\nexponential distribution?\nhttps://mp.weixin.qq.com/s/NsMX3U_Bcmyn7u6NFGIaBw\nSurvival Analysis (V) The Practical (Yet Overlooked) Weibull\nRegression,\nhttps://mp.weixin.qq.com/s/RsVaqu3p9SXNICWaxaPbeQ\nSurvival Analysis (VI) How to tell if your survival data can be\njudged with cox regression - equal proportional risk assumption,\nhttps://mp.weixin.qq.com/s/7lCRmezb0yw1JewHBw0ZrQ\n该如何分组呢？\n可以通过best\nseparation来按表达量高低分组，可参考FigureYa4bestSeparation用中位值分组或找最佳分组；或者批量为多个基因找最佳分组，可参考FigureYa35batch_bestSeparation。\n或者不用表达量分组，而是用已知的亚型（聚类得到，或者金标准亚型）分组，可参考FigureYa116supervisedCluster，进一步用它的金标准亚型寻找marker，再利用监督层次聚类在验证集上识别新亚型。\nHow should it be grouped?\nYou can use best separation to group by high or low expression, see\nFigureYa4bestSeparation to group by median value or find the best group;\nor batch to find the best group for multiple genes, see\nFigureYa35batch_bestSeparation.\nOr instead of using expression grouping, use known subtypes (obtained\nby clustering, or gold standard subtypes) grouping, see\nFigureYa116supervisedCluster, and further use its gold standard subtypes\nto find markers, and then use supervised hierarchical clustering to\nidentify new subtypes on the validation set.\n环境设置\nEnvironment setting\nsource(\"install_dependencies.R\")\nlibrary(\"survival\")\nlibrary(\"survminer\")\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 display English error messages\noptions(stringsAsFactors = FALSE) #禁止chr转成factor prohibit the conversion of chr to factor\n输入数据的预处理\nPreprocessing of input data\n如果你的数据已经整理成“easy_input_*.txt”的格式，就可以跳过这步，直接进入“两组对比”。\n如果想获得TCGA的生存数据，可参考FigureYa128Prognostic。\n需求方提供的输入数据生存期是Months列，样本分类和追踪情况揉在第2和3列中，1代表death，0代表alive，NA和1/0代表样本分类，因此，样本分类和追踪情况需要重新生成\nIf your data has been organized into “easy_input_*.txt” format, you\ncan skip this step and go directly to the “two group comparison”.\nFor TCGA survival data, see FigureYa128Prognostic.\nThe input data survival provided by the demand-side is the Months\ncolumn, and the sample classification and tracking are rubbed in columns\n2 and 3, with 1 for death, 0 for alive, and NA and 1/0 for Sample\nClassification, so the sample classification and tracking will need to\nbe regenerated\nsvData<-read.delim(file=\"not_easy_input.txt\",header=T,as.is=T)\nhead(svData)\nsvData$Expression <- NA\nsvData$Expression[!is.na(svData$PD.L1.protein.high.expression)] <- \"high\"\nsvData$Expression[is.na(svData$PD.L1.protein.high.expression)] <- \"low\"\nsvData$Status <- 1+(!is.na(svData$PD.L1.protein.high.expression|svData$PD.L1.protein.low.expression))\nhead(svData[,c(1,4,5)])\nwrite.table(svData[,c(1,4,5)],file=\"easy_input_2.txt\",sep = \"\\t\",col.names = T,row.names = F,quote = F)\n可以看到重新生成后，svData中生存期、样本分类和追踪情况分别是Months、Expression、Status列。\n多说一句，追踪信息遵循的规则是，The status indicator, normally\n0=alive, 1=dead. Other choices are TRUE/FALSE (TRUE = death) or 1/2\n(2=death)\n再模拟一个3组的输入文件，仅用来展示三组对比的画法：\nYou can see that after regeneration, the survival, sample\nclassification, and tracking status in svData are the Months,\nExpression, and Status columns, respectively.\nAs an additional note, tracking information follows the rule that the\nstatus indicator, normally 0=alive, 1=dead. Other choices are TRUE/FALSE\n(TRUE = death) or 1/2 (2=death)\nA further 3-group input file is simulated and used only to show the\ndrawing of the three contrasting groups:\nsvData$Expression[35:55] <- \"med\"\nwrite.table(svData[,c(1,4,5)],file=\"easy_input_3.txt\",sep = \"\\t\",col.names = T,row.names = F,quote = F)\n两组对比\nComparison of two groups\n输入文件\nInput file\n画图用的数据结构是一个包含样本分类、生存期和追踪情况的数据框。\nThe data structure used for drawing the graph is a data frame\ncontaining the sample classification, survival and follow-up.\nsvData <- read.table(\"easy_input_2.txt\", header = T, as.is = T)\nhead(svData)\nunique(svData$Expression)\nsvData$Expression <- factor(svData$Expression, levels = c(\"high\",\"low\"))\n开始画图\nStart drawing\n常见调整参数有颜色、线的类型、是否显示置信区间等\n用?ggsurvplot查看更多参数设置\nCommon adjustment parameters are color, line type, whether to display\nconfidence intervals, etc.\nSee more parameter settings with ?ggsurvplot\n# 这里用默认参数做回归\n# 如果想先判断符合哪种分布再选择合适的方法回归，我们再实现吧。\n# Here the regression is done with default parameters\n# If you want to determine which distribution is met before choosing the appropriate method of regression, let's crowdsource it again.\nfit <- survfit(Surv(Months, Status) ~ Expression, data = svData)\n\n#先用默认参数画，用于校对后面画的图\n#Drawing with default parameters first is used to proofread the diagrams drawn later on\nggsurvplot(fit)\n#不画置信区间\n#No confidence intervals are drawn\nggsurvplot(fit, pval = TRUE,linetype = c(\"solid\", \"dashed\"), #线的类型 type of line\n           palette = c(\"red\",\"blue\"),#线的颜色 color of line\n           legend.title=\"\",legend=c(0.7,0.9),#图例的位置 location of legend\n           legend.labs=c(\"High-expression\",\"Low-expression\"),\n           conf.int = F) #不显示置信区间 confidence intervals are not shown\nggsave(file=\"survivalcurve_2.pdf\", width = 4, height = 4)\n\n#画置信区间\n#Draw confidence intervals\npdf(\"survivalcurve_2_table.pdf\", width = 6, height = 5)\nggsurvplot(fit, pval = TRUE, linetype = \"solid\", #都画实线 draw solid lines\n           palette = c(\"red\",\"blue\"),\n           legend.title=\"\",legend=c(0.7,0.9),\n           legend.labs=c(\"High-expression\",\"Low-expression\"),\n           \n           # 画表格 \n           # draw a table\n           risk.table = TRUE,\n           tables.height = 0.2,\n           tables.theme = theme_cleantable(),\n\n           conf.int = T,#显示置信区间 show confidence intervals\n           conf.int.style=\"ribbon\",#展示方式 display mode\n           conf.int.alpha=0.1)#透明度 transparency\ndev.off()\n三组对比\nThree groups of comparisons\n如果有更多组要对比，就按照规律在参数里添加即可。\nIf there are more groups to compare, just follow the pattern and add\nthem in the parameters.\n输入文件\nInput file\nsvData <- read.table(\"easy_input_3.txt\", header = T, as.is = T)\nhead(svData)\nunique(svData$Expression)\nsvData$Expression <- factor(svData$Expression, levels = c(\"high\",\"med\",\"low\"))\n开始画图\nStart drawing\npvalue的计算方法可修改，可通过?surv_pvalue查看可选的method\nThe method of calculating pvalue can be modified, see the optional\nmethod via ?surv_pvalue\nfit <- survfit(Surv(Months, Status) ~ Expression, data = svData)\n\n#先用默认参数画，用于校对后面画的图\n#Drawing with default parameters first is used to proofread the diagrams drawn later on\nggsurvplot(fit)\n#不画置信区间\n#No confidence intervals are drawn\nggsurvplot(fit, pval = TRUE,linetype = c(\"solid\", \"solid\", \"solid\"), #线的类型 type of line\n           palette = c(\"red\",\"navy\",\"darkgreen\"),#线的颜色 color of line\n           legend.title=\"\",legend=c(0.7,0.9), #图例的位置 location of legend\n           legend.labs=c(\"High-expression\", \"med-expression\", \"low-expression\"),\n           conf.int = F) #不显示置信区间 confidence intervals are not shown\nggsave(file=\"survivalcurve_3.pdf\", width = 4, height = 4)\n\n#画置信区间\n#Draw confidence intervals\npdf(\"survivalcurve_3_table.pdf\", width = 7, height = 6)\nggsurvplot(fit, pval = TRUE, linetype = \"solid\", #都画成实线 draw solid lines\n           palette = c(\"red\",\"navy\",\"darkgreen\"),\n           legend.title=\"\",legend=c(0.8,0.9),\n           legend.labs=c(\"High-expression\",\"med-expression\", \"low-expression\"),\n           \n           # 画表格\n           # draw a table\n           risk.table = TRUE,\n           tables.height = 0.3,\n           tables.theme = theme_cleantable(),\n\n           conf.int = T,#显示置信区间 show confidence intervals\n           conf.int.style=\"ribbon\",#展示方式 display mode\n           conf.int.alpha=0.1)#透明度 transparency\ndev.off()\n输出的pdf文件是矢量图，可以在Illustrator等软件里进行字体、字号等编辑操作\nThe output pdf file is a vector image, can be in Illustrator and\nother software for fonts, font size and other editing operations\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa1survivalCurve_update_FigureYa1survivalCurve_update",
      "title": "FigureYa1survivalCurve_update/FigureYa1survivalCurve_update.html",
      "html": "FigureYa1survivalCurve_update/FigureYa1survivalCurve_update.html",
      "text": "texts/main_FigureYa1survivalCurve_update_FigureYa1survivalCurve_update.txt",
      "folder": "FigureYa1survivalCurve_update",
      "thumb": "gallery_compress/FigureYa1survivalCurve_update.webp"
    },
    "word_count": 1025,
    "lines_count": 227,
    "title": "FigureYa1SurvivalCurve_update",
    "description": "Requirement description 网上搜到过代码，但是都是用TCGA自己带的肺癌数据画的，我需要用自己的数据绘制。 两组或多组对比。",
    "input_data_types": [
      "临床数据",
      "生存数据"
    ],
    "output_types": [
      "统计表格",
      "生存曲线"
    ],
    "technical_methods": [
      "聚类分析",
      "生存分析"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "TRUE",
      "header",
      "width",
      "1",
      "pvalue",
      "theme",
      "legend",
      "int",
      "pval"
    ]
  },
  {
    "id": "main_FigureYa72biomarker_FigureYa72biomarker",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa72biomarker_FigureYa72biomarker.txt",
    "content": "FigureYa72biomarker\nFigureYa72biomarker\nWen Wang, Taojun Ye\n2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n复现原文的nearest shrunken centroid\nclassification找biomarker，画出文章里的图。\nRequirement Description\nReproduce the original article’s nearest shrunken centroid\nclassification to find the biomarker and draw the graph in the\narticle.\n出自\nhttps://www.nature.com/articles/s41598-017-14314-y\nfrom\nhttps://www.nature.com/articles/s41598-017-14314-y\n应用场景\n找癌症分型的biomarker。不限于例文的DNA甲基化数据，经典的用法是根据表达数据分型。\n参考资料：Robert Tibshirani, Trevor Hastie, Balasubramanian\nNarasimhan, and Gilbert Chu. 2002. Diagnosis of multiple cancer types by\nshrunken centroids of gene expression PNAS 99: 6567-6572.\nApplication Scenarios\nFinding biomarkers for cancer typing. not limited to DNA methylation\ndata in the example text, classic usage is typing based on expression\ndata.\nRef: Robert Tibshirani, Trevor Hastie, Balasubramanian Narasimhan,\nand Gilbert Chu. 2002. Diagnosis of multiple cancer types by shrunken\ncentroids of gene expression PNAS 99: 6567-6572.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\n# 加载PAMR包 - 用于微阵列数据分类分析 / Load PAMR package - for microarray data classification\nlibrary(pamr)  \n\n# 加载data.table包 - 提供高性能数据处理功能 / Load data.table package - for high-performance data manipulation\nlibrary(data.table)\n\n# 设置系统语言环境为英文 - 使报错信息显示为英文 / Set system language to English - for English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 设置全局选项 - 防止自动将字符串转换为因子 / Set global option - prevent automatic conversion of strings to factors\noptions(stringsAsFactors = FALSE)\n参数设置\nParameter setting\n# 定义颜色向量 - 用于后续可视化 / Define color vector - for visualization purposes\ncols = c(\"red\", \"green\")  \n\n# 定义分组标签 - 对应两种样本类型 / Define group labels - for two sample types\nlabels = c(\"Solid Tissue Normal\", \"Primary Tumor\")  \n\n# 设置抽样参数说明：\n# 全量计算会消耗极大内存（注释掉的原说明）\n# Sampling parameters setting:\n# Using full data will consume huge memory (original commented explanation)\n\n# 固体正常组织样本抽样数（设为0表示不抽样）\n# Number of solid tissue normal samples to sample (0 means no sampling)\nSTN_number <- 50  \n\n# 原发性肿瘤样本抽样数（设为0表示不抽样） \n# Number of primary tumor samples to sample (0 means no sampling)\nPT_number <- 50   \n\n# 重要警告注释：\n# 1. 不抽样（设为0）将导致极高内存使用（>5GB）\n# 2. 普通笔记本电脑可能无法处理\n# Important warnings:\n# 1. No sampling (set to 0) will cause extremely high memory usage (>5GB)\n# 2. Regular laptops may not handle it\n\n# 设置随机数种子 - 保证抽样结果可重复\n# Set random seed - ensures reproducible sampling results\nset.seed(6666)\n输入数据预处理\n做nearest shrunken centroid\nclassification需要两种信息：分类（例如normal和tumor）和特征数据（表达矩阵、DNA甲基化等等）。例文用TCGA\nKIRC的DNA甲基化芯片数据找区分tumor跟normal的biomarker。\n从\nUCSC\nxena\n下载Kidney Clear Cell Carcinoma\n(KIRC)处理好的甲基化芯片数据和表型注释文件。下载地址：\nDNA甲基化芯片：\nhttps://gdc.xenahubs.net/download/TCGA-KIRC/Xena_Matrices/TCGA-KIRC.methylation450.tsv.gz\n表型：\nhttps://tcga.xenahubs.net/download/TCGA.KIRC.sampleMap/KIRC_clinicalMatrix.gz\nInput data preprocessing\nTo do nearest shrunken centroid classification, we need two kinds of\ninformation: classification (e.g. normal and tumor) and feature data\n(expression matrix, DNA methylation, etc.). In the example, DNA\nmethylation microarray data from TCGA KIRC is used to find the biomarker\nthat distinguishes tumor from normal.\nDownload Kidney Clear Cell Carcinoma (KIRC) processed methylation\nmicroarray data and phenotype annotation files from\nUCSC xena\n. Download\naddress:\nDNA methylation microarray:\nhttps://gdc.xenahubs.net/download/TCGA-KIRC/Xena_Matrices/TCGA-KIRC.methylation450.tsv.gz\nPhenotypes:\nhttps://tcga.xenahubs.net/download/TCGA.KIRC.sampleMap/KIRC_clinicalMatrix.gz\n表型\nPhenotype\n# 读取表型数据 - 从压缩的临床数据文件中提取样本类型信息\n# Read phenotype data - extract sample type information from compressed clinical data file\nphenotype <- read.table(\n  file = gzfile(\"TCGA-KIRC.clinical.tsv.gz\"),  # 读取gzip压缩文件 / Read gzipped file\n  header = TRUE,                            # 第一行作为列名 / First row as column names\n  sep = \"\\t\",                               # 制表符分隔 / Tab-delimited\n  # colClasses = c(\"character\", rep(\"NULL\",82), \"integer\", rep(\"NULL\",37)),  # 只读取第一列和84列 / Only read 1st and 84th columns\n  row.names = 1                             # 第一列作为行名 / Use first column as row names\n)\nphenotype <- phenotype[,c(1, ncol(phenotype))]\nhead(phenotype)  # 查看前几行数据 / Check first few rows\n# 读取甲基化数据样本信息\n# Read methylation data sample information\nsample <- read.table(\n  file = gzfile(\"TCGA-KIRC.methylation450.tsv.gz\"),  # 甲基化数据文件 / Methylation data file\n  sep = \"\\t\",                                        # 制表符分隔 / Tab-delimited\n  stringsAsFactors = FALSE,                          # 不转换字符串为因子 / Don't convert strings to factors\n  nrows = 1,                                        # 只读第一行(样本名) / Only read first row (sample names)\n  row.names = 1                                     # 第一列作为行名 / Use first column as row names\n)\n\n# 匹配样本类型信息\n# Match sample type information\nsample_type <- phenotype[substr(sample, 1, 15), \"tissue_type.samples\"]  # 提取前15字符匹配 / Match first 15 characters\n\n# 识别正常组织和原发肿瘤样本\n# Identify normal and tumor samples\nSTN_samples <- which(sample_type == \"Normal\")  \nPT_samples <- which(sample_type == \"Tumor\")    \n\n# 样本抽样处理 - 考虑内存限制\n# Sample sampling processing - considering memory limitations\n\n# 正常组织样本抽样\n# Solid Tissue Normal sampling\nif(STN_number == 0){\n  STN_samples_select <- STN_samples  # 不抽样，使用全部样本 / No sampling, use all samples\n  STN_number <- length(STN_samples)  # 记录样本总数 / Record total sample count\n} else {\n  STN_samples_select <- sample(STN_samples, STN_number)  # 随机抽样 / Random sampling\n}\n\n# 原发肿瘤样本抽样\n# Primary Tumor sampling\nif(PT_number == 0){\n  PT_samples_select <- PT_samples    # 不抽样，使用全部样本 / No sampling, use all samples\n  PT_number <- length(PT_samples)    # 记录样本总数 / Record total sample count\n} else {\n  PT_samples_select <- sample(PT_samples, PT_number)  # 随机抽样 / Random sampling\n}\nDNA甲基化数据\nDNA methylation data\nfull_data <- fread(\"TCGA-KIRC.methylation450.tsv.gz\", sep=\"\\t\", header = T, stringsAsFactors = F)\n# 读取TCGA-KIRC项目的甲基化450K芯片数据（中文注释）\n# Read methylation 450K array data from TCGA-KIRC project (English comment)\n# 读取normal和tumor各50个样本，共485577个CpG位点（中文注释）\n# Read 50 normal and 50 tumor samples, total 485577 CpG sites (English comment)\n# select参数+1是因为fread的列选择从1开始（中文注释）\n# select parameter +1 because fread column selection starts from 1 (English comment)\n# methylation_matrix <- fread(file=\"TCGA-KIRC.methylation450.tsv.gz\", sep=\"\\t\", stringsAsFactors = F, header = T, select = c(STN_samples_select, PT_samples_select) + 1)\ncols_to_select <- c(STN_samples_select, PT_samples_select + 1)\nmethylation_matrix <- full_data[, ..cols_to_select]\ndim(methylation_matrix)\n# 读取所有CpG位点的ID（第一列）（中文注释）\n# Read IDs of all CpG sites (first column) (English comment)\n# cgList <- fread(file = \"TCGA-KIRC.methylation450.tsv.gz\", sep = \"\\t\", stringsAsFactors = F, header = T, select = 1)\ncgList <- full_data[[1]]\nhead(cgList)\n# 获取每个样本的表型信息（肿瘤或正常）（中文注释）\n# Get phenotype information for each sample (tumor or normal) (English comment)\nsample_select <- substr(sample[c(STN_samples_select, PT_samples_select)], 1, 15)\nhead(sample_select)\n(sample_type_select <- phenotype[sample_select, \"tissue_type.samples\"])\n# 数据预处理：过滤在所有样本中都有缺失值的CpG位点（中文注释）\n# Data preprocessing: Filter out CpG sites with missing values in all samples (English comment)\n# 保留所有样本中均无缺失值的位点（中文注释）\n# Keep sites with no missing values in all samples (English comment)\ncgList_selector <- apply(methylation_matrix, 1, function(x) {sum(is.na(x)) == 0})\ncgList_select <- unlist(cgList[cgList_selector])\nNearest shrunken centroid classification\n先把上面各种信息存到metylation.data里，然后用到pamr包里的两个函数：pamr.train和pamr.predict。\n用?pamr.train查看对输入的要求\nNearest shrunken centroid classification\nFirst, we saved the above information into metylation.data, and then\nwe used two functions from the pamr package: pamr.train and\npamr.predict.\nUse ?pamr.train to see the requirements for the inputs\nx- an expression genes in the rows, samples in the columns)\ny- a vector of the class labels for each sample. Optional\ncomponents- genenames, a vector of gene names, and geneid- a vector of\ngene identifiers.\n用?pamr.predict查看对输入的要求\nUse ?pamr.predict to see the requirements for inputs\nfit. The result of a call to pamr.train\nnewx. Matrix of features at which predictions are to be made\nthreshold. The desired threshold value\n# 使用pamr包训练最近收缩质心模型（中文注释）\n# Train a nearest shrunken centroid model using pamr package (English comment)\n# pamr.train函数专为基因表达（微阵列）数据设计（中文注释）\n# The pamr.train function is designed for gene expression (microarray) data (English comment)\nmethylation_matrix_filtered <- as.matrix(methylation_matrix[apply(methylation_matrix, 1, function(x) sum(is.na(x)) == 0), ])\nrownames(methylation_matrix_filtered) <- cgList_select\nmetylation.data <- list(\n  x = methylation_matrix_filtered,\n  y = sample_type_select,                                      # 样本类型标签（肿瘤/正常）（中文注释）\n  # Sample type labels (tumor/normal) (English comment)\n  genenames = cgList_select,                                   # CpG位点名称（中文注释）\n  # CpG site names (English comment)\n  geneid = cgList_select,                                      # CpG位点ID（中文注释）\n  # CpG site IDs (English comment)\n  samplelabels = sample_select,                                # 样本标签（中文注释）\n  # Sample labels (English comment)\n  batchlabels = NULL                                           # 批次标签（无批次信息）（中文注释）\n  # Batch labels (no batch information) (English comment)\n)\n\n# 释放内存：删除不再需要的大对象并执行垃圾回收（中文注释）\n# Free memory: Remove large objects that are no longer needed and perform garbage collection (English comment)\n# rm(methylation_matrix, cgList); gc()\n\n# 显示训练结果并存储模型（中文注释）\n# Display training results and store the model (English comment)\n(metylation.train <- pamr.train(data = metylation.data))\n# 自定义函数：从最近收缩质心模型中提取特征基因/CpG位点（中文注释）\n# Custom function: Extract feature genes/CpG sites from the nearest shrunken centroid model (English comment)\n# pamr.getGenes - 根据给定阈值获取有显著差异的特征（中文注释）\n# pamr.getGenes - Get significant features based on a given threshold (English comment)\npamr.getGenes <- function (fit, data, threshold) {\n  x = data$x[fit$gene.subset, fit$sample.subset]           # 提取模型使用的子集数据（中文注释）\n  # Extract subset of data used by the model (English comment)\n  geneid = data$geneid[fit$gene.subset]                    # 提取对应的基因/CpG ID（中文注释）\n  # Extract corresponding gene/CpG IDs (English comment)\n  aa = pamr.predict(fit, x, threshold = threshold, type = \"nonzero\")  # 预测非零系数的特征（中文注释）\n  # Predict features with non-zero coefficients (English comment)\n  g1 = geneid[aa]                                            # 获取筛选后的特征ID（中文注释）\n  # Get IDs of filtered features (English comment)\n  rm(x, geneid, aa)                                          # 释放临时变量占用的内存（中文注释）\n  # Free memory occupied by temporary variables (English comment)\n  gc()\n  return(as.character(g1))                                   # 返回字符型的特征ID列表（中文注释）\n  # Return a character list of feature IDs (English comment)\n}\n\n# 使用阈值17筛选出前11个最具判别力的CpG位点（中文注释）\n# Use threshold 17 to select the top 11 most discriminative CpG sites (English comment)\n# 阈值越大，筛选出的特征越少，判别力越强（中文注释）\n# Larger threshold results in fewer but more discriminative features (English comment)\ncgsites <- pamr.getGenes(metylation.train, metylation.data, threshold = 3)\ncgsites\ncg25247520, cg11201447 in cgsites\n开始画图\nPlot\n# 遍历筛选出的每个CpG位点，绘制其在肿瘤和正常样本中的甲基化水平分布图（中文注释）\n# Loop through each selected CpG site and plot its methylation levels in tumor and normal samples (English comment)\nfor(i in 1:length(cgsites)){\n  cgsite <- cgsites[i]  # 获取当前CpG位点ID（中文注释）\n  # Get the current CpG site ID (English comment)\n  \n  # 从甲基化数据中提取该位点在所有样本中的甲基化值（中文注释）\n  # Extract methylation values for this site across all samples (English comment)\n  methylValue <- metylation.data$x[which(cgList_select==cgsite), ]\n  \n  # 创建PDF文件保存可视化结果（中文注释）\n  # Create PDF file to save visualization results (English comment)\n  pdf(paste0(\"groupMethylation_\",cgsite,\".pdf\"))\n  \n  # 绘制正常样本的甲基化水平散点图（中文注释）\n  # Plot methylation levels for normal samples (English comment)\n  plot(1:STN_number, methylValue[1:STN_number], pch=1, col=cols[1], main=cgsite,\n       xlim=c(1, length(methylValue)), ylim=c(0,1),  # 设置坐标轴范围（中文注释）\n       # Set axis ranges (English comment)\n       yaxs=\"i\", xaxs=\"i\", xlab=\"\", xaxt=\"n\", ylab=\"Methylated levels\")  # 隐藏x轴刻度（中文注释）\n       # Hide x-axis tick marks (English comment)\n  \n  # 添加肿瘤样本的甲基化水平散点图（中文注释）\n  # Add methylation levels for tumor samples (English comment)\n  points((STN_number+1):length(methylValue), methylValue[(STN_number+1):length(methylValue)], \n         pch=1, col=cols[2])\n  \n  # 添加分隔线区分正常和肿瘤样本（中文注释）\n  # Add a vertical line to separate normal and tumor samples (English comment)\n  abline(v=STN_number+0.5, lty=2, lwd=2)\n  \n  # 添加图例说明不同颜色代表的样本类型（中文注释）\n  # Add legend to indicate sample types by color (English comment)\n  legend(\"topright\", pch=1, col=cols, legend=labels, bty=\"n\")\n  \n  # 关闭PDF设备（中文注释）\n  # Close the PDF device (English comment)\n  dev.off()\n}\n在当前文件夹会看到生成了11个pdf文件，每个cgsites对应一个pdf文件。\nIn the current folder will see the generation of 11 pdf files, each\ncgsites corresponds to a pdf file.\n原图复现\n原文选出的4个位点，有两个（cg25247520和cg11201447）出现在我们找到的cgsites当中。\n下面画原文选出的这4个位点。只要提供KIRC.methylation450.tsv.gz和KIRC_clinicalMatrix.gz两个文件，就能直接画图。\nOriginal image reproduction\nTwo of the 4 loci selected in the original article (cg25247520 and\ncg11201447) appear among the cgsites we found.\nThese 4 loci selected in the original article are drawn below. As\nlong as the files KIRC.methylation450.tsv.gz and KIRC_clinicalMatrix.gz\nare provided, we can draw the graph directly.\n# 定义要分析的CpG位点列表（中文注释）\n# Define the list of CpG sites to analyze (English comment)\ncgsites = c(\"cg08995609\", \"cg25247520\", \"cg13309012\", \"cg11201447\")\n\n# 设置绘图颜色和标签（中文注释）\n# Set colors and labels for plotting (English comment)\ncols = c(\"red\", \"green\")\nlabels = c(\"Normal\", \"Tumor\")\n\n\nphenotype <- read.table(\n  file = gzfile(\"TCGA-KIRC.clinical.tsv.gz\"),  # 读取gzip压缩文件 / Read gzipped file\n  header = TRUE,                            # 第一行作为列名 / First row as column names\n  sep = \"\\t\",                               # 制表符分隔 / Tab-delimited\n  # colClasses = c(\"character\", rep(\"NULL\",82), \"integer\", rep(\"NULL\",37)),  # 只读取第一列和84列 / Only read 1st and 84th columns\n  row.names = 1                             # 第一列作为行名 / Use first column as row names\n)\n\n# 读取样本ID列表（中文注释）\n# Read sample ID list (English comment)\n# 只读取第一行（列名）（中文注释）\n# Read only the first row (column names) (English comment)\nsample <- read.table(\n  file = gzfile(\"TCGA-KIRC.methylation450.tsv.gz\"),  # 甲基化数据文件 / Methylation data file\n  sep = \"\\t\",                                        # 制表符分隔 / Tab-delimited\n  stringsAsFactors = FALSE,                          # 不转换字符串为因子 / Don't convert strings to factors\n  nrows = 1,                                        # 只读第一行(样本名) / Only read first row (sample names)\n  row.names = 1                                     # 第一列作为行名 / Use first column as row names\n)\n\nsample_type <- phenotype[substr(sample, 1, 15), \"tissue_type.samples\"]  # 提取前15字符匹配 / Match first 15 characters\nsample_list <- !is.na(sample_type)\nsample_type <- na.omit(sample_type)\n# 识别正常组织和原发肿瘤样本\n# Identify normal and tumor samples\n \n\nnormal_number <- length(which(sample_type == \"Normal\"))  # 正常样本数量（中文注释）\n# Number of normal samples (English comment)\nisTumor <- sample_type == \"Tumor\"  # 肿瘤样本逻辑索引（中文注释）\n# Logical index for tumor samples (English comment)\nisNormal <- sample_type == \"Normal\"  # 正常样本逻辑索引（中文注释）\n# Logical index for normal samples (English comment)\n\n# 获取所有CpG位点列表（中文注释）\n# Get the list of all CpG sites (English comment)\ncgList <- read.table(file = gzfile(\"TCGA-KIRC.methylation450.tsv.gz\"),\n                     sep=\"\\t\", stringsAsFactors = F, header = T,\n                     colClasses = c(\"character\", rep(\"NULL\", ncol(sample)-1)))\nstr(cgList)  # 查看数据结构（中文注释）\n# Check data structure (English comment)\n\n# 循环绘制每个指定CpG位点的甲基化水平分布图（中文注释）\n# Loop to plot methylation levels for each specified CpG site (English comment)\nfor(i in 1:length(cgsites)){\n  cgsite <- cgsites[i]  # 当前分析的CpG位点（中文注释）\n  # Current CpG site being analyzed (English comment)\n  \n  # 从大文件中读取特定CpG位点的甲基化数据（中文注释）\n  # Read methylation data for a specific CpG site from the large file (English comment)\n  methylValue <- read.table(file = gzfile(\"TCGA-KIRC.methylation450.tsv.gz\"), sep = \"\\t\",\n                            skip = which(cgList[,1] %in% cgsite),  # 跳过到目标行（中文注释）\n                            # Skip to the target row (English comment)\n                            nrows = 1, row.names = 1)  # 只读取一行（中文注释）\n                            # Read only one row (English comment)\n  methylValue <- methylValue[,sample_list]\n  # 创建PDF文件保存可视化结果（中文注释）\n  # Create PDF file to save visualization results (English comment)\n  pdf(paste0(\"groupMethylation_\", cgsite, \"_4.pdf\"))\n  \n  # 绘制正常样本的甲基化水平散点图（中文注释）\n  # Plot methylation levels for normal samples (English comment)\n  plot(1:normal_number, methylValue[, which(isNormal)],\n       pch = 1, col = cols[1], main = cgsite,  # 设置点形状和颜色（中文注释）\n       # Set point shape and color (English comment)\n       xlim = c(1, length(methylValue)), ylim = c(0,1),  # 设置坐标轴范围（中文注释）\n       # Set axis ranges (English comment)\n       yaxs = \"i\", xaxs = \"i\", xlab = \"\", xaxt = \"n\", ylab = \"Methylated levels\")  # 隐藏x轴刻度（中文注释）\n       # Hide x-axis tick marks (English comment)\n  \n  # 添加肿瘤样本的甲基化水平散点图（中文注释）\n  # Add methylation levels for tumor samples (English comment)\n  points((normal_number + 1):length(methylValue), as.numeric(methylValue[1, which(isTumor)]),\n         pch=1, col=cols[2])\n  \n  # 添加分隔线区分正常和肿瘤样本（中文注释）\n  # Add a vertical line to separate normal and tumor samples (English comment)\n  abline(v=normal_number + 0.5, lty = 2, lwd = 2)\n  \n  # 添加图例说明不同颜色代表的样本类型（中文注释）\n  # Add legend to indicate sample types by color (English comment)\n  legend(\"topright\", pch = 1, col = cols, legend = labels, bty=\"n\")\n  \n  # 关闭PDF设备（中文注释）\n  # Close the PDF device (English comment)\n  dev.off()\n}\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa72biomarker_FigureYa72biomarker",
      "title": "FigureYa72biomarker/FigureYa72biomarker.html",
      "html": "FigureYa72biomarker/FigureYa72biomarker.html",
      "text": "texts/main_FigureYa72biomarker_FigureYa72biomarker.txt",
      "folder": "FigureYa72biomarker",
      "thumb": "gallery_compress/FigureYa72biomarker.webp"
    },
    "word_count": 2150,
    "lines_count": 411,
    "title": "FigureYa72biomarker",
    "description": "复现原文的nearest shrunken centroid classification找biomarker，画出文章里的图。 Requirement Description",
    "input_data_types": [
      "临床数据",
      "表达矩阵"
    ],
    "output_types": [
      "散点图",
      "统计表格"
    ],
    "technical_methods": [],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "colClasses",
      "header",
      "lwd",
      "ylim",
      "xlim",
      "yaxs",
      "labels",
      "geneid",
      "legend"
    ]
  },
  {
    "id": "main_FigureYa29map_FigureYa29map",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa29map_FigureYa29map.txt",
    "content": "FigureYa29 map\nFigureYa29 map\nKevin; Ying Ge, Yijing Chen\n2025-5-20\n需求描述\nrequirement description\n用R画出种质资源分布图，在地图上用不同颜色展示各个group的地理分布，中国的省用饼图展示。\nDraw a map of the distribution of germplasm resources in R. Show the\ngeographic distribution of each group on the map in different colors,\nand the provinces of China in a pie chart.\n出自\nhttps://genomebiology.biomedcentral.com/articles/10.1186/s13059-017-1289-9\nfrom\nhttps://genomebiology.biomedcentral.com/articles/10.1186/s13059-017-1289-9\n应用场景\napplication scenario\n在地图上展示特征的地理分布。\n场景一：种质资源的地理分布\n场景二：疾病在不同地区的发病情况\nShow the geographic distribution of features on a map.\nScenario 1: Geographic distribution of germplasm resources\nScenario 2: Disease incidence in different regions\n输入数据预处理\nPreprocessing of input data\n如果你的数据像\neasy_input.csv\n那样，已经有经纬度，就可以跳过这步，直接进入“开始画图”。\n输入数据来源：\nhttps://static-content.springer.com/esm/art%3A10.1186%2Fs13059-017-1289-9/MediaObjects/13059_2017_1289_MOESM1_ESM.xlsx\n输入数据没有提供点的经纬度，只有省和直辖市名，我们需要根据省份的名字提取经纬度。\nIf your data already has latitude and longitude like\neasy_input.csv\n, you can skip this step and go directly to\n“Start drawing”.\nInput data source:\nhttps://static-content.springer.com/esm/art%3A10.1186%2Fs13059-017-1289-9/MediaObjects/13059_2017_1289_MOESM1_ESM.xlsx\nThe input data does not provide the latitude and longitude of the\npoints, only the name of the province and municipality, we need to\nextract the latitude and longitude based on the name of the\nprovince.\ndf=read.csv(\"not_easy_input.csv\", sep = \";\", stringsAsFactors=F)\nhead(df)\ndim(df)\ntable(df$Type)\n后面将用两种颜色，分别展示两种\ntype\n的地理分布\nThe geographic distribution of each of the two\ntype\nwill\nbe shown later in two colors\n提取有用的列\nExtract useful columns\narea <- df$Origin\nl <- strsplit(area,\", \")\n\n# 下面三个list分别对应输入文件中的省、国家和type（顺序对应）\n# The following three lists correspond to the province, country, and type in the input file (in that order)\nprovince <- c()\ncountry <- c()\ntype <- c()\n\nj=1\nfor(i in 1:length(l)){\n  #删掉缺失省或国家信息的行\n  #delete lines with missing provincial or national information\n  if(length(l[[i]]) == 2) {\n    province[j] = l[[i]][1]\n    country[j] = l[[i]][2]\n    type[j] = df$Type[j]\n    j = j+1\n    }\n}\n\n#cpt为整理后的输入文件（包含国家、省、type）\n#cpt is the organized input file (contains country, province, type)\ncpt <- cbind(country, province, type)\ncpt <- as.data.frame(cpt)\nhead(cpt)\ndim(cpt)\n提取经纬度\nExtract latitude and longitude\nprovince.csv\n文件是世界各国省市的经纬度对照关系表，已经把省市经纬度处理成省市的中心位置。也可以用你有自己的对照表替换这个文件。\n获得\nprovince.csv\n过程描述：\n从simplemaps.com下载国家省市城市经纬度表(包括一些无用列)；\n用perl提取相关5列(国家省市城市经纬度)；\n将每个省市的城市的经纬度做了取平均处理(保证得到省市中心位置的经纬度)；\n最后得到\nprovince.csv\nThe\nprovince.csv\nfile is a table of latitude and\nlongitude correspondences for provinces and cities worldwide. The\nlatitude and longitude of the provinces and cities have been converted\nto their central positions. You can also replace this file with your own\ncorrespondence table.\nGet\nprovince.csv\nprocess description:\ndownload the table of latitude and longitude of national\nprovinces and cities from simplemaps.com (including some useless\ncolumns);\nuse perl to extract the relevant 5 columns (latitude and\nlongitude of national provinces and cities);\naveraging the latitude and longitude of the cities in each\nprovince (to ensure that we get the latitude and longitude of the center\nof the provincial city);\nFinally, we get\nprovince.csv\n.\npro <- read.csv(\"province.csv\", header=T, stringsAsFactors=F)\nhead(pro)\n# 提取输入文件中的省市的经纬度\n# extract the latitude and longitude of the provinces and cities in the input file\ncpll <- pro[pro$country == country[1]&pro$province == province[1],]\nfor(i in 2:length(province)){\n  cpll = rbind(cpll, pro[pro$country == country[i]&pro$province == province[i],])\n}\n\ncpll$type<-cpt$type\n\n#输出到文件\n#output to file\nwrite.csv(cpll, \"easy_input.csv\", quote = F, row.names = F)\n开始画图\nStart drawing\n提供三种类型的画图代码，分别画世界、美国和中国地图，挑选自己喜欢的类型画感兴趣的地区即可。\nProvide three types of plotting code for drawing maps of the world,\nthe United States, and China. just pick your favorite type to draw the\narea of interest.\n#install.packages(c(\"maps\",\"mapproj\",\"maptools\",\"ggsn\"))\nlibrary(ggplot2)\nlibrary(maps)\nlibrary(mapproj)\nlibrary(maptools) #使用的为maptools_1.1-8.tar.gz use maptools_1.1-8.tar.gz.\n#输入数据必须包含这三列：类型、经度和纬度。\n#the input data must contain these three columns: type, longitude and latitude.\ncpll<-read.csv(\"easy_input.csv\")\nhead(cpll)\nsummary(cpll)\n此处的输入文件只精确到省，每个省有多行。\nThe input file here is only accurate to the province, with multiple\nlines per province.\n各省每种type的数量作为点的size，以世界地图为例\nThe number of each type in each province as the point size, in the\ncase of a world map\nlibrary(plyr)\nlibrary(dplyr)\n\n# type的unique行计数\n# unique row count for type\ncpllt<-read.csv(\"easy_input.csv\")\ndim(cpllt)\ncpllt_uni <- ddply(cpllt,.(country,province,lng,lat,type),nrow)\ndim(cpllt_uni)\nnames(cpllt_uni)[6] <- \"type_num\"\nhead(cpllt_uni)\nworld_map <- map_data(\"world\")\npa <- ggplot() +\n  geom_polygon(data=world_map,\n               aes(x=long,y=lat,group=group),\n               fill=\"white\",\n               colour = \"#B1C5D4\") + #蓝色国家边界 blue state border\n  theme(panel.background = element_rect(fill = \"#B1C5D4\")) + #蓝色海洋 blue sea\n  geom_point(data = cpllt_uni, aes(x = lng, y = lat, \n                                  size = type_num, #点的大小代表type的数量 the size of the dot represents the number of type\n                                  colour = type, #type用不同颜色展示 type is displayed in different colors\n                                  alpha = I(0.5))) + #点的透明度 transparency of dot\n  scale_size_continuous(range = c(0.1,2)) + #点的大小范围 range of dot sizes\n  scale_color_brewer(palette = \"Set1\") + \n  \n  xlab(\"\") + ylab(\"\") +\n  theme(panel.grid =element_blank()) + #去除网格线 remove gridlines\n  theme(panel.border = element_blank()) + #去除外层边框 remove outer border\n  theme(axis.line = element_blank(), axis.ticks = element_blank(), axis.text = element_blank()) + #去除x轴 remove x-axis\n  coord_map(xlim=c(-180, 180), ylim=c(-60, 80)) \npa\nggsave(\"world_size.pdf\")\n分散画出省内所有的点，以美国为例\nDecentralize the drawing of all points within a province, using the\nUnited States as an example\n前面从\nprovince.csv\n文件提取了省市中心位置的经纬度，我们把同一个省的点分散显示。\nHaving extracted the latitude and longitude of the location of the\ncenter of the province from the\nprovince.csv\nfile earlier,\nlet’s show the points of the same province in a decentralized way.\n#随机移动点，获得新的经纬度\n#randomly move points to get a new latitude and longitude\nset.seed(1)\nlat_random <- sample(seq(-0.5,0.5,0.1),nrow(cpllt),replace=T)\nlng_random <- sample(seq(-0.5,0.5,0.1),nrow(cpllt),replace=T)\ncpllt_random <- cbind(cpllt[,1:2], lng = cpllt[,3] + lng_random,lat = cpllt[,4] + lat_random, type = cpllt$type)\nhead(cpllt_random)\n#查询某单独地区的名称\n#search for the name of an individual region\n#sort(unique(world_map$region)) #一共有252个地区 a total of 252 districts\n\nUSA_map <- map_data(\"world\",region = c(\"USA\",\"canada\"))\npc <- ggplot() +\n  geom_polygon(data = USA_map,\n               aes(x = long, y = lat,group = group),\n               fill = \"white\",\n               colour = \"black\") + #黑色国家边界 black state border\n  theme(panel.background = element_rect(fill = \"#B1C5D4\")) + \n  geom_point(data = cpllt_random[cpllt_random$country == c(\"United States\",\"Canada\"),], aes(x = lng, y = lat, colour = type), size = 0.1, alpha = I(0.4)) +\n  scale_color_brewer(palette = \"Set1\") + \n\n  xlab(\"\") + ylab(\"\") +\n  theme(panel.grid =element_blank()) + \n  theme(panel.border = element_blank()) + \n  theme(axis.line = element_blank(), axis.ticks = element_blank(), axis.text = element_blank()) + \n  guides(colour = FALSE) +\n  coord_map(xlim=c(-140, -50), ylim=c(15, 55))\npc\nggsave(\"US_points.pdf\")\n饼图展示各省type的占比，以中国为例\nPie chart showing the percentage of type by province, using China as\nan example\n先计算各省type的百分比\nFirst calculate the percentage of each province type\nlibrary(plyr)\nlibrary(dplyr)\n\n#type的unique行计数\n#unique row count for type\ncpllt<-read.csv(\"easy_input.csv\")\ncpllt_uni <- ddply(cpllt,.(country,province,lng,lat,type),nrow)\nnames(cpllt_uni)[6] <- \"type_num\"\nllt<-cpllt_uni[,c(-1,-2)]\nhead(llt)\n#提取不同type的个数，此处有两个type，根据实际需要增加\n#extract the number of different types, here there are two types, according to the actual need to increase\nllt1<-llt[llt$type==\"Improved cultivar\",]\ncolnames(llt1)[4]<-\"cultivar\"\nllt2<-llt[llt$type==\"Landrace\",]\ncolnames(llt2)[4]<-\"Landrace\"\n\nlltall<-merge(llt1, llt2, by = c(\"lng\",\"lat\"))\nlltall<-lltall[,c(-3,-5)]\n\n#计算该省的数量在全世界所占的百分比，用来画pie的半径\n#calculate the percentage of this province's quantity in the world to be used as the radius of the pie\ntype_sum <- sum(cpllt_uni$type_num)\nlltall$total<-lltall$`cultivar` + lltall$Landrace\nlltall$radius<-log10(lltall$total / type_sum * 1000)\n\nlltall$region<-seq(1:nrow(lltall))\nhead(lltall)\n用到了Y叔的\nscatterpie\n包，\nhttps://mp.weixin.qq.com/s/Jca8BqGFCLTa0aaLrQFNHA\nUsed Uncle Y’s\nscatterpie\npackage,\nhttps://mp.weixin.qq.com/s/Jca8BqGFCLTa0aaLrQFNHA\n#install.packages(\"scatterpie\")\nlibrary(scatterpie)\n\nChina_map <- map_data(\"world\",region=c(\"China\",\"Taiwan\",\"Japan\",\"South Korea\",\"North Korea\",\"Mongolia\",\"Russia\"))\npd <- ggplot() +\n  geom_polygon(data=China_map,\n               aes(x=long,y=lat,group=group),\n               fill=\"white\",\n               colour=\"black\") + \n  theme(panel.background = element_rect(fill = \"#B1C5D4\")) + \n\n  geom_scatterpie(aes(x=lng, y=lat, group=region, r=radius),\n                  data=lltall, cols=c(\"cultivar\",\"Landrace\"), \n                  color=NA, #不画pie的边界 boundary without drawing a pie\n                  alpha=.7) + #透明度 transparency\n  #pie半径的图例，展示该省所有数据占全世界的百分比\n  #legend for pie radius, showing all data for the province as a percentage of the whole world\n  geom_scatterpie_legend(lltall$radius, x=65, y=20, \n                         n = 3, #图例里画几个圈 how many circles are drawn in the legend\n                         labeller = function(x) round(0.1*10^x,2)) + \n  scale_fill_brewer(palette = \"Set1\") + #设置pie里的颜色 set the color in the pie\n  guides(fill = FALSE) + #不显示图例 legend not displayed\n  \n  xlab(\"\") + ylab(\"\") +\n  theme(panel.grid =element_blank()) + \n  theme(panel.border = element_blank()) + \n  theme(axis.line = element_blank(), axis.ticks = element_blank(), axis.text = element_blank()) + \n  coord_map(xlim=c(60, 155), ylim=c(15, 55))\npd\nggsave(\"China_pie.pdf\",width = 10,height = 8)\n组图\nCombined pictures\nlibrary(cowplot)\nplot_grid(pa, ncol = 1, labels = c(\"a\", \"b\"),\n  plot_grid(pc, pd, ncol = 2, labels = c(\"c\",\"d\")),\n  rel_heights = c(1.5, 1))\nggsave(\"map.pdf\",width = 16,height = 12)\nsessionInfo()",
    "chapter_info": {},
    "word_count": 1153,
    "lines_count": 300,
    "title": "FigureYa29 map",
    "description": "requirement description 用R画出种质资源分布图，在地图上用不同颜色展示各个group的地理分布，中国的省用饼图展示。 Draw a map of the distribution of germplasm resources in R. Show the",
    "input_data_types": [],
    "output_types": [
      "散点图",
      "统计表格"
    ],
    "technical_methods": [],
    "biology_areas": [],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "rel_heights",
      "",
      "colour",
      "ticks",
      "header",
      "width",
      "lng",
      "grid",
      "ylim",
      "n"
    ]
  },
  {
    "id": "main_FigureYa51TMB_update_FigureYa51TMB_update",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa51TMB_update_FigureYa51TMB_update.txt",
    "content": "FigureYa51TMB_update\nFigureYa51TMB_update\nAuthor(s)\n: Jingze Gao; Ying Ge, Yijing Chen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n用某个基因的表达量来分组，画出各组的TMB box plot，带散点，计算p\nvalue。\nUse the expression of a particular gene to group, draw a TMB box plot\nwith scatter points for each group, and calculate the p value.\n出自\nhttps://www.nejm.org/doi/full/10.1056/NEJMoa1406498\nfrom\nhttps://www.nejm.org/doi/full/10.1056/NEJMoa1406498\n应用场景\nApplication scenario\n借助突变数据TMB，把你的基因跟免疫治疗预后联系起来。\n可以用某个基因的表达量高低来分组（或根据其他信息分组），对比不同分组的TMB值。\n下一步，还可以用TMB值高低来分组，做生存分析。\nWith the help of mutation data TMB, link your genes to immunotherapy\nprognosis.\nYou can group based on high or low expression of a particular gene\n(or group based on other information) and compare the TMB values of\ndifferent groups.\nIn the next step, it is also possible to do survival analysis by\ngrouping with high or low TMB values.\n环境设置\nEnvironment setting\nsource(\"install_dependencies.R\")\nlibrary(TCGAbiolinks)\nlibrary(dplyr)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(ggpubr)\n\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 display English error messages\noptions(stringsAsFactors = FALSE) #禁止chr转成factor prohibit the conversion of chr to factor\n用表达量分组\nGroup with expressions\n如果你的分组信息已经保存成\neasy_input_group.csv\n的格式，就可以跳过这步，直接进入“输入文件”。\nIf your grouping information has been saved as\neasy_input_group.csv\n, you can skip this step and go\ndirectly to the\nInput file\n.\n从TCGA下载表达数据\nDownload expression data from TCGA\n如果你已经有表达数据，就可以跳过这步，直接进入“根据表达量给sample分组”\nIf you already have expression data, you can skip this step and go\ndirectly to “Group sample based on expression”\nexpquery <- GDCquery(project = \"TCGA-LIHC\", \n                data.category = \"Transcriptome Profiling\",\n                data.type = \"Gene Expression Quantification\",\n                workflow.type = \"STAR - Counts\")\nGDCdownload(expquery)\nexpquery2 <- GDCprepare(expquery)\nexpMatrix <- TCGAanalyze_Preprocessing(expquery2)\ndim(expMatrix)\nexpMatrix[1:3,1:4]\n\n#只取肿瘤组织\n#take only tumor tissue\ngroup_list <- ifelse(substr(colnames(expMatrix),14,14)=='0','tumor','normal')\nexpMatrix_tumor <- expMatrix[,group_list=='tumor']\ndim(expMatrix_tumor)\n\n#保存一个基因的表达量，此处选取TP53，对应ID为ENSG00000141510\n#save the expression of a gene, TP53 is selected here, corresponding to the ID of ENSG00000141510\nrownames(expMatrix_tumor) <- sapply(strsplit(rownames(expMatrix_tumor), \"\\\\.\"), function(x) x[1])\nwrite.csv(expMatrix_tumor[\"ENSG00000141510\",], \"easy_input_expr.csv\", quote=F, row.names = T)\n根据表达量给sample分组\nGroup sample based on expression\neasy_input_expr.csv，某个基因在各个sample里的表达量。\n第一列是sample ID，与突变数据里的sample\nID一致；第二列是基因的表达量。\neasy_input_expr.csv, the expression amount of a gene in each\nsample.\nThe first column is the sample ID, which corresponds to the sample ID\nin the mutation data; the second column is the expression amount of the\ngene.\nmyGene <- read.csv(\"easy_input_expr.csv\")\ncolnames(myGene) <- c(\"Tumor_Sample_Barcode\",\"Expr\") #改列名 modify the column name\n#保留barcode的前三个label\n#keep the first three labels of the barcode\nmyGene$Tumor_Sample_Barcode <- str_sub(myGene$Tumor_Sample_Barcode,1, 12)\nhead(myGene)\n# 用表达量中值分为两组\n# divided into two groups using the median expression\nmyGene$Expr_level <- ifelse(myGene$Expr > median(myGene$Expr),\"high\",\"low\")\nwrite.csv(myGene[,c(1,3)], \"easy_input_group_2.csv\", quote = F, row.names = F)\n\n# 或者自己定义cutoff，分为更多组，例如三组\n# or define your own cutoff and divide into more groups, e.g. three groups\ncutoff_low <- 3\ncutoff_high <- 8\nmyGene$Expr_level <- cut(myGene$Expr, breaks = c(-Inf, cutoff_low, cutoff_high, Inf), labels = c(\"low\",\"med\",\"high\"))\nwrite.csv(myGene[,c(1,3)], \"easy_input_group_3.csv\", quote = F, row.names = F)\n输入文件\nInput file\n需要TMB和分组文件（两组或更多组）。\nmutation-load.txt，TCGA的TMB，来源于2018年的这篇文献：The Immune\nLandscape of Cancer\nhttps://pubmed.ncbi.nlm.nih.gov/29628290/\n，我们直接拿来用就好。\nTMB and grouping files (two or more groups) are needed.\nmutation-load.txt, TCGA’s TMB, is derived from this 2018 paper, The\nImmune Landscape of Cancer\nhttps://pubmed.ncbi.nlm.nih.gov/29628290/\n, which we’ll\njust use directly.\n# 加载分组\n# 分两组的情况\n# load grouping\n# divide into two groups\nmyGroup <- read.csv(\"easy_input_group_2.csv\")\nmyGroup$Expr_level <- factor(myGroup$Expr_level, levels = c(\"low\", \"high\"))\n\n# 分三组的情况\n# divide into three groups\n#myGroup <- read.csv(\"easy_input_group_3.csv\")\n#myGroup$Expr_level <- factor(myGroup$Expr_level, levels = c(\"low\", \"med\", \"high\"))\nhead(myGroup)\n# 加载TMB\n# load TMB\nmyMut <- data.table::fread(\"mutation-load.txt\",data.table = F)\n# 其中Non-silent per Mb是TMB\n# among them, Non-silent per Mb is TMB\nhead(myMut)\n# 合并\n# merge\nTMB_clinical_mRNA <- myGroup %>%\n  inner_join(myMut,by = c(\"Tumor_Sample_Barcode\" = \"Patient_ID\")) %>%\n  rename(TMB = 'Non-silent per Mb' )\nhead(TMB_clinical_mRNA)\n开始画图\nStart drawing\n用ggplot2画图，用ggpubr算p value。\nUse ggplot2 to draw the graph, use ggpubr to calculate the p\nvalue.\nmycol <- c(\"darkgreen\", \"darkorchid3\", \"orange\") #与分组数量一致 consistent with the number of groups\np <- ggplot(TMB_clinical_mRNA, aes(x = Expr_level, y = TMB, color = Expr_level)) +\n  geom_boxplot(outlier.color = NA) + #隐去箱线图上的异常点 hide the abnormal points on the box plot\n\n  scale_color_manual(values = mycol) + #自定义配色 custom color scheme\n  \n  stat_compare_means(#paired = T, #whether you want a paired test\n                     #两组对比，用wilcox.test或t.test comparison between two groups using wilcox.test or t.test\n                     method = \"wilcox.test\", \n                     \n                     #多组对比，用kruskal.test或anova multiple group comparisons using kruskal.test or anova\n                     #method = \"kruskal.test\",\n                     label.y = max(TMB_clinical_mRNA$TMB)*1.1) + #label的位置 the position of label\n  \n  theme_bw() + #去除背景色 remove background color\n  theme(panel.grid =element_blank()) + #去除网格线 remove gridlines\n  theme(panel.border = element_blank()) + #去除外层边框 remove outer border\n  theme(axis.line = element_line(colour = \"black\")) + #沿坐标轴显示直线 display line along coordinate axis\n  xlab(\"Discovery Set\") + \n  #ylim(0,5) + #设置Y轴范围 set the Y-axis range\n  guides(color=FALSE) #不显示图例 legend is not displayed\np\n# 绘制Wikinson点图\n# draw Wikinson dot plot\np + geom_dotplot(binaxis = \"y\", #沿y轴堆积，并沿着x轴分组 stack along the y-axis and group along the x-axis\n               binwidth = 0.5, #最大组距 maximum group distance\n               dotsize = 1, #点的大小 size of the point\n               #如果点太多，两组叠在一起，就需要运行下面这行把它们分开\n               #if there are too many points and the two groups overlap, you need to run the following line to separate them\n               #stackgroups = T, binpositions=\"all\",\n               stackdir = \"center\")  #数量保持一致的中心堆叠方式 center stacking method with consistent quantity\nggsave(\"TMB_dot.pdf\")\n# 或者散点图\n# or scatter plot\np + geom_point(aes(group = Expr_level),\n             alpha=.3, #点太多，设为透明色，就能看到叠加效果 too many points, set them to transparent color to visualize the overlay effect\n             size = 2, #点的大小 size of the point\n             position=\"jitter\") #分散 disperse\nggsave(\"TMB_point.pdf\")\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa51TMB_update_FigureYa51TMB_update",
      "title": "FigureYa51TMB_update/FigureYa51TMB_update.html",
      "html": "FigureYa51TMB_update/FigureYa51TMB_update.html",
      "text": "texts/main_FigureYa51TMB_update_FigureYa51TMB_update.txt",
      "folder": "FigureYa51TMB_update",
      "thumb": "gallery_compress/FigureYa51TMB_update.webp"
    },
    "word_count": 843,
    "lines_count": 192,
    "title": "FigureYa51TMB_update",
    "description": "Requirement description 用某个基因的表达量来分组，画出各组的TMB box plot，带散点，计算p value。",
    "input_data_types": [
      "突变数据",
      "生存数据"
    ],
    "output_types": [
      "散点图",
      "箱线图",
      "统计表格",
      "生存曲线"
    ],
    "technical_methods": [
      "生存分析"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "paired",
      "colour",
      "values",
      "dotsize",
      "grid",
      "binpositions",
      "labels",
      "group",
      "method"
    ]
  },
  {
    "id": "main_FigureYa25Plus_Sankey_py_FigureYa25Plus_Sankey_py",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa25Plus_Sankey_py_FigureYa25Plus_Sankey_py.txt",
    "content": "FigureYa25Plus_Sankey_py\nFigureYa25Plus_Sankey_py\n¶\nAuthor:\nYing Ge\nIn [200]:\nfrom\ndatetime\nimport\ndatetime\nfrom\nIPython.display\nimport\nMarkdown\ncurrent_date\n=\ndatetime\n.\nnow\n()\n.\nstrftime\n(\n\"%Y-%m-\n%d\n\"\n)\nMarkdown\n(\nf\n\"**Date**:\n{\ncurrent_date\n}\n\"\n)\nOut[200]:\nDate\n: 2025-10-18\nAcademic Citation\n¶\nIf you use this code in your work or research, we kindly request that you cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization Framework for Enhancing Biomedical Data Interpretation and Research Efficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n¶\nRequirement Description\n¶\n使用plotly创建美观、交互式的Sankey图。\nDraw interactive sankey with plotly.\n出自\nhttps://www.nature.com/articles/s41388-019-1026-9\nFigure 2: Driver genes and pathways altered in MB.c, Graphical summary of the most frequently mutated genes (≥10 affected cases) and their subgroup distribution\n应用场景\n¶\nApplication Scenarios\n¶\n一套数据集可能有多重属性，每层属性之间有交叉，就可以用这种图来展示。另外，以第一变量为参照，往后的多层变量均参考与第一变量的关系，从而展示第一变量的流向。\nA dataset may have multiple attributes, and when there is an overlap between each layer of attributes, this type of plot can be used to display it. Additionally, using the first variable as a reference, subsequent multi-layer variables are all based on their relationship with the first variable, thereby illustrating the flow of the first variable.\n环境设置\n¶\nEnvironment Configuration\n¶\nIn [201]:\n#python --version\n#pip install jupyter ipykernel pandas numpy matplotlib seaborn\n#pip install scipy statsmodels plotly\n#pip install notebook nbconvert\nIn [202]:\nimport\npandas\nas\npd\nimport\nplotly.graph_objects\nas\ngo\nimport\nplotly.offline\nas\npyo\n输入文件\n¶\nInput files\n¶\neasy_input.txt，至少要有两列，想画出几列就提供几列数据。此处第一列是基因，第二列是突变，第三列是癌症亚型；想画更多层次关系就继续向后添加列。\n或者只写两列，第一列是miRNA，第二列是它的靶基因。\neasy_input.txt, there should be at least two columns; provide as many columns of data as you want to draw. Here the first column is the gene, the second is the mutation, and the third is the cancer subtype; keep adding columns backwards if you want to draw more hierarchical relationships.\nOr just write two columns, with the first column being the miRNA and the second column being its target gene.\n开始画图\n¶\nStart plotting\n¶\nIn [203]:\n# 设置 Plotly 在 Jupyter notebook 中显示 | Set up Plotly to display in Jupyter notebook\npyo\n.\ninit_notebook_mode\n(\nconnected\n=\nTrue\n)\n# 读取数据 | Read data\ndf\n=\npd\n.\nread_csv\n(\n'easy_input.txt'\n,\nsep\n=\n'\n\\t\n'\n,\nindex_col\n=\n0\n)\nprint\n(\n\"数据预览: | Data preview:\"\n)\nprint\n(\ndf\n.\nhead\n())\n# 定义颜色方案 | Define color scheme\ncolors\n=\n[\n\"#223D6C\"\n,\n\"#D20A13\"\n,\n\"#FFD121\"\n,\n\"#088247\"\n,\n\"#11AA4D\"\n,\n\"#58CDD9\"\n,\n\"#7A142C\"\n,\n\"#5D90BA\"\n,\n\"#029149\"\n,\n\"#431A3D\"\n,\n\"#91612D\"\n,\n\"#6E568C\"\n,\n\"#E0367A\"\n,\n\"#D8D155\"\n,\n\"#64495D\"\n,\n\"#7CC767\"\n]\n*\n3\ndef\nget_ordered_unique_values\n(\nseries\n):\n\"\"\"\n获取保持原始出现顺序的唯一值列表 | Get unique values list preserving original order\n\"\"\"\nseen\n=\nset\n()\nresult\n=\n[]\nfor\nitem\nin\nseries\n:\nif\nitem\nnot\nin\nseen\n:\nseen\n.\nadd\n(\nitem\n)\nresult\n.\nappend\n(\nitem\n)\nreturn\nresult\ndef\ncreate_sankey_plotly_simple\n(\ndf\n,\ncolumns\n=\nNone\n,\ntitle\n=\n\"Sankey Diagram\"\n):\n\"\"\"\n创建响应式的 Plotly 桑基图，保持原始顺序 | Create responsive Plotly Sankey diagram preserving original order\n\"\"\"\nif\ncolumns\nis\nNone\n:\ncolumns\n=\ndf\n.\ncolumns\n.\ntolist\n()\n# 为每列按原始出现顺序获取唯一值 | Get unique values for each column in original order\ncolumn_categories\n=\n{}\nfor\ncol\nin\ncolumns\n:\ncolumn_categories\n[\ncol\n]\n=\nget_ordered_unique_values\n(\ndf\n[\ncol\n])\n# 创建全局节点列表 | Create global node list\nall_categories\n=\n[]\nfor\ncol\nin\ncolumns\n:\nall_categories\n.\nextend\n(\ncolumn_categories\n[\ncol\n])\n# 创建节点映射 | Create node mapping\nnode_dict\n=\n{\ncat\n:\ni\nfor\ni\n,\ncat\nin\nenumerate\n(\nall_categories\n)}\n# 创建链接 | Create links\nlinks\n=\n[]\nfor\ni\nin\nrange\n(\nlen\n(\ncolumns\n)\n-\n1\n):\nsource_col\n=\ncolumns\n[\ni\n]\ntarget_col\n=\ncolumns\n[\ni\n+\n1\n]\n# 计算每个组合的频次 | Calculate frequency for each combination\ncombo_counts\n=\ndf\n.\ngroupby\n([\nsource_col\n,\ntarget_col\n],\nsort\n=\nFalse\n)\n.\nsize\n()\n.\nreset_index\n(\nname\n=\n'count'\n)\nfor\n_\n,\nrow\nin\ncombo_counts\n.\niterrows\n():\nsource_idx\n=\nnode_dict\n[\nrow\n[\nsource_col\n]]\ntarget_idx\n=\nnode_dict\n[\nrow\n[\ntarget_col\n]]\nvalue\n=\nrow\n[\n'count'\n]\nlinks\n.\nappend\n({\n'source'\n:\nsource_idx\n,\n'target'\n:\ntarget_idx\n,\n'value'\n:\nvalue\n})\n# 为节点分配颜色 | Assign colors to nodes\nnode_colors\n=\n[]\ncolor_idx\n=\n0\nfor\ncol\nin\ncolumns\n:\nfor\ncat\nin\ncolumn_categories\n[\ncol\n]:\nnode_colors\n.\nappend\n(\ncolors\n[\ncolor_idx\n%\nlen\n(\ncolors\n)])\ncolor_idx\n+=\n1\n# 创建半透明的链接颜色 | Create semi-transparent link colors\nlink_colors\n=\n[]\nfor\nlink\nin\nlinks\n:\n# 使用源节点的颜色，但添加透明度 | Use source node color with transparency\nsource_color\n=\nnode_colors\n[\nlink\n[\n'source'\n]]\n# 将十六进制颜色转换为 rgba | Convert hex color to rgba\nhex_color\n=\nsource_color\n.\nlstrip\n(\n'#'\n)\nrgb\n=\ntuple\n(\nint\n(\nhex_color\n[\ni\n:\ni\n+\n2\n],\n16\n)\nfor\ni\nin\n(\n0\n,\n2\n,\n4\n))\nrgba_color\n=\nf\n'rgba(\n{\nrgb\n[\n0\n]\n}\n,\n{\nrgb\n[\n1\n]\n}\n,\n{\nrgb\n[\n2\n]\n}\n, 0.4)'\nlink_colors\n.\nappend\n(\nrgba_color\n)\n# 创建 Plotly 桑基图 | Create Plotly Sankey diagram\nfig\n=\ngo\n.\nFigure\n(\ndata\n=\n[\ngo\n.\nSankey\n(\nnode\n=\ndict\n(\npad\n=\n15\n,\nthickness\n=\n20\n,\nline\n=\ndict\n(\ncolor\n=\n\"black\"\n,\nwidth\n=\n0.5\n),\nlabel\n=\nall_categories\n,\ncolor\n=\nnode_colors\n),\nlink\n=\ndict\n(\nsource\n=\n[\nlink\n[\n'source'\n]\nfor\nlink\nin\nlinks\n],\ntarget\n=\n[\nlink\n[\n'target'\n]\nfor\nlink\nin\nlinks\n],\nvalue\n=\n[\nlink\n[\n'value'\n]\nfor\nlink\nin\nlinks\n],\ncolor\n=\nlink_colors\n)\n)])\n# 设置布局，优化在 notebook 中的显示 | Set layout optimized for notebook display\nfig\n.\nupdate_layout\n(\ntitle\n=\ndict\n(\ntext\n=\ntitle\n,\nx\n=\n0.5\n,\n# 标题居中 | Center title\nfont\n=\ndict\n(\nsize\n=\n16\n)\n),\nfont_size\n=\n12\n,\n# 为 notebook 显示设置合适的尺寸 | Set appropriate size for notebook display\nwidth\n=\nNone\n,\n# 让它自适应 notebook 宽度 | Let it adapt to notebook width\nheight\n=\n500\n,\n# 设置一个合理的高度 | Set reasonable height\nmargin\n=\ndict\n(\nl\n=\n20\n,\n# 左边距 | Left margin\nr\n=\n20\n,\n# 右边距 | Right margin\nt\n=\n60\n,\n# 上边距 | Top margin\nb\n=\n20\n# 下边距 | Bottom margin\n)\n)\nreturn\nfig\ndef\nprint_data_summary\n(\ndf\n):\n\"\"\"\n打印数据摘要信息 | Print data summary information\n\"\"\"\nprint\n(\n\"=== 数据摘要 | Data Summary ===\"\n)\nprint\n(\nf\n\"总记录数 | Total records:\n{\nlen\n(\ndf\n)\n}\n\"\n)\nprint\n(\nf\n\"基因数量 | Number of genes:\n{\ndf\n[\n'gene'\n]\n.\nnunique\n()\n}\n\"\n)\nprint\n(\nf\n\"突变类型数量 | Number of mutation types:\n{\ndf\n[\n'mutation'\n]\n.\nnunique\n()\n}\n\"\n)\nprint\n(\nf\n\"亚型数量 | Number of subtypes:\n{\ndf\n[\n'subtype'\n]\n.\nnunique\n()\n}\n\"\n)\nprint\n(\n\"\n\\n\n各列的原始顺序 | Original order of each column:\"\n)\nfor\ncol\nin\ndf\n.\ncolumns\n:\nunique_vals\n=\nget_ordered_unique_values\n(\ndf\n[\ncol\n])\nprint\n(\nf\n\"\n{\ncol\n}\n:\n{\nunique_vals\n}\n\"\n)\n# 执行分析和绘图 | Execute analysis and plotting\nprint_data_summary\n(\ndf\n)\nIn [204]:\n# 创建图形并在 notebook 中显示 | Create figures and display in notebook\nprint\n(\n\"创建完整的桑基图... | Creating complete Sankey diagram...\"\n)\nfig1\n=\ncreate_sankey_plotly_simple\n(\ndf\n,\ntitle\n=\n\"Gene → Mutation → Subtype Flow\"\n)\n# 在 notebook 中显示图形 | Display figure in notebook\nfig1\n.\nshow\n()\nIn [205]:\nprint\n(\n\"创建基因到亚型的直接流向图... | Creating direct flow diagram from gene to subtype...\"\n)\nfig2\n=\ncreate_sankey_plotly_simple\n(\ndf\n[[\n'gene'\n,\n'subtype'\n]],\ntitle\n=\n\"Gene → Subtype Direct Flow\"\n)\n# 在 notebook 中显示图形 | Display figure in notebook\nfig2\n.\nshow\n()\nIn [206]:\n# 可选：如果你还想保存 HTML 文件 | Optional: if you want to save HTML files\nprint\n(\n\"保存为独立的 HTML 文件... | Saving as standalone HTML files...\"\n)\nconfig\n=\n{\n'responsive'\n:\nTrue\n,\n'displayModeBar'\n:\nTrue\n,\n'displaylogo'\n:\nFalse\n}\nfig1\n.\nwrite_html\n(\n\"sankey_full.html\"\n,\nconfig\n=\nconfig\n)\nfig2\n.\nwrite_html\n(\n\"sankey_direct.html\"\n,\nconfig\n=\nconfig\n)\nprint\n(\n\"=== 保存完成 | Save Complete ===\"\n)\nprint\n(\n\"- 图形已在 notebook 中显示 | Figures displayed in notebook\"\n)\nprint\n(\n\"- 同时保存了独立的 HTML 文件 | Standalone HTML files also saved\"\n)\nSession Info\n¶\nIn [207]:\nimport\nIPython\nprint\n(\nIPython\n.\nsys_info\n())\n!\njupyter\nnbconvert\n--to\nhtml\nFigureYa25Plus_Sankey_py.ipynb",
    "chapter_info": {
      "id": "main_FigureYa25Plus_Sankey_py_FigureYa25Plus_Sankey_py",
      "title": "FigureYa25Plus_Sankey_py/FigureYa25Plus_Sankey_py.html",
      "html": "FigureYa25Plus_Sankey_py/FigureYa25Plus_Sankey_py.html",
      "text": "texts/main_FigureYa25Plus_Sankey_py_FigureYa25Plus_Sankey_py.txt",
      "folder": "FigureYa25Plus_Sankey_py",
      "thumb": "gallery_compress/FigureYa25Plus_Sankey_py.webp"
    },
    "word_count": 1413,
    "lines_count": 895,
    "title": "FigureYa25Plus_Sankey_py",
    "description": "¶ Requirement Description ¶",
    "input_data_types": [
      "突变数据"
    ],
    "output_types": [],
    "technical_methods": [
      "聚类分析",
      "通路分析"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "label",
      "color_idx",
      "width",
      "rgb",
      "df",
      "unique_vals",
      "fig1",
      "source_idx",
      "name",
      "rgba_color"
    ]
  },
  {
    "id": "main_FigureYa187RMS_FigureYa187RMS",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa187RMS_FigureYa187RMS.txt",
    "content": "FigureYa187RMS\nFigureYa187RMS\nAuthor(s)\n: Xiaofan Lu\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-23\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement\n用c-index比较两个预后模型，并画出图A。 Compare the two prognostic\nmodels using c-index and draw Figure A.\n出自\nhttps://onlinelibrary.wiley.com/doi/full/10.1111/cpr.12861\nfromhttps://onlinelibrary.wiley.com/doi/full/10.1111/cpr.12861\nFIGURE 6 RMS curves for RPGI and the integrated PCPI scores are\nplotted for: A, the TCGA cohort, B, validation set 1 and C, validation\nset 2. Each point represents the RMS time of corresponding RPGI and PCPI\nscores. The RMS curves show a larger slope in all three data sets for\nPCPI, indicating superior estimation of survival with PCPI. C-indexes\nfor RPGI and PCPI are also provided. P values represent the difference\nbetween the two models in terms of C-index.\n应用场景\nApplication Scenarios\n计算限制性生存时间，并比较不同因素的预后价值 Calculate the\nrestrictive survival time and compare the prognostic value of different\nfactors\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(survival)\nlibrary(survcomp)\nlibrary(survRM2)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息  # Display an English error message\noptions(stringsAsFactors = FALSE) #禁止chr转成factor  # prohibit chr from being converted to factor\n自定义函数，计算、画图 Custom functions, calculation, and drawing\n# 自定义函数\n# Custom Functions\nrms2curve <- function(survdt = NULL, \n                      base.marker = NULL, \n                      modified.marker = NULL, \n                      tau = 120,\n                      n.grid = 100,\n                      prefix = NULL,\n                      width = 4.5,\n                      height = 4.5) {\n  \n  # survdt：输入数据，必须包含生存时间和生存状态，且无缺失值\n  # survdt: Input data must include the survival time and survival status, and there must be no missing values\n  # base.marker：数值向量，预先计算好的基础marker，样本顺序与survdt一致\n  # Base.Marker: Numerical vector, pre-calculated base marker, sample order consistent with survdt\n  # modified.marker：数值向量，预先计算好的“综合”marker，样本顺序与survdt一致\n  # modified.marker: Numerical vector, pre-calculated \"comprehensive\" marker, sample order consistent with survdt\n  # tau：限制时间点，一般为5年或10年，即60月或120月\n  # tau: The time limit is usually 5 or 10 years, that is, 60 months or 120 months\n  # n.grid：横左边切割用，默认为100，做百分化处理\n  # n.grid: Used for horizontal left cutting, with a default value of 100, for 100% splitting processing\n  # prefix：输出图片的前缀名\n  # prefix: The prefix name of the output image\n  # width：输出图片宽度\n  # width: Output the width of the image\n  # height：输出图片高度\n  # height: Output the height of the image\n  \n  cat(\"Please make sure the survival time (day|year) has been converted to survival time (month)!\\n\")\n  surv.time <- survdt$OS.time\n  surv.event <- survdt$OS\n  marker1 <- base.marker\n  marker2 <- modified.marker\n\n  surv <-Surv(surv.time,surv.event)\n  marker.pp <- seq(from=0,to=1,length=n.grid)\n  marker1.qq <- quantile(marker1,marker.pp)\n  marker2.qq <- quantile(marker2,marker.pp)\n  \n  fitdat.df1 <- data.frame(marker1=marker1)\n  newdat.df1 <- data.frame(marker1=marker1.qq)\n  \n  fitdat.df2 <- data.frame(marker2=marker2)\n  newdat.df2 <- data.frame(marker2=marker2.qq)\n  \n  cox.model1 <- coxph(surv~marker1,data=fitdat.df1)\n  rms.calc1 <- summary(survfit(cox.model1,\n                               newdata=newdat.df1),rmean=tau)\n  rms.mean1 <- rms.calc1$table[,\"rmean\"]\n  \n  cox.model2 <- coxph(surv~marker2,data=fitdat.df2)\n  rms.calc2 <- summary(survfit(cox.model2,newdata=newdat.df2),rmean=tau)\n  rms.mean2 <- rms.calc2$table[,\"rmean\"]\n  \n  fit1 <- coxph(Surv(OS.time,OS) ~ marker1,data = survdt)\n  cindex1 <- concordance.index(predict(fit1),surv.time = survdt$OS.time,surv.event = survdt$OS,method = \"noether\")\n  \n  fit2 <- coxph(Surv(OS.time,OS) ~ marker2,data = survdt)\n  cindex2 <- concordance.index(predict(fit2),surv.time = survdt$OS.time,surv.event = survdt$OS,method = \"noether\")\n  ccomp <- cindex.comp(cindex1 = cindex2, cindex2 = cindex1)\n\n  # RMS Curve\n  fig.name <- paste0(prefix,\".pdf\")\n  pdf(fig.name, width = width,height = height)\n  par(bty=\"o\", mgp = c(1.9,.33,0), mar=c(4.1,4.1,2.1,2.1)+.1, las=1, tcl=-.25)\n  plot(marker.pp,rms.mean1,type=\"p\",pch = 19,col = jco[1],ylim = c(0,tau),\n       xlab=\"Percentile of Riskscore\",ylab = \"RMS (Months)\",cex = 0.8)\n  points(marker.pp,rms.mean2,pch = 19,col = jco[2],cex = 0.8)\n  legend(\"bottomleft\", \n         legend = c(paste0(\"Baseline    model: C-index = \",round(cindex1$c.index,2)),paste0(\"Integrative model: C-index = \",round(cindex2$c.index,2)),\n                    paste0(\"P \",ifelse(ccomp$p.value < 0.001, \"< 0.001\", paste0(\"= \",round(ccomp$p.value,3))))),\n         fill = c(jco[1],jco[2],NA),cex=0.8, border=NA, y.intersp=1, x.intersp=0.2,bty = \"n\")\n  invisible(dev.off())\n  \n  return(list(survfit.marker1 = fit1,survfit.marker2 = fit2,cindex.compare = ccomp))\n}\n输入文件\nInput File\neasy_input.csv，包括一个baseline\nscore。一般是预后模型如LASSO得到的基因得分（可参考FigurejYa31lasso的输出文件lasso_output.txt），以及其他额外变量，这些变量可能提高预后的预测性能。\neasy_input.csv, including a baseline score. Generally, it is the gene\nscore obtained from prognostic models such as LASSO (refer to the output\nfile lasso_output.txt of FigurejYa31lasso), as well as other additional\nvariables, which may improve the predictive performance of\nprognosis.\n此处的输入数据来自原文，包括由多变量Cox +\nLASSO惩罚得到的riskscore（例文为RNA processing gene\nindex，缩写为RPGI），以及两个临床变量（年龄、stage），还有time-to-event数据。\nThe input data here are from the original text, including the riskscore\nobtained by multivariate Cox + LASSO penalty (the example text is RNA\nprocessing gene index, abbreviated as RPGI), as well as two clinical\nvariables (age, stage), and time-to-event data.\ndat <- read.csv(\"easy_input.csv\", row.names = 1, header = T, check.names = F, stringsAsFactors = F)\ndat$OS.time <- dat$OS.time/30.5 #把日转为月  # Convert days to months\ndat <- as.data.frame(na.omit(dat))\nhead(dat)\n# 设置颜色\n# Set Colors\njco <- c(\"#2874C5\",\"#EABF00\")\n多变量cox模型得到新的score\nThe multivariate cox model has obtained a new score\n例文为Processing-Clinical prognostic index (PCPI) Example text:\nProcessing-Clinical prognostic index (PCPI)\ntmp <- coxph(Surv(OS.time, OS) ~ Riskscore + Age + Stage, data = dat)\n\nbase.score <- dat$Riskscore\nnew.score <- as.numeric(apply(dat[,c(\"Riskscore\",\"Age\",\"Stage\")], 1, function(x) {x %*% as.numeric(tmp$coefficients)}))\n开始画图\nStart drawing\n用自定义的函数画图 Draw graphs using custom functions\nrms <- rms2curve(survdt = dat,\n                 base.marker = base.score,\n                 modified.marker = new.score,\n                 tau = 120,\n                 n.grid = 100,\n                 prefix = \"RMS\",\n                 width = 4.5,\n                 height = 4.5)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa187RMS_FigureYa187RMS",
      "title": "FigureYa187RMS/FigureYa187RMS.html",
      "html": "FigureYa187RMS/FigureYa187RMS.html",
      "text": "texts/main_FigureYa187RMS_FigureYa187RMS.txt",
      "folder": "FigureYa187RMS",
      "thumb": "gallery_compress/FigureYa187RMS.webp"
    },
    "word_count": 752,
    "lines_count": 163,
    "title": "FigureYa187RMS",
    "description": "Requirement 用c-index比较两个预后模型，并画出图A。 Compare the two prognostic models using c-index and draw Figure A.",
    "input_data_types": [
      "临床数据",
      "生存数据"
    ],
    "output_types": [
      "统计表格",
      "生存曲线"
    ],
    "technical_methods": [
      "生存分析"
    ],
    "biology_areas": [],
    "complexity_level": "高级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "to",
      "intersp",
      "survdt",
      "header",
      "width",
      "newdata",
      "grid",
      "event",
      "ylim"
    ]
  },
  {
    "id": "main_FigureYa217RMR_FigureYa217RMR",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa217RMR_FigureYa217RMR.txt",
    "content": "FigureYa217RMR_副本.Rmd\nFigureYa217RMR\nXiaofan Lu; Ying Ge, Yijing Chen\n2025-5-20\n需求描述\nrequirement description\n基于maximum relevance minimum redundancy (mRMR)算法，采用R语言（包）实现图1。\n数据：GSE84465（很有名的一个数据集，网上有些公众号都采用该数据集）\nBased on the maximum relevance minimum redundancy (mRMR) algorithm, Figure 1 is implemented using the R language (package).\nData: GSE84465 (a well-known dataset, adopted by several online public accounts)\n出自\nhttps://www.frontiersin.org/articles/10.3389/fbioe.2020.00167/full\nfrom\nhttps://www.frontiersin.org/articles/10.3389/fbioe.2020.00167/full\n应用场景\napplication scenario\n采用minimal Redundancy Maximal Relevance鉴定差异基因，后采用SVM + LOOCV (支持向量机 + 余一交叉验证)法，根据MCC统计量确定最小且最优基因组合用于构建预测模型。\nDifferential genes are identified using the minimal Redundancy Maximal Relevance method, followed by the application of SVM + LOOCV (Support Vector Machine + Leave-One-Out Cross-Validation) to determine the smallest and most optimal gene combination based on the MCC for constructing the predictive model.\n环境设置\nenvironment setting\n使用国内镜像安装包\nuse the domestic mirror installation package\nxxxxxxxxxx\noptions\n(\n\"repos\"\n=\nc\n(\nCRAN\n=\n\"https://mirrors.tuna.tsinghua.edu.cn/CRAN/\"\n))\noptions\n(\nBioC_mirror\n=\n\"http://mirrors.tuna.tsinghua.edu.cn/bioconductor/\"\n)\ninstall.packages\n(\n\"mRMRe\"\n)\n加载包\nload package\n​\nx\nlibrary\n(\nmRMRe\n)\nlibrary\n(\ne1071\n)\nSys.setenv\n(\nLANGUAGE\n=\n\"en\"\n)\n#显示英文报错信息 display English error messages\noptions\n(\nstringsAsFactors\n=\nFALSE\n)\n#禁止chr转成factor prohibit the conversion of chr to factor\n自定义函数，用来显示进度\nCustom function for displaying progress\nxxxxxxxxxx\ndisplay.progress\n=\nfunction\n(\nindex\n,\ntotalN\n,\nbreakN\n=\n20\n) {\nif\n(\nindex\n%%\nceiling\n(\ntotalN\n/\nbreakN\n)\n==\n0\n) {\ncat\n(\npaste\n(\nround\n(\nindex\n*\n100\n/\ntotalN\n),\n\"% \"\n,\nsep\n=\n\"\"\n))\n}\n}\n输入文件\nInput file\nGSE84465_GBM_All_data.csv，单细胞count数据，下载自\nhttps://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE84465\ncell_info.txt，单细胞样本信息，下载自\nhttps://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE84465\nSeries Matrix File(s)\nGSE84465_GBM_All_data.csv, single-cell count data, downloaded from\nhttps://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE84465\ncell_info.txt, single-cell sample information, downloaded from\nhttps://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE84465\nSeries Matrix File(s)\nxxxxxxxxxx\n# 加载单细胞count数据\n# Load single-cell count data\ncount\n<-\nread.delim\n(\n\"GSE84465_GBM_All_data.csv\"\n,\nheader\n=\nT\n,\ncheck.names\n=\nF\n,\nstringsAsFactors\n=\nF\n,\nrow.names\n=\n1\n,\nsep\n=\n\"\n\"\n)\n# 加载单细胞样本信息\n# Load single-cell sample information\ncinfo\n<-\nread.table\n(\n\"cell_info.txt\"\n,\nsep\n=\n\"\n\\t\n\"\n,\nrow.names\n=\nNULL\n,\nheader\n=\nT\n,\ncheck.names\n=\nF\n,\nstringsAsFactors\n=\nF\n)\nrownames\n(\ncinfo\n)\n<-\npaste0\n(\ncinfo\n$\nplate\n,\n\".\"\n,\ncinfo\n$\nwell\n)\nhead\n(\ncinfo\n)\n# 提取positive和negtive样本\n# Extract positive and negative samples\npos.sam\n<-\nrownames\n(\ncinfo\n[\nwhich\n(\ncinfo\n$\ntissue\n==\n\"Tumor\"\n),])\nneg.sam\n<-\nrownames\n(\ncinfo\n[\nwhich\n(\ncinfo\n$\ntissue\n==\n\"Periphery\"\n),])\n# 提取count数据里无效tag\n# Extract invalid tags from the count data\nrmtag\n<-\nc\n(\n\"no_feature\"\n,\n\"ambiguous\"\n,\n\"too_low_aQual\"\n,\n\"not_aligned\"\n,\n\"alignment_not_unique\"\n)\nindata\n<-\nas.data.frame\n(\nt\n(\ncount\n))\nindata\n<-\nindata\n[\nc\n(\npos.sam\n,\nneg.sam\n),\nsetdiff\n(\ncolnames\n(\nindata\n),\nrmtag\n)]\nindata\n$\nclass\n<-\nrep\n(\nc\n(\n1\n,\n0\n),\nc\n(\nlength\n(\npos.sam\n),\nlength\n(\nneg.sam\n)))\ncolnames\n(\nindata\n)\n<-\ngsub\n(\n\"-\"\n,\n\"_\"\n,\ncolnames\n(\nindata\n))\n# 避免后续构建模型时基因名出错 Avoid errors in gene names during subsequent model construction\n运行mRMR\nRun mRMR\nxxxxxxxxxx\nf_data\n<-\nmRMR.data\n(\ndata\n=\ndata.frame\n(\nas.matrix\n(\nindata\n)))\nresults\n<-\nmRMR.classic\n(\n\"mRMRe.Filter\"\n,\ndata\n=\nf_data\n,\ntarget_indices\n=\nncol\n(\nindata\n),\n# 最后一列是target The last column is target\nfeature_count\n=\n40\n)\n# 原文取100个，这里取40个加快下面预测模型的循环 The original text selected 100, but here we choose 40 to speed up the loop of the predictive model below\nfeats\n<-\ncolnames\n(\nindata\n)[\nsolutions\n(\nresults\n)[[\n1\n]][,\n1\n]]\n# 得到的40个features The 40 features obtained\n构建SVM预测模型\nConstruct an SVM prediction model\n很慢，请耐心，大概跑了4天。\nIt's very slow, please be patient, it's been running for about four days.\nxxxxxxxxxx\nprobcutoff\n<-\n0.5\nvar\n<-\nc\n()\nmcc\n<-\nc\n()\nfor\n(\ni\nin\nfeats\n) {\ncat\n(\ni\n,\n\"\n\\n\n\"\n)\nvar\n<-\nc\n(\nvar\n,\ni\n)\ntmp\n<-\nindata\n[,\nc\n(\nvar\n,\n\"class\"\n)]\nf\n<-\nas.formula\n(\npaste0\n(\n\"class~\"\n,\npaste\n(\nvar\n,\ncollapse\n=\n\"+\"\n)))\nsvmpred\n<-\nNULL\nfor\n(\nj\nin\n1\n:\nnrow\n(\ntmp\n)) {\n# 余一交叉验证 Leave-one-out cross-validation\ndisplay.progress\n(\nindex\n=\nj\n,\ntotalN\n=\nnrow\n(\ntmp\n))\ns\n<-\nrownames\n(\ntmp\n)[\nj\n]\n# 取出一个样本 Take out a sample\ntest.dat\n<-\ntmp\n[\ns\n,]\n# 该样本为测试集 This sample is the test set\ntrain.dat\n<-\ntmp\n[\nsetdiff\n(\nrownames\n(\ntmp\n),\ns\n),]\n# 其余样本为训练集 The remaining samples serve as the training set\n# 构建SVM模型\n# Construct an SVM model\nsvmfit\n<-\nsvm\n(\nformula\n=\nf\n,\ndata\n=\ntrain.dat\n,\nkernel\n=\n\"radial\"\n)\n# 应用于测试样本做预测\n# Applied to test samples for prediction\nsvmpredict\n<-\npredict\n(\nsvmfit\n,\ntest.dat\n,\nprobability\n=\nT\n)\n# 生成结果\n# Generate results\nsvmpred\n<-\nrbind.data.frame\n(\nsvmpred\n,\ndata.frame\n(\nid\n=\ns\n,\nprob\n=\nsvmpredict\n,\n# 预测概率 Prediction probability\ntrueclass\n=\ntest.dat\n$\nclass\n,\n# 金标准 Gold standard\nstringsAsFactors\n=\nF\n),\nstringsAsFactors\n=\nF\n)\n}\nsvmpred\n$\npredclass\n<-\nifelse\n(\nsvmpred\n$\nprob\n>\nprobcutoff\n,\n1\n,\n0\n)\n# 若概率大于50%判定1，否则为0 If the probability exceeds 50%, it is judged as 1; otherwise, it is 0.\ntp\n<-\nsum\n(\nsvmpred\n$\npredclass\n==\n1\n&\nsvmpred\n$\ntrueclass\n==\n1\n)\n# 计算真阳性 Calculate true positives\ntn\n<-\nsum\n(\nsvmpred\n$\npredclass\n==\n0\n&\nsvmpred\n$\ntrueclass\n==\n0\n)\n# 计算真阴性 Calculate true negatives\nfp\n<-\nsum\n(\nsvmpred\n$\npredclass\n==\n1\n&\nsvmpred\n$\ntrueclass\n==\n0\n)\n# 计算假阳性 Calculate false positives\nfn\n<-\nsum\n(\nsvmpred\n$\npredclass\n==\n0\n&\nsvmpred\n$\ntrueclass\n==\n1\n)\n# 计算假阴性 Calculate false negatives\nmcc\n<-\nc\n(\nmcc\n,\n(\ntp\n*\ntn\n-\nfp\n*\nfn\n)\n/\n(\nsqrt\n(\ntp\n+\nfp\n)\n*\nsqrt\n(\ntp\n+\nfn\n)\n*\nsqrt\n(\ntn\n+\nfp\n)\n*\nsqrt\n(\ntn\n+\nfn\n) ))\n# 计算MCC Calculate MCC\ncat\n(\n\"\n\\n\n\"\n)\n}\nsave\n(\nmcc\n,\nfile\n=\n\"mcc.rda\"\n)\n#保存到文件 Save to file\nmessage\n(\npaste0\n(\n\"--the maximal MCC reaches as \"\n,\nround\n(\nmcc\n[\nwhich.max\n(\nmcc\n)],\n3\n),\n\"\nat gene number of \"\n,\nwhich.max\n(\nmcc\n)))\n开始画图\nStart drawing\nx\n# 加载上一步的结果\n# Load the results from the previous step\n(\nload\n(\n\"mcc.rda\"\n))\nhead\n(\nmcc\n)\npar\n(\nbty\n=\n\"o\"\n,\nmgp\n=\nc\n(\n2\n,\n0.5\n,\n0\n),\nmar\n=\nc\n(\n3.1\n,\n3.1\n,\n2.1\n,\n2.1\n),\ntcl\n=-\n.25\n,\nlas\n=\n1\n)\nplot\n(\n1\n:\nlength\n(\nmcc\n),\nmcc\n,\nxlab\n=\n\"Number of Genes\"\n,\nylab\n=\n\"LOOCV MCC\"\n,\ntype\n=\n\"l\"\n,\nlwd\n=\n2\n)\n# 添加最大MCC的位置\n# Add the position of the highest MCC\npoints\n(\nwhich.max\n(\nmcc\n),\nmcc\n[\nwhich.max\n(\nmcc\n)],\npch\n=\n8\n,\ncol\n=\n\"red\"\n,\ncex\n=\n1.5\n)\n# 添加该位置的MCC信息\n# Add the MCC information for this location\ntext\n(\nwhich.max\n(\nmcc\n),\nmcc\n[\nwhich.max\n(\nmcc\n)]\n-\n0.04\n,\nlabels\n=\npaste0\n(\n\"(\"\n,\nwhich.max\n(\nmcc\n),\n\", \"\n,\nround\n(\nmcc\n[\nwhich.max\n(\nmcc\n)],\n3\n),\n\")\"\n),\ncol\n=\n\"red\"\n)\nxxxxxxxxxx\ndev.copy2pdf\n(\nfile\n=\n\"mcc.pdf\"\n,\nwidth\n=\n4\n,\nheight\n=\n4\n)\n# save.image(\"mRMR.RData\")\nSession Info\n会话信息\nxxxxxxxxxx\nsessionInfo\n()",
    "chapter_info": {
      "id": "main_FigureYa217RMR_FigureYa217RMR",
      "title": "FigureYa217RMR/FigureYa217RMR.html",
      "html": "FigureYa217RMR/FigureYa217RMR.html",
      "text": "texts/main_FigureYa217RMR_FigureYa217RMR.txt",
      "folder": "FigureYa217RMR",
      "thumb": "gallery_compress/FigureYa217RMR.webp"
    },
    "word_count": 1231,
    "lines_count": 895,
    "title": "FigureYa217RMR_副本.Rmd",
    "description": "requirement description 基于maximum relevance minimum redundancy (mRMR)算法，采用R语言（包）实现图1。 数据：GSE84465（很有名的一个数据集，网上有些公众号都采用该数据集）",
    "input_data_types": [
      "临床数据",
      "DNA-seq",
      "单细胞"
    ],
    "output_types": [
      "统计表格"
    ],
    "technical_methods": [],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "id",
      "acc",
      "header",
      "lwd",
      "width",
      "prob",
      "feature_count",
      "breakN",
      "labels"
    ]
  },
  {
    "id": "main_FigureYa183condSurv_FigureYa183condSurv",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa183condSurv_FigureYa183condSurv.txt",
    "content": "FigureYa183condSurv\nFigureYa183condSurv\nAuthor(s)\n: Xiaofan Lu\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement\n想画条件生存曲线，conditional survival，R包condsurv能实现。 To draw a\nconditional survival curve, the R package condsurv can achieve\nconditional survival.\n出自\nhttps://link.springer.com/article/10.1245/s10434-020-08235-w\nfromhttps://link.springer.com/article/10.1245/s10434-020-08235-w\nFIG. 1 Kaplan–Meier estimates for conditional survival up to 8 years\nin 3082 patients given 0–5 years’ 1.00 survival after resection of\npancreatic cancer\n应用场景\nApplication Scenarios\n绘制条件概率生存曲线，给出条件生存概率表。 Draw the conditional\nprobability survival curve and provide the conditional survival\nprobability table.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\noptions(warn = -1)\n\n#library(condsurv) # 本代码使用的函数为该函数包中gg_conditional_surv的修改版 #The function used in this code is a modified version of gg_conditional_surv in the function package\nlibrary(survival)\nlibrary(tidyverse)\nlibrary(survminer)\nlibrary(ggpubr)\nlibrary(patchwork)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息  # Display an English error message\noptions(stringsAsFactors = FALSE) #禁止chr转成factor   # prohibit chr from being converted to factor\n自定义函数 Custom function\nconditional_surv_est <- function(basekm, t1, t2) {\n  if (class(basekm) != \"survfit\") {\n    stop(\n      \"Argument to basekm must be of class survfit\"\n    )\n  }\n\n  if (max(t1) > max(basekm$time)) {\n    stop(\n      paste(\n        \"Argument to t1 specifies a value outside the range of observed times;\", \"the maximum observed time is\", round(max(basekm$time), 2)\n      )\n    )\n  }\n\n  if (max(t2) > max(basekm$time)) {\n    stop(paste(\n      \"Argument to t2 specifies a value outside the range of observed times;\",\n      \"the maximum observed time is\", round(max(basekm$time), 2)\n    ))\n  }\n\n  cs <- summary(basekm, times = c(t1, t2))$surv[2] /\n    summary(basekm, times = c(t1, t2))$surv[1]\n  cs.sq <- cs^2\n\n  d <- basekm$n.event[basekm$time >= t1 &\n                        basekm$time <= t2 &\n                        basekm$n.event > 0]\n\n  r <- basekm$n.risk[basekm$time >= t1 &\n                       basekm$time <= t2 &\n                       basekm$n.event > 0]\n\n  dr <- d / (r * (r - d))\n  var.cs <- 1 / (log(cs)^2) * sum(dr)\n  ci <- cs^(exp(c(1, -1) * stats::qnorm(0.975) * sqrt(var.cs)))\n  ci.cs <- round(ci, 2)\n\n  return(\n    list(\n      cs_est = round(cs, 2),\n      cs_lci = ci.cs[1],\n      cs_uci = ci.cs[2]\n    )\n  )\n}\n\ncon_prob <- function(i){\n  y <- as.numeric(i)\n  table=purrr::map_df(\n    prob_times,\n    ~conditional_surv_est(\n      basekm = myfit,\n      t1 = y,\n      t2 = .x)) %>%\n    mutate(years = prob_times) %>%\n    select(years, everything())\n  table$con=i\n  table$label=ifelse(table$years<y,NA,paste0((table$cs_est)*100,\"%\"))\n  data.frame(table)\n}\n\nplot_condsurv <- function (survdt = NULL,\n                           at, \n                           surv.cut = NULL,\n                           main = \"\", \n                           xlab = \"Time (Years)\", \n                           ylab = \"Survival probability\", \n                           curv.col = NULL,\n                           lwd = 1.2,\n                           legend.pos = \"top\") \n{\n  # survdat: 生存数据，至少包含两列，生存时间（futime，年为单位）和生存状态（fustat）\n  # survdat: Survival data, at least two columns, survival time (futime, in years) and survival status (fustat)\n  # at：一个数值序列，表示条件生存时间中的附加时间，如在第三年存活的基础上额外存活at年的概率\n  # at: A numerical sequence representing additional time in conditional survival time, such as the probability of surviving for an extra at years on top of surviving in the third year\n  # surv.cut：KM曲线在surv.cut处截断\n  # surv.cut: The KM curve cuts off at surv.cut\n  # main：图像主题，默认无\n  # main: Image theme, none by default\n  # xlab：图像x轴名称，默认以年为单位\n  # xlab: Image X-axis name, default in years\n  # ylab：图像y轴名称，默认以25%为间隔\n  # ylab: Y-axis name of the image, with a default interval of 25%\n  # curv.col：各条件生存曲线的颜色\n  # curv.col: The color of the survival curve for each condition\n  # lwd：线条宽度\n  # lwd: Line width\n  # legend.pos：图例位置，默认为顶部\n  # Legend.pos: legend location, default to top\n  \n  library(ggplot2)\n  library(survival)\n  library(tidyverse)\n  \n  basekm <- survfit(Surv(futime, fustat)~ 1, data=survdt, type=\"kaplan-meier\", error=\"greenwood\", conf.type=\"plain\", na.action=na.exclude)\n  \n  if (max(at) > max(basekm$time)) {\n    stop(paste(\"Argument to at specifies value(s) outside the range of observed times;\", \n               \"the maximum observed time is\", round(max(basekm$time), 2)))\n  }\n  if(surv.cut <= max(at)) {\n    stop(\"Time cutoff should be greater than the maximal conditional survival point\\n\")\n  }\n  if(!all(is.element(c(\"fustat\",\"futime\"),colnames(survdt)))) {\n    stop(\"Make sure the survival data has two columns of fustat and futime\\n\")\n  }\n  \n  nt <- length(at)\n  fitkm <- list()\n  fitkmdat <- list()\n  for (i in 1:nt) {\n    fitkm[[i]] <- survival::survfit(formula = stats::as.formula(basekm$call$formula), \n                                    data = eval(basekm$call$data), start.time = at[i])\n    fitkmdat[[i]] <- tibble::tibble(timept = fitkm[[i]]$time, \n                                    prob = fitkm[[i]]$surv)\n  }\n  condsurvdat <- fitkmdat %>% purrr::map_df(`[`, .id = \"which_at\") %>% \n    dplyr::mutate(condtime = factor(which_at, levels = seq(1, nt), labels = at))\n  \n  condsurvdat$condtime <- paste0(condsurvdat$condtime,\" Year\")\n  \n  # 第一幅条件生存概率曲线\n  # The first conditional survival probability curve\n  if(is.null(surv.cut)) {\n    condsurv_plot <- ggplot(condsurvdat, aes(x = timept, y = prob, color = condtime)) + \n                            scale_color_manual(values = mycol) + \n                            geom_step(lwd = lwd) + \n                            ylim(0, 1) + \n                            labs(x = xlab, y = ylab, title = main, color = \"Given conditional survival\") + \n                            geom_segment(aes(x = 0, y = 1, xend = at[length(at)], yend = 1),lwd = lwd, color = curv.col[at[length(at)] + 1]) +\n                            theme_classic() +\n                            theme(axis.text.x = element_text(angle = 0, hjust = 1, size = 12),\n                                  panel.border = element_rect(colour = \"black\", fill=NA, size=0.2),\n                                  axis.ticks = element_line(size=0.2, color=\"black\"),\n                                  axis.ticks.length = unit(0.2, \"cm\"),\n                                  legend.position = legend.pos,\n                                  axis.title = element_text(size = 15),\n                                  axis.text = element_text(size = 10))\n    ggsave(\"conditional_survival_curve.pdf\")\n    \n  } else {\n    condsurv_plot <- ggplot(condsurvdat, aes(x = timept, y = prob, color = condtime)) + \n                            scale_color_manual(values = mycol) + \n                            geom_step(lwd = lwd) + \n                            ylim(0, 1) + \n                            xlim(0, surv.cut) + \n                            labs(x = xlab, y = ylab, title = main, color = \"Given conditional survival\") + \n                            geom_segment(aes(x = 0, y = 1, xend = at[length(at)], yend = 1),lwd = lwd, color = curv.col[at[length(at)] + 1]) +\n                            theme_classic() +\n                            theme(axis.text.x = element_text(angle = 0, hjust = 1, size = 12),\n                                  panel.border = element_rect(colour = \"black\", fill=NA, size=0.2),\n                                  axis.ticks = element_line(size=0.2, color=\"black\"),\n                                  axis.ticks.length = unit(0.2, \"cm\"),\n                                  legend.position = legend.pos,\n                                  axis.title = element_text(size = 15),\n                                  axis.text = element_text(size = 10))\n  }\n  \n  # 输出条件生存概率表\n  # Output the conditional survival probability table\n  condsurvmat <- matrix(\"\",\n                        nrow = max.condsurv + 1,\n                        ncol = floor(max(survdt$futime)) + 1,\n                        dimnames = list(paste0(\"y\",0:max.condsurv),\n                                         paste0(\"y\",0:floor(max(survdt$futime)))))\n  condsurvmat <- as.data.frame(condsurvmat)\n  \n  for (given_year in 0:max.condsurv) {\n    for (reach_year in given_year:floor(max(survdt$futime))) {\n      condsurvmat[paste0(\"y\",given_year),paste0(\"y\",reach_year)] <- \n        paste0(conditional_surv_est(basekm, given_year, reach_year)$cs_est * 100,\"%\")\n    }\n  }\n  write.csv(condsurvmat,file = \"conditional_survival_matrix.csv\",row.names = T,col.names = NA,quote = F)\n  \n  return(list(condsurvdat = condsurvdat, condsurvcurve = condsurv_plot, condsurvmat = condsurvmat, cond = at, prob_times = seq(0,surv.cut,1), basekm = basekm))\n}\n输入文件\nInput File\neasy_input.csv，生存数据，至少包含两列，生存时间（futime，年为单位）和生存状态（fustat）。\neasy_input.csv, survival data, must contain at least two columns:\nsurvival time (futime, in years) and survival status (fustat).\ndat <- read.csv(\"easy_input.csv\",row.names = NULL,check.names = F,stringsAsFactors = F, header = T)\nhead(dat)\ntable(dat$fustat)\n分析画图\nAnalysis drawing\n原文上半部分是图，下半部分是表格。 The upper part of the original\ntext is a graph and the lower part is a table.\n这里都用画图的方式实现，让三部分结果对齐。当然你也可以像原文那样画成表格。\nHere, all are achieved through drawing diagrams to align the results of\nthe three parts. Of course, you can also draw it as a table just like in\nthe original text.\n# 注意将生存时间转换为年\n# Note to convert the survival time to years\ndat$futime <- dat$futime/365\n\n# 设置最长希望观测的生存时间点（条件概率的最大生存时间，如5年）\n# Set the maximum desired survival time point for observation (the maximum survival time of conditional probability, such as 5 years)\nmax.condsurv <- 5\n\n# 自定义颜色\n# Custom Colors\nmycol <- RColorBrewer::brewer.pal(n = max.condsurv + 1, name = 'Set2')\n\n# 第一幅\n# The First One\n# 调用函数画图，同时输出生存概率表\n# Call the function to draw a graph and output the survival probability table at the same time\np1 <- plot_condsurv(survdt = dat,\n                   at = 0:max.condsurv,\n                   surv.cut = 6,\n                   curv.col = mycol,\n                   legend.pos = \"top\")\n\n# 第二幅\n# The Second One\n# 把条件生存概率表画成图\n# Plot the conditional survival probability table as a graph\nmyfit <- p1$basekm \ncond <- p1$cond\nprob_times <- p1$prob_time\ndata <- do.call(rbind,lapply(cond, con_prob))\ndata$years <- as.factor(data$years)\np2 <- ggplot(data = data, aes(x=years,y=con,label=label))+\n        ggpubr::geom_exec(geom_text, data = data, size = 5, color = \"con\")+\n        scale_y_reverse()+theme_classic()+\n        theme(legend.position = \"none\",\n           axis.text.x = element_text(size=15),\n           axis.text.y = element_text(size=15),\n           axis.title = element_text(size=15))+\n        xlab(\"Survival probability to reach X years\")+\n        ylab(\"Given years of survival\") +\n        scale_color_gradientn(colours = mycol) #颜色跟第一幅图一致\n\n# 第三幅\n# The Third One\nn <- ggrisktable(myfit, break.time.by=1, data = dat)\nm <- n$data[(min(prob_times)+1):(max(prob_times)+1),]\nm$time <- as.factor(m$time)\n# 把风险表输出到文件\n# Output the risk table to a file\nrisk <- t(data.frame(risk = m$n.risk))\ncolnames(risk) <- m$time\nwrite.csv(risk, \"number_at_risk.csv\", quote = F)\n# 把风险表画成图\n# Draw the risk table as a graph\np3 <- ggplot(data = m, aes(x=time, y=strata, label=n.risk)) +\n  ggpubr::geom_exec(geom_text, data = m, size = 5, color = \"black\") +\n  theme_classic() +\n  theme(legend.position = \"none\",\n        axis.text.x = element_text(size=15),\n        axis.text.y = element_text(size=15),\n        axis.title = element_text(size=15)) +\n  ylab(\"Number at risk\") + \n  xlab(\"Years\")\n合并图像并输出 Merge the images and output them\ncondsurv_plot <- p1$condsurvcurve + p2 + p3 + \n  plot_layout(ncol = 1, heights = c(5,5,1))\ncondsurv_plot\nggsave(\"conditional_survival_curve.pdf\", width = 8, height = 12)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa183condSurv_FigureYa183condSurv",
      "title": "FigureYa183condSurv/FigureYa183condSurv.html",
      "html": "FigureYa183condSurv/FigureYa183condSurv.html",
      "text": "texts/main_FigureYa183condSurv_FigureYa183condSurv.txt",
      "folder": "FigureYa183condSurv",
      "thumb": "gallery_compress/FigureYa183condSurv.webp"
    },
    "word_count": 1331,
    "lines_count": 310,
    "title": "FigureYa183condSurv",
    "description": "Requirement 想画条件生存曲线，conditional survival，R包condsurv能实现。 To draw a conditional survival curve, the R package condsurv can achieve",
    "input_data_types": [
      "生存数据"
    ],
    "output_types": [
      "统计表格",
      "生存曲线"
    ],
    "technical_methods": [
      "生存分析"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "pos",
      "basekm",
      "colour",
      "id",
      "values",
      "ticks",
      "times",
      "survdt"
    ]
  },
  {
    "id": "main_FigureYa264epiImmune_FigureYa264epiImmune",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa264epiImmune_FigureYa264epiImmune.txt",
    "content": "FigureYa264epiImmune\nFigureYa264epiImmune\nAuthor(s)\n: Shuwen Cheng; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-05-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nDemand description\n我想实现这篇文章的Figure 1A。\n此图的内容：在117例CD8+T细胞高浸润的TCGA黑色素瘤样本中，表观遗传调节因子的表达与细胞毒性T淋巴细胞（CTL）评分之间的相关性。注：1.细胞毒性T淋巴细胞（CTL）评分：文献报道（PMID:\n30127393）的CD8+T细胞标志与功能的基因的平均表达水平（CD8A、CD8B、GZMA、GZMB和PRF1）。2.CD8+\nT细胞高浸润水平：高于TIMER上的四分位数。\n此图的优点：1.扩展性强，换成其他基因及免疫细胞也可以用。2.实用性强：很密集的展示了很多信息。\n绘图的难点：1.作者通过5个基因的平均表达量来定义CTL评分，代码如何实现呢？2.如何通过TIMER确定CD8\n+T细胞高浸润的TCGA样本？3.CTL评分与TCGA基因表达水平之间的相关性，代码如何实现？4.如何绘制文章中的柱状图？\nI would like to draw the creation of Figure 1A for this article.\nContent of the figure: The correlation between the expression of\nepigenetic regulators and the Cytotoxic T Lymphocyte (CTL) score in 117\nTCGA melanoma samples with high CD8+ T-cell infiltration. Notes: 1.CTL\nscore: The average expression level of genes associated with CD8+ T-cell\nmarkers and function, as reported in the literature (PMID: 30127393)\n(CD8A, CD8B, GZMA, GZMB, and PRF1). 2.High CD8+ T-cell infiltration\nlevel: Above the upper quartile on TIMER.\nAdvantages of this figure: 1.Highly scalable: It can be adapted\nfor other genes and immune cells. 2.Highly practical: It densely\npresents a large amount of information.\nChallenges in creating the figure: 1.How to implement the code\nfor calculating the CTL score based on the average expression of the\nfive genes? 2.How to identify TCGA samples with high CD8+ T-cell\ninfiltration using TIMER? 3.How to implement the code for calculating\nthe correlation between the CTL score and TCGA gene expression levels?\n4.How to reproduce the bar plot shown in the article?\n出自：\nhttps://linkinghub.elsevier.com/retrieve/pii/S1550413121001674\n图1. FTO缺失通过增强肿瘤浸润性T细胞抑制肿瘤生长。 (A)\n在117例具有充分CD8+ T细胞浸润的TCGA黑色素瘤样本中（定义为TIMER估算的CD8+\nT细胞浸润水平高于上四分位数，详见方法部分），已知表观遗传调控因子表达与细胞毒性T淋巴细胞（CTL）评分（CD8A、CD8B、GZMA、GZMB和PRF1的平均表达量）的Spearman相关性分析。采用Spearman秩相关系数（rho）评估基于秩次的关联性度量。\nSource:\nhttps://linkinghub.elsevier.com/retrieve/pii/S1550413121001674\nFigure 1. The absence of FTO inhibits tumor growth by enhancing\ntumor-infiltrating T cells. (A) Spearman correlation of the expression\nof known epigenetic regulators with cytotoxic T lymphocyte (CTL) scores\n(average expression of CD8A, CD8B, GZMA, GZMB, and PRF1) in 117 TCGA\nmelanoma samples with sufficient CD8+ T cell infiltration (defined as an\nestimated CD8+ T cell infiltration level higher than upper quartile by\nTIMER) (STAR methods). Spearman’s rho statistic is used to estimate a\nrank-based measure of association.\n应用场景\nApplication scenarios\n从下载TCGA数据开始，进行TIMER打分，根据某一类免疫细胞分组，计算表观遗传调控因子的表达与细胞毒性T淋巴细胞CTL评分之间的相关性，并画出柱形图。\n把TCGA表达数据跟免疫浸润、表观遗传都联系起来了，或许对挖掘调控机制有启发。\nStarting from downloading TCGA data, perform TIMER scoring, group by\na specific type of immune cell, calculate the correlation between the\nexpression of epigenetic regulatory factors and the cytotoxic T\nlymphocyte (CTL) score, and plot a bar chart.\nThis connects TCGA expression data with immune infiltration and\nepigenetics, which may provide insights into regulatory mechanisms.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(ggprism)\nlibrary(magrittr)\nlibrary(tidyverse)\nlibrary(ggcorrplot)\nlibrary(immunedeconv)\nlibrary(TCGAbiolinks)\nlibrary(org.Hs.eg.db)\nlibrary(clusterProfiler)\nlibrary(SummarizedExperiment)\n# 自定义函数，把FPKM转换成TPM\n# Custom function to convert FPKM to TPM\nfpkmToTpm <- function(fpkm) {exp(log(fpkm) - log(sum(fpkm)) + log(1e6))}\n\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n下载TCGA数据并根据文章描述进行过滤\nDownload TCGA data and filter according to the article\ndescription\n# 从GDC获取TCGA-SKCM项目的RNA-seq计数数据\n# Query TCGA-SKCM RNA-seq count data from GDC\nTCGA_SKCM_FPKM <- GDCquery(project = \"TCGA-SKCM\",\n                           data.category = \"Transcriptome Profiling\",\n                           data.type = \"Gene Expression Quantification\",\n                           workflow.type = \"STAR - Counts\") %T>% \n  GDCdownload %>% GDCprepare \n\n# 数据转换与清洗\n# Data Transformation and Cleaning\nTCGA_SKCM_TPM <- TCGA_SKCM_FPKM %>% \n  assay() %>% \n  as.data.frame() %>% \n  rownames_to_column(\"ENSEMBL\") %>% \n  mutate(ENSEMBL = sub(\"\\\\..*\", \"\", ENSEMBL)) %>% \n  left_join(\n    bitr(.$ENSEMBL, \"ENSEMBL\", \"SYMBOL\", org.Hs.eg.db) %>% \n      group_by(ENSEMBL) %>% \n      summarise(SYMBOL = SYMBOL[1], .groups = \"drop\"),  \n    by = \"ENSEMBL\"\n  ) %>% \n  # 过滤无效映射\n  # Filter invalid mappings\n  filter(!is.na(SYMBOL) & SYMBOL != \"\") %>% \n  # 按基因符号聚合（保留最大值）\n  # Aggregate by gene symbol (keeping maximum values)\n  group_by(SYMBOL) %>% \n  summarise(across(where(is.numeric), max), .groups = \"drop\") %>% \n  # 检查重复行名\n  # Check for duplicate row names\n  { \n    dup <- duplicated(.$SYMBOL)\n    if(any(dup)) warning(paste(\"Duplicated SYMBOL removed:\", .$SYMBOL[dup]))\n    filter(., !dup)\n  } %>% \n  column_to_rownames(\"SYMBOL\") %>% \n  # FPKM转TPM\n  # Convert FPKM to TPM\n  apply(2, fpkmToTpm) %>% \n  as.data.frame() %>% \n  # 过滤低表达基因\n  # Filter low-expressed genes\n  filter(rowMeans(.) > 1)\n\n# 保存到文件\n# Save to file\nsave(TCGA_SKCM_TPM, file = \"TCGA_SKCM_TPM.Rdata\")\n进行TIMER打分，并根据CD8分为3组\nPerform TIMER scoring and divide into 3 groups based on CD8\nlevels\n这里用immunedeconv包进行TIMER打分\nHere we use the immunedeconv package for TIMER scoring\n# 加载前面处理好的数据\n# Load the pre-processed data\n(load(\"TCGA_SKCM_TPM.Rdata\"))\n# 使用TIMER进行打分，指明每个样本所属的癌种\n# Perform TIMER scoring, specifying the cancer type for each sample\nTCGA_SKCM_imme <- deconvolute_timer(TCGA_SKCM_TPM, indications = rep(\"skcm\", ncol(TCGA_SKCM_TPM))) %>%\n  t %>% as.data.frame\n# 计算四分位数# Calculate quartiles\n# Calculate quartiles\n(TIMER4 <- quantile(TCGA_SKCM_imme$T_cell.CD8))\n# 根据四分位数分为3组\n# Divide into 3 groups based on quartiles\nTCGA_SKCM_CD8_h <- TCGA_SKCM_imme %>% filter(T_cell.CD8 >= TIMER4[4])\nTCGA_SKCM_CD8_m <- TCGA_SKCM_imme %>% filter(T_cell.CD8 >= TIMER4[2]\n & T_cell.CD8 < TIMER4[2])\nTCGA_SKCM_CD8_l <- TCGA_SKCM_imme %>% filter(T_cell.CD8 < TIMER4[2])\n自定义表观修饰基因集，并进行整合\nCustom epigenetic modification gene sets and integration\n文中没有找到定义的表观修饰相关的基因集，可以根据背景知识自定义，这里提供的基因集仅供参考。\nThe article did not provide defined gene sets related to epigenetic\nmodifications. Custom gene sets can be created based on background\nknowledge. The gene sets provided here are for reference only.\n# 这里定义三类表观修饰基因\n# Define three categories of epigenetic modification genes\nm6A_genes <- c(\"METTL3\", \"METTL14\", \"FTO\", \"ALKBH5\",\n           \"YTHDF1\", \"YTHDF2\", \"YTHDF3\", \"IGF2BP1\", \"IGF2BP2\", \"IGF2BP3\") %>% \n  as.data.frame %>% mutate(type = \"m6A_genes\")\nDNAm_genes <- c(\"CTCF\", \"DNMT1\", \"HELLS\", \"UHRF1\", \"UHRF2\", \"USP7\", \"ZNF445\") %>% \n  as.data.frame %>% mutate(type = \"DNAm_genes\")\nHis_genes <- c(\"CARM1\", \"COPRS\", \"NR1H4\", \"PRDM14\", \"PRDM4\",\n               \"PRMT1\", \"PRMT2\", \"PRMT5\", \"PRMT6\", \"PRMT7\", \"PRMT8\") %>% \n  as.data.frame %>% mutate(type = \"His_genes\")\n\n# 合并基因集\n# Merge gene sets\ngenes_df <- rbind(m6A_genes, DNAm_genes, His_genes) %>% set_colnames(c(\"gene\", \"type\"))\n计算CTL\nCalculate CTL score\n根据文中定义，CTL为CD8A、CD8B、GZMA、GZMB和PRF1表达的均值。\nAs defined in the paper, CTL score is calculated as the mean\nexpression of CD8A, CD8B, GZMA, GZMB and PRF1.\n# CD8+ T细胞细胞毒性评分计算\n# CD8+ T Cell Cytotoxicity Score Calculation\nTCGA_SKCM_CD8_h_score <- TCGA_SKCM_TPM %>% \n  select(rownames(TCGA_SKCM_CD8_h)) %>% \n  t %>% as.data.frame %>% \n  mutate(CTL = (CD8A + CD8B + GZMA + GZMB + PRF1)/5) %>% \n  select_if(colnames(.) %in% c(\"CTL\", all_of(genes_df$gene)))\n# 保存到文件\n# Save results to file\nwrite.csv(TCGA_SKCM_CD8_h_score, \"output_CTL.csv\", quote = F)\n计算相关系数以及显著性\nCalculate correlation coefficients and significance\n# 使用spearman方法计算P值\n# Calculate p-values using Spearman method\ncorp_df <- cor_pmat(TCGA_SKCM_CD8_h_score, method = \"spearman\") %>%\n  as.data.frame %>%\n  select(CTL) %>% \n  set_colnames(\"p.val\") %>% \n  filter(rownames(.) != \"CTL\") %>% \n  rownames_to_column(\"gene\") \n\n# 使用spearman方法计算相关系数\n# Calculate correlation coefficients using Spearman method\ncor_df <- cor(TCGA_SKCM_CD8_h_score, method = \"spearman\") %>%\n  as.data.frame %>%\n  select(CTL) %>% \n  filter(rownames(.) != \"CTL\") %>% \n  rownames_to_column(\"gene\") %>% \n  inner_join(genes_df) %>% \n  inner_join(corp_df) %>% \n  \n  # 这一步因为筛选之后基因太少，不好看，故而注释掉了，实际作图时根据需要调整\n  # This filtering step is commented out because too few genes remain after filtering, making the visualization less informative. Adjust as needed for actual plotting.\n  # filter(p.val < 0.01) %>% \n  mutate(group = ifelse(CTL > 0, 1, -1))\n\n# 保存到文件\n# Save results to file\nwrite.csv(cor_df, \"output_cor.csv\")\n开始画图\nPlotting\n# 相关性柱状图绘制\n# Correlation Barplot Visualization\nggplot(cor_df, aes(x = gene, y = CTL, fill = type)) +\n  geom_col() +\n  geom_hline(yintercept = c(-0.25, 0.25), lwd = 1, lty = 2) +\n  scale_y_continuous(breaks = c(-0.25, 0, 0.25), \n                     labels = c(\"-0.25\", \"0\", \"0.25\")) +\n  scale_x_discrete(limits = cor_df %>% arrange(group, type, CTL) %$% gene) +\n  \n  # 设置填充色标尺（三种甲基化类型）\n  # Set fill color scale (three methylation types)\n  scale_fill_manual(labels = c(\"DNA Methylation\", \"Histone Methylation\", \"m6A Methylation\"),\n                    values = c(\"darkgoldenrod3\", \"mediumorchid3\", \"seagreen3\")) +\n  \n  # 坐标轴标签设置\n  # Axis labels settings\n  xlab(NULL) +\n  ylab(\"Correlation coefficient with CTL\") +\n  \n  # 使用prism主题（仿GraphPad风格）\n  # Use prism theme (GraphPad style)\n  theme_prism() +\n  \n  # 自定义主题元素\n  # Custom theme elements\n  theme(panel.border = element_rect(fill=NA, color=\"black\", size=1.5, linetype=\"solid\"),\n        axis.line = element_line(size = 0),\n        axis.ticks.x = element_blank(),\n        axis.text.x = element_blank(), \n        legend.position = c(0.02, 0.95), legend.justification = c(0, 1),\n        legend.text = element_text(size = 12)) -> p\np\n# 以下代码可用于在图中添加文字，也可以忽略代码，手动添加\n# 写pvalue，根据自己的数据调整位置\n# Optional gene labeling (can also add manually in Illustrator)\n# Add p-value annotation (adjust position as needed)\np + annotate(\"text\", x = 20, y = -0.3, \n           label = \"p < 0.01\", size = 5) + \n  geom_text(data = subset(cor_df, gene == \"USP7\"),\n            aes(gene, CTL - 0.02,label = \"USP7\")) + \n  geom_text(data = subset(cor_df, gene == \"COPRS\"),\n            aes(gene, CTL - 0.02,label = \"COPRS\")) +\n  geom_text(data = subset(cor_df, gene == \"YTHDF2\"),\n            aes(gene, CTL - 0.02,label = \"YTHDF2\")) +\n  geom_text(data = subset(cor_df, gene == \"IGF2BP1\"),\n            aes(gene, CTL + 0.02,label = \"IGF2BP1\"))\n# 保存为PDF\n# Save as PDF\nggsave(\"epiImmune.pdf\", width = 6, height = 4)\n后期处理\nPost-processing\n输出的PDF文件是矢量图，可以用Illustrator等矢量图编辑器打开，把图中文字改为斜体，调整左右两侧基因名的位置。或者干脆手动添加想要显示的基因名。\nThe output PDF file is a vector graphic, which can be opened in\nvector editing software like Illustrator. You can modify the text in the\nfigure to italics and adjust the positions of gene names on both sides.\nAlternatively, you can manually add the desired gene names.\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa264epiImmune_FigureYa264epiImmune",
      "title": "FigureYa264epiImmune/FigureYa264epiImmune.html",
      "html": "FigureYa264epiImmune/FigureYa264epiImmune.html",
      "text": "texts/main_FigureYa264epiImmune_FigureYa264epiImmune.txt",
      "folder": "FigureYa264epiImmune",
      "thumb": "gallery_compress/FigureYa264epiImmune.webp"
    },
    "word_count": 1302,
    "lines_count": 284,
    "title": "FigureYa264epiImmune",
    "description": "Demand description 我想实现这篇文章的Figure 1A。 此图的内容：在117例CD8+T细胞高浸润的TCGA黑色素瘤样本中，表观遗传调节因子的表达与细胞毒性T淋巴细胞（CTL）评分之间的相关性。注：1.细胞毒性T淋巴细胞（CTL）评分：文献报道（PMID:",
    "input_data_types": [
      "临床数据"
    ],
    "output_types": [
      "散点图"
    ],
    "technical_methods": [],
    "biology_areas": [
      "癌症研究",
      "免疫学"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "values",
      "lwd",
      "width",
      "pvalue",
      "labels",
      "group",
      "limits",
      "method"
    ]
  },
  {
    "id": "main_FigureYa228linkCor_FigureYa228linkCor",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa228linkCor_FigureYa228linkCor.txt",
    "content": "FigureYa228linkCor\nFigureYa228linkCor\nAuthor(s)\n: Xiaofan Lu\nReviewer(s)\n: Ying Ge, Hui Huang\nDate\n: 2025-10-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\nTo cite package “bladder cancer signature” in publications use:\nMariathasan S, Turley SJ, Nickles D, Castiglioni A, Yuen K, Wang Y,\net al. TGFβ attenuates tumour response to PD-L1 blockade by contributing\nto exclusion of T cells. Nature. 2018; 554: 544-8.\nTo cite “immunotherapy predicted pathways signature” in publications\nuse:\nHu J, Yu A, Othmane B, Qiu D, Li H, Li C, Liu P, Ren W, Chen M, Gong\nG, Guo X, Zhang H, Chen J, Zu X. Siglec15 shapes a non-inflamed tumor\nmicroenvironment and predicts the molecular subtype in bladder cancer.\nTheranostics 2021; 11(7):3089-3108.\ndoi:10.7150/thno.53649\n.\nhttps://www.thno.org/v11p3089.htm\n需求描述\n这个图10D可以实现吗？真的很漂亮，蝴蝶图 | Can this Figure 10D be\nimplemented? It’s really beautiful, butterfly plot\nFrom\nhttps://www.thno.org/v11p3089.html\nFigure 6. Roles of Siglec15 in predicting immune phenotypes in the\nXiangYing cohort. (C) Correlations between Siglec15 and the steps of the\ncancer immunity cycle\n. (D) Correlations between\nSiglec15 and the enrichment scores of\nimmunotherapy-predicted\npathways\n.\n图的解析\n用热图展示通路的自相关分析结果；\nC和D两个热图，分别展示两类通路各自的相关分析结果，放在一起方便对比；\n用连线展示Siglec15跟两类通路的各个具体通路之间的相关性，实线代表正相关、虚线代表负相关，用颜色代表P\nvalue；\nPlot Analysis\nUse a heatmap to display the autocorrelation analysis results of the\npathways.\nThe two heatmaps, C and D, respectively show the correlation\nanalysis results of two types of pathways, placed together for easy\ncomparison.\nUse lines to show the correlation between Siglec15 and each specific\npathway of the two types. Solid lines represent positive correlation,\ndashed lines represent negative correlation, and color represents the\nP-value.\n应用场景 | Application Scenario\n展示相关性分析结果，多对多（C热图、D热图）、1对多（Siglec15跟C的连线，Siglec15跟D的连线）、两组对比（C和D画一起）画一起。\n例文是1个基因跟多个通路的相关性，可以替换为1个基因跟多个基因之间、或1个通路跟多个基因之间等等，灵活套用。\n如果只有一组，就是单独的C或D；如果有两组，就像例文一样拼成蝴蝶；如果有更多组，同样套用easy_input*文件，画出多个图后，按自己的审美组合。\nDisplay correlation analysis results, many-to-many (C heatmap, D\nheatmap), one-to-many (Siglec15 connections with C, Siglec15 connections\nwith D), two-group comparison (C and D plotted together).\nThe example shows correlations between 1 gene and multiple pathways,\nwhich can be replaced with correlations between 1 gene and multiple\ngenes, or 1 pathway and multiple genes, etc., for flexible\napplication.\nIf there is only one group, it’s a separate C or D; if there are two\ngroups, combine them like a butterfly as in the example; if there are\nmore groups, apply the same easy_input* files, create multiple plots,\nand combine them according to your aesthetic preferences.\n环境设置 | Environment Setup\nsource(\"install_dependencies.R\") # 如果没有安装相关包，先运行这行代码安装依赖包 | If you haven't installed the required packages, run this line to install dependencies\nlibrary(data.table) # 读取大数据集 | for reading large datasets\nlibrary(GSVA) # 计算通路富集得分 | for calculating pathway enrichment scores\nlibrary(ggplot2) # 画图 | for plotting\nlibrary(ggcor) # 相关性图 | for correlation plots by Yuhui Li\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息\noptions(stringsAsFactors = FALSE) #禁止chr转成factor\n自定义函数（来自cogena），用于提取msigdb特定通路的基因，参考FigureYa151pathifier\nCustom function (from cogena) for extracting genes of specific\npathways from msigdb, reference FigureYa151pathifier\n# 读取gmt文件为列表形式，满足pathifier的输入要求\n# Read gmt file as list format to meet pathifier input requirements\n\ngmt2list <- function(annofile){\n  if (!file.exists(annofile)) {\n    stop(\"There is no such gmt file.\")\n  }\n  \n  if (tools::file_ext(annofile) == \"xz\") {\n    annofile <- xzfile(annofile)\n    x <- scan(annofile, what=\"\", sep=\"\\n\", quiet=TRUE)\n    close(annofile)\n  } else if (tools::file_ext(annofile) == \"gmt\") {\n    x <- scan(annofile, what=\"\", sep=\"\\n\", quiet=TRUE)\n  } else {\n    stop (\"Only gmt and gmt.xz are accepted for gmt2list\")\n  }\n  \n  y <- strsplit(x, \"\\t\")\n  names(y) <- sapply(y, `[[`, 1)\n  \n  annoList <- lapply(y, `[`, c(-1,-2))\n  return(annoList)\n}\n输入文件的获得 | Obtaining Input Files\n如果你的数据已经整理为\neasy_input_*.txt\n的格式，就可以直接进入“开始画图”。\n下面用基因表达矩阵和通路-基因信息，计算各通路的富集得分（可以理解为通路的表达矩阵）。\ntcga_blca_fpkm.txt，基因表达矩阵。\n通路的基因信息，例文根据文献整理了两类通路，其他通路套用这样的格式即可：\nbladder cancer\nsignature.txt，膀胱癌相关签名，每行一个通路，第一列为通路名（Signature），第二列为基因（Genes）。用于绘制(C)\nCorrelations between Siglec15 and the steps of the cancer immunity\ncycle。出自例文的Table S9.xlsx，Bladder cancer\nsignatures，取Signature和Genes两列。是例文作者从这篇文章整理出来的：Mariathasan\nS, Turley SJ, Nickles D, Castiglioni A, Yuen K, Wang Y, et al. TGFβ\nattenuates tumour response to PD-L1 blockade by contributing to\nexclusion of T cells. Nature. 2018; 554: 544-8.\nimmunotherapy predicted pathways.txt，治疗签名，用于绘制(D)\nCorrelations between Siglec15 and the enrichment scores of\nimmunotherapy-predicted pathways。整理自例文的Table S9.xlsx，Therapeutic\npredicted\npathways，选取Description一列为Anticancer_immunotherapy的Pathway及其对应的Genes。可以直接拿来用到自己的文章里，记得引用例文哦～～\nIf your data is already formatted as easy_input_*.txt, you can\ndirectly proceed to “Start Plotting”.\nBelow, using gene expression matrix and pathway-gene information,\ncalculate the enrichment scores for each pathway (can be understood as\npathway expression matrix).\ntcga_blca_fpkm.txt\n: Gene expression matrix.\nPathway gene information: The example paper organized two types of\npathways based on literature, other pathways can follow this format:\nbladder cancer signature.txt\n: bladder cancer-related\nsignatures, with one pathway per row, first column as pathway name\n(Signature), second column as genes (Genes). Used for plotting (C)\nCorrelations between Siglec15 and the steps of the cancer immunity\ncycle. Derived from Table S9.xlsx of the example paper, Bladder cancer\nsignatures, taking Signature and Genes columns. Organized by the example\npaper authors from this article: Mariathasan S, Turley SJ, Nickles D,\nCastiglioni A, Yuen K, Wang Y, et al. TGFβ attenuates tumour response to\nPD-L1 blockade by contributing to exclusion of T cells. Nature. 2018;\n554: 544-8.\nimmunotherapy predicted pathways.txt\n: therapeutic\nsignatures, used for plotting (D) Correlations between Siglec15 and the\nenrichment scores of immunotherapy-predicted pathways. Organized from\nTable S9.xlsx of the example paper, Therapeutic predicted pathways,\nselecting Pathways with Description as Anticancer_immunotherapy and\ntheir corresponding Genes. Can be directly used in your own article,\nremember to cite the example paper\n“A set of\ngene signatures positively correlated with the\nclinical response of an anti-PD-L1 agent (atezolizumab) in BLCA\nwere collected from Mariathasan’s study [27]. Twelve bladder cancer\nsignatures that are specific to different molecular subtypes were\ncollected from the study performed by the Bladder Cancer Molecular\nTaxonomy Group [19]. We also collected other\ntherapeutic\nsignatures\n, including oncogenic pathways that could shape a\nnon-inflamed TME, targeted therapy-associated gene signatures, and gene\nsignatures predicting radiotherapy responses (Table S9).”\n# load TCGA-BLCA FPKM\nexpr <- read.table(\"tcga_blca_fpkm.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\ntumsam <- colnames(expr)[substr(colnames(expr),11,13) == \"01A\"] # 取出肿瘤样本\n# load immunotherapy-predicted pathways\nimmPath <- read.table(\"immunotherapy predicted pathways.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\nimmPath.list <- list()\nfor (i in rownames(immPath)) {\n  tmp <- immPath[i,\"Genes\"]\n  tmp <- toupper(unlist(strsplit(tmp,\", \",fixed = T)))\n  tmp <- gsub(\" \",\"\",tmp)\n  immPath.list[[i]] <- tmp\n}\n\n# load bladder cancer related signatures\nblcaPath <- read.table(\"bladder cancer signature.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\nblcaPath.list <- list()\nfor (i in rownames(blcaPath)) {\n  tmp <- blcaPath[i,\"Genes\"]\n  tmp <- toupper(unlist(strsplit(tmp,\", \",fixed = T)))\n  tmp <- gsub(\" \",\"\",tmp)\n  blcaPath.list[[i]] <- tmp\n}\n计算富集得分，保存到文件，便于套用\nCalculate enrichment scores, save to files for easy reuse\n# 计算immunotherapy-predicted pathways的富集得分\n# Calculate enrichment scores for immunotherapy-predicted pathways\nimmPath.param <- GSVA::ssgseaParam(\n  as.matrix(log2(expr[,tumsam] + 1)),\n  immPath.list\n)\nimmPath.score <- GSVA::gsva(immPath.param, verbose = FALSE)\n# 保存到文件，便于套用 | Save to file for easy reuse\nwrite.table(immPath.score, \"easy_input_immPath.txt\", sep = \"\\t\", row.names = TRUE, col.names = NA, quote = FALSE)\n\n# 计算膀胱癌相关签名的富集得分\n# Calculate enrichment scores for bladder cancer related signatures\nblcaPath.param <- GSVA::ssgseaParam(\n  as.matrix(log2(expr[,tumsam] + 1)),\n  blcaPath.list\n)\nblcaPath.score <- GSVA::gsva(blcaPath.param, verbose = FALSE)\n# 保存到文件，便于套用 | Save to file for easy reuse\nwrite.table(blcaPath.score, \"easy_input_blcaPath.txt\", sep = \"\\t\", row.names = TRUE, col.names = NA, quote = FALSE)\n对于自己的数据，你可能想提取自己感兴趣的通路计算通路的富集得分。可以从\nmsigdb\n下载gmt文件\nc5.all.v7.4.symbols.gmt\n，提取自己感兴趣的通路及其对应的基因，计算富集得分。\nFor your own data, you may want to extract pathways of interest and\ncalculate their enrichment scores. You can download the gmt file\nc5.all.v7.4.symbols.gmt from msigdb, extract pathways of interest and\ntheir corresponding genes, and calculate enrichment scores.\n# 从gmt文件提取感兴趣的通路 | Extract pathways of interest from gmt file\n# 例如提取带有`METABOLISM`字样的通路 | For example, extract pathways containing `METABOLISM`\ngset <- gmt2list(\"c5.all.v7.4.symbols.gmt\") \n\n# 使用data.table的%like%操作符提取包含METABOLISM的通路\n# Use data.table's %like% operator to extract pathways containing METABOLISM\ngset.list <- gset[names(gset) %like% \"METABOLISM\"]\n\n# 检查基因集是否为空 ｜ Check if gene set is empty\nif (length(gset.list) == 0) {\n  stop(\"No pathways found containing 'METABOLISM'. Please check your gmt file and filter criteria.\")\n}\n\ncat(\"Found\", length(gset.list), \"pathways containing 'METABOLISM'\\n\")\n\n# 计算通路富集得分 | Calculate pathway enrichment scores\ngset.score <- GSVA::gsva(\n  expr = as.matrix(log2(expr[, tumsam] + 1)),\n  gset.idx.list = gset.list,\n  method = \"ssgsea\",\n  verbose = FALSE,  # 减少输出信息 ｜ Reduce output information\n  parallel.sz = 1   # 单线程运行，避免并行问题 ｜ Run single-threaded to avoid parallel issues\n)\n\n# 保存到文件 | Save to file\nwrite.table(gset.score, \"easy_input_gset.txt\", sep = \"\\t\", row.names = TRUE, col.names = NA, quote = FALSE)\n\ncat(\"Pathway enrichment scores saved to 'easy_input_gset.txt'\\n\")\n开始画图 ｜ Start Plotting\n关于 -log10(p-value) 的使用说明 | About -log10(p-value)\nUsage\n本图使用 -log10(p-value)\n来可视化显著性水平，这是生物信息学中的标准做法。数值越大表示显著性越强：\n连线颜色基于 -log10(p-value) 进行编码\n图例中同时显示 p-value 范围和对应的 -log10(p-value) 范围\n参考：\nhttps://mp.weixin.qq.com/s/dyaeBr8tnJhxN-fuYjE-hQ\nThis plot uses -log10(p-value) to visualize significance levels,\nwhich is a standard practice in bioinformatics. Higher values indicate\nstronger significance:\nLine colors are encoded based on -log10(p-value)\nThe legend displays both p-value ranges and corresponding\n-log10(p-value) ranges\nReference:\nhttps://mp.weixin.qq.com/s/dyaeBr8tnJhxN-fuYjE-hQ\n# 加载单个基因的表达量，也就是\"1对多\"的\"1\"\n# Load expression of a single gene, which is the \"1\" in \"1-to-many\"\nsiglec15 <- read.csv(\"easy_input_gene.csv\", row.names = 1, check.names = F)\n\n# 加载第一组富集得分 | Load first set of enrichment scores\nimmPath.score <- read.table(\"easy_input_immPath.txt\", check.names = F)\n# 跟目标基因SIGLEC15的表达量合并 | Merge with target gene SIGLEC15 expression\nimmPath.score <- rbind.data.frame(immPath.score,\n                                  siglec15)\n\n# 加载第二组富集得分 | Load second set of enrichment scores\nblcaPath.score <- read.table(\"easy_input_blcaPath.txt\", check.names = F)\n# 跟目标基因SIGLEC15的表达量合并 | Merge with target gene SIGLEC15 expression\nblcaPath.score <- rbind.data.frame(blcaPath.score,\n                                   siglec15)\n循环计算相关性并画图 | Loop to calculate correlations and plot\n# 循环计算相关性并绘制左下角｜Loop to calculate correlations and plot bottom left\nimmCorSiglec15 <- NULL\nfor (i in rownames(immPath.score)) {\n  # 确保数据是数值型 ｜ Ensure data is numeric\n  x_data <- as.numeric(immPath.score[i,])\n  y_data <- as.numeric(siglec15)\n\n  cr <- cor.test(x_data, y_data, method = \"pearson\")\n  immCorSiglec15 <- rbind.data.frame(immCorSiglec15,\n                                     data.frame(gene = \"Siglec15\",\n                                                path = i,\n                                                r = cr$estimate,\n                                                p = cr$p.value,\n                                                stringsAsFactors = F),\n                                     stringsAsFactors = F)\n}\nimmCorSiglec15$sign <- ifelse(immCorSiglec15$r > 0,\"pos\",\"neg\")\nimmCorSiglec15$absR <- abs(immCorSiglec15$r)\nimmCorSiglec15$rSeg <- as.character(cut(immCorSiglec15$absR,c(0,0.25,0.5,0.75,1),labels = c(\"0.25\",\"0.50\",\"0.75\",\"1.00\"),include.lowest = T))\nimmCorSiglec15$pSeg <- as.character(cut(-log10(immCorSiglec15$p),c(0,2,5,10,Inf),labels = c(\"ns (p≥0.01)\",\"<0.01 (2≤-log10p<5)\",\"<0.001 (5≤-log10p<10)\",\"<1e-10 (-log10p≥10)\"),include.lowest = T))\nimmCorSiglec15[nrow(immCorSiglec15),\"pSeg\"] <- \"Not Applicable\"\n\nimmCorSiglec15$rSeg <- factor(immCorSiglec15$rSeg, levels = c(\"0.25\",\"0.50\",\"0.75\",\"1.00\"))\nimmCorSiglec15$pSeg <- factor(immCorSiglec15$pSeg, levels = c(\"<1e-10 (-log10p≥10)\",\"<0.001 (5≤-log10p<10)\",\"<0.01 (2≤-log10p<5)\",\"Not Applicable\",\"ns (p≥0.01)\"))\nimmCorSiglec15$sign <- factor(immCorSiglec15$sign, levels = c(\"pos\",\"neg\"))\n\np1 <- quickcor(t(immPath.score), \n         type = \"lower\",\n         show.diag = TRUE) + \n  geom_colour() +\n  add_link(df = immCorSiglec15, \n           mapping = aes(colour = pSeg, size = rSeg, linetype = sign),\n           spec.key = \"gene\",\n           env.key = \"path\",\n           diag.label = FALSE) +\n  scale_size_manual(values = c(0.5, 1, 1.5, 2)) +\n  scale_color_manual(values = c(\"#19A078\",\"#DA6003\",\"#7570B4\",\"#E8288E\",\"#65A818\")) +\n  scale_fill_gradient2(low = \"#9483E1\",mid = \"white\",high = \"#E11953\",midpoint=0) +\n  remove_axis(\"x\")\np1\nggsave(filename = \"ggcor plot in bottom left.pdf\", width = 10,height = 8)\n# 循环计算相关性并绘制右上角｜Loop to calculate correlations and plot top right\nblcaCorSiglec15 <- NULL\nfor (i in rownames(blcaPath.score)) {\n  # 确保数据是数值型｜Ensure data is numeric\n  x_data <- as.numeric(blcaPath.score[i,])\n  y_data <- as.numeric(siglec15)\n  \n  cr <- cor.test(x_data, y_data, method = \"pearson\")\n  blcaCorSiglec15 <- rbind.data.frame(blcaCorSiglec15,\n                                     data.frame(gene = \"Siglec15\",\n                                                path = i,\n                                                r = cr$estimate,\n                                                p = cr$p.value,\n                                                stringsAsFactors = F),\n                                     stringsAsFactors = F)\n}\nblcaCorSiglec15$sign <- ifelse(blcaCorSiglec15$r > 0,\"pos\",\"neg\")\nblcaCorSiglec15$absR <- abs(blcaCorSiglec15$r)\nblcaCorSiglec15$rSeg <- as.character(cut(blcaCorSiglec15$absR,c(0,0.25,0.5,0.75,1),labels = c(\"0.25\",\"0.50\",\"0.75\",\"1.00\"),include.lowest = T))\nblcaCorSiglec15$pSeg <- as.character(cut(-log10(blcaCorSiglec15$p),c(0,2,5,10,Inf),labels = c(\"ns (p≥0.01)\",\"<0.01 (2≤-log10p<5)\",\"<0.001 (5≤-log10p<10)\",\"<1e-10 (-log10p≥10)\"),include.lowest = T))\nblcaCorSiglec15[nrow(blcaCorSiglec15),\"pSeg\"] <- \"Not Applicable\"\n\nblcaCorSiglec15$rSeg <- factor(blcaCorSiglec15$rSeg, levels = c(\"0.25\",\"0.50\",\"0.75\",\"1.00\"))\nblcaCorSiglec15$pSeg <- factor(blcaCorSiglec15$pSeg, levels = c(\"<1e-10 (-log10p≥10)\",\"<0.001 (5≤-log10p<10)\",\"<0.01 (2≤-log10p<5)\",\"Not Applicable\",\"ns (p≥0.01)\"))\nblcaCorSiglec15$sign <- factor(blcaCorSiglec15$sign, levels = c(\"pos\",\"neg\"))\n\np2 <- quickcor(t(blcaPath.score), \n         type = \"upper\",\n         show.diag = TRUE) + \n  geom_colour() +\n  add_link(df = blcaCorSiglec15, \n           mapping = aes(colour = pSeg, size = rSeg, linetype = sign),\n           spec.key = \"gene\",\n           env.key = \"path\",\n           diag.label = FALSE) +\n  scale_size_manual(values = c(0.5, 1, 1.5, 2)) +\n  scale_color_manual(values = c(\"#19A078\",\"#DA6003\",\"#7570B4\",\"#E8288E\",\"#65A818\")) +\n  scale_fill_gradient2(low = \"#9483E1\",mid = \"white\",high = \"#E11953\",midpoint=0) +\n  remove_axis(\"x\")\np2\nggsave(filename = \"ggcor plot in top right.pdf\", width = 10,height = 8)\n后期处理 ｜ Post-processing\n输出的PDF文件是矢量图，可以用矢量图编辑器打开，编辑文字和图形。\nThe output PDF files are vector graphics that can be opened with\nvector graphic editors to edit text and graphics.\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa228linkCor_FigureYa228linkCor",
      "title": "FigureYa228linkCor/FigureYa228linkCor.html",
      "html": "FigureYa228linkCor/FigureYa228linkCor.html",
      "text": "texts/main_FigureYa228linkCor_FigureYa228linkCor.txt",
      "folder": "FigureYa228linkCor",
      "thumb": "gallery_compress/FigureYa228linkCor.webp"
    },
    "word_count": 1857,
    "lines_count": 367,
    "title": "FigureYa228linkCor",
    "description": "这个图10D可以实现吗？真的很漂亮，蝴蝶图 | Can this Figure 10D be implemented? It’s really beautiful, butterfly plot From",
    "input_data_types": [
      "临床数据",
      "表达矩阵"
    ],
    "output_types": [
      "散点图",
      "热图",
      "统计表格"
    ],
    "technical_methods": [
      "通路分析"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "gene",
      "colour",
      "key",
      "values",
      "header",
      "width",
      "df",
      "labels"
    ]
  },
  {
    "id": "main_FigureYa284pairwiseLogrank_FigureYa284pairwiseLogrank",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa284pairwiseLogrank_FigureYa284pairwiseLogrank.txt",
    "content": "FigureYa284pairwiseLogrank\nFigureYa284pairwiseLogrank\nAuthor(s)\n: Xiaofan Lu; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirements Description\n希望画出文章里面Figure2的a。\nWe hope to draw a in Figure2 of the article.\n出自\nhttps://www.nature.com/articles/s41586-019-1906-8\n图2 | SICs和B细胞对STS患者生存期的预测价值\nb，多变量Cox比例风险回归分析结果，展示所有纳入分析的变量。各变量的参照水平均为首个分组。灰色条形表示P>0.05；绿色和红色条形分别表示该变量在多变量模型中与预后呈显著正相关和负相关。误差线代表95%置信区间。FNCLCC为法国国家抗癌中心联盟的缩写。\nSource:\nhttps://www.nature.com/articles/s41586-019-1906-8\nFig. 2 | SICs and B cells are predictive of the survival of patients\nwith STS. b, Multivariate Cox proportional regression outcome, with all\nincluded variables represented. For each variable, the reference level\nis the first one. A grey bar indicates P > 0.05; and variables\nindicated by green and red bars are positively and negatively,\nrespectively, significantly associated with prognosis in this\nmultivariate model. Error bars represent the 95% confidence interval.\nFNCLCC, Fédération Nationale des Centres de Lutte Contrele Cancer.\n应用场景\nApplication Scenario\n对3组及以上的亚组进行生存分析，并打印配对比较的统计表格。\n参考：MOVICS包中compSurv()函数：\nhttps://github.com/xlucpu/MOVICS/blob/master/R/compSurv.R\nSurvival analysis for 3+ subgroups with pairwise comparison\nstatistics table.\nReference: compSurv() function from MOVICS package\nhttps://github.com/xlucpu/MOVICS/blob/master/R/compSurv.R\n环境设置\nEnvironment Setup\nUsing domestic mirrors for package installation.\nsource(\"install_dependencies.R\")\n加载包\nLoading packages\nlibrary(survival)\nlibrary(survminer)\nlibrary(RColorBrewer)\nlibrary(tibble)\nlibrary(ggpp)\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\")\n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n输入文件\nInput Files\neasy_input.csv，生存和分组信息，这里是乳腺癌数据。\neasy_input.csv containing survival and grouping information (breast\ncancer data).\n# 加载示例数据\n# Load example data\ndat <- read.table(\"easy_input.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\n生存分析\nSurvival Analysis\n# 仿照原文将PAM50分型按照ABCDE标记\n# Label PAM50 subtypes as A-E following the paper\ndat$group <- sapply(dat$PAM50,function(x) {\n  switch(x, \n         \"Basal\"  = \"A\", \n         \"Her2\"   = \"B\", \n         \"LumA\"   = \"C\", \n         \"LumB\"   = \"D\", \n         \"Normal\" = \"E\")}) \n\n# 将生存时间转换为月份\n# Convert survival time to months\ndat$OS.time <- dat$OS.time * 12 \n\n# 生存分析\n# Survival analysis\nfitd <- survdiff(Surv(OS.time, OS) ~ group,\n                 data      = dat,\n                 na.action = na.exclude)\np.val <- 1 - pchisq(fitd$chisq, length(fitd$n) - 1)\n\n# 拟合生存曲线\n# Fit survival curves\nfit <- survfit(Surv(OS.time, OS)~ group,\n               data      = dat,\n               type      = \"kaplan-meier\",\n               error     = \"greenwood\",\n               conf.type = \"plain\",\n               na.action = na.exclude)\n\n# 配对生存分析\n# Pairwise survival analysis\nps <- pairwise_survdiff(Surv(OS.time, OS)~ group,\n                        data            = dat,\n                        p.adjust.method = \"none\")\n开始画图\nStart Plotting\n# 设置颜色\n# Set colors\nmycol <- brewer.pal(n = 10, \"Paired\")[c(2,4,6,8,10)]\n\n# 绘制基础图形\n# Draw the basic graphics\n\n## 隐藏类标记\n## Remove \"group=\" prefix\nnames(fit$strata) <- gsub(\"group=\", \"\", names(fit$strata))\n\n## 生存曲线图\n## Survival curve plot\np <- ggsurvplot(fit               = fit,\n                # 不绘制置信区间 \n                # No confidence intervals\n                conf.int          = FALSE, \n                # 生存风险表 \n                #Show risk table\n                risk.table        = TRUE, \n                risk.table.col    = \"strata\",\n                # KM曲线颜色\n                # KM curve colors\n                palette           = mycol, \n                data              = dat,\n                # 时间轴，一般考虑5年（原文）或者10年长度\n                # Time axis (5-10 year range)\n                xlim              = c(0,120), \n                size              = 1,\n                # 时间轴的刻度（每年）\n                # Tick marks (annual)\n                break.time.by     = 12, \n                legend.title      = \"\",\n                xlab              = \"Time (months)\",\n                ylab              = \"Overall survival\",\n                risk.table.y.text = FALSE,\n                # 风险表的高度\n                # Risk table height\n                tables.height     = 0.3)\np\n# 输出图像\n# Save plot\npdf.options(reset = TRUE, onefile = FALSE)\npdf(\"km curve with pairwise logrank test.pdf\", width = 4.5, height = 6)\nprint(p)\ndev.off()\n会话信息\nSession Info\n# 显示会话信息\n# Show session information\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa284pairwiseLogrank_FigureYa284pairwiseLogrank",
      "title": "FigureYa284pairwiseLogrank/FigureYa284pairwiseLogrank.html",
      "html": "FigureYa284pairwiseLogrank/FigureYa284pairwiseLogrank.html",
      "text": "texts/main_FigureYa284pairwiseLogrank_FigureYa284pairwiseLogrank.txt",
      "folder": "FigureYa284pairwiseLogrank",
      "thumb": "gallery_compress/FigureYa284pairwiseLogrank.webp"
    },
    "word_count": 522,
    "lines_count": 158,
    "title": "FigureYa284pairwiseLogrank",
    "description": "Requirements Description 希望画出文章里面Figure2的a。 We hope to draw a in Figure2 of the article.",
    "input_data_types": [
      "生存数据"
    ],
    "output_types": [
      "统计表格",
      "生存曲线"
    ],
    "technical_methods": [
      "生存分析"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "header",
      "width",
      "n",
      "xlim",
      "fit",
      "onefile",
      "int",
      "col",
      "method"
    ]
  },
  {
    "id": "main_FigureYa33DCA_update_FigureYa33DCA_update",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa33DCA_update_FigureYa33DCA_update.txt",
    "content": "FigureYa33DCA_update\nFigureYa33DCA_update\nAuthor(s)\n: Dongqiang Zeng; Ying Ge, Yijing\nChen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n画出paper里的DCA曲线\nDraw the DCA curve from the paper\n出自\nhttps://www.europeanurology.com/article/S0302-2838(17)30267-1/fulltext\nfrom\nhttps://www.europeanurology.com/article/S0302-2838(17)30267-1/fulltext\n应用场景\nApplication scenario\n生存数据因为带了时间和事件发生的混合因素，适合用\nstdca.R\n这个function，是MSKCC的统计学专家写的。\n队列研究里，像例文的B图那样，有opt-in\n和opt-out两种选择，来帮助确定高风险的患者进行干预、低风险的患者避免过度医疗。这个图的最终目的就是为了展示这个价值。\nSurvival data, which involves the combination of time and event\noccurrence factors, is suitable for using the\nstdca.R\nfunction, written by statistical experts at MSKCC.\nIn cohort studies, like the B-figure in the example, there are both\nopt-in and opt-out choices to help identify high-risk patients for\nintervention and low-risk patients to avoid overmedication. The ultimate\npurpose of this graph is to demonstrate this value.\n环境设置\nEnvironment setting\nuse the domestic mirror installation package\nsource(\"install_dependencies.R\")\ninstall.packages(\"magick\")\ninstall.packages(\"cmprsk\")\nload package\nlibrary(survival)\nlibrary(ggplotify)\nlibrary(magick)\nlibrary(cowplot)\n\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 display English error messages\noptions(stringsAsFactors = FALSE) #禁止chr转成factor prohibit the conversion of chr to factor\n加载自定义函数\nstdca.R\n文件里的画图函数来自：\nhttps://github.com/matt-black/dcapy/blob/master/test/resource/stdca.R\n关于该函数的用法，查看本压缩包中的\nR stdca Help File.pdf\n为了画出更美观的图，修改了\nstdca.R\n文件的图例位置、线型和线的颜色\n在修改的代码前后用\n#Ya#汉字\n的形式标记，搜索’#Ya#’就能找到修改的地方。\nLoad custom functions\nThe drawing function in the\nstdca.R\nfile is from:\nhttps://github.com/matt-black/dcapy/blob/master/test/resource/stdca.R\nFor the usage of this function, see\nR stdca Help File.pdf\nin this zip file.\nChanged the legend position, line type, and line color in the\nstdca.R\nfile for a better looking diagram.\nUse\n#Ya#Chinese character\nto mark the modified code\nbefore and after the modifications, search for ‘#Ya#’ to find the\nmodifications.\nsource(\"stdca.R\") #stdca.R文件位于当前文件夹 stdca.R file is located in the current folder\n输入文件\nInput file\neasy_input.txt，跟\nFigureYa30nomogram\n里的easy_input.txt是同一个文件，来自\nsurvival\n包。\neasy_input.txt, the same file as easy_input.txt in\nFigureYa30nomogram\n, from the\nsurvival\npackage.\npbc <- read.table(\"easy_input.txt\")\npbc <- pbc[complete.cases(pbc),] #删掉缺失数据 delete missing data\n#先把bili分为三类：低、中、高\n#first, categorize bili into three groups: low, medium, and high\npbc$catbili <- cut(pbc$bili,breaks=c(-Inf, 2, 4, Inf),\n                   labels=c(\"low\",\"medium\",\"high\"))\n\n#把status分为两类，原来的2为变成1，原来的1和0变成0\n#split status into two categories, the original 2 to become 1, the original 1 and 0 to become 0\npbc$died <- pbc$status==2\npbc$status <- ifelse(pbc$died==\"TRUE\",1,0)\n\nhead(pbc)\n模仿\neasy_input.txt\n，修改你手里数据的格式。\nMimic\neasy_input.txt\nand modify the format of the data\nyou have in hand.\n利用系数重新预测模型\nRepredict the model using the coefficients\nSrv = Surv(pbc$time, pbc$died)\n\n#此处选择5年的时间节点，输入文件的time列的单位是天，5年是1825天。\n#下面每两行计算1种cox模型的系数，后面将画图对比\n#这里模型的名字写为model1、model2，相应的图中也会显示这个名字。\n#实际使用时，修改为你最终要呈现到图中的名字\n#Here choose a 5 year timestep, the time column of the input file is in days, 5 years is 1825 days.\n#Below, every two lines calculate the coefficients of one type of Cox model, followed by a comparison through plotting.\n#Here the name of the model is written as model1, model2, and the corresponding graph will show this name.\n#When you use them in practice, change them to the names you want to show in the graph.\ncoxmod1 = coxph(Srv ~ trt + age + sex + hepato + catbili + copper + stage, data=pbc)\npbc$model1 = c(1 - (summary(survfit(coxmod1, newdata=pbc), times=1825)$surv))\n\ncoxmod2 = coxph(Srv ~ ascites + spiders + edema + chol + albumin + alk.phos + ast + trig + platelet + protime, data=pbc)\npbc$model2 = c(1 - (summary(survfit(coxmod2,newdata=pbc), times=1825)$surv))\n\ncoxmod3 = coxph(Srv ~ trt + age + sex + hepato + catbili + copper + stage + ascites + spiders + edema + chol + albumin + alk.phos + ast + trig + platelet + protime, data=pbc)\npbc$model3 = c(1 - (summary(survfit(coxmod3,newdata=pbc), times=1825)$surv))\n\ncoxmod4 = coxph(Srv ~ stage, data=pbc)\npbc$model4 = c(1 - (summary(survfit(coxmod4,newdata=pbc), times=1825)$surv))\n\nhead(pbc)\n开始画图\nStart drawing\n画Net benefit\nDraw Net benefit\n画一条\nDraw one\nmod1 <- stdca(data=pbc, outcome=\"status\", ttoutcome=\"time\", timepoint=1825, \n                 predictors=\"model1\", # 跟上一步模型的名字一致 same name as the model in the previous step\n              cmprsk=TRUE, smooth=TRUE, xstop=0.5,intervention=\"FALSE\")\n#mod2 <- stdca(data=pbc, outcome=\"status\", ttoutcome=\"time\", timepoint=1825, \n#             predictors=\"model2\", cmprsk=TRUE, smooth=TRUE, xstop=0.5,intervention=\"FALSE\")\n\n#mod3 <- stdca(data=pbc, outcome=\"status\", ttoutcome=\"time\", timepoint=1825, \n#             predictors=\"model3\", cmprsk=TRUE, smooth=TRUE, xstop=0.5,intervention=\"FALSE\")\n\n#mod4 <- stdca(data=pbc, outcome=\"status\", ttoutcome=\"time\", timepoint=1825, \n#             predictors=\"model4\", cmprsk=TRUE, smooth=TRUE, xstop=0.5,intervention=\"FALSE\")\n多条对比\nMultiple comparisons\npdf(\"net_benefit.pdf\",width = 6,height = 6)\nstdca(data=pbc, outcome=\"status\", ttoutcome=\"time\", timepoint=1825,\n      predictors=c(\"model1\",\"model2\",\"model3\",\"model4\"), # 跟前面模型的名字保持一致 consistent with the name of the previous model\n      cmprsk=TRUE, smooth=TRUE, \n      xstop=0.5,intervention=\"FALSE\")\ndev.off()\n画干预的net reduction\nDraw intervention for net reduction\n画一条\nDraw one\nmod1 <- stdca(data=pbc, outcome=\"status\", ttoutcome=\"time\", timepoint=1825, \n      predictors=\"model1\", cmprsk=TRUE, smooth=TRUE, xstop=0.5,intervention=\"TRUE\")\n#mod2 <- stdca(data=pbc, outcome=\"status\", ttoutcome=\"time\", timepoint=1825, \n#      predictors=\"model2\", cmprsk=TRUE, smooth=TRUE, xstop=0.5,intervention=\"TRUE\")\n\n#mod3 <- stdca(data=pbc, outcome=\"status\", ttoutcome=\"time\", timepoint=1825, \n#      predictors=\"model3\", cmprsk=TRUE, smooth=TRUE, xstop=0.5,intervention=\"TRUE\")\n\n#mod4 <- stdca(data=pbc, outcome=\"status\", ttoutcome=\"time\", timepoint=1825, \n#      predictors=\"model4\", cmprsk=TRUE, smooth=TRUE, xstop=0.5,intervention=\"TRUE\")\n多条对比\nMultiple comparisons\npdf(\"net_reduction.pdf\",width = 6,height = 6)\nstdca(data=pbc, outcome=\"status\", ttoutcome=\"time\", timepoint=1825,\n      predictors=c(\"model1\",\"model2\",\"model3\",\"model4\"), \n      cmprsk=TRUE, smooth=TRUE, \n      xstop=0.5,intervention=\"TRUE\")\ndev.off()\n其他参考资料\nOther references\nDCA很年轻，资料不多，这里提供两个资料，供参考：\n优缺点看这篇：\nhttp://jama.jamanetwork.com/article.aspx?articleID=2091968\n这里还有教程、R和Stata代码：\nhttps://www.mskcc.org/sites/default/files/node/4509/documents/dca-tutorial-2015-2-26.pdf\nDCA is very young and not much information is available, so here are\ntwo sources for reference:\nSee this one for advantages and disadvantages:\nhttp://jama.jamanetwork.com/article.aspx?articleID=2091968\nThere are also tutorials, R and Stata codes here:\nhttps://www.mskcc.org/sites/default/files/node/4509/documents/dca-tutorial-2015-2-26.pdf\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa33DCA_update_FigureYa33DCA_update",
      "title": "FigureYa33DCA_update/FigureYa33DCA_update.html",
      "html": "FigureYa33DCA_update/FigureYa33DCA_update.html",
      "text": "texts/main_FigureYa33DCA_update_FigureYa33DCA_update.txt",
      "folder": "FigureYa33DCA_update",
      "thumb": "gallery_compress/FigureYa33DCA_update.webp"
    },
    "word_count": 771,
    "lines_count": 198,
    "title": "FigureYa33DCA_update",
    "description": "Requirement description 画出paper里的DCA曲线 Draw the DCA curve from the paper",
    "input_data_types": [
      "生存数据"
    ],
    "output_types": [
      "统计表格",
      "网络图",
      "生存曲线"
    ],
    "technical_methods": [
      "网络分析",
      "生存分析"
    ],
    "biology_areas": [],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "times",
      "predictors",
      "width",
      "newdata",
      "xstop",
      "ttoutcome",
      "timepoint",
      "labels",
      "coxmod1"
    ]
  },
  {
    "id": "main_FigureYa86SNPmotif_FigureYa86SNPmotif",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa86SNPmotif_FigureYa86SNPmotif.txt",
    "content": "FigureYa86SNPmotif\nFigureYa86SNPmotif\nYing Ge, Taojun Ye\n2025-5-20\n需求描述\n突变会影响转录因子结合吗？作出判断，并同时画出motif\nlogo和SNP的图。\n#Requirement description\nDoes mutation affect transcription factor binding? Make a judgment\nand draw the motif logo and SNP diagram simultaneously.\n出自\nhttp://cancerres.aacrjournals.org/content/77/7/1649\nfrom\nhttp://cancerres.aacrjournals.org/content/77/7/1649\n应用场景\n在基因组上同时展示突变位点和motif，为突变影响转录因子结合提供量化（pvalue、score）和可视化的证据。\n在“小丫画图”公众号回复“SNP”，查看这个图在更多paper里的应用。\n运行下面这行，查看motifbreakR的官方手册\n#Application scenarios\nSimultaneously displaying mutation sites and motifs on the genome\nprovides quantitative (p-value, score) and visual evidence for the\nimpact of mutations on transcription factor binding.\nReply to “SNP” on the “Xiaoya Painting” official account to check the\napplication of this picture in more papers.\nRun the following line to view the official manual of\nmotionbreakR\n# 打开motifbreakR包的示例文档浏览器（中文注释）\n# Open the vignette browser for the motifbreakR package (English comment)\nbrowseVignettes(\"motifbreakR\")\nmotifbreakR还可以跟其他工具结合使用，一系列结果图作为证据，帮你充实文章。看这篇：\nVariant Annotation\nWorkshop with FunciVAR, StateHub and MotifBreakR\nMotifbreakR can also be used in conjunction with other tools, with a\nseries of result graphs as evidence to help enrich your article. Read\nthis article: [Variant Annotation Workshop with FunciVAR, StateHub, and\nMotifBreakR]（\nhttps://www.simoncoetzee.com/bioc2017.html\n)\n环境设置\n使用国内镜像安装包\n#Environment settings\nUse domestic image installation package\n# 设置R包安装源为清华大学镜像（中文注释）\n# Set R package installation source to Tsinghua University mirror (English comment)\noptions(\"repos\"= c(CRAN=\"https://mirrors.tuna.tsinghua.edu.cn/CRAN/\"))\n\n# 设置Bioconductor包镜像为清华大学镜像（中文注释）\n# Set Bioconductor package mirror to Tsinghua University mirror (English comment)\noptions(BioC_mirror=\"http://mirrors.tuna.tsinghua.edu.cn/bioconductor/\")\n\n# 检查是否安装了BiocManager包，如果没有则安装（中文注释）\n# Check if BiocManager package is installed, install if not (English comment)\nif (!requireNamespace(\"BiocManager\", quietly = TRUE))\n    install.packages(\"BiocManager\")\n\n# 使用BiocManager安装motifbreakR包（中文注释）\n# Install the motifbreakR package using BiocManager (English comment)\nBiocManager::install(\"motifbreakR\")\n\n# 如果你只提供rs ID，就需要安装这个包（中文注释）\n# If you only provide rs IDs, you need to install this package (English comment)\n# SNP locations and alleles for Homo sapiens extracted from NCBI dbSNP Build 151. The source data files used for this package were created by NCBI between February 16-22, 2018, and contain SNPs mapped to reference genome GRCh38.p7\n# 这个版本的SNP文件480M，其他版本更大，建议下载后本地安装，<http://bioconductor.org/packages/3.8/data/annotation/src/contrib/SNPlocs.Hsapiens.dbSNP142.GRCh37_0.99.5.tar.gz>\n# This version of the SNP file is 480M, other versions are even larger. It is recommended to download and install locally. <http://bioconductor.org/packages/3.8/data/annotation/src/contrib/SNPlocs.Hsapiens.dbSNP142.GRCh37_0.99.5.tar.gz>\nBiocManager::install(\"SNPlocs.Hsapiens.dbSNP142.GRCh37\")\n\n# 如果你提供bed或vcf，有下面这个包就够了（中文注释）\n# If you provide bed or vcf files, this package is sufficient (English comment)\n# Full genome sequences for Homo sapiens (Human) as provided by UCSC (hg19, Feb. 2009) and stored in Biostrings objects.\nBiocManager::install(\"BSgenome.Hsapiens.UCSC.hg19\")\n其他物种到\nhttp://www.bioconductor.org/packages/3.8/data/annotation\n查找相应的包的名字。\n你的电脑可能需要安装GhostScript，参考\nhttps://github.com/Simon-Coetzee/motifBreakR\n里的Prepairing\nto install\n加载包\nOther species to<\nhttp://www.bioconductor.org/packages/3.8/data/annotation\n>Search for the name of the corresponding package.\nYour computer may need to install GhostScript, refer to<\nhttps://github.com/Simon-Coetzee/motifBreakR\n>Preparing to install in\nLibrary Package\n# 加载motifbreakR包 - 用于分析SNP对转录因子结合位点的影响（中文注释）\n# Load the motifbreakR package - for analyzing the impact of SNPs on transcription factor binding sites (English comment)\nlibrary(motifbreakR)\n# 加载人类SNP位点信息包（基于GRCh37/hg19基因组和dbSNP142数据库）（中文注释）\n# Load the human SNP locations package (based on GRCh37/hg19 genome and dbSNP142 database) (English comment)\n# 包含约8400万个SNPs的位置、参考等位基因和常见变异等位基因信息（中文注释）\n# Contains location, reference alleles, and common variant alleles for ~84 million SNPs (English comment)\nlibrary(SNPlocs.Hsapiens.dbSNP142.GRCh37)\n# 加载人类基因组序列包（基于UCSC hg19版本）（中文注释）\n# Load the human genome sequence package (based on UCSC hg19 version) (English comment)\nlibrary(BSgenome.Hsapiens.UCSC.hg19)\n\n# 设置环境变量，使R显示英文错误信息（便于查找解决方案）（中文注释）\n# Set environment variable to display R error messages in English (easier for troubleshooting) (English comment)\nSys.setenv(LANGUAGE = \"en\")\n\n# 禁止R自动将字符向量转换为因子类型（中文注释）\n# Prevent R from automatically converting character vectors to factors (English comment)\n# 因子类型在数据分析中可能导致意外结果，通常建议关闭此自动转换（中文注释）\n# Factors can cause unexpected results in data analysis, it's generally recommended to disable this automatic conversion (English comment)\noptions(stringsAsFactors = FALSE)\n输入数据\nmotifbreakR可以用SNP的rs ID，或bed文件，或vcf文件作为输入。\n#Input data\nMotifbreakR can use SNP’s rs ID, bed file, or vcf file as input.\n提供SNP的rs ID\n输入文件可以只提供SNP的rsID，例如rs1006140\n##Provide rs ID for SNP\nThe input file can only provide the rsID of SNP, for example\nrs1006140\n#SNPID <- read.table(\"easy_input_rs.txt\")$V1\n#SNPID\n# 从文件读取SNP ID列表（当前已注释掉，使用下面的单个SNP ID）（中文注释）\n# Read SNP ID list from file (currently commented out, using single SNP ID below) (English comment)\n#SNPID <- read.table(\"easy_input_rs.txt\")$V1\n#SNPID\n\n# 直接指定单个SNP ID进行分析（中文注释）\n# Directly specify a single SNP ID for analysis (English comment)\nSNPID <- \"rs1927914\"\n\n# 从dbSNP数据库中获取指定SNP的详细信息（中文注释）\n# Retrieve detailed information for the specified SNP from dbSNP database (English comment)\n# 参数说明（Parameter explanation）:\n# - rsid: 要查询的SNP ID (The SNP ID to query)\n# - dbSNP: 使用的dbSNP数据库版本 (The version of dbSNP database to use)\n# - search.genome: 参考基因组 (Reference genome)\nSNPinfo <- snps.from.rsid(rsid = SNPID, \n                           dbSNP = SNPlocs.Hsapiens.dbSNP142.GRCh37, \n                           search.genome = BSgenome.Hsapiens.UCSC.hg19)\n\n# 显示获取的SNP信息（中文注释）\n# Display the retrieved SNP information (English comment)\nSNPinfo\n提供突变位点的bed或vcf文件\neasy_input.bed，整理自例文里的Table S1\n##Provide bed or vcf files for mutation sites\neasy_input.bed， Organize Table S1 from the example text\n# 从BED格式文件中批量读取SNP信息（中文注释）\n# Read SNP information in bulk from a BED format file (English comment)\n\n# 参数说明（Parameter explanation）:\n# - file: 输入的BED格式文件路径 (Path to the input BED format file)\n# - search.genome: 参考基因组 (Reference genome)\n# - format: 输入文件格式，支持\"BED\"或\"VCF\" (Input file format, supports \"BED\" or \"VCF\")\n# SNPinfo <- snps.from.file(file = \"easy_input.bed\", # 输入BED格式文件 (Input BED format file)\n#                           search.genome = BSgenome.Hsapiens.UCSC.hg19,\n#                           format = \"bed\") # 也可以选择\"vcf\"格式 (Can also choose \"vcf\" format)\n判断SNP对motif的影响\n#Assessing the impact of SNPs on motif\n# 运行motifbreakR分析SNP对转录因子结合位点的影响（中文注释）\n# Run motifbreakR to analyze the impact of SNPs on transcription factor binding sites (English comment)\n\n# 参数说明（Parameter explanation）:\n# - snpList: 包含SNP信息的对象 (Object containing SNP information)\n# - filterp: 是否过滤p值 (Whether to filter by p-value)\n# - pwmList: 使用的位置权重矩阵库 (Position Weight Matrix library to use)\n# - threshold: 显著性阈值 (Significance threshold)\n# - method: 评分方法 (Scoring method)\n# - bkg: 背景碱基频率 (Background base frequencies)\n# - BPPARAM: 并行计算参数 (Parallel computation parameters)\nhocomoco <- query(MotifDb, \"HOCOMOCO\")\nresults <- motifbreakR(snpList = SNPinfo, filterp = TRUE,\n                       pwmList = hocomoco,\n                       threshold = 1e-4,\n                       method = \"ic\",\n                       bkg = c(A=0.25, C=0.25, G=0.25, T=0.25),\n                       BPPARAM = BiocParallel::bpparam())\n\n# 提取特定SNP(rs1927914)的分析结果（中文注释）\n# Extract analysis results for a specific SNP (rs1927914) (English comment)\nresult1 <- results[names(results) %in% \"rs1927914\"]\n\n# 去除结果中的重复行（中文注释）\n# Remove duplicate rows from the results (English comment)\nresult1 <- unique(result1)\n\n# 计算每个motif预测的p值（中文注释）\n# Calculate p-values for each motif prediction (English comment)\nresult1pval <- calculatePvalue(result1)\n\n# 显示计算得到的p值（中文注释）\n# Display the calculated p-values (English comment)\nresult1pval\n# 计算突变型与野生型结合分数的差异（Altscore-Refscore）（中文注释）\n# Calculate the difference in binding scores between mutant and wild-type (Altscore-Refscore) (English comment)\nresult1pval$score <- result1pval$scoreAlt-result1pval$scoreRef\n\n# 将最终分析结果保存为CSV文件（中文注释）\n# Save the final analysis results to a CSV file (English comment)\n# write.csv(result1pval, \"output.csv\", quote = F)\n开始画图\n#Start drawing\n# 保存结果为PDF文件（当前已注释掉，直接显示图形）（中文注释）\n# Save results as PDF file (currently commented out, displaying graph directly) (English comment)\n#pdf(\"SNPmotif.pdf\")\n#grid.newpage()\n\n# 可视化特定SNP(rs1927914)对motif结合的影响（中文注释）\n# Visualize the impact of a specific SNP (rs1927914) on motif binding (English comment)\n\n# 参数说明（Parameter explanation）:\n# - results: 包含motif分析结果的对象 (Object containing motif analysis results)\n# - rsid: 要可视化的SNP ID (SNP ID to visualize)\n# - effect: 显示的效应强度阈值，\"strong\"显示强效应，\"weak\"显示所有效应 (Threshold for effect strength to display, \"strong\" shows strong effects, \"weak\" shows all effects)\nplotMB(results = result1, rsid = \"rs1927914\", \n       effect = \"strong\") # 也可以选择\"weak\"显示所有预测结果 (Can also choose \"weak\" to show all predictions)\n# 关闭PDF设备（当前已注释掉）（中文注释）\n# Close the PDF device (currently commented out) (English comment)\n#dev.off()\n后期加工\n根据output.csv中的最后一列score，向图中添加每个转录因子的Altscore-Refscore\n#Post processing\nAdd the Altscore Refscore for each transcription factor to the graph\nbased on the last column score in the output. csv\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa86SNPmotif_FigureYa86SNPmotif",
      "title": "FigureYa86SNPmotif/FigureYa86SNPmotif.html",
      "html": "FigureYa86SNPmotif/FigureYa86SNPmotif.html",
      "text": "texts/main_FigureYa86SNPmotif_FigureYa86SNPmotif.txt",
      "folder": "FigureYa86SNPmotif",
      "thumb": "gallery_compress/FigureYa86SNPmotif.webp"
    },
    "word_count": 1103,
    "lines_count": 221,
    "title": "FigureYa86SNPmotif",
    "description": "突变会影响转录因子结合吗？作出判断，并同时画出motif logo和SNP的图。 Does mutation affect transcription factor binding? Make a judgment",
    "input_data_types": [
      "DNA-seq",
      "突变数据"
    ],
    "output_types": [
      "统计表格"
    ],
    "technical_methods": [
      "motif分析"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "dbSNP",
      "bkg",
      "pvalue",
      "snpList",
      "method",
      "BioC_mirror",
      "effect",
      "LANGUAGE",
      "results"
    ]
  },
  {
    "id": "main_FigureYa115cofactor_FigureYa115cofactor",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa115cofactor_FigureYa115cofactor.txt",
    "content": "FigureYa115cofactor\nFigureYa115cofactor\nAuthor(s)\n: Long Zhao, Taojun Ye\nReviewer(s)\n: Ying Ge\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nChIP-seq的correlation，用于找cofactor。\ndeeptools能实现类似的功能，但是它只选其中一个作为标准定为1，然后其他的和这个标准比。我要的是所有样品聚类，看哪一些更相似，没法选定哪个作为标准。我用diffbind做了，可以达到目的，想找到更好的方法。文献里面真不知道是怎么做到的，方法里面完全没有描述。\n用这篇Cell paper\nhttps://www.cell.com/cell/fulltext/S0092-8674(19)30629-4\n的数据画类似这样的相关性热图：\nRequirement description\nChIP seq correlation, used to find cofactors.\nDeeptools can achieve similar functionality, but it only selects one\nas the standard set as 1, and then compares the others with this\nstandard. What I want is to cluster all the samples to see which ones\nare more similar, I can’t choose which one as the standard. I used\ndiffbind to achieve my goal and I want to find a better way. I really\ndon’t know how it was done in the literature, there is no description of\nthe method at all.\nUsing this Cell paper<\nhttps://www.cell.com/cell/fulltext/S0092-8674\n(19) Draw\na correlation heatmap similar to this for the data of 30629-4>:\n出自：\nhttps://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1721-4\nfrom:\nhttps://genomebiology.biomedcentral.com/articles/10.1186/s13059-019-1721-4\n出自：\nhttps://www.cell.com/cell/fulltext/S0092-8674(11)01155-X?_returnURL=https%3A%2F%2Flinkinghub.elsevier.com%2Fretrieve%2Fpii%2FS009286741101155X%3Fshowall%3Dtrue\nfrom:\nhttps://www.cell.com/cell/fulltext/S0092-8674(11)01155-X?_returnURL=https%3A%2F%2Flinkinghub.elsevier.com%2Fretrieve%2Fpii%2FS009286741101155X%3Fshowall%3Dtrue\n出自：\nhttps://www.cell.com/cell/fulltext/S0092-8674(17)30193-9?_returnURL=https%3A%2F%2Flinkinghub.elsevier.com%2Fretrieve%2Fpii%2FS0092867417301939%3Fshowall%3Dtrue\nfrom:\nhttps://www.cell.com/cell/fulltext/S0092-8674(17)30193-9?_returnURL=https%3A%2F%2Flinkinghub.elsevier.com%2Fretrieve%2Fpii%2FS0092867417301939%3Fshowall%3Dtrue\n出自：\nhttps://www.cell.com/cell-stem-cell/fulltext/S1934-5909(18)30591-5?_returnURL=https%3A%2F%2Flinkinghub.elsevier.com%2Fretrieve%2Fpii%2FS1934590918305915%3Fshowall%3Dtrue\nfrom:\nhttps://www.cell.com/cell-stem-cell/fulltext/S1934-5909(18)30591-5?_returnURL=https%3A%2F%2Flinkinghub.elsevier.com%2Fretrieve%2Fpii%2FS1934590918305915%3Fshowall%3Dtrue\n应用场景\n哪些调控蛋白的结合位点更相近？转录因子过表达/敲降后变得跟谁更像了？通过计算ChIP-seq数据间的correlation，找到线索，进而推测转录因子的作用机制。\nApplication scenarios\nWhich regulatory proteins have binding sites that are more similar?\nWho is more similar to transcription factors after\noverexpression/knockdown? By calculating the correlation between ChIP\nseq data, clues can be found to infer the mechanism of action of\ntranscription factors.\n环境设置\n下载并安装Anaconda发行版，\nhttps://www.anaconda.com/distribution/#download-section\n用Jupyter notebook打开FigureYa115cofactor.ipynb文档\n用法参考这篇：\nhttps://mp.weixin.qq.com/s/G-CQhNEJBmMRuDe2kxND_w\n通过bioconda安装intervene, python 2.7环境：\n注：\n下文以“```bash”开头的代码都要复制粘贴到Terminal里运行（Linux和MAC自带），Windows10用WSL。\nEnvironment settings\nDownload and install the Anaconda distribution,\nhttps://www.anaconda.com/distribution/#download\n-section\nOpen the FigureYa115cofactor.ipynb document with Jupyter notebook\nRefer to this article for usage:\n<\nhttps://mp.weixin.qq.com/s/G-CQhNEJBmMRuDe2kxND_w\n>\nInstall Interne through Bioconda, Python 2.7 environment:\n**Note: * * The code starting with ‘bash’ in the following text\nshould be copied and pasted into Terminal to run (Linux and MAC\nbuilt-in), Windows 10 uses WSI.\nconda install -c bioconda intervene\nsource(\"install_dependencies.R\")\n# 加载corrplot包，用于绘制相关系数矩阵图 | Load the corrplot package for visualizing correlation matrices\nlibrary(corrplot)\n# 加载RColorBrewer包，用于生成色彩方案 | Load the RColorBrewer package for generating color schemes\nlibrary(RColorBrewer)\n\n# 加载pheatmap包，用于绘制热图 | Load the pheatmap package for creating heatmaps\nlibrary(pheatmap)\n\n# 设置环境变量使R显示英文错误信息 | Set environment variable to display error messages in English\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止将字符串自动转换为因子类型 | Disable automatic conversion of strings to factors\noptions(stringsAsFactors = FALSE)\n输入文件的获取\n输入文件需要多个ChIP-seq的peak.bed文件。\nRetrieve input files\nThe input file requires multiple ChIP seq peak.bed files.\n下载\n例文的数据链接：\nhttps://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE120104\n，点击Download中的(custom)，选择以’_ChIP_K562_OPTIMAL_ppr.IDR0.02.filt.narrowPeak.gz‘结尾的文件，下载的文件是GSE120104_RAW.tar，位于当前文件夹。\nDownload\nData link for example text:<\nhttps://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE120104\n>Click on (custom) in Download and select the file that ends with\n’_ChIP_K562∝TIMAL_ppr.IDR0.02. tilt. arrowheadPeak. gz’. The downloaded\nfile is GSE120104_SAW. tar, located in the current folder.\n#解压缩\ntar –xvf GSE120104_RAW.tar\n\n#全部解压缩\ngunzip *narrowPeak.gz\n#Decompress\ntar –xvf GSE120104_RAW.tar\n\n#Extract all files\ngunzip *narrowPeak.gz\nsort peak，并把文件名改为factor的名字\n观察文件名发现，本套数据的peak.bed文件都以.narrowPeak结尾，factor的名字在\nGSM*\n和\n_ChIP\n之间。\n根据本套数据的命名规则提取factor的名字，作为排序后的peak.bed的文件名\nfor i in `ls *.narrowPeak`\ndo\nx=${i/_ChIP_K562*.narrowPeak/} \nx=${x/GSM*_/}\nsort $i -k1,1V -k2,2n -k3,3n > $x.bed\ndone\n\n#删除原有数据\nrm -rf *.narrowPeak\n实际操作中，自己的peak.bed文件的名字可以直接写成factor的名字，运行下面这段就好。如果你的peak.bed已经排过序，就可以跳过这部分，直接进入“开始画图”。\nfor i in `ls *.narrowPeak`\ndo\nsort $i -k1,1V -k2,2n -k3,3n > $i\ndone\n\n#删除原有数据\nrm -rf *.narrowPeak\n题外话：\n测序数据在发表文章时，作者会把数据上传到GEO/SRA数据库，GEO里除了原始的fastq、bigwig（bw）或bedGraph文件以外，大部分也提供了peak.bed文件。可以直接下载peak.bed文件，或者从头跑，call\npeak，生成peak.bed。可参考FigureYa107ChIPheatmap或FigureYa108RNAseqChIP。\n哪些数据更靠谱？\n推荐首选高影响因子的文章里的数据，快速查询高分数据的方式，可参考FigureYa104GEOmining。\nsort peak， And change the file name to the name of factor\nObserving the file names, it was found that the peak.bed files of\nthis set of data all end with. narrowPeak, and the name of the factor is\nbetween ’GSM *’ and ’_ChIP’.\nExtract the name of the factor according to the naming rules of this\nset of data, and use it as the file name for the sorted peak.bed\nfor i in `ls *.narrowPeak`\ndo\nx=${i/_ChIP_K562*.narrowPeak/} \nx=${x/GSM*_/}\nsort $i -k1,1V -k2,2n -k3,3n > $x.bed\ndone\n\n#Delete existing data\nrm -rf *.narrowPeak\nIn practical operation, the name of your peak.bed file can be\ndirectly written as the name of the factor. Just run the following\nparagraph. If your peak.bed has already been sorted, you can skip this\nsection and go directly to “Start Drawing”.\nfor i in `ls *.narrowPeak`\ndo\nsort $i -k1,1V -k2,2n -k3,3n > $i\ndone\n\n#Delete existing data\nrm -rf *.narrowPeak\n**Off topic: When publishing an article, the author will upload the\nsequencing data to the GEO/SRA database. In addition to the original\nfastq, bigwig (bw), or bedGraph files, most GEO also provides peak.bed\nfiles. You can directly download the peak.bed file or run it from\nscratch, call peak， Generate peak.bed. You can refer to\nFigureYa107ChIPheatmap or FigureYa108RNAseqChIP.\nWhich data is more reliable?\nRecommend selecting\ndata from articles with high impact factors, and refer to Figure Ya104\nGEOmining for a quick way to query high scoring data.\n开始画图\nStart drawing\n用intervene计算相关性\n通过pearson或者spearman等计算不同peak之间的相关系数，例文用的是pearson\nintervene pairwise -i ./*.bed --filenames --htype color --corr --corrtype pearson\nintervene还有许多参数，比如不计算fraction而用jaccard\nindex，需要加–compute jaccard –htype\n{tribar,dendrogram,color,pie,circle,square,ellipse,number,shade}\n其他图形展示，还包括venn和upset等等，具体官方教程有详细例子，详见官方教程：\nhttps://intervene.readthedocs.io/en/latest/index.html\n输出文件：\n运行结束，会在当前文件夹产生一个Intervene_results文件夹，里面包含3个文件：\nIntervene_pairwise_frac.pdf，Intervene给出的图\nIntervene_pairwise_frac.R，画上面那个图的代码。\nIntervene_pairwise_frac_matrix.txt，相关性矩阵，用它重新画自己喜欢的图。\nCalculate correlation using intervene\nCalculate the correlation coefficient between different peaks using\nPearson or Spearman, etc. The example used is Pearson\nintervene pairwise -i ./*.bed --filenames --htype color --corr --corrtype pearson\nThere are still many parameters in the interlayer, such as using the\nJaccard index instead of calculating the fraction, which requires adding\n– calculate Jaccard –Htype {tribar, dendrogram, color, pie, circle,\nsquare, ellipse, number, shape} other graphic displays, including venn\nand upset, etc. The official tutorial provides detailed examples, please\nrefer to the official tutorial:<\nhttps://intervene\n. readthedocs. io/en/latex/index.\nhtml>\n**Output file: * * At the end of the run, an Intervene_ results\nfolder will be generated in the current folder, containing three\nfiles:\n-Intervene_ pairweise_frac.pdf, the diagram provided by Intervene\n-\nIntervene_pairwise_frac.R， Draw the code for the image above. -\nIntervene_pairwise_frac_matrix.txt， Correlation matrix, use it to\nredraw your favorite graph.\n用corrplot画图\n如果觉得上面的图不够cool，想多些自由发挥空间，就用‘Intervene_pairwise_frac_matrix.txt’文件DIY画图。hclust聚类图：\nDraw with corrplot\nIf you feel that the above image is not cool enough and want more\nfree space to express yourself, you can DIY draw with the file\n‘Intervene_pairwas_frac_matrix. txt’. HCLUST Cluster Diagram:\n# 从文本文件读取交集矩阵数据并转换为矩阵格式 | Read intersection matrix data from text file and convert to matrix format\nintersection_matrix <- as.matrix(read.table(\"Intervene_results/Intervene_pairwise_frac_matrix.txt\"))\n\n# 计算矩阵列之间的Pearson相关系数 | Compute Pearson correlation coefficients between columns of the matrix\nintersection_matrix <- cor(intersection_matrix, method=\"pearson\")\n\n# Intervene自带的代码，打开Intervene_pairwise_frac.R文件就能看到\n# Intervene's built-in code, can be found in Intervene_pairwise_frac.R file\n#pdf(\"Intervene_pairwise_frac.pdf\", width=8, height=8)\n\n# 使用corrplot绘制相关系数矩阵图 | Visualize correlation matrix using corrplot\ncorrplot(intersection_matrix, \n         method =\"color\",  # 使用颜色表示相关系数 | Use color to represent correlation coefficients\n         title=\"Pairwise intersection-pearson correlation(Fraction of overlap)\",  # 图表标题 | Plot title\n         tl.col=\"black\", tl.cex=0.8,  # 设置文本标签颜色和大小 | Set text label color and size\n         is.corr = TRUE,  # 输入是否为相关系数矩阵 | Whether input is a correlation matrix\n         diag=FALSE, addrect=1,  # 不显示对角线，添加1个矩形框 | Don't show diagonal, add 1 rectangle\n         mar=c(0,0,2,1),  # 设置边距 | Set margins\n         rect.col = \"black\")  # 矩形框颜色 | Rectangle color\n#invisible(dev.off())\n\n# 充分利用corrplot的参数，让图上展示的信息更丰富\n# Leverage more corrplot parameters to enhance information visualization\n# https://cran.r-project.org/web/packages/corrplot/vignettes/corrplot-intro.html\npdf(\"Intervene_pairwise_frac_plus.pdf\", width=8, height=8)  # 保存高信息密度图表为PDF | Save enhanced plot as PDF\n\n#自定义颜色 | Custom color palette\ncols <- brewer.pal(11,\"Spectral\")  # 使用Spectral调色板 | Use Spectral color palette\n# 更多可选的调色板：BrBG PiYG PRGn PuOr RdBu RdGy RdYlBu RdYlGn Spectral\n# More color palettes: BrBG PiYG PRGn PuOr RdBu RdGy RdYlBu RdYlGn Spectral\n\n# 使用增强参数绘制相关系数矩阵图 | Enhanced visualization with more parameters\ncorrplot(intersection_matrix, \n         method =\"color\",  # 使用颜色表示相关系数 | Use color to represent correlation coefficients\n         title=\"Pairwise intersection-pearson correlation(Fraction of overlap)\",  # 图表标题 | Plot title\n         tl.col=\"black\", tl.cex=0.8,  # 设置文本标签颜色和大小 | Set text label color and size\n         is.corr = TRUE,  # 输入是否为相关系数矩阵 | Whether input is a correlation matrix\n         diag=FALSE,  # 不显示对角线 | Don't show diagonal\n         col = cols,  # 使用自定义颜色 | Use custom color palette\n         order = \"hclust\",  # 按层次聚类排序变量 | Order variables by hierarchical clustering\n         addrect = 4,  # 添加4个聚类矩形框 | Add 4 clustering rectangles\n         mar=c(0,0,2,1),  # 设置边距 | Set margins\n         rect.col = \"black\")  # 矩形框颜色 | Rectangle color\ninvisible(dev.off())  # 关闭PDF设备 | Close PDF device\n用pheatmap画图\ncorrplot的热图参数很丰富，然而不能画树。我们还是用pheatmap画吧～\nDraw with pheatmap\nThe heatmap parameters of corrplot are rich, but it cannot draw\ntrees. Let’s use pheatmap to draw it\n# 使用pheatmap绘制热图可视化相关性矩阵 | Visualize correlation matrix using pheatmap\npheatmap(intersection_matrix, \n         cellwidth = 8,  # 每个单元格的宽度（像素） | Width of each cell (pixels)\n         cellheight = 8,  # 每个单元格的高度（像素） | Height of each cell (pixels)\n         fontsize = 8,  # 文本字体大小 | Font size for text\n         \n         # 自定义颜色渐变：从深蓝色到白色再到深红色 | Custom color gradient: navy -> white -> firebrick\n         color = colorRampPalette(c(\"navy\", \"white\", \"firebrick3\"))(20),\n         \n         show_colnames = TRUE,  # 显示列名 | Show column names\n         show_rownames = TRUE,  # 显示行名 | Show row names\n         \n         # 可选：隐藏行聚类树状图 | Optional: Hide row clustering dendrogram\n         # treeheight_row = \"0\",\n         \n         # 可选：隐藏列聚类树状图 | Optional: Hide column clustering dendrogram\n         # treeheight_col = \"0\",\n         \n         filename = \"Intervene_pairwise_frac_tree.pdf\",  # 保存的文件名 | Output file name\n         border_color = \"NA\")  # 不显示单元格边框 | No border around cells\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa115cofactor_FigureYa115cofactor",
      "title": "FigureYa115cofactor/FigureYa115cofactor.html",
      "html": "FigureYa115cofactor/FigureYa115cofactor.html",
      "text": "texts/main_FigureYa115cofactor_FigureYa115cofactor.txt",
      "folder": "FigureYa115cofactor",
      "thumb": "gallery_compress/FigureYa115cofactor.webp"
    },
    "word_count": 1387,
    "lines_count": 297,
    "title": "FigureYa115cofactor",
    "description": "ChIP-seq的correlation，用于找cofactor。 deeptools能实现类似的功能，但是它只选其中一个作为标准定为1，然后其他的和这个标准比。我要的是所有样品聚类，看哪一些更相似，没法选定哪个作为标准。我用diffbind做了，可以达到目的，想找到更好的方法。文献里面真不知道是怎么做到的，方法里面完全没有描述。 用这篇Cell paper",
    "input_data_types": [],
    "output_types": [
      "散点图",
      "热图",
      "统计表格"
    ],
    "technical_methods": [
      "聚类分析",
      "motif分析"
    ],
    "biology_areas": [],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "acc",
      "width",
      "order",
      "cellwidth",
      "col",
      "method",
      "mar",
      "diag",
      "height"
    ]
  },
  {
    "id": "main_FigureYa249Regulon_FigureYa249Regulon",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa249Regulon_FigureYa249Regulon.txt",
    "content": "FigureYa249Regulon\nFigureYa249Regulon\nAuthor(s)\n: Xiaofan Lu\nDate\n: 2025-10-05\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\nIf you use ComplexHeatmap in published research, please cite:\nZuguang Gu, et al., Complex heatmaps reveal patterns and correlations\nin multidimensional genomic data, Bioinformatics, 2016.\nZuguang Gu. Complex Heatmap Visualization, iMeta, 2022.\n需求描述\nFigure2a中regulon的计算方法（看起来上半部分是癌种特异性的，下半部分是通用的，随便哪个都行）。\nRequirement Description\nThe calculation method of regulon in Figure 2a (it seems that the top\nhalf is cancer-specific, the bottom half is generic, whichever is\nfine).\n出自\nhttps://www.biorxiv.org/content/10.1101/2021.05.30.446369v1.full\nfrom\nhttps://www.biorxiv.org/content/10.1101/2021.05.30.446369v1.full\nFigure 2. Molecular landscape of four MIBC iCSs. a) Heatmap showing\nregulon activity profiles\nfor 23 transcription factors\n(top panel，即下文复现的图), potential regulators associated with\nchromatin remodelling (middle panel), and 296 unique differentially\nmethylated promoters derived from each iCS vs. adjacent normal samples\n(bottom panel).\n应用场景\n计算转录调控网络regulon的活性（注意：并非转录因子活性），画图展示各亚型中regulon的活性规律。\n让你的表达谱分析逐层递进，可参考例文的做法：\nFigure 2a热图分上中下三部分，把自己的表达数据跟转录因子、chromatin\nremodelling\nregulator、甲基化分析建立联系，探讨转录调控机制。看作者怎么描述结果的：\nApplication Scenarios\nThe activity of the transcriptional regulatory network regulon was\ncalculated (note: it is not transcription factor activity), and the\nactivity of regulon in each isoform was plotted.\nTo make your expression profile analysis progressive, you can refer\nto the example method:\nFigure 2a is divided into three parts: upper, middle and lower, and\nlinks your expression data with transcription factors, chromatin\nremodelling regulators, and methylation analysis to explore\ntranscriptional regulatory mechanisms. See what the author has to say\nabout the results:\nTo further explore transcriptomic differences, we analysed regulons\nfor\n23 MIBC-specific TFs\nand potential\nregulators relevant to cancerous chromatin remodelling\n[5, 30], leading to a strong confirmation of the biological pertinency\nof the four-classification because the regulon activity was tightly\nassociated with iCSs (Figure 2a)… Regulon activity profiles that were\nassociated with cancerous\nchromatin remodelling\nhighlighted other possible differential regulatory patterns among four\niCSs, indicating that epigenetically driven transcriptional networks\nmight be important differentiators of these molecular subtypes (Figure\n2a). The potential epigenetic differences among the subtypes might be\nfurther supported by\ndifferential methylation analysis\n,\nwhich demonstrated that iLS3 (265 vs. 45 in iLS2) and iBS4 (191 vs. 26\nin iBS1) had more hypermethylated promoters (296 unique loci) than the\n21 adjacent normal bladder samples had (Figure 2a).\n文中很多图我们都实现过，例如：\nFigure 1b的画法可参考FigureYa196PanPie\nFigure 2b的画法可参考FigureYa248MutLandscape\nFigure 3de可产考FigureYa25sankey和FigureYa125Fishertest\nFigure 4f可参考FigureYa106immunotherapy\nFigure 5b可参考FigureYa12box，f可参考FigureYa162boxViolin\nFigure\n6可参考FigureYa35batch_bestSeparation，FigureYa144DiagHeatmap或\nhttps://mp.weixin.qq.com/s/34WRZRBVPHUNRLlzNH2nzw\nMany of the pictures in the article have been crowdsourced, such\nas:\nFor more information about Figure 1b, see FigureYa196PanPie\nFor Figure 2b, see FigureYa248MutLandscape\nFigure 3de see FigureYa25sankey and FigureYa125Fishertest\nFigure 4f can refer to Figure Ya106 immunotherapy\nFigure 5b can refer to FigureYa12box, and f can refer to\nFigureYa162boxViolin\nFor Figure 6, see FigureYa35batch_bestSeparation,\nFigureYa144DiagHeatmap, or\nhttps://mp.weixin.qq.com/s/34WRZRBVPHUNRLlzNH2nzw\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nlibrary(RTN)\nlibrary(snow)\nlibrary(ComplexHeatmap)\nlibrary(ClassDiscovery)\nlibrary(RColorBrewer)\nlibrary(gplots)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # error messages are displayed in English\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # chr is not allowed to be converted to factor\n自定义函数 Custom functions\nstandarize.fun <- function(indata=NULL, halfwidth=NULL, centerFlag=T, scaleFlag=T) {  \n  outdata=t(scale(t(indata), center=centerFlag, scale=scaleFlag))\n  if (!is.null(halfwidth)) {\n    outdata[outdata>halfwidth]=halfwidth\n    outdata[outdata<(-halfwidth)]= -halfwidth\n  }\n  return(outdata)\n}\n输入文件\neasyinput_tcga_tpm.txt，表达矩阵\neasyinput_tcga_phenotype.txt，每个样本对应的亚型信息，这里有四个亚型。\neasyinput_regulon.txt，运行regulon分析只需要基因的名字。\n热图上中下三部分各对应一类基因（转录因子、chromatin remodelling\nregulator、甲基化）。\n这里以最上面的23个转录因子为例，基因名出自\nhttps://www.sciencedirect.com/science/article/pii/S0092867417310565?via%3Dihub\n。\n对23个转录因子的描述原文：a total of 23 ‘regulator’ genes that were\nassociated induced/repressed targets: the steroid hormone receptors\nESR1/2, AR and PGR; the nuclear receptors PPARG, three RARs (A/B/G), and\nthree RXRs (A/B/G); the receptor tyrosine kinases ERBB2/3 and FGFR1/3;\nand the transcription factors FOXA1, FOXM1, GATA3/6, HIF1A, KLF4 and\nSTAT3 and TP63\n对于自己的数据，可以自己挖掘或从文献中获取感兴趣的组织、疾病甚至发育时期特异的调控因子。\nInput files\neasyinput_tcga_tpm.txt, the expression matrix。\neasyinput_tcga_phenotype.txt, the subtype information corresponding\nto each sample, there are four subtypes here.\neasyinput_regulon.txt, only the name of the gene is required to run\nthe regulon analysis.\nThe upper, middle, and lower parts of the heatmap correspond to a\nclass of genes (transcription factor, chromatin remodelling regulator,\nmethylation).\nHere are the top 23 transcription factors as an example, and the\ngene names are from\nhttps://www.sciencedirect.com/science/article/pii/S0092867417310565?via=ihub\n。\na total of 23 ‘regulator’ genes that were associated\ninduced/repressed targets: the steroid hormone receptors ESR1/2, AR and\nPGR; the nuclear receptors PPARG, three RARs (A/B/G), and three RXRs\n(A/B/G); the receptor tyrosine kinases ERBB2/3 and FGFR1/3; and the\ntranscription factors FOXA1, FOXM1, GATA3/6, HIF1A, KLF4 and STAT3 and\nTP63\nFor your own data, you can dig your own or obtain specific\nregulators of interest in tissues, diseases, and even developmental\nperiods from the literature. **\n# 加载基因表达以及样本数值信息\n# Load gene expression and sample value information\ntcgaBLCA <- read.table(\"easyinput_tcga_tpm.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\npheno <- read.table(\"easyinput_tcga_phenotype.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\n\n# 加载MIBC特异性的调控子\n# Load MIBC-specific regulators\ntfs <- read.table(\"easyinput_regulon.txt\",header = T)\n计算regulon活性 - Regulon analysis\nbootstrap计算reference regulatory network运行时间较长。\n为方便反复运行调试代码，把中间数据保存到了文件。可跳过这步，进入“开始画图”。\nCalculate regulon activity - Regulon analysis\nBootstrap calculates that the reference regulatory network takes a\nlong time to run.\nIn order to facilitate the repeated running of the debugging code,\nthe intermediate data is saved to a file. You can skip this step and go\nto Start Drawing.\n# 取共有的基因名\n# Take the common gene name\nregulatoryElements <- intersect(tfs$regulon, rownames(tcgaBLCA))\n\n# 运行TNI构建程序\n# Run the TNI builder\n# we used the R package “RTN” to reconstruct transcriptional regulatory networks (regulons)\nrtni_tcgaBLCA <- tni.constructor(expData = as.matrix(log2(tcgaBLCA + 1)), # 样图计算时候没有取对数,  # There is no logarithm when calculating the sample,\n                                 regulatoryElements = regulatoryElements)\n# 通过置换以及bootstrap计算reference regulatory network.\n# Reference regulatory network is calculated by substitution and bootstrap.\n# mutual information analysis and Spearman rank-order correlation deduced the possible associations between a regulator and all potential target from the transcriptome expression profile, and permutation analysis was utilized to erase associations with an FDR > 0.00001. Bootstrapping strategy removed unstable associations through one thousand times of resampling with consensus bootstrap greater than 95%. \n# 这里量力而行设置多核，或者直接单核运算\n# Set up multi-core or single-core operation as you can\noptions(cluster=snow::makeCluster(spec = 4, \"SOCK\")) # 打开4核并行计算（不确定是不是4核，不过我windows只用4，服务器我开12）# Turn on 4-core parallel computing (I'm not sure if it's 4 cores, but I only use 4 for windows, and I open 12 for servers)\nrtni_tcgaBLCA <- tni.permutation(rtni_tcgaBLCA, pValueCutoff = 1e-5, nPermutations = 1000)\nrtni_tcgaBLCA <- tni.bootstrap(rtni_tcgaBLCA, nBootstraps = 1000)\nstopCluster(getOption(\"cluster\")) # 关闭并行计算 # Turn off parallel computing\n\n# 计算DPI-filtered regulatory network\n# Calculate the DPI-filtered regulatory network\n# Data processing inequality filtering eliminated the weakest associations in triangles of two regulators and common targets\nrtni_tcgaBLCA <- tni.dpi.filter(rtni_tcgaBLCA, eps = 0, sizeThreshold = TRUE, minRegulonSize = 15)\n# 保存TNI对象以便后续分析\n# Save the TNI object for later analysis\nsave(rtni_tcgaBLCA, file=\"rtni_tcgaBLCA.RData\")\n\n# load(\"rtni_tcgaBLCA.RData\")\n# 计算每个样本的regulon活性\n# Calculate the regulon activity for each sample\n# Individual regulon activity was estimated by two-sided GSEA\nrtnigsea_tcgaBLCA <- tni.gsea2(rtni_tcgaBLCA, regulatoryElements = regulatoryElements)\nMIBC_regact <- tni.get(rtnigsea_tcgaBLCA, what = \"regulonActivity\")\n\n# 保存活性对象\n# Save the active object\nsave(MIBC_regact,file = \"MIBC_regact.RData\")\n开始画图\nStart drawing\n# 加载活性对象\n# Load the active object\n(load(\"MIBC_regact.RData\"))\n# 设置颜色\n# Set the color\nclust.col <- c(\"#DD492E\",\"#40548A\",\"#32A087\",\"#EC7D21\")\nblue <- \"#5bc0eb\"\ngold <- \"#ECE700\"\n\nplotdata <- standarize.fun(t(MIBC_regact$differential),halfwidth = 1.5) # 标准化regulon的活性 # Normalize the activity of regulon \nannCol.tcga <- pheno[order(pheno$CMOIC),,drop = F] # 构建样本注释信息，并对亚型进行排序 # Construct sample annotation information and sort subtypes\nannColors.tcga <- list()\nannColors.tcga[[\"CMOIC\"]] <- c(\"CS1\" = clust.col[1],\n                               \"CS2\" = clust.col[2],\n                               \"CS3\" = clust.col[3],\n                               \"CS4\" = clust.col[4])\nhcg <- hclust(distanceMatrix(as.matrix(MIBC_regact$differential[rownames(annCol.tcga),]), \"euclidean\"), \"ward.D\")\nhm <- pheatmap(plotdata[hcg$order,rownames(annCol.tcga)],\n               border_color = NA, # 热图单元格无边框 # Heatmap cells have no borders\n               color = colorpanel(64,low=blue,mid = \"black\",high=gold),\n               cluster_rows = F, # 行不聚类 # Rows are not clustered\n               cluster_cols = F, # 列聚类 # Column clustering\n               show_rownames = T, # 显示行名 # Show the rowname\n               show_colnames = F, # 不显示列名 # Column names are not displayed\n               gaps_col = cumsum(table(annCol.tcga$CMOIC))[1:3], # 亚型分割 # Subtype segmentation\n               cellwidth = 0.8, # 固定单元格宽度 # Fixed cell width\n               cellheight = 10, # 固定单元格高度 # Fixed cell height\n               name = \"MIBC Regulon\", # 图例名字 # Legend name\n               annotation_col = annCol.tcga[,\"CMOIC\",drop = F], # 样本注释 # Sample annotations\n               annotation_colors = annColors.tcga[\"CMOIC\"]) # 样本注释的对应颜色 # The color of the sample annotation\n \npdf(\"regulon heatmap.pdf\", width = 8,height = 6)\ndraw(hm) # 输出热图 # Output heatmap\ninvisible(dev.off())\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa249Regulon_FigureYa249Regulon",
      "title": "FigureYa249Regulon/FigureYa249Regulon.html",
      "html": "FigureYa249Regulon/FigureYa249Regulon.html",
      "text": "texts/main_FigureYa249Regulon_FigureYa249Regulon.txt",
      "folder": "FigureYa249Regulon",
      "thumb": "gallery_compress/FigureYa249Regulon.webp"
    },
    "word_count": 1306,
    "lines_count": 241,
    "title": "FigureYa249Regulon",
    "description": "Figure2a中regulon的计算方法（看起来上半部分是癌种特异性的，下半部分是通用的，随便哪个都行）。 Requirement Description The calculation method of regulon in Figure 2a (it seems that the top",
    "input_data_types": [
      "临床数据",
      "表达矩阵",
      "突变数据"
    ],
    "output_types": [
      "热图",
      "统计表格",
      "箱线图",
      "散点图",
      "网络图"
    ],
    "technical_methods": [
      "motif分析",
      "聚类分析",
      "标准化",
      "网络分析",
      "质量控制"
    ],
    "biology_areas": [
      "癌症研究",
      "发育生物学"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "annotation_col",
      "center",
      "header",
      "pValueCutoff",
      "eps",
      "width",
      "sizeThreshold",
      "cluster_cols",
      "regulatoryElements"
    ]
  },
  {
    "id": "main_FigureYa150diversityScore_FigureYa150diversityScore",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa150diversityScore_FigureYa150diversityScore.txt",
    "content": "FigureYa150diversityScore\nFigureYa150diversityScore\nZongcheng Li\n2025-5-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirements description\n用R实现文中计算diversity score的算法。 Use R to implement the\nalgorithm for calculating diversity score in the article.\n出自\nhttps://www.sciencedirect.com/science/article/pii/S1535610819303757\nFrom\nhttps://www.sciencedirect.com/science/article/pii/S1535610819303757\n顺便画出下图： By the way, draw the following figure:\nFigure 3. Intratumoral Heterogeneity in Liver Cancer. (E) Diversity\nscore of tumor samples according to the median value of diversity:\nDiv-Low, below median value; Div-High, above median value. Data are\npresented as means ± SEM.\n应用场景\nApplication scenario\n用单细胞DNA测序数据计算diversity score，用来评价肿瘤异质性。 Use\nsingle-cell DNA sequencing data to calculate the diversity score to\nevaluate tumor heterogeneity.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nlibrary(Seurat)\nlibrary(magrittr)\nlibrary(ggplot2)\nlibrary(ggpubr)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 #Display English error message\noptions(stringsAsFactors = FALSE) #禁止chr转成factor #Disable chr conversion to factor\n根据文章方法描述，自定义计算diversity score的函数 According to the\nmethod described in the article, customize the function to calculate the\ndiversity score\ncalcDiversityScore <- function(eigenvectorSpace, \n                               inWhichTumor,\n                               removeOutiler = T,\n                               nsd = 2, topPCs = 1:3){\n  message(\"get centroid...\")\n  centroidMean <- apply(eigenvectorSpace, 2, function(x) tapply(x, inWhichTumor, mean))\n  centroidMeanExpand <- centroidMean[match(inWhichTumor, rownames(centroidMean)),]\n  if(removeOutiler){\n    message(\"remove outlier...\")\n    centroidSD <- apply(eigenvectorSpace, 2, function(x) tapply(x, inWhichTumor, sd))\n    centroidSDExpand <- centroidSD[match(inWhichTumor, rownames(centroidSD)),]\n    outlierMatrix <- (eigenvectorSpace < centroidMeanExpand - nsd* centroidSDExpand) |\n      (eigenvectorSpace > centroidMeanExpand + nsd* centroidSDExpand)\n    outlierInd <- apply(outlierMatrix[,topPCs], 1, all)\n    centroidMeanExpand <- centroidMeanExpand[!outlierInd, ]\n    eigenvectorSpace <- eigenvectorSpace[!outlierInd,]\n    inWhichTumor <- inWhichTumor[!outlierInd]\n    message(sum(outlierInd), \" outlier cells were removed\")\n  }\n  tapply(sqrt(rowSums((eigenvectorSpace - centroidMeanExpand)^2)), inWhichTumor, mean)\n}\n输入文件\nInput file\n按照这个方式，下载和挖掘GEO上已发表的单细胞测序数据： Download and\nmine the single-cell sequencing data published on GEO in this way:\n打开页面\nhttps://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE125449\n，拖到底，在Supplementary\nfile里，点击ftp，下载下面四个文件：\nOpen the page\nhttps://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE125449\n,\nscroll to the bottom, click ftp in Supplementary file, and download the\nfollowing four files:\nGSE125449_Set1_barcodes.tsv.gz\nGSE125449_Set1_genes.tsv.gz\nGSE125449_Set1_matrix.mtx.gz\nGSE125449_Set1_samples.txt.gz\nftp://ftp.ncbi.nlm.nih.gov/geo/series/GSE125nnn/GSE125449/suppl\nSet 1 contains scRNA-seq data of twelve samples, i.e., S16_P10_LCP18,\nS02_P01_LCP21, S10_P05_LCP23, S09_P04_LCP25, S08_P03_LCP26,\nS07_P02_LCP28, S11_P06_LCP29, S12_P07_LCP30, S20_P12_LCP35,\nS21_P13_LCP37, S15_P09_LCP38, and S19_P11_LCP39.\n!!! Important\n!!!\n把这四个文件放到\n./data/\n文件夹里\n!!!\nImportant !!!\nPut these four files in the\n./data/\nfolder\n解压缩，按以下规则重命名:\nUnzip and rename as follows:\nGSE125449_Set1_barcodes.tsv ==> barcodes.tsv\nGSE125449_Set1_genes.tsv ==> genes.tsv\nGSE125449_Set1_matrix.mtx ==> matrix.mtx\nGSE125449_Set1_samples.txt ==> samples.txt\nSamples used for scoring\nH23 - S10_P05_LCP23,\nC25 - S09_P04_LCP25,\nC26 - S08_P03_LCP26,\nC29 - S11_P06_LCP29,\nH30 - S12_P07_LCP30,\nH37 - S21_P13_LCP37,\nH38 - S15_P09_LCP38,\nC39 - S19_P11_LCP39.\numi <- Read10X(data.dir = \"data/\")\ndim(umi)\nannot <- read.table(file = \"data/samples.txt\", sep = \"\\t\", header = T)\nrownames(annot) <- annot$Cell.Barcode\ndim(annot)\nidentical(colnames(umi), rownames(annot))\nsampleUsed <- c(H23 = \"S10_P05_LCP23\", \n                C25 = \"S09_P04_LCP25\", \n                C26 = \"S08_P03_LCP26\", \n                C29 = \"S11_P06_LCP29\", \n                H30 = \"S12_P07_LCP30\", \n                H37 = \"S21_P13_LCP37\",\n                H38 = \"S15_P09_LCP38\", \n                C39 = \"S19_P11_LCP39\")\ncellUsed <- rownames(subset(annot, Sample %in% sampleUsed & Type == \"Malignant cell\"))\ntme <- CreateSeuratObject(counts = umi[, cellUsed], \n                          meta.data = annot[cellUsed,],\n                          min.cells = 3, min.features = 500)\n#可以暂时先保存一下\n#You can save it temporarily\n#save(tme, file = \"tme.Rdata\")\nAnalysis using Seurat\n#(load(\"tme.Rdata\"))\ntme %<>% \n  NormalizeData(scale.factor = 1e4) %<>%  # Normalization\n  ScaleData() %>%                         # Scaling\n  FindVariableFeatures(selection.method = \"mvp\", # HVGs\n                       mean.cutoff = c(0.05, 3), \n                       dispersion.cutoff = c(0.5, Inf)) %<>% \n  RunPCA(npcs = 50,verbose = F)  # PCA\nElbowPlot(tme, ndims = 50, reduction = \"pca\")\nCalc Diversity Score\neigenvectorSpace <- tme@reductions$pca@cell.embeddings[,1:30] # top 20 PCs were used\n\n#用自定义函数calcDiversityScore计算diversity score\n# Use custom function calcDiversityScore to calculate diversity score\ndiversityScores <- calcDiversityScore(eigenvectorSpace, tme@meta.data$Sample, removeOutiler = T)\nsampleUsed <- c(H23 = \"S10_P05_LCP23\", \n                C25 = \"S09_P04_LCP25\", \n                C26 = \"S08_P03_LCP26\", \n                C29 = \"S11_P06_LCP29\", \n                H30 = \"S12_P07_LCP30\", \n                H37 = \"S21_P13_LCP37\",\n                H38 = \"S15_P09_LCP38\", \n                C39 = \"S19_P11_LCP39\")\nsampleUsed[match(names(diversityScores), sampleUsed)]\ndiversityScores\n# 整理数据格式用于画图\n# Arrange data format for plotting\nggData <- data.frame(score = diversityScores,\n                     Group = ifelse(diversityScores > 12.3, \"High\", \"Low\"), \n                     ID = names(sampleUsed[match(names(diversityScores), sampleUsed)]),\n                     row.names = names(diversityScores))\nggData$Group <- factor(ggData$Group, levels = c(\"Low\", \"High\"))\ntable(ggData$Group, ggData$ID)\n#保存到文件\n#Save to file\nwrite.csv(ggData, \"output_diversity_score.csv\", quote = F)\n开始画图\nStart plotting\nggplot(ggData,\n       mapping = aes(Group, score, color = Group)) +\n  geom_jitter(width = 0.3) +\n  scale_color_manual(values = c(\"blue\", \"red\"))+\n  geom_point(stat=\"summary\", fun.y=\"mean\", \n             size = 6, shape = \"—\",\n             show.legend = F) + \n  geom_errorbar(stat=\"summary\", fun.data=\"mean_se\", \n                width = 0.3) +\n  stat_compare_means(comparisons = list(c(\"Low\", \"High\")))+\n  lims(y = c(0,40)) + \n  theme_classic() +\n  theme(legend.position = \"none\")\nggsave(\"diversityScore.pdf\", width = 2, height = 3)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa150diversityScore_FigureYa150diversityScore",
      "title": "FigureYa150diversityScore/FigureYa150diversityScore.html",
      "html": "FigureYa150diversityScore/FigureYa150diversityScore.html",
      "text": "texts/main_FigureYa150diversityScore_FigureYa150diversityScore.txt",
      "folder": "FigureYa150diversityScore",
      "thumb": "gallery_compress/FigureYa150diversityScore.webp"
    },
    "word_count": 682,
    "lines_count": 185,
    "title": "FigureYa150diversityScore",
    "description": "Requirements description 用R实现文中计算diversity score的算法。 Use R to implement the algorithm for calculating diversity score in the article.",
    "input_data_types": [
      "单细胞"
    ],
    "output_types": [
      "统计表格"
    ],
    "technical_methods": [
      "标准化"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "score",
      "C39",
      "values",
      "acc",
      "header",
      "width",
      "removeOutiler",
      "H37",
      "cutoff"
    ]
  },
  {
    "id": "main_FigureYa63pubmedMiningV2_FigureYa63pubmedMiningV2",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa63pubmedMiningV2_FigureYa63pubmedMiningV2.txt",
    "content": "FigureYa63PubmedMiningV2\nFigureYa63PubmedMiningV2\nAuthor(s)\n: Haitao Wang, Melvin L.K. Chua; Ying Ge,\nYijing Chen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n通过API检索NCBI的Pubmed数据库，批量获得文章信息，整理出摘要里基因的词频。\nNCBI’s Pubmed database is searched through the API to obtain article\ninformation in bulk and organize the word frequencies of the genes in\nthe abstracts.\n应用场景\nApplication scenario\n老板交给我的这个基因好陌生，用这套代码跑出表格，一眼望去，发现它的好朋友我都很熟，于是，熟悉的思路、方法都能用上了。\n文章做到第三部分卡住了，我的基因到底调控了谁，或者谁调控了它，或者它跟谁是好朋友一同发挥作用？用这套代码跑出表格，一眼望去，发现目的基因跟我熟悉的一类分子一同出现在某篇文章的摘要里，我们实验室有非常完善的研究这类分子的实验体系，接下来就瞄准这个分子了。\n只要设置好检索词，就可以批量检索并整理文献和摘要，让你的头脑风暴比别人快10倍。\n包含三个模块，相对独立，可分别运行。全部运行完将让你对目的基因有个整体的认识。\n【模块一】文章的增长趋势\n【模块二】发表了哪些文章\n【模块三】\n从摘要找好朋友\nThe gene my boss handed to me is quite unfamiliar. Using this set\nof code to generate a table, at a glance, I found that I am very\nfamiliar with its good friends, so I can apply familiar ideas and\nmethods.\nThe article got stuck at the third part. Exactly which gene is\nregulated by mine, or who regulates it, or with whom does it cooperate\nto function? Running this set of code to generate a table, at a glance,\nI found the target gene appearing alongside a familiar class of\nmolecules in the abstract of a certain article. Our laboratory has a\nvery comprehensive experimental system for studying this class of\nmolecules, so the next step is to focus on this molecule.\nAs long as you set the search terms, you can batch search and\norganize the literature and abstracts, so that your brainstorming is 10\ntimes faster than others.\nIt contains three modules that are relatively independent and can be\nrun separately. All run through will give you an overall understanding\nof the target gene.\n[Module 1] Trends in the growth of articles\n[Module 2] What articles are published\n[Module 3]\nFind a good friend from the abstract\n环境设置\nEnvironment setting\nsource(\"install_dependencies.R\")\nlibrary(data.table)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(rentrez) \nlibrary(pubmed.mineR)\nlibrary(DT)\nlibrary(htmlwidgets)\n\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 display English error messages\noptions(stringsAsFactors = FALSE) #禁止chr转成factor prohibit the conversion of chr to factor\n输入文件\nInput file\n常用词\nCommon words\ncommon_words_new.v2.txt，常用词。【模块三】计算词频时，要去除这些常用词。\ncommon_words_new.v2.txt, common words. [Module 3] These common words\nare removed when calculating word frequency.\ncommon_words_new <- read.table(\"common_words_new.v2.txt\")\ncommon_words_new <- common_words_new$V1\n基因名\nGene name\n每行一个基因。包含基因名、别名、位点，【模块三】将从摘要中统计这些基因名。还可以换成你想统计词频的其他类型的词。\nOne gene per row. It contains gene names, aliases, and loci. [Module\n3] will count these gene names from the abstract. You can also replace\nthem with other types of words for which you want to count\nfrequency.\n(load(\"HGNCdata.rda\")) #位于当前文件夹 located in the current folder\nhead(HGNCdata)\n参数设置\nParameter setting\n在这里设置检索词、检索的文章发表时间范围\nset search terms and the publication time range of the retrieved\narticles here\ntargetGene <- \"PD-L1\" #检索的基因名 retrieved gene names\nyear <- 2010:2018 #检索的文章的发表年份范围 the publication year range of the retrieved articles\n这里用的检索词跟你在网页版Pubmed中用的检索词是一样的，初级用法就是用AND或OR连接你希望检索到的内容，例如基因名、疾病、处理、物种等。医学领域推荐直接用MeSH\nterme来限定，Medical Subject Headings(MeSH) refer to wiki\nhttps://en.wikipedia.org/wiki/Medical_Subject_Headings\n如果用基因名作为检索词，建议把基因的别名都放进来，可以通过下面的代码提取：\nThe search terms used here are the same as those you would use in the\nweb version of Pubmed, and the primary use is to connect what you wish\nto retrieve with AND or OR, such as gene name, disease, treatment,\nspecies, etc. In the medical field, it is recommended to directly use\nMeSH terms to specify, Medical Subject Headings(MeSH) refer to wiki\nhttps://en.wikipedia.org/wiki/Medical_Subject_Headings\nIf the gene name is used as a search term, it is recommended to put\nin all the aliases of the gene, which can be extracted by the following\ncode:\ntargetGene.Symbol <- HGNCdata[HGNCdata$Approved.Symbol %like% targetGene,]\ntargetGene.Synonyms <- HGNCdata[HGNCdata$Synonyms %like% targetGene,]\ntargetGeneInfo <- rbind(targetGene.Symbol, targetGene.Synonyms)\ntargetGeneInfo\nterm <- paste(as.character(targetGeneInfo$Approved.Symbol), str_replace_all(targetGeneInfo$Synonyms, \", \", \" OR \"), sep = \" OR \")\nterm\n# 还可以加上疾病的名字，例如GBM的MeSH term: Glioblastoma\n# the name of the disease can also be added, e.g. GBM's MeSH term: Glioblastoma\n#term <- paste0 (\"(\", term, \") AND Glioblastoma[MeSH Terms]\")\n#term\n\n# 或者自己手写基因名作为检索词\n# or handwrite your own gene name as a search term\n#term <- \"CD274 OR PD-L1 OR PDL1\"\n【模块一】文章的增长趋势\n[Module 1] Trends in the growth of articles\n#查询NCBI里的数据库简称\n#query database abbreviations in NCBI\n#entrez_dbs()\n#pubmed里有哪些可以查询的fields\n#what fields can be queried in PubMed?\n#entrez_db_searchable(db = \"pubmed\")\n\n#先写个函数，获取特定年份范围内发表的带有检索词的文章数量\n#first write a function to get the number of articles with a search term published in a specific range of years\nsearch_year <- function(year, term){\n    query <- paste(term, \"AND (\", year, \"[PDAT])\")\n    entrez_search(db=\"pubmed\", term=query, retmax=0)$count\n}\n\n# 用前面“参数设置”里定义的检索词检索，文章越多，等的越久\n# use the search terms defined in the previous \"parameter setting\" to search, the more articles you have, the longer you have to wait\npapers <- sapply(year, search_year, term=term, USE.NAMES=FALSE) \n\nplot(year, papers, type='b', main=\"The PD-L1 papers\")\n【模块二】发表了哪些文章\n[Module 2] What articles are published\n检索并从结果中提取出PMID、发表日期、文章名、期刊。\nRetrieve and extract the PMID, publication date, article name, and\njournal from the results.\n#我们先把retmax设为0，先不让它返回结果，这步只为了查看一共多少条记录\n#let's set retmax to 0 and not let it return a result, just to see how many records there are\npre.result <- entrez_search(db=\"pubmed\", term=term, retmode = \"xml\", retmax = 0)\npre.result$count #一共有多少条记录 how many records in total\n#返回所有检索到的结果\n#return all retrieved results\n#result <- entrez_search(db=\"pubmed\", term=term, retmode = \"xml\", retmax = pre.result$count)\n#网速慢的话，先返回前200条记录\n#if you have a slow internet connection, return the first 200 records first\nresult <- entrez_search(db=\"pubmed\", term=term, retmode = \"xml\", retmax = 200)\n\n#下载所有文件信息\n#记录太多会被拒绝，因此每次提取200篇\n#download all the paper info\n#too many records will be rejected, so extract 200 articles each time\nn <- 200 #每次读入的记录数量 number of records read each time\nres <- c()\nfor (i in seq(1,length(result$ids),n)) {\n  multi_summ <- entrez_summary(db=\"pubmed\",id=result$ids[i:(i+n-1)])\n  date_and_cite <- extract_from_esummary(multi_summ, c(\"uid\",\"pubdate\", \"authors\",\"title\", \"fulljournalname\",\"elocationid\"))\n  res1 <- data.frame(t(date_and_cite))\n  res1 <- data.frame(lapply(res1, as.character), stringsAsFactors=FALSE)\n  res <- rbind(res,res1)\n}\n\n# 整理author name\n# organize author name\ntmp <- sub('^...............','', res$authors) # 如果想从左侧删除N个字符用 if you want to delete N characters from the left side, use\ntmp <- gsub(\"\\\", \\\"\", \", \", tmp)\ntmp <- data.frame(sapply(tmp, function(x) unlist(strsplit(x,'\\\"'))[1]),stringsAsFactors = F)[,1]\ntmp <- data.frame(sapply(tmp, function(x) unlist(strsplit(x,'\"),'))[1]),stringsAsFactors = F)[,1]\ntmp <- data.frame(sapply(tmp, function(x) unlist(strsplit(x,'\",'))[1]),stringsAsFactors = F)[,1]\nres$authors <- tmp\n\n#把结果保存到文本文件\n#save the results to a text file\nwrite.table(res, \"output_paper.txt\", quote = F, sep = \"\\t\", row.names = F)\n添加文章的Pubmed链接，保存成网页格式\nAdd the Pubmed link of the article, save it in web format\nuid <- res$uid\npubdate <- res$pubdate\npmcrefcount <- res$pmcrefcount\nauthors <- res$authors\ntitle <- res$title\nfulljournalname <- res$fulljournalname\nelocationid <- res$elocationid\n\n# 写个函数\n# write a function\ncreateLink <- function(base,val) {\n  sprintf('<a href=\"%s\" class=\"btn btn-link\" target=\"_blank\" >%s</a>',base,val)\n}\n\n# 按照网址规律给PMID和题目加上Pubmed链接\n# add the Pubmed link to PMIDs and titles following the URL pattern\nres <- data.frame(uid = createLink(paste0(\"https://www.ncbi.nlm.nih.gov/pubmed/?term=\",uid),uid),\n                  pubdate = pubdate, \n                  authors = authors,\n                  title = createLink(paste0(\"https://www.ncbi.nlm.nih.gov/pubmed/?term=\",uid),title),\n                  fulljournalname = fulljournalname,\n                  elocationid = elocationid,\n                  stringsAsFactors = F)\nres <- na.omit(res)\ny <- DT::datatable(res,escape = F,rownames=F)\n\n#保存到网页格式的文件\n#save to web format file\nDT::saveWidget(y,\"output_paper.html\")\n【模块三】从摘要找好朋友\n[Module 3]\nFind a good friend from the\nabstract\n*\n检索\nRetrieve\n这段检索跟前面“【模块二】发表了哪些文章”的开头一样，就不重复运行了。\nThis retrieval is the same as the beginning of “[Module 2] What\narticles are published”, so it will not be run again.\npre.result <- entrez_search(db=\"pubmed\", term=term, retmode = \"xml\", retmax = 0)\npre.result$count \n\n#返回所有检索到的结果\n#return all retrieved results\n#result <- entrez_search(db=\"pubmed\", term=term, retmode = \"xml\", retmax = pre.result$count)\n#此处返回前200条记录\n#return the first 200 records here\nresult <- entrez_search(db=\"pubmed\", term=term, retmode = \"xml\", retmax = 200)\n把xml文件整理成数据框格式\nOrganize xml file into dataframe format\nxml中包含title、authors、year、journal、key_words、doi、pmid、abstract等信息，整理成data.frame格式。\nThe xml contains information such as title, authors, year, journal,\nkey_words, doi, pmid, abstract, etc., organized into the data.frame\nformat.\nn <- 200 #每次读入的记录数量 number of records read each time\nabstract0 <- c()\nfor (i in seq(1, length(result$ids), n)) {\n  rec <- parse_pubmed_xml(entrez_fetch(db = \"pubmed\", id = result$ids[i : (i + n - 1)], rettype = \"xml\"))\n  abstract1 <- as.data.frame(do.call('rbind', rec))\n  abstract0 <- rbind(abstract0, abstract1)\n}\nabstract1[1,]\nlength(abstract1$abstract) # how many abstract 有多少摘要\nabstract <- unlist(abstract0$abstract)\n\n#查看其中某一篇文章的摘要\n#view the abstract of one of the articles\n#abstract[30]\n提取abstract中的基因名，并统计出现频率。\nExtract the gene names in abstract and count the frequency of\noccurrence.\n先把摘要分割成单个的单词，然后根据输入文件common_words_new.v2.txt去掉常用词，再根据HGNCdata.rda挑出基因名。\nFirst, split the abstract into individual words, then remove common\nwords according to the input file common_words_new.v2.txt, and finally\nextract gene names based on HGNCdata.rda.\n# 先用标点符号分割出单词\n# split the word with punctuation first \ntempa <- unlist(strsplit(abstract, \",\",fixed = T));\ntempb <- unlist(strsplit(tempa, \":\",fixed = T));\ntempc <- unlist(strsplit(tempb, \";\",fixed = T));\ntempd <- unlist(strsplit(tempc, \"'\",fixed = T));\ntempe <- unlist(strsplit(tempd, \" \",fixed = T));\ntempf <- unlist(strsplit(tempe, \"/\",fixed = T));\ntempf <- unlist(strsplit(tempe, \"\\\\|\",fixed = T));\ntempf <- unlist(strsplit(tempf, \"(\",fixed = T));\ntempf <- unlist(strsplit(tempf, \")\",fixed = T));\ntempf <- unlist(strsplit(tempf, \"-\",fixed = T));\ntempf <- unlist(strsplit(tempf, \".\",fixed = T));\n\n# 这里都转成大写字母，便于识别基因名，或者根据你自己的需要调整\n# it's all capitalized here to make it easier to identify the gene name, or adjust it to your own needs\ntempf <- toupper(tempf) \ntempi <- as.data.frame(table(tempf));\n\n# 判断是不是常用词，如果是常用词，就删掉\n# determine if it is a common word, and if it is a common word, delete it\ntempj <- unlist(lapply(toupper(common_words_new), function(x){tempoo = which(as.character(tempi[,1]) == x); if (length(tempoo) != 0) return(tempoo)}));\ntempk <- tempi[-tempj,];\n\n# 根据Approved.Symbol挑出基因名\n# select gene names based on Approved.Symbol\ntempl <- as.character(HGNCdata$Approved.Symbol);\nhead(templ)\n# 有些物种的gene symbol里有小写字母，需要先转成大写，就运行下面这行\n# some species have lowercase letters in their gene symbols that need to be converted to uppercase first, so run the following line\n#templ <- toupper(templ)\ntempm <- unlist(lapply(templ,function(x){return(which(x == as.character(tempk$tempf)))}));\ntempn <- tempk[tempm,]\n\n# 按照基因名出现频率排序\n# sort by frequency of gene names\ntempn2<- tempn[order(as.numeric(tempn$Freq), decreasing = T),]\ntempo <- unlist(lapply(as.character(tempn2$tempf), function(x){return(which(x == templ))}));\nSynonyms <- as.character(HGNCdata$Synonyms[tempo]);\ndata_table <- cbind.data.frame(Symbol=as.character(tempn2$tempf), Synonyms, Freq=as.numeric(tempn2$Freq));\ncolnames(data_table) <- c(\"Gene_symbol\", \"Synonyms\", \"Freq\");\n\n# 把基因名的出现频率保存到文件\n# save the frequency of gene names to a file\nwrite.table(data_table, \"output_friends.txt\", sep = \"\\t\", quote = F, row.names = F)\n给基因添加GeneCards链接，保存成网页格式\nAdd GeneCards link to gene, save it in web format\n# 跟【模块二】一样的函数\n# same function as [Module 2]\ncreateLink <- function(base,val) {\n  sprintf('<a href=\"%s\" class=\"btn btn-link\" target=\"_blank\" >%s</a>',base,val)\n}\n\n# 根据GeneCards的网址规律，给基因名添加链接\n# add links to gene names according to the URL pattern of GeneCards\nres <- data.frame(symbols=createLink(paste0(\"https://www.genecards.org/cgi-bin/carddisp.pl?gene=\",as.character(tempn2$tempf)),as.character(tempn2$tempf)),\n                  Synonyms,\n                  as.numeric(tempn2$Freq),\n                  stringsAsFactors = F)\nres <- na.omit(res)\ny <- DT::datatable(res,escape = F,rownames=F)\n\n#保存到网页格式的文件\n#save to web format file\nDT::saveWidget(y,\"output_friends.html\")\n功能扩展\nFunction expansion\n【模块一】的文章数量可以借鉴时间数据的展示方式，画出酷炫的图；\n【模块二】的结果可以添加影响因子；\n【模块三】的结果可以画成词云。\n享受吧！希望能帮助你加快研究进度！！！\nThe number of articles in [Module 1] can be visualized in a cool\ngraph using time data display methods;\nThe results of [Module 2] can be added with impact factor;\nThe results of [Module 3] can be drawn as word clouds.\nEnjoy it! Hope can help you speed up your research!!!\n参考资料\nReference\nNCBI里的各种数据库，都可以用rentrez这个R包通过API访问，达到批量检索、处理的目的。\n参考资料：\nhttps://bioconnector.github.io/workshops/r-ncbi.html\nVarious databases in NCBI can be accessed through API using the\nrentrez R package, achieving the purpose of batch retrieval and\nprocessing.\nReference:\nhttps://bioconnector.github.io/workshops/r-ncbi.html\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa63pubmedMiningV2_FigureYa63pubmedMiningV2",
      "title": "FigureYa63pubmedMiningV2/FigureYa63pubmedMiningV2.html",
      "html": "FigureYa63pubmedMiningV2/FigureYa63pubmedMiningV2.html",
      "text": "texts/main_FigureYa63pubmedMiningV2_FigureYa63pubmedMiningV2.txt",
      "folder": "FigureYa63pubmedMiningV2",
      "thumb": "gallery_compress/FigureYa63pubmedMiningV2.webp"
    },
    "word_count": 1675,
    "lines_count": 344,
    "title": "FigureYa63PubmedMiningV2",
    "description": "Requirement description 通过API检索NCBI的Pubmed数据库，批量获得文章信息，整理出摘要里基因的词频。 NCBI’s Pubmed database is searched through the API to obtain article",
    "input_data_types": [],
    "output_types": [
      "统计表格"
    ],
    "technical_methods": [],
    "biology_areas": [
      "神经科学",
      "药物研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "id",
      "uid",
      "NAMES",
      "elocationid",
      "tempoo",
      "term",
      "pubdate",
      "authors",
      "decreasing"
    ]
  },
  {
    "id": "main_FigureYa293machineLearning_FigureYa293machineLearning",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa293machineLearning_FigureYa293machineLearning.txt",
    "content": "FigureYa293machineLearningV2\nFigureYa293machineLearningV2\nAuthor(s)\n: Guoqi Li; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-05-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nDemand description\n这个文章里比较不同的模型放在一个图，以及比较不同的算法放在一个图。\nIn this article, different models are compared in one graph, and\ndifferent algorithms are compared in another graph.\n出自\nhttps://www.nature.com/articles/s41467-022-28421-6\n图2 通过基于机器学习的整合流程，开发并验证了一种共识性IRLS模型。 A\n在LOOCV框架下构建了共计101种预测模型，并计算了各模型在所有验证数据集中的C指数。\nB 在TCGA-CRC队列（n =\n584）中，当偏似然偏差达到最小值时确定最优λ值，并进一步生成最具预后价值基因的Lasso系数。数据以均值±95%置信区间[CI]表示。\nC 逐步Cox回归最终获得的16个lncRNA系数。 D–K\n基于IRLS的TCGA-CRC患者总生存期（OS）Kaplan-Meier曲线（对数秩检验：P =\n9.16e−19）。\nSource:\nhttps://www.nature.com/articles/s41467-022-28421-6\nFig. 2 A consensus IRLS was developed and validated via the machine\nlearning-based integrative procedure. A A total of 101 kinds of\nprediction models via LOOCV framework and further calculated the C-index\nof each model across all validation datasets. B In the TCGA-CRC cohort\n(n = 584), the determination of the optimal λ was obtained when the\npartial likelihood deviance reached the minimum value, and further\ngenerated Lasso coefficients of the most useful prognostic genes. Data\nare presented as mean ± 95% confidence interval [CI]. C Coefficients of\n16 lncRNAs finally obtained in stepwise. Cox regression. D–K\nKaplan–Meier curves of OS according to the IRLS in TCGA-CRC (log-rank\ntest: P = 9.16e−19).\n应用场景\nApplication scenarios\n基于这10种算法的组合去构建模型，会受到输入数据集的基因数目和质量的影响。\n因此，基于不同的基因，有些模型可能得不到特征而出现报错的现象，这属于正常现象。\n最后的result都会有结果，但是得到结果会有变化，以及有些模型（指单一模型）或模型组合（指组合模型）预测效能的C指数为0.5，这些模型都是未得到结果的模型（根本原因是输入数据中基因的问题），所以可以调整输入数据的基因来获取更多有结果的模型组合结果。\n例文当中有些Figure的画法可参考FigureYa：\nFigure\n1，FigureYa69cancerSubtype、FigureYa71ssGSEA、FigureYa55panCancer_violin、FigureYa15WGCNA、FigureYa170ImmuLncRNA\nFigure\n2，FigureYa293machineLearning、FigureYa31lasso、FigureYa35batch_bestSeparation\nFigure 3，FigureYa189timeCindex、FigureYa220repeatedLasso\nFigure 5，FigureYa90subgroup\nFigure 6，FigureYa105GDSC\nFigure 7，FigureYa71ssGSEA、FigureYa152DouleCorPlot\nThe performance of models built using these 10 algorithms in\ncombination is influenced by the number and quality of genes in the\ninput dataset.\nTherefore, depending on the genes used, some models may fail to\nextract features and return errors—this is a normal occurrence.\nAll final results will be generated, but the outcomes may vary.\nAdditionally, some models (single models) or model combinations\n(ensemble models) may yield a C-index of 0.5, indicating that they\nfailed to produce meaningful results (primarily due to issues with the\ninput gene data). To obtain more valid model combinations, adjusting the\ninput gene set may help.\nFor reference on figure design, you may consult FigureYa:\nFigure\n1，FigureYa69cancerSubtype、FigureYa71ssGSEA、FigureYa55panCancer_violin、FigureYa15WGCNA、FigureYa170ImmuLncRNA\nFigure\n2，FigureYa293machineLearning、FigureYa31lasso、FigureYa35batch_bestSeparation\nFigure 3，FigureYa189timeCindex、FigureYa220repeatedLasso\nFigure 5，FigureYa90subgroup\nFigure 6，FigureYa105GDSC\nFigure 7，FigureYa71ssGSEA、FigureYa152DouleCorPlotexamples.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(survival)\nlibrary(randomForestSRC)\nlibrary(glmnet)\nlibrary(plsRcox)\nlibrary(superpc)\nlibrary(gbm)\nlibrary(CoxBoost)\nlibrary(survivalsvm)\nlibrary(dplyr)\nlibrary(tibble)\nlibrary(BART)\nlibrary(miscTools)\nlibrary(compareC)\nlibrary(ggplot2)\nlibrary(ggsci)\nlibrary(tidyr)\nlibrary(ggbreak)\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n输入文件\nInput Files\nTCGA.txt，GSE57303.txt，GSE62254.txt，数据集。行为样本，第一列为样本名，第二三列为生存时间和生存状态，后面的列均为基因。\nTCGA.txt, GSE57303.txt, GSE62254.txt, datasets. Rows represent\nsamples, with the first column being sample names, the second and third\ncolumns being survival time and survival status, and the remaining\ncolumns all being genes.\n# 加载数据集\n# Load datasets\ntcga <- read.table(\"TCGA.txt\", header = T,sep = \"\\t\", quote = \"\", check.names = F)\nGSE57303 <- read.table(\"GSE57303.txt\", header = T, sep = \"\\t\", quote = \"\", check.names = F)\nGSE62254 <- read.table(\"GSE62254.txt.gz\", header = TRUE, sep = \"\\t\", quote = \"\", check.names = FALSE)\n\n# 生成包含三个数据集的列表\n# Create a list containing the three datasets\nmm <- list(TCGA = tcga,\n           GSE57303 = GSE57303, GSE62254 = GSE62254)\n\n# 数据标准化\n# Data standardization\nmm <- lapply(mm,function(x){\n  x[,-c(1:3)] <- scale(x[,-c(1:3)])\n  return(x)})\n\nresult <- data.frame()\n\n# TCGA作为训练集\n# Use TCGA as the training set\nest_data <- mm$TCGA\n\n# GEO作为验证集\n# Use GEO as the validation set\nval_data_list <- mm\n\npre_var <- colnames(est_data)[-c(1:3)]\nest_dd <- est_data[, c('OS.time', 'OS', pre_var)]\nval_dd_list <- lapply(val_data_list, function(x){x[, c('OS.time', 'OS', pre_var)]})\n\n# 设置种子数和节点数，其中节点数可以调整\n# Set the seed number and node size (node size can be adjusted)\nrf_nodesize <- 5\nseed <- 123\n下面开始实现10种方法：\nBelow starts the implementation of 10 methods:\n1.RSF\ncv.res <- cv.CoxBoost(est_dd2[, 'OS.time'], est_dd2[, 'OS'], as.matrix(est_dd2[, -c(1, 2)]), \n                      maxstepno = 500, K = 10, type = \"verweij\",  penalty = pen$penalty)\nfit <- CoxBoost(est_dd2[, 'OS.time'], est_dd2[, 'OS'], as.matrix(est_dd2[, -c(1, 2)]), \n                stepno = cv.res$optimal.step, penalty = pen$penalty)\nrs <- lapply(val_dd_list2, function(x){cbind(x[, 1:2], RS = as.numeric(predict(fit, newdata = x[, -c(1, 2)], newtime = x[, 1],  newstatus = x[, 2], type = \"lp\")))})\ncc <- data.frame(Cindex = sapply(rs, function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n  rownames_to_column('ID')\ncc$Model <- paste0('RSF + CoxBoost')\nresult <- rbind(result, cc)\n\n## 1-3.RSF + Enet\nset.seed(seed)\nfit <- rfsrc(Surv(OS.time, OS)~., data = est_dd, \n             ntree = 1000, nodesize = rf_nodesize, \n             splitrule = 'logrank',\n             importance = T,\n             proximity = T,\n             forest = T,\n             seed = seed)\n\nvimp_result <- vimp(fit, importance = \"permute\")  \nimportance_scores <- vimp_result$importance\nrid <- names(sort(importance_scores, decreasing = TRUE))  \n\n# 3. 筛选重要变量（例如保留重要性 > 0 的变量）\n# Filter important variables (e.g. keep those with importance > 0)\nrid <- rid[importance_scores[rid] > 0] \n\nest_dd2 <- est_data[, c('OS.time', 'OS', rid)]\nval_dd_list2 <- lapply(val_data_list, function(x){x[, c('OS.time', 'OS', rid)]})\nx1 <- as.matrix(est_dd2[, rid])\nx2 <- as.matrix(Surv(est_dd2$OS.time, est_dd2$OS))\nfor (alpha in seq(0.1, 0.9, 0.1)) {\n  set.seed(seed)\n  fit = cv.glmnet(x1, x2, family = \"cox\", alpha = alpha, nfolds = 10)\n  rs <- lapply(val_dd_list2, function(x){cbind(x[, 1:2], RS = as.numeric(predict(fit, type = 'link', newx = as.matrix(x[, -c(1, 2)]), s = fit$lambda.min)))})\n  cc <- data.frame(Cindex = sapply(rs, function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n    rownames_to_column('ID')\n  cc$Model <- paste0('RSF + ', 'Enet', '[α=', alpha, ']')\n  result <- rbind(result, cc)\n  }\n\n## 1-4.RSF + GBM\nset.seed(seed)\nfit <- rfsrc(Surv(OS.time, OS)~., data = est_dd,\n             ntree = 1000, nodesize = rf_nodesize,  \n             splitrule = 'logrank',\n             importance = T,\n             proximity = T,\n             forest = T,\n             seed = seed)\n\nvimp_result <- vimp(fit, importance = \"permute\")  \nimportance_scores <- vimp_result$importance\nrid <- names(sort(importance_scores, decreasing = TRUE))  \n\n# 3. 筛选重要变量（例如保留重要性 > 0 的变量）\n# Filter important variables (e.g. keep those with importance > 0)\nrid <- rid[importance_scores[rid] > 0] \n\nest_dd2 <- est_data[, c('OS.time', 'OS', rid)]\nval_dd_list2 <- lapply(val_data_list, function(x){x[, c('OS.time', 'OS', rid)]})\nset.seed(seed)\nfit <- gbm(formula = Surv(OS.time, OS)~., data = est_dd2, distribution = 'coxph',\n                         n.trees = 10000,\n                         interaction.depth = 3,\n                         n.minobsinnode = 10,\n                         shrinkage = 0.001,\n                         cv.folds = 10, n.cores = 6)\n\nbest <- which.min(fit$cv.error)\nset.seed(seed)\nfit <- gbm(formula = Surv(OS.time,OS)~., data = est_dd2, distribution = 'coxph',\n           n.trees = best,\n           interaction.depth = 3,\n           n.minobsinnode = 10,\n           shrinkage = 0.001,\n           cv.folds = 10,n.cores = 8)\nrs <- lapply(val_dd_list2, function(x){cbind(x[, 1:2], RS = as.numeric(predict(fit, x, n.trees = best, type = 'link')))})\ncc <- data.frame(Cindex=sapply(rs, function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n  rownames_to_column('ID')\ncc$Model <- paste0('RSF + ', 'GBM')\nresult <- rbind(result, cc)\n\n## 1-5.RSF + Lasso\nset.seed(seed)\nfit <- rfsrc(Surv(OS.time, OS)~., data = est_dd,\n             ntree = 1000, nodesize = rf_nodesize, \n             splitrule = 'logrank',\n             importance = T,\n             proximity = T,\n             forest = T,\n             seed = seed)\n\n\nvimp_result <- vimp(fit, importance = \"permute\")  \nimportance_scores <- vimp_result$importance\nrid <- names(sort(importance_scores, decreasing = TRUE))  \n\n# 3. 筛选重要变量（例如保留重要性 > 0 的变量）\n# Filter important variables (e.g. keep those with importance > 0)\nrid <- rid[importance_scores[rid] > 0] \n\nest_dd2 <- est_data[, c('OS.time', 'OS', rid)]\nval_dd_list2 <- lapply(val_data_list, function(x){x[, c('OS.time', 'OS', rid)]})\nx1 <- as.matrix(est_dd2[, rid])\nx2 <- as.matrix(Surv(est_dd2$OS.time, est_dd2$OS))\nset.seed(seed)\nfit = cv.glmnet(x1, x2,\n                nfold = 10, \n                family = \"binomial\", alpha = 1,\n                type.measure = \"class\")\nrs <- lapply(val_dd_list2, function(x){cbind(x[, 1:2], RS = as.numeric(predict(fit, type = 'response', newx = as.matrix(x[, -c(1, 2)]), s = fit$lambda.min)))})\ncc <- data.frame(Cindex = sapply(rs, function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n  rownames_to_column('ID')\ncc$Model <- paste0('RSF + ', 'Lasso')\nresult <- rbind(result, cc)\n\n## 1-6.RSF + plsRcox\nset.seed(seed)\nfit <- rfsrc(Surv(OS.time, OS)~., data = est_dd,\n             ntree = 1000, nodesize = rf_nodesize, \n             splitrule = 'logrank',\n             importance = T,\n             proximity = T,\n             forest = T,\n             seed = seed)\n\nvimp_result <- vimp(fit, importance = \"permute\") \nimportance_scores <- vimp_result$importance\nrid <- names(sort(importance_scores, decreasing = TRUE))  \n\n# 3. 筛选重要变量（例如保留重要性 > 0 的变量）\n# Filter important variables (e.g. keep those with importance > 0)\nrid <- rid[importance_scores[rid] > 0] \n\nest_dd2 <- est_data[, c('OS.time', 'OS', rid)]\nval_dd_list2 <- lapply(val_data_list, function(x){x[, c('OS.time', 'OS', rid)]})\nset.seed(seed)\ncv.plsRcox.res = cv.plsRcox(list(x = est_dd2[, rid], time = est_dd2$OS.time, status = est_dd2$OS), nt = 10, verbose = FALSE)\nfit <- plsRcox(est_dd2[, rid], time = est_dd2$OS.time, event = est_dd2$OS, nt = as.numeric(cv.plsRcox.res[5]))\nrs <- lapply(val_dd_list2, function(x){cbind(x[, 1:2], RS = as.numeric(predict(fit, type = \"lp\", newdata = x[, -c(1, 2)])))})\ncc <- data.frame(Cindex = sapply(rs, function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n  rownames_to_column('ID')\ncc$Model <- paste0('RSF + ', 'plsRcox')\nresult <- rbind(result, cc)\n\n## 1-7.RSF + Ridge\nset.seed(seed)\nfit <- rfsrc(Surv(OS.time, OS)~., data = est_dd, \n             ntree = 1000, nodesize = rf_nodesize,\n             splitrule = 'logrank',\n             importance = T,\n             proximity = T,\n             forest = T,\n             seed = seed)\n\nvimp_result <- vimp(fit, importance = \"permute\") \nimportance_scores <- vimp_result$importance\nrid <- names(sort(importance_scores, decreasing = TRUE))  \n\n# 3. 筛选重要变量（例如保留重要性 > 0 的变量）\n# Filter important variables (e.g. keep those with importance > 0)\nrid <- rid[importance_scores[rid] > 0] \n\nest_dd2 <- est_data[, c('OS.time', 'OS', rid)]\nval_dd_list2 <- lapply(val_data_list, function(x){x[, c('OS.time', 'OS', rid)]})\nx1 <- as.matrix(est_dd2[, rid])\nx2 <- as.matrix(Surv(est_dd2$OS.time, est_dd2$OS))\nset.seed(seed)\nfit = cv.glmnet(x1, x2,\n                nfold=10, \n                family = \"binomial\", alpha = 0,\n                type.measure = \"class\")\nrs <- lapply(val_dd_list2, function(x){cbind(x[, 1:2], RS = as.numeric(predict(fit, type = 'response', newx = as.matrix(x[, -c(1, 2)]), s = fit$lambda.min)))})\ncc <- data.frame(Cindex = sapply(rs, function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n  rownames_to_column('ID')\ncc$Model <- paste0('RSF + ', 'Ridge')\nresult <- rbind(result, cc)\n\n## 1-8.RSF + StepCox\nset.seed(seed)\nfit <- rfsrc(Surv(OS.time,OS)~., data = est_dd,\n             ntree = 1000, nodesize = rf_nodesize, \n             splitrule = 'logrank',\n             importance = T,\n             proximity = T,\n             forest = T,\n             seed = seed)\n\nvimp_result <- vimp(fit, importance = \"permute\")  \nimportance_scores <- vimp_result$importance\nrid <- names(sort(importance_scores, decreasing = TRUE))  \n\n# 3. 筛选重要变量（例如保留重要性 > 0 的变量）\n# Filter important variables (e.g. keep those with importance > 0)\nrid <- rid[importance_scores[rid] > 0] \n\nest_dd2 <- est_data[, c('OS.time', 'OS', rid)]\nval_dd_list2 <- lapply(val_data_list, function(x){x[, c('OS.time', 'OS', rid)]})\nfor (direction in c(\"both\", \"backward\", \"forward\")) {\n  fit <- step(coxph(Surv(OS.time, OS)~., est_dd2), direction = direction)\n  rs <- lapply(val_dd_list2, function(x){cbind(x[, 1:2], RS=predict(fit, type = 'risk', newdata = x))})\n  cc <- data.frame(Cindex = sapply(rs, function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n    rownames_to_column('ID')\n  cc$Model <- paste0('RSF + ', 'StepCox', '[', direction, ']')\n  result <- rbind(result, cc)\n  }\n2.Enet\nx1 <- as.matrix(est_dd[, pre_var])\nx2 <- as.matrix(Surv(est_dd$OS.time, est_dd$OS))\nfor (alpha in seq(0.1, 0.9, 0.1)) {\n  set.seed(seed)\n  fit = cv.glmnet(x1, x2, family = \"cox\", alpha = alpha, nfolds = 10)\n  rs <- lapply(val_dd_list,function(x){cbind(x[, 1:2], RS = as.numeric(predict(fit,type = 'link', newx = as.matrix(x[,-c(1,2)]), s = fit$lambda.min)))})\n  cc <- data.frame(Cindex = sapply(rs,function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n    rownames_to_column('ID')\n  cc$Model <- paste0('Enet', '[α=', alpha, ']')\n  result <- rbind(result, cc)\n  }\n3.StepCox\nfor (direction in c(\"both\", \"backward\", \"forward\")) {\n  fit <- step(coxph(Surv(OS.time,OS)~., est_dd), direction = direction)\n  rs <- lapply(val_dd_list,function(x){cbind(x[, 1:2], RS = predict(fit, type = 'risk', newdata = x))})\n  cc <- data.frame(Cindex = sapply(rs, function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n    rownames_to_column('ID')\n  cc$Model <- paste0('StepCox', '[', direction, ']')\n  result <- rbind(result, cc)\n  }\nfor (direction in c(\"both\", \"backward\", \"forward\")) {\n  fit <- step(coxph(Surv(OS.time, OS)~., est_dd), direction = direction)\n  rid <- names(coef(fit))#这里不用卡P值，迭代的结果就是可以纳入的基因\n  est_dd2 <- est_data[,c('OS.time', 'OS', rid)]\n  val_dd_list2 <- lapply(val_data_list, function(x){x[, c('OS.time', 'OS', rid)]})\n  set.seed(seed)\n  pen <- optimCoxBoostPenalty(est_dd2[, 'OS.time'], est_dd2[, 'OS'], as.matrix(est_dd2[, -c(1,2)]),\n                              trace=TRUE, start.penalty = 500, parallel = T)\n  cv.res <- cv.CoxBoost(est_dd2[, 'OS.time'], est_dd2[, 'OS'], as.matrix(est_dd2[, -c(1,2)]),\n                        maxstepno = 500, K = 10 , type = \"verweij\", penalty = pen$penalty)\n  fit <- CoxBoost(est_dd2[, 'OS.time'], est_dd2[, 'OS'], as.matrix(est_dd2[, -c(1, 2)]),\n                  stepno = cv.res$optimal.step, penalty = pen$penalty)\n  rs <- lapply(val_dd_list2, function(x){cbind(x[, 1:2], RS = as.numeric(predict(fit, newdata = x[, -c(1, 2)], newtime=x[, 1], newstatus=x[,2], type=\"lp\")))})\n  cc <- data.frame(Cindex = sapply(rs,function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n    rownames_to_column('ID')\n  cc$Model <- paste0('StepCox', '[', direction, ']', ' + CoxBoost')\n  result <- rbind(result, cc)\n  x1 <- as.matrix(est_dd2[, rid])\n  x2 <- as.matrix(Surv(est_dd2$OS.time, est_dd2$OS))\n  for (alpha in seq(0.1, 0.9, 0.1)) {\n    set.seed(seed)\n    fit = cv.glmnet(x1, x2, family = \"cox\",alpha = alpha, nfolds = 10)\n    rs <- lapply(val_dd_list2, function(x){cbind(x[, 1:2], RS = as.numeric(predict(fit, type = 'link', newx = as.matrix(x[, -c(1, 2)]), s = fit$lambda.min)))})\n    cc <- data.frame(Cindex = sapply(rs,function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n      rownames_to_column('ID')\n    cc$Model <- paste0('StepCox', '[', direction, ']', ' + Enet', '[α=', alpha, ']')\n    result <- rbind(result, cc)\n    }\n  set.seed(seed)\n  fit <- gbm(formula = Surv(OS.time, OS)~., data = est_dd2, distribution = 'coxph',\n             n.trees = 10000,\n             interaction.depth = 3,\n             n.minobsinnode = 10,\n             shrinkage = 0.001,\n             cv.folds = 10,n.cores = 6)\n  \n  # 找到具有最小交叉验证误差的树数量索引\n  # find index for number trees with minimum CV error\n  best <- which.min(fit$cv.error)\n  \n  set.seed(seed)\n  fit <- gbm(formula = Surv(OS.time, OS)~., data = est_dd2, distribution = 'coxph',\n             n.trees = best,\n             interaction.depth = 3,\n             n.minobsinnode = 10,\n             shrinkage = 0.001,\n             cv.folds = 10,n.cores = 8)\n  rs <- lapply(val_dd_list2, function(x){cbind(x[,1:2], RS = as.numeric(predict(fit, x, n.trees = best, type = 'link')))})\n  cc <- data.frame(Cindex=sapply(rs, function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n    rownames_to_column('ID')\n  cc$Model <- paste0('StepCox', '[', direction, ']', ' + GBM')\n  result <- rbind(result, cc)\n  x1 <- as.matrix(est_dd2[, rid])\n  x2 <- as.matrix(Surv(est_dd2$OS.time, est_dd2$OS))\n  set.seed(seed)\n  fit = cv.glmnet(x1, x2,\n                  nfold=10, #例文描述：10-fold cross-validation\n                  family = \"binomial\", alpha = 1,\n                  type.measure = \"class\")\n  rs <- lapply(val_dd_list2, function(x){cbind(x[,1:2], RS = as.numeric(predict(fit, type = 'response', newx = as.matrix(x[, -c(1, 2)]), s = fit$lambda.min)))})\n  cc <- data.frame(Cindex = sapply(rs, function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n    rownames_to_column('ID')\n  cc$Model <- paste0('StepCox', '[', direction, ']', ' + Lasso')\n  result <- rbind(result, cc)\n  set.seed(seed)\n  cv.plsRcox.res = cv.plsRcox(list(x = est_dd2[,rid], time = est_dd2$OS.time, status = est_dd2$OS), nt = 10, verbose = FALSE)\n  fit <- plsRcox(est_dd2[, rid], time = est_dd2$OS.time,\n                 event = est_dd2$OS, nt = as.numeric(cv.plsRcox.res[5]))\n  rs <- lapply(val_dd_list2, function(x){cbind(x[, 1:2], RS = as.numeric(predict(fit, type = \"lp\", newdata = x[, -c(1,2)])))})\n  cc <- data.frame(Cindex = sapply(rs, function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n    rownames_to_column('ID')\n  cc$Model <- paste0('StepCox', '[', direction, ']', ' + plsRcox')\n  result <- rbind(result, cc)\n  x1 <- as.matrix(est_dd2[, rid])\n  x2 <- as.matrix(Surv(est_dd2$OS.time, est_dd2$OS))\n  set.seed(seed)\n  fit = cv.glmnet(x1, x2,\n                  nfold = 10, #例文描述：10-fold cross-validation\n                  family = \"binomial\", alpha = 0,\n                  type.measure = \"class\")\n  rs <- lapply(val_dd_list2, function(x){cbind(x[,1:2], RS = as.numeric(predict(fit, type = 'response', newx = as.matrix(x[, -c(1, 2)]), s = fit$lambda.min)))})\n  cc <- data.frame(Cindex = sapply(rs, function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n    rownames_to_column('ID')\n  cc$Model <- paste0('StepCox', '[', direction, ']', ' + Ridge')\n  result <- rbind(result, cc)\n  set.seed(seed)\n  fit <- rfsrc(Surv(OS.time,OS)~., data = est_dd2,\n               ntree = 1000, nodesize = rf_nodesize, #该值建议多调整\n               splitrule = 'logrank',\n               importance = T,\n               proximity = T,\n               forest = T,\n               seed = seed)\n  rs <- lapply(val_dd_list2, function(x){cbind(x[, 1:2], RS = predict(fit, newdata = x)$predicted)})\n  cc <- data.frame(Cindex = sapply(rs, function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n    rownames_to_column('ID')\n  cc$Model <- paste0('StepCox', '[', direction, ']', ' + RSF')\n  result <- rbind(result, cc)\n  data <- list(x = t(est_dd2[, -c(1, 2)]), y = est_dd2$OS.time,\n               censoring.status = est_dd2$OS,\n               featurenames = colnames(est_dd2)[-c(1,2)])\n  set.seed(seed)\n  fit <- superpc.train(data = data,type = 'survival', s0.perc = 0.5) #default\n  cv.fit <- superpc.cv(fit, data, n.threshold = 20, #default\n                       n.fold = 10,\n                       n.components = 3,\n                       min.features = 5,\n                       max.features = nrow(data$x),\n                       compute.fullcv = TRUE,\n                       compute.preval = TRUE)\n  rs <- lapply(val_dd_list2, function(w){\n    test <- list(x = t(w[, -c(1,2)]), y = w$OS.time, censoring.status = w$OS, featurenames = colnames(w)[-c(1,2)])\n    ff <- superpc.predict(fit, data, test, threshold = cv.fit$thresholds[which.max(cv.fit[[\"scor\"]][1,])], n.components = 1)\n    rr <- as.numeric(ff$v.pred)\n    rr2 <- cbind(w[,1:2], RS = rr)\n    return(rr2)\n    })\n  cc <- data.frame(Cindex = sapply(rs, function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n    rownames_to_column('ID')\n  cc$Model <- paste0('StepCox', '[', direction, ']', ' + SuperPC')\n  result <- rbind(result, cc)\n  fit = survivalsvm(Surv(OS.time,OS)~., data = est_dd2, gamma.mu = 1)\n  rs <- lapply(val_dd_list2, function(x){cbind(x[, 1:2], RS = as.numeric(predict(fit, x)$predicted))})\n  cc <- data.frame(Cindex = sapply(rs, function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n    rownames_to_column('ID')\n  cc$Model <- paste0('StepCox', '[', direction, ']', ' + survival-SVM')\n  result <- rbind(result, cc)\n  }\n4.CoxBoost\ncv.res <- cv.CoxBoost(est_dd[, 'OS.time'], est_dd[, 'OS'], as.matrix(est_dd[, -c(1,2)]), maxstepno = 500, K = 10, type = \"verweij\", penalty = pen$penalty)\nfit <- CoxBoost(est_dd[, 'OS.time'], est_dd[, 'OS'], as.matrix(est_dd[, -c(1,2)]),\n                stepno = cv.res$optimal.step, penalty = pen$penalty)\nrs <- lapply(val_dd_list, function(x){cbind(x[,1:2], RS = as.numeric(predict(fit, newdata = x[, -c(1,2)], newtime = x[,1], newstatus = x[,2], type = \"lp\")))})\ncc <- data.frame(Cindex = sapply(rs,function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n  rownames_to_column('ID')\ncc$Model <- paste0('CoxBoost')\nresult <- rbind(result, cc)\n\n## 4-2.CoxBoost + Enet\nset.seed(seed)\npen <- optimCoxBoostPenalty(est_dd[, 'OS.time'], est_dd[, 'OS'], as.matrix(est_dd[, -c(1,2)]),\n                            trace = TRUE, start.penalty = 500, parallel = T)\ncv.res <- cv.CoxBoost(est_dd[, 'OS.time'], est_dd[, 'OS'], as.matrix(est_dd[, -c(1,2)]),\n                      maxstepno = 500, K = 10, type = \"verweij\", penalty = pen$penalty)\nfit <- CoxBoost(est_dd[, 'OS.time'], est_dd[, 'OS'], as.matrix(est_dd[, -c(1,2)]),\n                stepno = cv.res$optimal.step, penalty = pen$penalty)\nrid <- as.data.frame(coef(fit))\nrid$id <- rownames(rid)\nrid <- rid[which(rid$`coef(fit)`!=0), \"id\"]\nest_dd2 <- est_data[, c('OS.time', 'OS', rid)]\nval_dd_list2 <- lapply(val_data_list, function(x){x[, c('OS.time', 'OS', rid)]})\nx1 <- as.matrix(est_dd2[, rid])\nx2 <- as.matrix(Surv(est_dd2$OS.time, est_dd2$OS))\nfor (alpha in seq(0.1, 0.9, 0.1)) {\n  set.seed(seed)\n  fit = cv.glmnet(x1, x2, family = \"cox\", alpha = alpha, nfolds = 10)\n  rs <- lapply(val_dd_list2, function(x){cbind(x[, 1:2], RS = as.numeric(predict(fit, type = 'link', newx = as.matrix(x[, -c(1,2)]), s = fit$lambda.min)))})\n  cc <- data.frame(Cindex = sapply(rs, function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n    rownames_to_column('ID')\n  cc$Model <- paste0('CoxBoost', ' + Enet', '[α=', alpha, ']')\n  result <- rbind(result, cc)\n  }\n\n## 4-3.CoxBoost + GBM\nset.seed(seed)\npen <- optimCoxBoostPenalty(est_dd[, 'OS.time'], est_dd[, 'OS'], as.matrix(est_dd[, -c(1,2)]),\n                                          trace = TRUE, start.penalty = 500, parallel = T)\ncv.res <- cv.CoxBoost(est_dd[, 'OS.time'], est_dd[, 'OS'], as.matrix(est_dd[, -c(1,2)]),\n                                    maxstepno = 500, K= 10, type = \"verweij\", penalty = pen$penalty)\nfit <- CoxBoost(est_dd[, 'OS.time'], est_dd[, 'OS'], as.matrix(est_dd[, -c(1,2)]),\n                              stepno = cv.res$optimal.step, penalty = pen$penalty)\nrid <- as.data.frame(coef(fit))\nrid$id <- rownames(rid)\nrid <- rid[which(rid$`coef(fit)`!=0), \"id\"]\nest_dd2 <- est_data[, c('OS.time', 'OS', rid)]\nval_dd_list2 <- lapply(val_data_list, function(x){x[,c('OS.time', 'OS', rid)]})\nset.seed(seed)\nfit <- gbm(formula = Surv(OS.time,OS)~., data = est_dd2, distribution = 'coxph',\n           n.trees = 10000,\n           interaction.depth = 3,\n           n.minobsinnode = 10,\n           shrinkage = 0.001,\n           cv.folds = 10, n.cores = 6)\n\n# 找到具有最小交叉验证误差的树数量索引\n# find index for number trees with minimum CV error\nbest <- which.min(fit$cv.error)\n\nset.seed(seed)\nfit <- gbm(formula = Surv(OS.time,OS)~., data = est_dd2, distribution = 'coxph',\n           n.trees = best,\n           interaction.depth = 3,\n           n.minobsinnode = 10,\n           shrinkage = 0.001,\n           cv.folds = 10,n.cores = 8)\nrs <- lapply(val_dd_list2,function(x){cbind(x[, 1:2], RS = as.numeric(predict(fit, x, n.trees = best, type = 'link')))})\ncc <- data.frame(Cindex=sapply(rs, function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n  rownames_to_column('ID')\ncc$Model <- paste0('CoxBoost + ', 'GBM')\nresult <- rbind(result, cc)\n\n## 4-4.CoxBoost + Lasso\nset.seed(seed)\npen <- optimCoxBoostPenalty(est_dd[, 'OS.time'], est_dd[, 'OS'], as.matrix(est_dd[, -c(1,2)]),\n                                          trace = TRUE, start.penalty = 500, parallel = T)\ncv.res <- cv.CoxBoost(est_dd[, 'OS.time'], est_dd[, 'OS'], as.matrix(est_dd[, -c(1,2)]),\n                                    maxstepno = 500, K = 10, type = \"verweij\", penalty = pen$penalty)\nfit <- CoxBoost(est_dd[, 'OS.time'], est_dd[, 'OS'], as.matrix(est_dd[, -c(1,2)]),\n                              stepno=cv.res$optimal.step, penalty=pen$penalty)\nrid <- as.data.frame(coef(fit))\nrid$id <- rownames(rid)\nrid <- rid[which(rid$`coef(fit)` != 0), \"id\"]\nest_dd2 <- est_data[,c('OS.time', 'OS', rid)]\nval_dd_list2 <- lapply(val_data_list, function(x){x[, c('OS.time', 'OS', rid)]})\nx1 <- as.matrix(est_dd2[, rid])\nx2 <- as.matrix(Surv(est_dd2$OS.time, est_dd2$OS))\nset.seed(seed)\nfit = cv.glmnet(x1, x2,\n                nfold = 10, \n                family = \"binomial\", alpha = 1,\n                type.measure = \"class\")\nrs <- lapply(val_dd_list2, function(x){cbind(x[,1:2], RS = as.numeric(predict(fit, type = 'response', newx = as.matrix(x[, -c(1,2)]), s = fit$lambda.min)))})\ncc <- data.frame(Cindex = sapply(rs, function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n  rownames_to_column('ID')\ncc$Model <- paste0('CoxBoost + ', 'Lasso')\nresult <- rbind(result, cc)\n\n## 4-5.CoxBoost + plsRcox\nset.seed(seed)\npen <- optimCoxBoostPenalty(est_dd[, 'OS.time'], est_dd[, 'OS'], as.matrix(est_dd[, -c(1,2)]),\n                                          trace = TRUE, start.penalty = 500, parallel = T)\ncv.res <- cv.CoxBoost(est_dd[, 'OS.time'], est_dd[, 'OS'], as.matrix(est_dd[, -c(1,2)]),\n                                    maxstepno = 500, K = 10, type = \"verweij\", penalty = pen$penalty)\nfit <- CoxBoost(est_dd[, 'OS.time'], est_dd[, 'OS'], as.matrix(est_dd[, -c(1,2)]),\n                              stepno = cv.res$optimal.step, penalty = pen$penalty)\nrid <- as.data.frame(coef(fit))\nrid$id <- rownames(rid)\nrid <- rid[which(rid$`coef(fit)` != 0), \"id\"]\nest_dd2 <- est_data[,c('OS.time', 'OS', rid)]\nval_dd_list2 <- lapply(val_data_list, function(x){x[,c('OS.time', 'OS', rid)]})\nset.seed(seed)\ncv.plsRcox.res = cv.plsRcox(list(x = est_dd2[,rid], time = est_dd2$OS.time, status = est_dd2$OS), nt = 10, verbose = FALSE)\nfit <- plsRcox(est_dd2[, rid], time = est_dd2$OS.time, event = est_dd2$OS, nt = as.numeric(cv.plsRcox.res[5]))\nrs <- lapply(val_dd_list2, function(x){cbind(x[,1:2], RS = as.numeric(predict(fit, type=\"lp\", newdata = x[, -c(1,2)])))})\ncc <- data.frame(Cindex = sapply(rs, function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n  rownames_to_column('ID')\ncc$Model <- paste0('CoxBoost + ', 'plsRcox')\nresult <- rbind(result, cc)\n\n## 4-6.CoxBoost + Ridge\nset.seed(seed)\npen <- optimCoxBoostPenalty(est_dd[, 'OS.time'], est_dd[, 'OS'], as.matrix(est_dd[, -c(1,2)]),\n                                          trace = TRUE, start.penalty = 500, parallel = T)\ncv.res <- cv.CoxBoost(est_dd[, 'OS.time'], est_dd[, 'OS'], as.matrix(est_dd[, -c(1,2)]),\n                      maxstepno = 500, K=10, type=\"verweij\", penalty = pen$penalty)\nfit <- CoxBoost(est_dd[, 'OS.time'], est_dd[, 'OS'], as.matrix(est_dd[, -c(1,2)]),\n                stepno = cv.res$optimal.step, penalty = pen$penalty)\nrid <- as.data.frame(coef(fit))\nrid$id <- rownames(rid)\nrid <- rid[which(rid$`coef(fit)` != 0), \"id\"]\nest_dd2 <- est_data[,c('OS.time', 'OS', rid)]\nval_dd_list2 <- lapply(val_data_list, function(x){x[,c('OS.time', 'OS', rid)]})\nx1 <- as.matrix(est_dd2[, rid])\nx2 <- as.matrix(Surv(est_dd2$OS.time, est_dd2$OS))\nset.seed(seed)\nfit = cv.glmnet(x1, x2,\n                nfold=10, \n                family = \"binomial\", alpha = 0,\n                type.measure = \"class\")\nrs <- lapply(val_dd_list2, function(x){cbind(x[,1:2], RS = as.numeric(predict(fit, type = 'response', newx = as.matrix(x[, -c(1,2)]), s = fit$lambda.min)))})\ncc <- data.frame(Cindex = sapply(rs,function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n  rownames_to_column('ID')\ncc$Model <- paste0('CoxBoost + ', 'Ridge')\nresult <- rbind(result, cc)\n\n## 4-7.CoxBoost + StepCox\nset.seed(seed)\npen <- optimCoxBoostPenalty(est_dd[, 'OS.time'], est_dd[, 'OS'], as.matrix(est_dd[, -c(1,2)]),\n                                          trace = TRUE, start.penalty = 500, parallel = T)\ncv.res <- cv.CoxBoost(est_dd[, 'OS.time'], est_dd[, 'OS'], as.matrix(est_dd[, -c(1,2)]),\n                                    maxstepno = 500, K = 10, type = \"verweij\", penalty = pen$penalty)\nfit <- CoxBoost(est_dd[, 'OS.time'], est_dd[, 'OS'], as.matrix(est_dd[, -c(1,2)]),\n                              stepno = cv.res$optimal.step, penalty = pen$penalty)\nrid <- as.data.frame(coef(fit))\nrid$id <- rownames(rid)\nrid <- rid[which(rid$`coef(fit)` != 0), \"id\"]\nest_dd2 <- est_data[,c('OS.time', 'OS', rid)]\nval_dd_list2 <- lapply(val_data_list, function(x){x[,c('OS.time', 'OS', rid)]})\nfor (direction in c(\"both\", \"backward\", \"forward\")) {\n  fit <- step(coxph(Surv(OS.time,OS)~., est_dd2), direction = direction)\n  rs <- lapply(val_dd_list2, function(x){cbind(x[,1:2], RS = predict(fit, type = 'risk', newdata = x))})\n  cc <- data.frame(Cindex = sapply(rs, function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n    rownames_to_column('ID')\n  cc$Model <- paste0('CoxBoost + ', 'StepCox', '[', direction, ']')\n  result <- rbind(result, cc)\n  }\ncv.res <- cv.CoxBoost(est_dd[, 'OS.time'], est_dd[, 'OS'], as.matrix(est_dd[,-c(1,2)]),\n                      maxstepno = 500, K= 10, type = \"verweij\", penalty = pen$penalty)\nfit <- CoxBoost(est_dd[, 'OS.time'], est_dd[, 'OS'], as.matrix(est_dd[,-c(1,2)]),\n                stepno = cv.res$optimal.step, penalty = pen$penalty)\nrid <- as.data.frame(coef(fit))\nrid$id <- rownames(rid)\nrid <- rid[which(rid$`coef(fit)` != 0), \"id\"]\nest_dd2 <- est_data[,c('OS.time', 'OS', rid)]\nval_dd_list2 <- lapply(val_data_list, function(x){x[,c('OS.time', 'OS', rid)]})\ndata <- list(x = t(est_dd2[, -c(1,2)]), y = est_dd2$OS.time, censoring.status = est_dd2$OS,\n             featurenames = colnames(est_dd2)[-c(1,2)])\nset.seed(seed)\nfit <- superpc.train(data = data, type = 'survival', s0.perc = 0.5) #default\ncv.fit <- superpc.cv(fit, data, n.threshold = 20, #default\n                     n.fold = 10,\n                     n.components = 3,\n                     min.features = 5,\n                     max.features = nrow(data$x),\n                     compute.fullcv = TRUE,\n                     compute.preval =TRUE)\nrs <- lapply(val_dd_list2, function(w){\n  test <- list(x=t(w[, -c(1,2)]), y = w$OS.time, censoring.status = w$OS, featurenames = colnames(w)[-c(1,2)])\n  ff <- superpc.predict(fit, data, test, threshold = cv.fit$thresholds[which.max(cv.fit[[\"scor\"]][1,])], n.components = 1)\n  rr <- as.numeric(ff$v.pred)\n  rr2 <- cbind(w[,1:2], RS = rr)\n  return(rr2)\n  })\ncc <- data.frame(Cindex = sapply(rs,function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n  rownames_to_column('ID')\ncc$Model <- paste0('CoxBoost + ', 'SuperPC')\nresult <- rbind(result, cc)\n\n## 4-9.CoxBoost + survival-SVM\nset.seed(seed)\npen <- optimCoxBoostPenalty(est_dd[, 'OS.time'], est_dd[, 'OS'], as.matrix(est_dd[, -c(1,2)]),\n                            trace = TRUE, start.penalty = 500, parallel = T)\ncv.res <- cv.CoxBoost(est_dd[, 'OS.time'], est_dd[, 'OS'], as.matrix(est_dd[, -c(1,2)]),\n                      maxstepno = 500, K = 10, type = \"verweij\", penalty = pen$penalty)\nfit <- CoxBoost(est_dd[, 'OS.time'], est_dd[, 'OS'], as.matrix(est_dd[,-c(1,2)]),\n                stepno = cv.res$optimal.step, penalty = pen$penalty)\nrid <- as.data.frame(coef(fit))\nrid$id <- rownames(rid)\nrid <- rid[which(rid$`coef(fit)` != 0), \"id\"]\nest_dd2 <- est_data[, c('OS.time', 'OS', rid)]\nval_dd_list2 <- lapply(val_data_list, function(x){x[, c('OS.time', 'OS', rid)]})\nfit = survivalsvm(Surv(OS.time, OS)~., data = est_dd2, gamma.mu = 1)\nrs <- lapply(val_dd_list2, function(x){cbind(x[, 1:2], RS = as.numeric(predict(fit, x)$predicted))})\ncc <- data.frame(Cindex = sapply(rs, function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n  rownames_to_column('ID')\ncc$Model <- paste0('CoxBoost + ', 'survival-SVM')\nresult <- rbind(result, cc)\n5.plsRcox\nset.seed(seed)\ncv.plsRcox.res = cv.plsRcox(list(x = est_dd[,pre_var], time = est_dd$OS.time, status = est_dd$OS), nt = 10, verbose = FALSE)\nfit <- plsRcox(est_dd[,pre_var], time = est_dd$OS.time, event = est_dd$OS, nt = as.numeric(cv.plsRcox.res[5]))\nrs <- lapply(val_dd_list, function(x){cbind(x[, 1:2], RS = as.numeric(predict(fit,type = \"lp\", newdata = x[, -c(1, 2)])))})\ncc <- data.frame(Cindex = sapply(rs, function(x){as.numeric(summary(coxph(Surv(OS.time,OS) ~ RS, x))$concordance[1])})) %>%\n  rownames_to_column('ID')\ncc$Model <- paste0('plsRcox')\nresult <- rbind(result, cc)\n6.superpc\ndata <- list(x = t(est_dd[, -c(1,2)]), y = est_dd$OS.time, censoring.status = est_dd$OS, featurenames = colnames(est_dd)[-c(1, 2)])\nset.seed(seed) \nfit <- superpc.train(data = data,type = 'survival', s0.perc = 0.5) \ncv.fit <- superpc.cv(fit, data, n.threshold = 20, \n                     n.fold = 10,\n                     n.components = 3,\n                     min.features = 5,\n                     max.features = nrow(data$x),\n                     compute.fullcv = TRUE,\n                     compute.preval = TRUE)\nrs <- lapply(val_dd_list, function(w){\n  test <- list(x = t(w[,-c(1,2)]), y = w$OS.time, censoring.status = w$OS, featurenames = colnames(w)[-c(1,2)])\n  ff <- superpc.predict(fit, data, test, threshold = cv.fit$thresholds[which.max(cv.fit[[\"scor\"]][1,])], n.components = 1)\n  rr <- as.numeric(ff$v.pred)\n  rr2 <- cbind(w[,1:2], RS = rr)\n  return(rr2)\n  })\ncc <- data.frame(Cindex = sapply(rs,function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n  rownames_to_column('ID')\ncc$Model <- paste0('SuperPC')\nresult <- rbind(result, cc)\n7.GBM\nset.seed(seed)\nfit <- gbm(formula = Surv(OS.time,OS)~., data = est_dd, distribution = 'coxph',\n           n.trees = 10000,\n           interaction.depth = 3,\n           n.minobsinnode = 10,\n           shrinkage = 0.001,\n           cv.folds = 10, n.cores = 6)\n\n# 找到具有最小交叉验证误差的树数量索引\n# find index for number trees with minimum CV error\nbest <- which.min(fit$cv.error)\n\nset.seed(seed)\nfit <- gbm(formula = Surv(OS.time, OS)~., data = est_dd, distribution = 'coxph',\n           n.trees = best,\n           interaction.depth = 3,\n           n.minobsinnode = 10,\n           shrinkage = 0.001,\n           cv.folds = 10, n.cores = 8)\nrs <- lapply(val_dd_list,function(x){cbind(x[,1:2], RS = as.numeric(predict(fit, x, n.trees = best, type = 'link')))})\ncc <- data.frame(Cindex = sapply(rs, function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n  rownames_to_column('ID')\ncc$Model <- paste0('GBM')\nresult <- rbind(result, cc)\n8.survivalsvm\nfit = survivalsvm(Surv(OS.time,OS)~., data = est_dd, gamma.mu = 1)\nrs <- lapply(val_dd_list, function(x){cbind(x[,1:2], RS = as.numeric(predict(fit, x)$predicted))})\ncc <- data.frame(Cindex = sapply(rs, function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n  rownames_to_column('ID')\ncc$Model <- paste0('survival - SVM')\nresult <- rbind(result, cc)\n9.Ridge\nx1 <- as.matrix(est_dd[, pre_var])\nx2 <- as.matrix(Surv(est_dd$OS.time, est_dd$OS))\nset.seed(seed)\nfit = glmnet(x1, x2, family = \"binomial\", alpha = 0, lambda = NULL)\ncvfit = cv.glmnet(x1, x2,\n                  nfold = 10, \n                  family = \"binomial\",\n                  type.measure = \"class\"\n)\n\nrs <- lapply(val_dd_list, function(x){cbind(x[, 1:2], RS = as.numeric(predict(fit, type = 'response', newx = as.matrix(x[, -c(1,2)]), s = cvfit$lambda.min)))})\ncc <- data.frame(Cindex = sapply(rs, function(x){as.numeric(summary(coxph(Surv(OS.time,OS) ~ RS, x))$concordance[1])})) %>%\n  rownames_to_column('ID')\ncc$Model <- paste0('Ridge')\nresult <- rbind(result, cc)\n10.Lasso\nx1 <- as.matrix(est_dd[, pre_var])\nx2 <- as.matrix(Surv(est_dd$OS.time, est_dd$OS))\nset.seed(seed)\nfit = cv.glmnet(x1, x2,\n                nfold = 10, \n                family = \"binomial\", alpha = 1,\n                type.measure = \"class\")\nrs <- lapply(val_dd_list, function(x){cbind(x[, 1:2], RS = as.numeric(predict(fit, type = 'response', newx = as.matrix(x[, -c(1,2)]), s = fit$lambda.min)))})\ncc <- data.frame(Cindex = sapply(rs, function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n  rownames_to_column('ID')\ncc$Model <- paste0('Lasso')\nresult <- rbind(result, cc)\n\n## 10.1.Lasso + CoxBoost\nx1 <- as.matrix(est_dd[, pre_var])\nx2 <- as.matrix(Surv(est_dd$OS.time, est_dd$OS))\nset.seed(seed)\nfit = cv.glmnet(x1, x2,\n                nfold = 10,\n                family = \"cox\", alpha = 1)\nfit$lambda.min\nmyCoefs <- coef(fit, s = \"lambda.min\");\nrid <- myCoefs@Dimnames[[1]][which(myCoefs != 0 )]\nrid <- rid[-1]\nest_dd2 <- est_data[, c('OS.time', 'OS', rid)]\nval_dd_list2 <- lapply(val_data_list, function(x){x[, c('OS.time', 'OS', rid)]})\nset.seed(seed)\npen <- optimCoxBoostPenalty(est_dd2[, 'OS.time'], est_dd2[, 'OS'], as.matrix(est_dd2[, -c(1,2)]),\n                            trace = TRUE, start.penalty = 500, parallel = T)\ncv.res <- cv.CoxBoost(est_dd2[, 'OS.time'], est_dd2[, 'OS'], as.matrix(est_dd2[, -c(1,2)]),\n                      maxstepno = 500, K = 10, type = \"verweij\", penalty = pen$penalty)\nfit <- CoxBoost(est_dd2[, 'OS.time'], est_dd2[, 'OS'], as.matrix(est_dd2[, -c(1,2)]),\n                stepno = cv.res$optimal.step, penalty = pen$penalty)\nrs <- lapply(val_dd_list2, function(x){cbind(x[,1:2], RS = as.numeric(predict(fit, newdata = x[,-c(1,2)], newtime = x[,1], newstatus = x[,2], type = \"lp\")))})\ncc <- data.frame(Cindex=sapply(rs, function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n  rownames_to_column('ID')\ncc$Model <- paste0('Lasso + CoxBoost')\nresult <- rbind(result, cc)\n\n## 10.2.Lasso + GBM\nx1 <- as.matrix(est_dd[, pre_var])\nx2 <- as.matrix(Surv(est_dd$OS.time, est_dd$OS))\nset.seed(seed)\nfit = cv.glmnet(x1, x2,\n                nfold = 10, \n                family = \"binomial\", alpha = 1,\n                type.measure = \"class\")\nfit$lambda.min\nmyCoefs <- coef(fit, s = \"lambda.min\");\nrid <- myCoefs@Dimnames[[1]][which(myCoefs != 0 )]\nrid <- rid[-1]\nest_dd2 <- est_data[,c('OS.time', 'OS', rid)]\nval_dd_list2 <- lapply(val_data_list, function(x){x[,c('OS.time', 'OS', rid)]})\nset.seed(seed)\nfit <- gbm(formula = Surv(OS.time,OS)~., data = est_dd2, distribution = 'coxph',\n                         n.trees = 10000,\n                         interaction.depth = 3,\n                         n.minobsinnode = 10,\n                         shrinkage = 0.001,\n                         cv.folds = 10, n.cores = 6)\n\n# 找到具有最小交叉验证误差的树数量索引\n# find index for number trees with minimum CV error\nbest <- which.min(fit$cv.error)\n\nset.seed(seed)\nfit <- gbm(formula = Surv(OS.time,OS)~., data = est_dd2, distribution = 'coxph',\n           n.trees = best,\n           interaction.depth = 3,\n           n.minobsinnode = 10,\n           shrinkage = 0.001,\n           cv.folds = 10, n.cores = 8)\nrs <- lapply(val_dd_list2, function(x){cbind(x[, 1:2], RS = as.numeric(predict(fit, x, n.trees = best, type = 'link')))})\ncc <- data.frame(Cindex = sapply(rs,function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])}))%>%\n  rownames_to_column('ID')\ncc$Model <- paste0('Lasso + ', 'GBM')\nresult <- rbind(result, cc)\n\n## 10.3.Lasso + plsRcox\nx1 <- as.matrix(est_dd[, pre_var])\nx2 <- as.matrix(Surv(est_dd$OS.time, est_dd$OS))\nset.seed(seed)\nfit = cv.glmnet(x1, x2,\n                nfold = 10, \n                family = \"binomial\", alpha = 1,\n                type.measure = \"class\")\nfit$lambda.min\nmyCoefs <- coef(fit, s = \"lambda.min\");\nrid <- myCoefs@Dimnames[[1]][which(myCoefs != 0 )]\nrid <- rid[-1]\nest_dd2 <- est_data[,c('OS.time', 'OS', rid)]\nval_dd_list2 <- lapply(val_data_list, function(x){x[,c('OS.time', 'OS', rid)]})\nset.seed(seed)\ncv.plsRcox.res = cv.plsRcox(list(x = est_dd2[, rid], time = est_dd2$OS.time, status = est_dd2$OS), nt = 10, verbose = FALSE)\nfit <- plsRcox(est_dd2[, rid], time = est_dd2$OS.time, event = est_dd2$OS, nt = as.numeric(cv.plsRcox.res[5]))\nrs <- lapply(val_dd_list2, function(x){cbind(x[, 1:2], RS = as.numeric(predict(fit, type = \"lp\", newdata = x[,-c(1,2)])))})\ncc <- data.frame(Cindex = sapply(rs, function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n  rownames_to_column('ID')\ncc$Model <- paste0('Lasso + ', 'plsRcox')\nresult <- rbind(result, cc)\n\n## 10.4.Lasso + RSF\nx1 <- as.matrix(est_dd[, pre_var])\nx2 <- as.matrix(Surv(est_dd$OS.time, est_dd$OS))\nset.seed(seed)\nfit = cv.glmnet(x1, x2,\n                nfold = 10, \n                family = \"binomial\", alpha = 1,\n                type.measure = \"class\")\nfit$lambda.min\nmyCoefs <- coef(fit, s = \"lambda.min\");\nrid <- myCoefs@Dimnames[[1]][which(myCoefs != 0 )]\nrid<-rid[-1]\nest_dd2 <- est_data[,c('OS.time', 'OS', rid)]\nval_dd_list2 <- lapply(val_data_list, function(x){x[, c('OS.time', 'OS', rid)]})\nset.seed(seed)\nfit <- rfsrc(Surv(OS.time,OS)~., data = est_dd2,\n             ntree = 1000, nodesize = rf_nodesize, \n             splitrule = 'logrank',\n             importance = T,\n             proximity = T,\n             forest = T,\n             seed = seed)\nrs <- lapply(val_dd_list2, function(x){cbind(x[, 1:2], RS = predict(fit, newdata = x)$predicted)})\ncc <- data.frame(Cindex = sapply(rs, function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n  rownames_to_column('ID')\ncc$Model <- paste0('Lasso', ' + RSF')\nresult <- rbind(result, cc)\n\n## 10.5.Lasso + stepcox\nx1 <- as.matrix(est_dd[, pre_var])\nx2 <- as.matrix(Surv(est_dd$OS.time, est_dd$OS))\nset.seed(seed)\nfit = cv.glmnet(x1, x2,\n                nfold = 10, \n                family = \"binomial\", alpha = 1,\n                type.measure = \"class\")\nfit$lambda.min\nmyCoefs <- coef(fit, s = \"lambda.min\");\nrid <- myCoefs@Dimnames[[1]][which(myCoefs != 0 )]\nrid <- rid[-1]\nest_dd2 <- est_data[, c('OS.time', 'OS', rid)]\nval_dd_list2 <- lapply(val_data_list, function(x){x[, c('OS.time', 'OS', rid)]})\nfor (direction in c(\"both\", \"backward\", \"forward\")) {\n  fit <- step(coxph(Surv(OS.time,OS)~., est_dd2), direction = direction)\n  rs <- lapply(val_dd_list2, function(x){cbind(x[, 1:2], RS = predict(fit, type = 'risk', newdata = x))})\n  cc <- data.frame(Cindex = sapply(rs, function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n    rownames_to_column('ID')\n  cc$Model <- paste0('Lasso + ', 'StepCox', '[', direction, ']')\n  result <- rbind(result, cc)\n  }\nmyCoefs <- coef(fit, s = \"lambda.min\");\nrid <- myCoefs@Dimnames[[1]][which(myCoefs != 0 )]\nrid <- rid[-1]\nest_dd2 <- est_data[,c('OS.time', 'OS', rid)]\nval_dd_list2 <- lapply(val_data_list, function(x){x[, c('OS.time', 'OS', rid)]})\ndata <- list(x = t(est_dd2[,-c(1,2)]), y = est_dd2$OS.time, censoring.status = est_dd2$OS,\n                           featurenames = colnames(est_dd2)[-c(1,2)])\nset.seed(seed)\nfit <- superpc.train(data = data,type = 'survival', s0.perc = 0.5) \ncv.fit <- superpc.cv(fit,data,n.threshold = 20, \n                     n.fold = 10,\n                     n.components = 3,\n                     min.features = 5,\n                     max.features = nrow(data$x),\n                     compute.fullcv = TRUE,\n                     compute.preval = TRUE)\nrs <- lapply(val_dd_list2, function(w){\n  test <- list(x = t(w[,-c(1,2)]), y = w$OS.time, censoring.status = w$OS, featurenames = colnames(w)[-c(1,2)])\n  ff <- superpc.predict(fit, data, test, threshold = cv.fit$thresholds[which.max(cv.fit[[\"scor\"]][1,])], n.components = 1)\n  rr <- as.numeric(ff$v.pred)\n  rr2 <- cbind(w[, 1:2], RS = rr)\n  return(rr2)\n  })\ncc <- data.frame(Cindex = sapply(rs, function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n  rownames_to_column('ID')\ncc$Model <- paste0('Lasso + ', 'SuperPC')\nresult <- rbind(result, cc)\n\n## 10.7.Lasso + survival-SVM\nx1 <- as.matrix(est_dd[, pre_var])\nx2 <- as.matrix(Surv(est_dd$OS.time, est_dd$OS))\nset.seed(seed)\nfit = cv.glmnet(x1, x2,\n                nfold = 10, \n                family = \"binomial\", alpha = 1,\n                type.measure = \"class\")\nfit$lambda.min\nmyCoefs <- coef(fit, s = \"lambda.min\");\nrid <- myCoefs@Dimnames[[1]][which(myCoefs != 0 )]\nrid <- rid[-1]\nest_dd2 <- est_data[,c('OS.time', 'OS', rid)]\nval_dd_list2 <- lapply(val_data_list, function(x){x[,c('OS.time', 'OS', rid)]})\nfit = survivalsvm(Surv(OS.time,OS)~., data = est_dd2, gamma.mu = 1)\nrs <- lapply(val_dd_list2, function(x){cbind(x[,1:2], RS = as.numeric(predict(fit, x)$predicted))})\ncc <- data.frame(Cindex = sapply(rs, function(x){as.numeric(summary(coxph(Surv(OS.time, OS) ~ RS, x))$concordance[1])})) %>%\n  rownames_to_column('ID')\ncc$Model <- paste0('Lasso + ', 'survival-SVM')\nresult <- rbind(result, cc)\n\n# 将得到的结果赋给result2变量进行操作\n# Assign the obtained results to variable result2 for processing\nresult2 <- result %>%\n  group_by(Model, ID) %>%\n  summarise(Cindex = mean(Cindex), .groups = \"drop\")\n\n### 将结果的长数据转换为宽数据\n### Convert long format results to wide format\ndd2 <- pivot_wider(result2, names_from = 'ID', values_from = 'Cindex') %>% as.data.frame()\n\n# 将C指数定义为数值型\n# Define C-index as numeric type\ndd2[,-1] <- apply(dd2[,-1], 2, as.numeric)\n\n# 求每个模型的C指数在三个数据集的均值\n# Calculate mean C-index across three datasets for each model\ndd2$All <- apply(dd2[,2:4], 1, mean)\n\n# 求每个模型的C指数在GEO验证集的均值\n# Calculate mean C-index in GEO validation sets for each model\ndd2$GEO <- apply(dd2[,3:4], 1, mean)\n\n###查看每个模型的C指数\n### View C-index for each model\nhead(dd2)\n#输出C指数结果\n# Output C-index results\nwrite.table(dd2,\"output_C_index.txt\", col.names = T, row.names = F, sep = \"\\t\", quote = F)\n\n# 这里原文仅看了GEO验证集的C指数均值，可以看到StepCox[forward] + lasso的模型组合在GEO验证集的平均C指数最高\n# The original text only examined GEO validation set's mean C-index, showing StepCox[forward] + lasso had highest average C-index\n\n### StepCox[forward] + lasso构建预测模型\n### Build predictive model with StepCox[forward] + lasso\nfit <- step(coxph(Surv(OS.time,OS)~., est_dd), direction = \"forward\")\nmultiCoxSum = summary(fit)\noutTab = data.frame()\noutTab = cbind(\n  coef = multiCoxSum$coefficients[,\"coef\"],\n  HR = multiCoxSum$conf.int[,\"exp(coef)\"],\n  HR.95L = multiCoxSum$conf.int[,\"lower .95\"],\n  HR.95H = multiCoxSum$conf.int[,\"upper .95\"],\n  pvalue = multiCoxSum$coefficients[,\"Pr(>|z|)\"])\noutTab <- as.data.frame(outTab)\noutTab = cbind(id = row.names(outTab), outTab)\n\n# 输出多因素cox结果\n# Output multivariate Cox results\nwrite.table(outTab, file = \"output_multiCox.txt\", sep = \"\\t\", row.names = F, quote = F)\n\n# 多因素cox并没有基因的剔除，因此用全部基因做lasso\n# 这里不用卡P值，迭代的结果就是可以纳入的基因\n# Multivariate Cox didn't exclude any genes, so using all genes for lasso\n# No need to filter by p-value here, iteration results indicate includable genes\nrid <- names(coef(fit)) \n\n# 训练集\n# Training set\nest_dd2 <- est_data[,c('OS.time', 'OS', rid)]\n\n# 验证集\n# Validation sets\nval_dd_list2 <- lapply(val_data_list, function(x){x[,c('OS.time', 'OS', rid)]})\n\nx1 <- as.matrix(est_dd2[,rid])\nx2 <- as.matrix(Surv(est_dd2$OS.time, est_dd2$OS))\nset.seed(seed)\nfit = glmnet(x1, x2, family = \"binomial\", alpha = 1, lambda = NULL)\nmypal <- pal_npg(\"nrc\")(10)\n开始画图\nPlotting\n图B - Lasso作图\nFigure B - Lasso plot\npdf(\"A_lasso.pdf\", width = 8, height = 6)\nplot(fit, xvar = \"dev\", label = TRUE, lwd = 2, col = mypal, font.axis = 2,\n     font.axis = 2,font.main = 2)\ndev.off()\ncvfit = cv.glmnet(x1, x2,\n                  nfold = 10, \n                  family = \"binomial\",\n                  type.measure = \"class\"\n)\ncvfit$lambda.min\nmyCoefs <- coef(cvfit, s = \"lambda.min\");\nlasso_fea <- myCoefs@Dimnames[[1]][which(myCoefs != 0 )]\n(lasso_fea <- lasso_fea[-1])\nwrite.csv(lasso_fea,\"output_feature_lasso.csv\")\n\npdf(\"B_lasso.pdf\", width = 8, height = 6)\nplot(cvfit, lwd = 2, col = mypal, font.axis = 2,\n     font.axis = 2, font.main = 2, font.sub = 2)\ndev.off()\nfit = cv.glmnet(x1, x2,\n                nfold = 10, \n                family = \"binomial\", alpha = 1,\n                type.measure = \"class\")\n\n### 根据StepCox[forward] + lasso得到三个数据集每个样本的风险分数\n### Calculate risk scores for each sample in three datasets using StepCox[forward] + lasso\nrs <- lapply(val_dd_list2, function(x){cbind(x[,1:2], RS = as.numeric(predict(fit, type = 'response', newx = as.matrix(x[,-c(1,2)]), s = fit$lambda.min)))})\nA_lasso.pdf可以把基因名标注在图上，方法可参考FigureYa31lasso\nFor A_lasso.pdf, gene names can be labeled on the plot. Refer to\nFigureYa31lasso for method:\n图A - C指数的热图\nFigure A - Heatmap of C-indices\nlibrary(ComplexHeatmap)\nlibrary(circlize)\nlibrary(RColorBrewer)\n\n# 根据C指数排序\n# Sort by C-index value\ndd2 <- dd2[order(dd2$GEO, decreasing = T),]\n\n# 仅绘制GEO验证集的C指数热图\n# Create heatmap data using only GEO validation sets' C-indices\ndt <- dd2[, 3:4]\nrownames(dt) <- dd2$Model\ncol_ha <- HeatmapAnnotation(which = \"col\", Cohort = c(\"GSE57303\",\"GSE62254\"),\n                            annotation_name_gp = gpar(fontsize = 9, fontface = \"bold\"),\n                            annotation_name_side = \"left\",\n                            col = list(Cohort=c(\"GSE57303\"=\"#00A087B2\",\n                                                \"GSE62254\"=\"#3C5488B2\")),\n                            annotation_legend_param = list(Cohort=list(title = \"Cohort\",\n                                                                       title_position = \"topleft\",\n                                                                       title_gp = gpar(fontsize = 12, fontface = \"bold\"),\n                                                                       labels_rot = 0,\n                                                                       legend_height = unit(1,\"cm\"),\n                                                                       legend_width = unit(5,\"mm\"),\n                                                                       labels_gp = gpar(fontsize = 9,\n                                                                                        fontface = \"bold\"))\n                                                           )\n                            )\n# 行注释\n# Row annotations\nrow_ha <- rowAnnotation('Mean Cindex' = anno_barplot(round(rowMeans(dt), 3), bar_width = 1, add_numbers = T,\n                                                     labels = c(\"Mean Cindex\"), height = unit(1, \"mm\"),\n                                                     gp = gpar(col = \"white\", fill = \"skyblue1\"), numbers_gp = gpar(fontsize = 8),\n                                                     axis_param = list(at = c(0, 0.5, 1),\n                                                                       labels = c(\"0\", \"0.5\", \"1\")),\n                                                     width = unit(2.5, \"cm\")),\n                        annotation_name_side = \"bottom\",\n                        annotation_name_gp = gpar(fontsize = 9, fontface = \"bold\", angle = 90))\n\n# 自定义图形，主要是热图右侧的条形图\n# Custom cell function to display values in heatmap cells\ncell_fun <- function(j, i, x, y, width, height, fill) {\n  grid.text(\n    round(dt[i, j], 2), \n    x, y,\n    gp = gpar(\n      fontsize = 8\n    ))\n}\n\n# 画出热图\n# Generate heatmap\npdf(\"ComplexHeatmap.pdf\", width = 10, height = 18)\nheatmap <- Heatmap(dt,name = \" \",\n                   heatmap_legend_param = list(title=\"\",title_position = \"topleft\", labels_rot = 0,\n                                               legend_height = unit(8,\"cm\"),\n                                               legend_width = unit(5,\"mm\"),\n                                               labels_gp = gpar(fontsize = 15, fontface = \"bold\")),\n                   border = TRUE,\n                   column_split = c(\"GSE57303\",\"GSE62254\"),\n                   column_gap = unit(3, \"mm\"),\n                   show_column_names = F,\n                   show_row_names = T,\n                   col = colorRamp2(c(0.4,0.55,0.7), c(\"#4DBBD5B2\", \"white\", \"#E64B35B2\")), \n                   column_title =\"\", \n                   #row_title =\"Intersect Gene\",\n                   column_title_side = \"top\",\n                   row_title_side = \"left\",\n                   row_title_rot = 90, \n                   column_title_gp = gpar(fontsize = 12, fontface = \"bold\",col = \"black\"), \n                   #row_title_gp = gpar(fontsize = 15, fontface = \"bold\",col = \"black\"),\n                   cluster_columns =F,\n                   cluster_rows = F,\n                   column_order = c(colnames(dt)),\n                   show_row_dend = F, \n                   cell_fun = cell_fun,\n                   top_annotation = col_ha,\n                   right_annotation = row_ha\n)\ndraw(heatmap)\ndev.off()\n图C - 模型比较\nFigure C - Model Comparison\n# 首先获取TCGA样本的StepCox[forward] + lasso模型的风险分数\n# First get risk scores from StepCox[forward] + lasso model for TCGA samples\nrs_tcga <- rs$TCGA\nrs_GSE57303 <- rs$GSE57303\nrs_GSE62254 <- rs$GSE62254\nrownames(rs_tcga) <- tcga$sample\nrownames(rs_GSE57303) <- GSE57303$sample\nrownames(rs_GSE62254) <- GSE62254$sample\nhead(rs_tcga)\n# 这里原文是与其他模型进行比较，其实就是在rs_tcga第四列开始加上每个样本在其他模型的风险分数\n# 这里我们将每个数据集的4到10列随机生成一些数，作为样本在其他模型的风险分数\n# The original text compares with other models by adding risk scores from other models\n# Here we randomly generate numbers for columns 4-10 as risk scores from other models\nfor (i in 4:10) {\n  rs_tcga[,i] <- runif(nrow(rs_tcga), min = 1, max = 10)\n  names(rs_tcga)[i] <- paste0(\"Set\", i)\n}\nfor (i in 4:10) {\n  rs_GSE57303[,i] <- runif(nrow(rs_GSE57303), min = 1, max = 10)\n  names(rs_GSE57303)[i] <- paste0(\"Set\", i)\n}\nfor (i in 4:10) {\n  rs_GSE62254[,i] <- runif(nrow(rs_GSE62254), min = 1, max = 10)\n  names(rs_GSE62254)[i] <- paste0(\"Set\", i)\n}\n### 这里的模型比较*号的意思是：其他模型的C指数与RS相比差异是否显著\n### The asterisks in model comparison indicate whether C-index differences from RS are significant\n\n### 第一步，计算模型的C指数\n### Step 1: Calculate C-indices for each model\n\n# 先将每种模型分别存入列表中\n# Store each model's results in a list\nlist_tcga <- list(RS = rs_tcga[,c(1:2,3)], Set4 = rs_tcga[,c(1:2,4)],\n                Set5 = rs_tcga[,c(1:2,5)], Set6 = rs_tcga[,c(1:2,6)],\n                Set7 = rs_tcga[,c(1:2,7)], Set8 = rs_tcga[,c(1:2,8)],\n                Set9 = rs_tcga[,c(1:2,9)], Set10 = rs_tcga[,c(1:2,10)])\ncc_tcga <- data.frame(Cindex = sapply(list_tcga,function(x){as.numeric(summary(coxph(Surv(OS.time, OS)~., x))$concordance[1])}),\n                      se = sapply(list_tcga,function(x){as.numeric(summary(coxph(Surv(OS.time, OS)~.,x))$concordance[2])})) %>%\n  rownames_to_column('ID')\n\nlist_GSE57303 <- list(RS = rs_GSE57303[,c(1:2,3)], Set4 = rs_GSE57303[,c(1:2,4)],\n                Set5 = rs_GSE57303[,c(1:2,5)], Set6 = rs_GSE57303[,c(1:2,6)],\n                Set7 = rs_GSE57303[,c(1:2,7)], Set8 = rs_GSE57303[,c(1:2,8)],\n                Set9 = rs_GSE57303[,c(1:2,9)], Set10 = rs_GSE57303[,c(1:2,10)])\ncc_GSE57303 <- data.frame(Cindex = sapply(list_GSE57303, function(x){as.numeric(summary(coxph(Surv(OS.time, OS)~., x))$concordance[1])}),\n                      se = sapply(list_GSE57303, function(x){as.numeric(summary(coxph(Surv(OS.time, OS)~., x))$concordance[2])})) %>%\n  rownames_to_column('ID')\n\nlist_GSE62254 <- list(RS = rs_GSE62254[,c(1:2,3)], Set4 = rs_GSE62254[,c(1:2,4)],\n                Set5 = rs_GSE62254[,c(1:2,5)], Set6 = rs_GSE62254[,c(1:2,6)],\n                Set7 = rs_GSE62254[,c(1:2,7)], Set8 = rs_GSE62254[,c(1:2,8)],\n                Set9 = rs_GSE62254[,c(1:2,9)], Set10 = rs_GSE62254[,c(1:2,10)])\ncc_GSE62254 <- data.frame(Cindex = sapply(list_GSE62254, function(x){as.numeric(summary(coxph(Surv(OS.time, OS)~., x))$concordance[1])}),\n                      se = sapply(list_GSE62254, function(x){as.numeric(summary(coxph(Surv(OS.time, OS)~., x))$concordance[2])})) %>%\n  rownames_to_column('ID')\n\n### 第二步，计算其他模型C指数与RS差异的显著性\n### Step 2: Calculate significance of differences between other models' C-indices and RS\nrt <- rs_tcga\ntcga_compareC_p <- data.frame(Var = colnames(rt[, 4:10]), pval = c(1:length(colnames(rt[, 4:10]))))\nfor (i in colnames(rt[, 4:10])) {\n  p <- compareC(rt$OS.time, rt$OS, rt$RS, rt[,i])$pval\n  tcga_compareC_p[which(tcga_compareC_p$Var == i), 2] <- p\n}\nwrite.table(tcga_compareC_p,\"output_TCGA_Cindex_p.txt\", col.names = T, row.names = F, sep = \"\\t\", quote = F)\n\nrt <- rs_GSE57303\nGSE57303_compareC_p <- data.frame(Var=colnames(rt[, 4:10]),pval=c(1:length(colnames(rt[, 4:10]))))\nfor (i in colnames(rt[, 4:10])) {\n  p <- compareC(rt$OS.time, rt$OS, rt$RS, rt[, i])$pval\n  GSE57303_compareC_p[which(GSE57303_compareC_p$Var == i), 2] <- p\n}\nwrite.table(GSE57303_compareC_p, \"output_GSE57303_Cindex_p.txt\", col.names = T, row.names = F, sep = \"\\t\", quote = F)\n\nrt <- rs_GSE62254\nGSE62254_compareC_p <- data.frame(Var = colnames(rt[, 4:10]), pval = c(1:length(colnames(rt[, 4:10]))))\nfor (i in colnames(rt[, 4:10])) {\n  p <- compareC(rt$OS.time, rt$OS, rt$RS, rt[,i])$pval\n  GSE62254_compareC_p[which(GSE62254_compareC_p$Var == i), 2] <- p\n}\nwrite.table(GSE62254_compareC_p, \"output_GSE62254_Cindex_p.txt\", col.names = T, row.names = F, sep = \"\\t\", quote = F)\n\n### 第三步，将C指数，置信区间，差异显著性整合\n### Step 3: Integrate C-indices, confidence intervals and significance\n\n# 添加一行，使得两个数据可以直接合并\n# Add a row so datasets can be merged directly\ntcga_compareC_p <- rbind(c(\"RS\", 1), tcga_compareC_p)\nGSE57303_compareC_p <- rbind(c(\"RS\", 1), GSE57303_compareC_p)\nGSE62254_compareC_p <- rbind(c(\"RS\", 1), GSE62254_compareC_p)\n\n# 合并两个数据\n# Merge the two datasets\nall_tcga <- data.frame(cc_tcga, p = tcga_compareC_p[, 2])\nall_GSE57303 <- data.frame(cc_GSE57303, p = GSE57303_compareC_p[, 2])\nall_GSE62254 <- data.frame(cc_GSE62254, p = GSE62254_compareC_p[, 2])\n\n### 第四步，画图\n### Step 4: Plotting\ndd <- all_tcga\n\n# 将p值转换为*号\n# Convert p-values to asterisks\ndd$ll <- ifelse(dd$p < 0.0001, '****', ifelse(dd$p < 0.001, '***', ifelse(dd$p < 0.01, '**', ifelse(dd$p < 0.05, '*', ''))))\nrownames(dd) <- NULL\n\nggplot(dd, aes(Cindex, reorder(ID, Cindex))) +\n  geom_errorbarh(aes(xmax = Cindex + se, xmin = Cindex - se), color = \"black\", height = 0, size = 0.7) + \n  geom_point(size = 4, shape = 21, fill = pal_nejm()(10)[1]) + # 绘制点图\n  ylab(NULL) + xlab(NULL) +\n  labs(title =\"TCGA\") +\n  geom_vline(xintercept = 0.6, linetype = 'dashed', size = 0.5, color = 'grey50') + \n  theme_bw(base_rect_size = 1) +\n  theme(panel.grid = element_blank(),\n        axis.text.y = element_text(size = 12),\n        axis.text.x = element_text(size = 12),\n        axis.title = element_text(size = 13),\n        plot.title = element_text(hjust = 0.5, size = 15),\n        legend.position = 'none',\n        strip.text = element_text(size = 14)) + \n  geom_text(aes(x = 0.89, y = ID, label = ll), color = 'black', size = 3, vjust = 0.76) + \n  scale_x_continuous(breaks = c(0.5,0.7,0.9), limits = c(0.4, 0.94))\nggsave(\"tcga_model_compare.pdf\", width = 6, height = 8)\n\n# 在另外两个数据集中进行同样的操作\n# Perform the same operation in the other two datasets\ndd <- all_GSE57303\ndd$ll <- ifelse(dd$p < 0.0001, '****', ifelse(dd$p < 0.001, '***', ifelse(dd$p < 0.01, '**', ifelse(dd$p < 0.05, '*', ''))))\nrownames(dd) <- NULL\n\nggplot(dd, aes(Cindex, reorder(ID, Cindex))) +\n  geom_errorbarh(aes(xmax = Cindex + se, xmin = Cindex - se), color = \"black\", height = 0, size = 0.7) +\n  geom_point(size = 4, shape = 21, fill = pal_nejm()(10)[1]) +\n  ylab(NULL) + xlab(NULL) +\n  labs(title =\"GSE57303\") +\n  geom_vline(xintercept = 0.6, linetype = 'dashed', size = 0.5, color = 'grey50') +\n  theme_bw(base_rect_size = 1) +\n  theme(panel.grid = element_blank(),\n        axis.text.y = element_text(size = 12),\n        axis.text.x = element_text(size = 12),\n        axis.title = element_text(size = 13),\n        plot.title = element_text(hjust = 0.5, size = 15),\n        legend.position = 'none',\n        strip.text = element_text(size = 14)) + \n  geom_text(aes(x = 0.89, y = ID, label = ll), color = 'black', size = 3, vjust = 0.76) +\n  scale_x_continuous(breaks = c(0.5, 0.7, 0.9), limits = c(0.4, 0.94))\nggsave(\"GSE57303_model_compare.pdf\", width = 6, height = 8)\n\ndd <- all_GSE62254\ndd$ll <- ifelse(dd$p < 0.0001, '****', ifelse(dd$p < 0.001, '***', ifelse(dd$p < 0.01, '**', ifelse(dd$p < 0.05, '*', ''))))\nrownames(dd) <- NULL\n\nggplot(dd, aes(Cindex, reorder(ID, Cindex))) +\n  geom_errorbarh(aes(xmax = Cindex + se, xmin = Cindex-se), color = \"black\", height = 0, size = 0.7) +\n  geom_point(size = 4, shape = 21, fill = pal_nejm()(10)[1]) +\n  ylab(NULL) + xlab(NULL) +\n  labs(title =\"GSE62254\") +\n  geom_vline(xintercept = 0.6, linetype = 'dashed', size = 0.5, color = 'grey50') +\n  theme_bw(base_rect_size = 1) +\n  theme(panel.grid = element_blank(),\n        axis.text.y = element_text(size = 12),\n        axis.text.x = element_text(size = 12),\n        axis.title = element_text(size = 13),\n        plot.title = element_text(hjust = 0.5, size = 15),\n        legend.position = 'none',\n        strip.text = element_text(size = 14)) + \n  geom_text(aes(x = 0.89, y = ID, label = ll), color = 'black', size = 3, vjust = 0.76) +\n  scale_x_continuous(breaks = c(0.5,0.7,0.9), limits = c(0.4,0.94))\nggsave(\"GSE62254_model_compare.pdf\", width = 6, height = 8)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa293machineLearning_FigureYa293machineLearning",
      "title": "FigureYa293machineLearning/FigureYa293machineLearning.html",
      "html": "FigureYa293machineLearning/FigureYa293machineLearning.html",
      "text": "texts/main_FigureYa293machineLearning_FigureYa293machineLearning.txt",
      "folder": "FigureYa293machineLearning",
      "thumb": "gallery_compress/FigureYa293machineLearning.webp"
    },
    "word_count": 6830,
    "lines_count": 1363,
    "title": "FigureYa293machineLearningV2",
    "description": "Demand description 这个文章里比较不同的模型放在一个图，以及比较不同的算法放在一个图。 In this article, different models are compared in one graph, and",
    "input_data_types": [
      "临床数据",
      "生存数据"
    ],
    "output_types": [
      "热图",
      "统计表格",
      "箱线图",
      "生存曲线"
    ],
    "technical_methods": [
      "标准化",
      "生存分析",
      "质量控制"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "maxstepno",
      "seed",
      "annotation_legend_param",
      "newdata",
      "cluster_columns",
      "xmax",
      "fit",
      "cvfit"
    ]
  },
  {
    "id": "main_FigureYa222PCAgene_FigureYa222PCAgene",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa222PCAgene_FigureYa222PCAgene.txt",
    "content": "FigureYa222PCAgene_副本.Rmd\nFigureYa222PCAgene\nZongcheng Li; Ying Ge, Yijing Chen\n2025-5-20\n需求描述\nrequirement description\n这个PCA很特别\nThis PCA is quite special.\n出自\nhttps://linkinghub.elsevier.com/retrieve/pii/S0092867420300568\n图3. 卵母细胞亚型在逐步发育阶段的动态基因表达模式\n(A) 基于主成分1（PC1）和主成分2（PC2）所呈现的基因表达模式，PCA图显示四种卵母细胞亚型。\n(B) 沿PC1维度，对卵母细胞发育至关重要的代表性基因的相对基因表达模式。\nfrom\nhttps://linkinghub.elsevier.com/retrieve/pii/S0092867420300568\nFigure 3. Dynamic Gene-Expression Patterns of Oocyte Subtypes at Stepwise Developmental Stages\n(A) PCA plot showing four oocyte subtypes based on gene-expression patterns exhibited by PC1 and PC2.\n(B) Relative gene-expression patterns of representative genes essential for oocyte development along the PC1 dimension.\n应用场景\napplication scenario\n单细胞RNA-seq，从PCA结果就能看出基因表达模式跟细胞类型的关系。\n原文：Principal component analysis (PCA) revealed that the four oocyte subtypes were distributed along the principal component 1 (PC1) dimension (Figure 3A; Table S2).\nConsistently, the relative expression levels of\ngenes known to be essential for follicular development also varied along PC1 axis\n(Figures 3B and S3A). Genes promoting follicle development, such as ZP1, BMP15, and GDF9, were progressively\nupregulated from oocyte subtype C1 to C4\n. Meiotic M phase genes WEE2 and AURKA as well as DNA methyltransferase, DNMT1 and DNMT3A, were also gradually upregulated from subtype C1 to C4 (Figures 3B and S3A).\nSingle-cell RNA-seq, the relationship between gene expression patterns and cell types can be discerned directly from the PCA results.\nOriginal text: Principal component analysis (PCA) revealed that the four oocyte subtypes were distributed along the principal component 1 (PC1) dimension (Figure 3A; Table S2).\nConsistently, the relative expression levels of\ngenes known to be essential for follicular development also varied along PC1 axis\n(Figures 3B and S3A). Genes promoting follicle development, such as ZP1, BMP15, and GDF9, were progressively\nupregulated from oocyte subtype C1 to C4\n. Meiotic M phase genes WEE2 and AURKA as well as DNA methyltransferase, DNMT1 and DNMT3A, were also gradually upregulated from subtype C1 to C4 (Figures 3B and S3A).\n环境设置\nenvironment setting\n使用国内镜像安装包\nuse the domestic mirror installation package\nxxxxxxxxxx\noptions\n(\n\"repos\"\n=\nc\n(\nCRAN\n=\n\"https://mirrors.tuna.tsinghua.edu.cn/CRAN/\"\n))\noptions\n(\nBioC_mirror\n=\n\"http://mirrors.tuna.tsinghua.edu.cn/bioconductor/\"\n)\ninstall.packages\n(\n\"leiden\"\n)\ninstall.packages\n(\n\"spatstat\"\n)\ninstall.packages\n(\n\"uwot\"\n)\ninstall.packages\n(\n\"ggbeeswarm\"\n)\n加载包\nload package\nxxxxxxxxxx\nlibrary\n(\nSeurat\n)\nlibrary\n(\nmagrittr\n)\nlibrary\n(\nggplot2\n)\nSys.setenv\n(\nLANGUAGE\n=\n\"en\"\n)\n#显示英文报错信息 display English error messages\noptions\n(\nstringsAsFactors\n=\nFALSE\n)\n#禁止chr转成factor prohibit the conversion of chr to factor\n输入文件\nInput file\nsc.seurat.Rdata，单细胞RNA-seq预处理获得的文件。出自FigureYa206scHeatmap，文件较大，已上传至微云\nhttps://share.weiyun.com/vZiSM9pB\n怎样获得这个文件？拖到文末看“附：单细胞RNA-seq数据预处理”\nsc.seurat.Rdata, the file obtained from single-cell RNA-seq preprocessing. It originates from FigureYa206scHeatmap. The file is relatively large and has been uploaded to Weiyun\nhttps://share.weiyun.com/vZiSM9pB\nHow to obtain this file? Scroll to the end of the document and see \"Appendix: Single-cell RNA-seq Data Preprocessing\"\nxxxxxxxxxx\n(\nload\n(\n\"sc.seurat.Rdata\"\n))\nPCA\n原文采用的聚类方法\nThe clustering method employed in the original text\n例文的非监督聚类方法比较特殊，以SCENIC的分析结果作为输入（SCENIC的用法可参考FigureYa194pySCENIC），用modified ‘clustering-and-classification’ algorithm (Lake et al., 2016) 给细胞做聚类。clustering-and-classification也是个很有趣的半监督聚类算法，如果有需要，我们后面再众筹。\nThe unsupervised clustering method used in the example text is quite unique, taking the analysis results from SCENIC as input (for the usage of SCENIC, you can refer to FigureYa194pySCENIC), and applying modified 'clustering-and-classification' algorithm (Lake et al., 2016) to cluster the cells. The clustering-and-classification is also an interesting semi-supervised clustering algorithm, and if needed, we can consider crowdfunding it later on.\n我们用Seurat自带的无监督聚类\nWe employ Seurat's built-in unsupervised clustering\nx\n## 提取oocytes subtype的细胞的数据\n# 从文章附件获得oocytes subtype的细胞ID（191 young oocytes, 227 old oocytes）\n# 这里用到第一列cell ID，用于提取oocytes subtype的细胞\n## Extract data for oocyte subtype cells\n# Obtain cell IDs for oocyte subtypes from article attachments (191 young oocytes, 227 old oocytes)\n# Utilise the first column cell ID to extract cells for oocyte subtypes\nmeta_oo\n<-\nreadxl\n::\nread_excel\n(\npath\n=\n\"1-s2.0-S0092867420300568-mmc2.xlsx\"\n,\nsheet\n=\n2\n)\nsc_oo\n<-\nsc\n[,\nmeta_oo\n$\ncell\n]\n# only 414 (not 418?! ) cells in the metadata\n## 自己的数据，就不涉及取子集，直接用sc就好，用下面这行代替上面两行：\n## For your own data, there's no need to take a subset; you can directly use sc, replace the two lines above with the following:\n# sc_oo <- sc\nsc_oo_mnn\n<-\nbatchelor\n::\nmnnCorrect\n(\n# mmnCorrect is no longer in scran mmnCorrect不再包含在scran中\nas.SingleCellExperiment\n(\nsc_oo\n),\nbatch\n=\nsc_oo\n$\nindividual\n,\nk\n=\n4\n,\nsigma\n=\n0.1\n,\ncos.norm.in\n=\nT\n,\ncos.norm.out\n=\nT\n,\nvar.adj\n=\nT\n)\nprData\n<-\nSummarizedExperiment\n::\nassay\n(\nsc_oo_mnn\n)\n# HVGs\n#sc_oo %<>% FindVariableFeatures(selection.method = \"mvp\", mean.cutoff = c(1,8))\nsc_oo\n%<>%\nFindVariableFeatures\n(\nselection.method\n=\n\"vst\"\n)\nVariableFeatures\n(\nsc_oo\n)\n%>%\nlength\n()\n# PCA\nprres\n<-\nprcomp\n(\nprData\n[\nVariableFeatures\n(\nsc_oo\n), ]\n%>%\nt\n,\nscale.\n=\nF\n)\n#prres <- prcomp(prData %>% t, scale. = F)\n#prres$x <- sc_oo@reductions$pca@cell.embeddings\n# unsupervised clustering based on mnn matrix\nsc_oo\n%<>%\nScaleData\nsc_oo\n@\nassays\n$\nRNA\n@\nscale.data\n<-\nprData\n[\nrownames\n(\nsc_oo\n@\nassays\n$\nRNA\n@\nscale.data\n),\ncolnames\n(\nsc_oo\n@\nassays\n$\nRNA\n@\nscale.data\n)]\nsc_oo\n%<>%\nRunPCA\nElbowPlot\n(\nsc_oo\n)\nxxxxxxxxxx\nsc_oo\n%<>%\nFindNeighbors\n(\ndims\n=\n1\n:\n15\n)\n%>%\nFindClusters\n(\nresolution\n=\n0.6\n)\npca.pv\n<-\nsc_oo\n@\nreductions\n$\npca\n# 每个基因的主成分\n# The principal component of each gene\n# pca.pv@feature.loadings\ndim\n(\npca.pv\n@\nfeature.loadings\n)\n开始画图\nStart drawing\n画Fig. 3A\nDraw Fig. 3A\nx\n#计算坐标轴标签\n#Calculate axis labels\npc1.pv\n<-\npaste0\n(\nround\n(\npca.pv\n@\nstdev\n[\n1\n],\ndigits\n=\n3\n)\n*\n100\n,\n\"%\"\n)\npc2.pv\n<-\npaste0\n(\nround\n(\npca.pv\n@\nstdev\n[\n2\n],\ndigits\n=\n3\n)\n*\n100\n,\n\"%\"\n)\n# 修改seurat_clusters的名字\n# Rename the seurat_clusters\nsc_oo\n@\nmeta.data\n$\nseurat_clusters\n<-\nfactor\n(\nsc_oo\n@\nmeta.data\n$\nseurat_clusters\n,\nlevels\n=\nc\n(\n\"0\"\n,\n\"1\"\n,\n\"2\"\n,\n\"3\"\n),\nlabels\n=\nc\n(\n\"C1\"\n,\n\"C2\"\n,\n\"C3\"\n,\n\"C4\"\n))\n# 画图\n# draw\nPCAPlot\n(\nsc_oo\n,\ngroup.by\n=\n\"seurat_clusters\"\n)\n+\nscale_color_manual\n(\nvalues\n=\nc\n(\n\"darkmagenta\"\n,\n\"steelblue\"\n,\n\"chartreuse3\"\n,\n\"red\"\n))\n+\nxlab\n(\npaste0\n(\n\"PC1 (\"\n,\npc1.pv\n,\n\")\"\n))\n+\nylab\n(\npaste0\n(\n\"PC2 (\"\n,\npc2.pv\n,\n\")\"\n))\nxxxxxxxxxx\n# 保存到文件\n# Save to file\nggsave\n(\n\"PCA_A.pdf\"\n,\nwidth\n=\n6\n,\nheight\n=\n5\n)\n画Fig. 3B\nDraw Fig. 3B\n用Seurat自带的无监督聚类获得的seurat_clusters画图\nPlotting the seurat_clusters obtained using Seurat's built-in unsupervised clustering\nx\n#ggplot() + geom_point(mapping = aes(prres$x[,1],  prres$x[,2], color = sc_oo$seurat_clusters))\nmarkers\n<-\nc\n(\n\"ZP1\"\n,\n\"WEE2\"\n,\n\"DNMT1\"\n,\n\"ATP6\"\n,\n\"FIGLA\"\n,\n\"SOX17\"\n)\nreshape2\n::\nmelt\n(\ncbind\n(\nsc_oo\n@\nmeta.data\n[,\n\"seurat_clusters\"\n,\ndrop\n=\nF\n],\nPC1\n=\n-\nprres\n$\nx\n[,\n1\n],\nGetAssayData\n(\nsc_oo\n)[\nmarkers\n,]\n%>%\nt\n#SummarizedExperiment::assay(sc_oo_mnn)[markers,] %>% t\n),\nid.vars\n=\nc\n(\n\"seurat_clusters\"\n,\n\"PC1\"\n))\n%>%\nggplot\n(\nmapping\n=\naes\n(\nPC1\n,\nvalue\n))\n+\nylab\n(\n\"Relative expression\"\n)\n+\ngeom_point\n(\nmapping\n=\naes\n(\ncolor\n=\nseurat_clusters\n))\n+\ngeom_smooth\n()\n+\nscale_color_manual\n(\nvalues\n=\nc\n(\n\"darkmagenta\"\n,\n\"steelblue\"\n,\n\"chartreuse3\"\n,\n\"red\"\n))\n+\nfacet_wrap\n(\n~\nvariable\n,\nscales\n=\n\"free_y\"\n)\n+\ntheme_classic\n()\n+\ntheme\n(\npanel.border\n=\nelement_rect\n(\nfill\n=\nNA\n),\naxis.text.x\n=\nelement_blank\n(),\naxis.ticks.x\n=\nelement_blank\n())\nxxxxxxxxxx\nggsave\n(\n\"PCA_B.pdf\"\n,\nwidth\n=\n7\n,\nheight\n=\n4\n)\n跟原文对比\nCompare with the original text\n1-s2.0-S0092867420300568-mmc2.xlsx的第二列是细胞所在的cluster，是原文采用的聚类方法获得的cluster信息，用它跟我们做的“Seurat自带的无监督聚类”的结果对比。\n没有完全重复出原文的效果。最可能的原因是mnn算法计算出的数据有差别，或者是作者选用的输入基因是特别的，原文方法中没有描述。\nThe second column of 1-s2.0-S0092867420300568-mmc2.xlsx indicates the cluster to which each cell belongs, representing the cluster information obtained by the clustering method used in the original text. This can be compared with the results of our \"unsupervised clustering with Seurat's built-in method\".\nThe results do not perfectly replicate the effects of the original text. The most likely reasons are differences in the data calculated by the MNN (Multimodal Neighborhood Network) algorithm or the use of specific input genes by the authors, which are not described in the original method.\nxxxxxxxxxx\nmeta_oo\n<-\nreadxl\n::\nread_excel\n(\npath\n=\n\"1-s2.0-S0092867420300568-mmc2.xlsx\"\n,\nsheet\n=\n2\n)\ndim\n(\nmeta_oo\n)\nsc_oo\n$\nsubtype\n<-\nmeta_oo\n$\ncluster\n[\nmatch\n(\ncolnames\n(\nsc_oo\n),\nmeta_oo\n$\ncell\n)]\ntable\n(\nsc_oo\n$\nsubtype\n,\nsc_oo\n$\nseurat_clusters\n)\n用原文聚类获得的subtype画图\nPlot the subtypes obtained from original text clustering\nx\n#ggplot() +\ngeom_point\n(\nmapping\n=\naes\n(\nprres\n$\nx\n[,\n1\n],\nprres\n$\nx\n[,\n2\n],\ncolor\n=\nsc_oo\n$\nsubtype\n))\nmarkers\n<-\nc\n(\n\"ZP1\"\n,\n\"WEE2\"\n,\n\"DNMT1\"\n,\n\"ATP6\"\n,\n\"FIGLA\"\n,\n\"SOX17\"\n)\nreshape2\n::\nmelt\n(\ncbind\n(\nsc_oo\n@\nmeta.data\n[,\n\"subtype\"\n,\ndrop\n=\nF\n],\nPC1\n=\n-\nprres\n$\nx\n[,\n1\n],\nGetAssayData\n(\nsc_oo\n)[\nmarkers\n,]\n%>%\nt\n#SummarizedExperiment::assay(sc_oo_mnn)[markers,] %>% t\n),\nid.vars\n=\nc\n(\n\"subtype\"\n,\n\"PC1\"\n))\n%>%\nggplot\n(\nmapping\n=\naes\n(\nPC1\n,\nvalue\n))\n+\nylab\n(\n\"Relative expression\"\n)\n+\ngeom_point\n(\nmapping\n=\naes\n(\ncolor\n=\nsubtype\n))\n+\ngeom_smooth\n()\n+\nscale_color_manual\n(\nvalues\n=\nc\n(\n\"darkmagenta\"\n,\n\"steelblue\"\n,\n\"chartreuse3\"\n,\n\"red\"\n))\n+\nfacet_wrap\n(\n~\nvariable\n,\nscales\n=\n\"free_y\"\n)\n+\ntheme_classic\n()\n+\ntheme\n(\npanel.border\n=\nelement_rect\n(\nfill\n=\nNA\n),\naxis.text.x\n=\nelement_blank\n(),\naxis.ticks.x\n=\nelement_blank\n())\nxxxxxxxxxx\nggsave\n(\n\"PCA_B_ori.pdf\"\n,\nwidth\n=\n7\n,\nheight\n=\n4\n)\n附：单细胞RNA-seq数据预处理\nAppendix: Single-cell RNA-seq Data Preprocessing\n以下代码出自\nFigureYa206scHeatmap\n，会输出\nsc.seurat.Rdata\n，可作为以上代码的输入文件。\nThe following code is from\nFigureYa206scHeatmap\nand will output\nsc.seurat.Rdata\n, which can serve as the input file for the above code.\n下载单细胞RNA-seq数据\nDownload single-cell RNA-seq data\n1.UMI count，从NCBI\nGSE130664\n下载：\nGSE130664_merge_UMI_count.txt.gz\n文件。\n1.UMI count, download from NCBI\nGSE130664\n:\nGSE130664_merge_UMI_count.txt.gz\nfile.\nxxxxxxxxxx\ndownload.file\n(\n\"https://www.ncbi.nlm.nih.gov/geo/download/?acc=GSE130664&format=file&file=GSE130664%5Fmerge%5FUMI%5Fcount%2Etxt%2Egz\"\n,\ndestfile\n=\n\"GSE130664_merge_UMI_count.txt.gz\"\n)\n2.metadata，从\n例文的\nSupplementary Tables获得：\n1-s2.0-S0092867420300568-mmc1.xlsx\n2.Metadata, obtained from the Supplementary Tables of\nthe example paper\n:\n1-s2.0-S0092867420300568-mmc1.xlsx\n读取数据\nRead data\nxxxxxxxxxx\numi\n<-\nread.table\n(\nfile\n=\ngzfile\n(\n\"GSE130664_merge_UMI_count.txt.gz\"\n),\nheader\n=\nT\n,\nrow.names\n=\n1\n,\nsep\n=\n\"\n\\t\n\"\n)\nqc\n<-\nreadxl\n::\nread_excel\n(\n\"1-s2.0-S0092867420300568-mmc1.xlsx\"\n,\nsheet\n=\n2\n)\nmeta\n<-\nreadxl\n::\nread_excel\n(\n\"1-s2.0-S0092867420300568-mmc1.xlsx\"\n,\n3\n)\n%>%\ncolumn_to_rownames\n(\n\"cell\"\n)\n数据预处理\nData preprocessing\n参见方法部分：\n定量和统计分析 -> 单细胞RNA-Seq数据处理。\nSee Methods:\nQUANTIFICATION AND STATISTICAL ANALYSIS -> Single-Cell RNA-Seq Data Processing\nxxxxxxxxxx\n# 细胞质量控制\n# QC of Cells\ncells\n<-\nqc\n%>%\nfilter\n(\n`Mapping rate`\n>=\n0.2\n&\n`Gene number`\n>=\n700\n&\nUMI\n>=\n3000\n)\n%>%\npull\n(\nRename\n)\n# seurat 对象\n# seurat object\nsc\n<-\nCreateSeuratObject\n(\ncounts\n=\numi\n[,\ncells\n],\nmeta.data\n=\nmeta\n)\n# 表达量转换\n# expression transformation\nsc\n@\nassays\n$\nRNA\n@\ndata\n<-\nsc\n@\nassays\n$\nRNA\n@\ncounts\n%>%\napply\n(\n2\n,\nfunction\n(\nx\n){\nlog2\n(\n10\n^\n5\n*\nx\n/\nsum\n(\nx\n)\n+\n1\n)\n})\n# 去除其他细胞\n# remove other cells\nsc\n<-\nsc\n[,\nsc\n$\ncluster\n!=\n\"other\"\n]\n# 给cluster改名\n# rename the clusters\nsc\n$\ncluster_short\n<-\nfactor\n(\nplyr\n::\nmapvalues\n(\nsc\n$\ncluster\n,\nc\n(\n\"Oocyte\"\n,\n\"Natural killer T cell\"\n,\n\"Macrophage\"\n,\n\"Granulosa cell\"\n,\n\"Endothelial cell\"\n,\n\"Smooth muscle cell\"\n,\n\"Stromal cell\"\n),\nc\n(\n\"OO\"\n,\n\"NKT\"\n,\n\"M\"\n,\n\"GC\"\n,\n\"EC\"\n,\n\"SMC\"\n,\n\"SC\"\n)),\nlevels\n=\nc\n(\n\"OO\"\n,\n\"NKT\"\n,\n\"M\"\n,\n\"GC\"\n,\n\"EC\"\n,\n\"SMC\"\n,\n\"SC\"\n))\n# 给cluster自定义颜色\n# customise colours for the cluster\ncluster_colors\n<-\nsetNames\n(\nbrewer.pal\n(\n7\n,\n\"Set1\"\n),\nlevels\n(\nsc\n$\ncluster_short\n))\n# 保存一下，便于停下来接着跑\n# save the progress so that you can stop and resume later\nsave\n(\nsc\n,\ncluster_colors\n,\nfile\n=\n\"sc.seurat.Rdata\"\n)\n# 还可以把表达矩阵输出到文件\n# you can also output the expression matrix to a file\n#write.csv(sc@assays$RNA@data, \"easy_input_expr.csv\", quote = F)\nSession Info\n会话信息\nsessionInfo\n()",
    "chapter_info": {
      "id": "main_FigureYa222PCAgene_FigureYa222PCAgene",
      "title": "FigureYa222PCAgene/FigureYa222PCAgene.html",
      "html": "FigureYa222PCAgene/FigureYa222PCAgene.html",
      "text": "texts/main_FigureYa222PCAgene_FigureYa222PCAgene.txt",
      "folder": "FigureYa222PCAgene",
      "thumb": "gallery_compress/FigureYa222PCAgene.webp"
    },
    "word_count": 1914,
    "lines_count": 1147,
    "title": "FigureYa222PCAgene_副本.Rmd",
    "description": "requirement description 这个PCA很特别 This PCA is quite special.",
    "input_data_types": [
      "表达矩阵",
      "单细胞"
    ],
    "output_types": [
      "热图",
      "统计表格",
      "PCA图",
      "网络图"
    ],
    "technical_methods": [
      "主成分分析",
      "聚类分析",
      "网络分析",
      "质量控制"
    ],
    "biology_areas": [
      "发育生物学"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "values",
      "acc",
      "format",
      "header",
      "width",
      "pvalue",
      "cutoff",
      "sigma",
      "labels"
    ]
  },
  {
    "id": "main_FigureYa65SVM_FigureYa65SVM",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa65SVM_FigureYa65SVM.txt",
    "content": "FigureYa65SVM\nFigureYa65SVM\nAuthor(s)\n: Dongqiang Zeng, Yin Li; Ying Ge, Yijing\nChen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n利用svm-rfe和lasso logistic\nregression进行特征变量筛选，重现原文方法\nFeature variable screening using svm-rfe and lasso logistic\nregression to reproduce the original method\n出自\nhttp://ascopubs.org/doi/full/10.1200/JCO.2016.68.2153\nfrom\nhttp://ascopubs.org/doi/full/10.1200/JCO.2016.68.2153\n应用场景\nApplication scenario\nsvm-rfe（support vector machine - recursive feature\nelimination）是基于支持向量机的机器学习方法，\n通过删减svm产生的特征向量来寻找最佳变量。\nlasso lr（logistic\nregression）也是机器学习的方法之一，通过寻找分类错误最小时的λ来确定变量。\n主要用于筛选特征变量，构建最佳分类模型。\nsvm-rfe (support vector machine - recursive feature elimination) is a\nmachine learning method based on support vector machines, which seeks\nthe optimal variables by eliminating the feature vectors generated by\nsvm.\nlasso lr (logistic regression) is also one of the machine learning\nmethods that identifies variables by finding the λ with the smallest\nclassification error.\nIt is mainly used to filter the feature variables to construct the\nbest classification model.\n环境设置\nEnvironment setting\nsource(\"install_dependencies.R\")\nlibrary(tidyverse)\nlibrary(glmnet)\nsource('msvmRFE.R')   #文件夹内自带 it comes with it in the folder\nlibrary(VennDiagram)\nlibrary(sigFeature)\nlibrary(e1071)\nlibrary(caret)\nlibrary(randomForest)\n输入文件\nInput file\neasy_input.csv，带有分组信息的矩阵。此处用例文自带的GSE75041，经过处理后得到，处理过程见文件夹中的HowToGetEasyInput.R。\n可自行准备，至少包含以下信息：\n第一列：sample ID\n第二列：样本分组信息，最好为二分类变量\n第三列之后：表达矩阵\neasy_input.csv, a matrix with grouping information. Here, the example\ntext’s own GSE75041 is used, obtained after processing, and the\nprocessing procedure can be found in the HowToGetEasyInput.R file within\nthe folder.\nIt can be prepared by yourself and contains at least the following\ninformation:\nFirst column: sample ID\nSecond column: sample grouping information, preferably for\ndichotomous variables\nAfter the third column: the expression matrix\ntrain <- read.csv(\"easy_input.csv\",row.names = 1, \n                  as.is = F) #后面svmRFE函数要求group的类型为factor the following svmRFE function requires the type of group to be factor\n\ndim(train)\ntrain[1:4,1:4]\n下面就以train作为输入，分别进行lasso和SVM-REF的变量筛选\nNext, take train as the input to filter the variables of lasso and\nSVM-REF respectively\n图A，用LASSO-logitstic-Algorithm进行特征选择\nFigure A, feature selection with LASSO-logitstic-Algorithm\n找特征\nFind features\n# 转为lasso需要的格式\n# convert to lasso required format\nx <- as.matrix(train[,-1])  \n(y <- ifelse(train$group == \"NR\", 0,1)) #把分组信息换成01 replace the grouping information with 01\n#library(glmnet)\nfit = glmnet(x, y, family = \"binomial\", alpha = 1, lambda = NULL)\n\n# 画A图\n# draw figure A\n#pdf(\"A_lasso.pdf\", width = 5, height = 5)\nplot(fit, xvar = \"dev\", label = TRUE)\n#dev.off()\n注\n：lasso图的更多细节调整，请参考FigureYa31lasso，例如在lasso图的线旁边显示特征名称，或用图例显示特征名称。\nNote\n: See FigureYa31lasso for more detailed\nadjustments to the lasso plot, such as displaying feature names next to\nthe lines in the lasso plot, or displaying feature names with a\nlegend.\ncvfit = cv.glmnet(x, y, \n                  nfold=10, #例文描述：10-fold cross-validation example text description: 10-fold cross-validation\n                  family = \"binomial\", type.measure = \"class\")\nplot(cvfit)\ncvfit$lambda.min #查看最佳lambda view the best lambda\n# 获取LASSO选出来的特征\n# get the features selected by LASSO\nmyCoefs <- coef(cvfit, s=\"lambda.min\");\nlasso_fea <- myCoefs@Dimnames[[1]][which(myCoefs != 0 )]\n(lasso_fea <- lasso_fea[-1])\n# 把lasso找到的特征保存到文件\n# save the features found by lasso to a file\nwrite.csv(lasso_fea,\"feature_lasso.csv\")\n效果评估\nEffect evaluation\n# 使用选出来的特征进行模型的预测\n# 因为没有验证数据，这里用了训练数据\n# use the selected features for model prediction\n# since there is no validation data, training data is used here\npredict <- predict(cvfit, newx = x[1:nrow(x),], s = \"lambda.min\", type = \"class\")\ntable(predict,y)\n看到此处预测的准确性是百分之百，实际操作时还是要找测试集来做检验。\nSeeing that the accuracy of the prediction here is 100%, it is still\nnecessary to find a test set for inspection during the actual\noperation.\n图B，使用SVM-REF-Algorithm-进行特征选择\nFigure B, feature selection using SVM-REF-Algorithm-\n例文用的是e1071包，参考资料：\njohncolby的代码：\nhttps://github.com/johncolby/SVM-RFE\nhttp://www.colbyimaging.com/wiki/statistics/msvm-rfe\nThe example text uses the e1071 package, reference:\njohncolby’s code:\nhttps://github.com/johncolby/SVM-RFE\nhttp://www.colbyimaging.com/wiki/statistics/msvm-rfe\n找特征\nFind features\n#library(e1071)\n#source(msvmRFE.R)\ninput <- train\n\n#采用五折交叉验证 (k-fold crossValidation）\n#use 5-fold cross validation (k-fold crossValidation）\nsvmRFE(input, k = 5, halve.above = 100) #分割数据，分配随机数 split data, assign random numbers\nnfold = 5\nnrows = nrow(input)\nfolds = rep(1:nfold, len=nrows)[sample(nrows)]\nfolds = lapply(1:nfold, function(x) which(folds == x)) \nresults = lapply(folds, svmRFE.wrap, input, k=5, halve.above=100) #特征选择 feature selection\ntop.features = WriteFeatures(results, input, save=F) #查看主要变量 view main variables\nhead(top.features)\n#把SVM-REF找到的特征保存到文件\n#save the features found by SVM-REF to a file\nwrite.csv(top.features,\"feature_svm.csv\")\n效果评估（Estimate generalization error）\nEffect evaluation (Estimate generalization error)\n每个featsweep列表元素都对应于使用多个顶级特征（即 featsweep[1]\n仅使用顶级特征，featsweep[2]\n使用前2个特征，等等）。其中，svm.list包含外部5折交叉验证中每个10折的泛化误差估计值。这些精度的平均值为误差。\n测试300个变量时运行了大概9个小时(16G-台式机)\nEach featsweep list element corresponds to using that many of the top\nfeatures (i.e. featsweep[1] is using only the top feature, featsweep[2]\nis using the top 2 features, etc.). Within each, svm.list contains the\ngeneralization error estimates for each of the 10 folds in the external\n5-fold CV. These accuracies are averaged as error.\nTesting 300 variables took approximately 9 hours (16G-desktop)\n# 运行时间主要取决于选择变量的个数，一般的电脑还是不要选择太多变量\n# 选前5个变量进行SVM模型构建，体验一下\n# the runtime depends on the number of variables selected, so don't select too many variables for a normal computer\n# select the first 5 variables for SVM model construction, experience it\n#featsweep = lapply(1:5, FeatSweep.wrap, results, input) #5个变量 5 variables\n#featsweep\n\n# 选前300个变量进行SVM模型构建，然后导入已经运行好的结果\n# select the top 300 variables to construct the SVM model, and then import the already executed results\n#featsweep = lapply(1:300, FeatSweep.wrap, results, input) #300个变量 300 variables\n#save(featsweep,file = \"featsweep.RData\")\n(load(\"featsweep.RData\"))\n# 画图\n# draw plots\nno.info = min(prop.table(table(input[,1])))\nerrors = sapply(featsweep, function(x) ifelse(is.null(x), NA, x$error))\n\n#dev.new(width=4, height=4, bg='white')\n#pdf(\"B_svm-error.pdf\",width = 5,height = 5)\nPlotErrors(errors, no.info=no.info) #查看错误率 view error rate\n#dev.off()\n\n#dev.new(width=4, height=4, bg='white')\n#pdf(\"B_svm-accuracy.pdf\",width = 5,height = 5)\nPlotaccuracy(1-errors,no.info=no.info) #查看准确率 view accuracy rate\n#dev.off()\n\n# 图中红色圆圈所在的位置，即错误率最低点\n# the position of the red circle in the figure, that is, the lowest point of the error rate\nwhich.min(errors)\n比较lasso和SVM-REF方法一找出的特征变量，画Venn图\nCompare the feature variables found by lasso and SVM-REF method 1,\ndraw the Venn plot\n(myoverlap <- intersect(lasso_fea, top.features[1:which.min(errors), \"FeatureName\"])) #交集 intersection\nsummary(lasso_fea%in%top.features[1:which.min(errors), \"FeatureName\"])\n#pdf(\"C_lasso_SVM_venn.pdf\", width = 5, height = 3)\ngrid.newpage()\nvenn.plot <- venn.diagram(list(LASSO = lasso_fea, #画图 draw a plot\n                               SVM_RFE = as.character(top.features[1:which.min(errors),\"FeatureName\"])), NULL, \n                          fill = c(\"#E31A1C\",\"#E7B800\"), \n                          alpha = c(0.5,0.5), cex = 4, cat.fontface=3, \n                          category.names = c(\"LASSO\", \"SVM_RFE\"), \n                          main = \"Overlap\")\ngrid.draw(venn.plot)\n#dev.off()\n跟例文的结果对比\nCompare the results with the example\nexample_lasso.txt，例文用lasso找出来的特征\nexample_SVM-RFE.txt，例文用SVM-RFE找出来的特征\nexample_lasso.txt, features found by lasso in the example paper\nexample_SVM-RFE.txt, features found by SVM-RFE in the example\n# lasso结果对比\n# comparison of lasso result\nex_lasso <- read.table(\"example_lasso.txt\")\ndim(ex_lasso)\nintersect(lasso_fea, ex_lasso$V1)\nsummary(lasso_fea%in%ex_lasso$V1)\n# SVM结果对比\n# comparison of SVM result\nex_SVM <- read.table(\"example_SVM-RFE.txt\")\ndim(ex_SVM)\nintersect(top.features[1:which.min(errors), \"FeatureName\"], ex_SVM$V1)\nsummary(top.features[1:which.min(errors), \"FeatureName\"]%in%ex_SVM$V1)\n# overlap对比\n# overlap comparison\nex_overlap <- read.table(\"example_overlap.txt\")\ndim(ex_overlap)\nintersect(myoverlap, ex_overlap$V1)\nsummary(myoverlap%in%ex_overlap$V1)\n重合度非常低，小伙伴一起探讨吧！\nThere’s very little overlap, explore with your buddies!\n附\nAppendix\nSVM-RFE算法有多套代码可以实现，这里提供了另外两种SVM-REF-Algorithm的实现方法。\n实际操作中可分别运行，对比效果，然后选其一。\n见Lasso-SVM-REF-algorithm-Feature\nselection.R文件中的方法二和方法三。\nThere are several sets of codes to implement the SVM-REF algorithm,\nand two other implementation methods of the SVM-REF-Algorithm are\nprovided here.\nIn practice, you can run them separately, compare the effect, and\nthen choose one of them.\nSee Methods 2 and Methods 3 in the Lasso-SVM-REF-algorithm-Feature\nselection.R file.\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa65SVM_FigureYa65SVM",
      "title": "FigureYa65SVM/FigureYa65SVM.html",
      "html": "FigureYa65SVM/FigureYa65SVM.html",
      "text": "texts/main_FigureYa65SVM_FigureYa65SVM.txt",
      "folder": "FigureYa65SVM",
      "thumb": "gallery_compress/FigureYa65SVM.webp"
    },
    "word_count": 1046,
    "lines_count": 252,
    "title": "FigureYa65SVM",
    "description": "Requirement description 利用svm-rfe和lasso logistic regression进行特征变量筛选，重现原文方法",
    "input_data_types": [
      "临床数据",
      "表达矩阵"
    ],
    "output_types": [
      "统计表格"
    ],
    "technical_methods": [],
    "biology_areas": [],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "label",
      "measure",
      "info",
      "featsweep",
      "width",
      "len",
      "cvfit",
      "fit",
      "folds",
      "bg"
    ]
  },
  {
    "id": "main_FigureYa135multiVolcano_FigureYa135multiVolcano",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa135multiVolcano_FigureYa135multiVolcano.txt",
    "content": "FigureYa135multiVolcano\nFigureYa135multiVolcano\nAuthor(s)\n: Qian Liu\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n从形式上复现文章里的这个复杂火山图。 Reproduce the complex volcano\nmap in the article in form.\n出自\nhttps://onlinelibrary.wiley.com/doi/abs/10.1002/ijc.31765\nFrom\nhttps://onlinelibrary.wiley.com/doi/abs/10.1002/ijc.31765\nFigure 1. DMPs analysis in LSTs cases and controls. (b) Volcano plot\nof top DMPs and position of methylation probes in relation to the gene\n(IGR, intergenic region; TSS, transcription start site; UTR,\nuntranslated region). The percentages of hypermethylated and\nhypomethylated DMPs are displayed on top. The proportions of different\ngenomic features are shown on the right.\n图的解析：\nAnalysis of the\nfigure:\n中央散点图横坐标是甲基化差异（foldchange），纵坐标是P value；\n右侧是位于各特征区域内的位点所在百分比，根据feature计算而来\n顶部是对位点的另一层分类信息hypo、hyper所在的百分比，根据散点图横坐标beta-value计算而来。\nThe horizontal axis of the central scatter plot is the methylation\ndifference (foldchange), and the vertical axis is the P value;\nThe right side is the percentage of sites located in each feature\nregion, calculated based on the feature\nThe top is another layer of classification information for the site,\nthe percentage of hypo and hyper, calculated based on the horizontal\naxis beta-value of the scatter plot\n应用场景\nApplication scenarios\n同时展示多层信息，不仅限于例文中的甲基化位点。 Show multiple layers\nof information at the same time, not limited to the methylation sites in\nthe example text.\n还可以换成差异表达基因，把横坐标deltabeta换成foldchange，feature换成基因分类即可。\nYou can also change to differentially expressed genes, replace the\nhorizontal axis deltabeta with foldchange, and replace feature with gene\nclassification.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\n# BiocManager::install(\"janitor\")\nLoad package\nlibrary(magrittr)\nlibrary(ggplot2)\nlibrary(ggrepel)\nlibrary(janitor)\nlibrary(cowplot)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 #Display English error message\noptions(stringsAsFactors = FALSE) #禁止chr转成factor #Disable chr conversion to factor\n输入文件\nInput file\neasy_input.csv，包含四列： easy_input.csv, contains four columns:\n第一列ID，用于在图中标出P value低的位点ID。\n第二列p value，用于画散点图。\n第三列deltaBeta（foldchange），用于画散点图。另外，这里会用这列计算hypo和hypermethylated的百分比，用来画顶端百分比图。如果你不想用deltaBeta列来计算百分比，可以直接给出百分比，详见文档中“顶部百分比图\np3\n的绘制”部分。\n第四列feature，用于画右侧柱状图。这里是位点所在的基因组位置特征，也可以换做其他特征，例如差异表达基因所在的通路、编码/非编码、原癌/抑癌等。\nThe first column ID is used to mark the site ID with low P value in\nthe figure.\nThe second column p value is used to draw scatter plots.\nThe third column deltaBeta (foldchange) is used to draw scatter\nplots. In addition, this column will be used to calculate the percentage\nof hypo and hypermethylated, which is used to draw the top percentage\nmap. If you do not want to use the deltaBeta column to calculate the\npercentage, you can directly give the percentage. For details, see the\n“Drawing the top percentage map\np3\n” section in the\ndocument.\nThe fourth column, feature, is used to draw the bar graph on the\nright. This is the genomic location feature of the site, which can also\nbe replaced by other features, such as the pathway where the\ndifferentially expressed gene is located, coding/non-coding,\nproto-oncogene/cancer suppressor, etc.\ndata <- read.csv(\"easy_input.csv\", check.names=FALSE)\nrow.names(data) <- data[, 1]\ncolnames(data)[1] <- \"Geneid\"\nhead(data)\n下面分别绘制散点图、顶部比例和右侧bar plot，最后组图。 The following\nare the scatter plots, top ratios and right bar plots, and finally the\ngroup diagrams.\n散点图\np1\n的绘制\nDraw a scatter plot\np1\np1 <- ggplot(data, aes(deltaBeta, -log10(data$P.Value))) +\n  # 只给-log10(data$P.Value) > 60 的点写文字标签\n  # Write text labels only for points with -log10(data$P.Value) > 60\n  geom_text_repel(aes(deltaBeta, -log10(data$P.Value),\n                      label = ifelse(-log10(data$P.Value) > 60, rownames(data), \"\"))) + \n  geom_point(aes(color = feature)) +\n  guides(colour = guide_legend(override.aes = list(size=5))) + # 修改 legeng size 大小 # Modify the size of the legeng\n  theme(legend.position = \"none\") + # 去掉图例 # Remove the legend\n  labs(x = \"Methylation difference (beta-value)\",\n       y = bquote(~-log[10]~(italic(\"P-value\")))) + #参考了FigureYa59Volcano # Reference to FigureYa59Volcano\n  theme(axis.title.x = element_text(color=\"black\", size = 14, face = \"bold\"),\n        axis.title.y = element_text(color=\"black\", size = 14, face = \"bold\"))\n\np1\n# 原图带灰色背景和网格线\n# Original image with gray background and grid lines\n\n# 如果想去除背景和网格线，就运行下面这段\n# If you want to remove the background and grid lines, run the following paragraph\np1 <- p1 + theme_classic() +\n  theme(#panel.background = element_rect(fill = NA),\n        panel.border = element_rect(color = NA, fill = NA, size = 2),\n        panel.grid.major.x = element_blank(),\n        panel.grid.minor.x = element_blank(),\n        panel.grid.minor.y = element_blank(),\n        panel.grid.major.y = element_blank()) +\n  scale_y_continuous(breaks = c(0, 25, 50, 75, 100),\n                     labels = c(0, 25, 50, 75, \"\"),\n                     limits = c(0, 100))\np1\n散点图右侧面的柱子图\np2\n的绘制\nDraw the column chart\np2\non the right side of the\nscatter plot\n# 获得 Percent 中计数列的 n 的最大值\n# Get the maximum value of n in the count column in Percent\nn_max = max(Percent$n)\nn_max\np2\n顶部百分比图\np3\n的绘制\nDrawing of the top percentage graph\np3\n首先计算\nHyper\n和\nHypo\n各占的比例，看图两者加起来是百分之一百，这里没有 0 ，就不考虑 0 了。\nFirst, calculate the proportion of\nHyper\nand\nHypo\n. As you can see from the graph, the sum of the two is\n100%. There is no 0 here, so 0 is not considered.\n因此定义\n> 0\n就为\nHyper\n,\n< 0\n就为\nHypo\n。得到\nHyper\n所占百分比为 68.44 %, 得到\nHypo\n所占百分比为 31.56 %\nTherefore, define\n> 0\nas\nHyper\n, and\n< 0\nas\nHypo\n. The percentage of\nHyper\nis 68.44 %, and the percentage of\nHypo\nis 31.56 %\npercent_Hyper <- sum(data$deltaBeta < 0) / nrow(data)\npaste(\"Hyper was\", round(percent_Hyper * 100, 2), \"%\" )\n# 如果你不想用deltaBeta列来计算百分比，可以用以下两行直接给出百分比：\n# If you don't want to use the deltaBeta column to calculate the percentage, you can use the following two lines to give the percentage directly:\n#percent_Hypo <- \"0.8\"\n#percent_Hyper <- \"0.2\"\n\n### 手动给两个百分比的文字标签写个位置\n### Manually write a position for the two percentage text labels\n# 实际使用当中要根据自己的数据调整xmin和xmax\n# In actual use, you need to adjust xmin and xmax according to your own data\ndf1 <- data.frame(xmin = c(-350, 500, 1928, 4591),\n                  xmax = c(500, 1928, 4591, 6500),\n                  ymin = 00,\n                  ymax = 100,\n                  class  = c(\"A\",\"B\",\"C\",\"A\"),\n                  text = c(paste(round(percent_Hyper * 100, 2), \"%\" ),  \"\", \"\", paste(round(percent_Hypo * 100, 2), \"%\" )))\ndf1\n组图\nGroup pictures\ncombined_plot <- insert_xaxis_grob(p1, p3, \n                                   position = \"top\",\n                                   height = grid::unit(0.4, \"in\") # 调节高度比\n)\ncombined_plot <- insert_yaxis_grob(combined_plot, p2, \n                                   position = \"right\",\n                                   width = grid::unit(2.5, \"in\")\n)\n# ggdraw(combined_plot) \n\nsubtitle_theme_1 <- ggdraw() +\n  draw_label(\"Hyermethylated DMPs          Hypomethylated DMPs\",\n             x = 0.1, y = 0.25,\n             hjust = 0, vjust = 1.01, size = 10,  fontface = \"bold\")\n\np <- plot_grid(subtitle_theme_1, combined_plot, ncol = 1, \n               rel_heights = c(0.1, 1)) #顶部百分比图和散点图的比例\np\n# 保存到文件\n# Save to file\nggsave(\"multiVolcano.pdf\")\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa135multiVolcano_FigureYa135multiVolcano",
      "title": "FigureYa135multiVolcano/FigureYa135multiVolcano.html",
      "html": "FigureYa135multiVolcano/FigureYa135multiVolcano.html",
      "text": "texts/main_FigureYa135multiVolcano_FigureYa135multiVolcano.txt",
      "folder": "FigureYa135multiVolcano",
      "thumb": "gallery_compress/FigureYa135multiVolcano.webp"
    },
    "word_count": 998,
    "lines_count": 227,
    "title": "FigureYa135multiVolcano",
    "description": "Requirement description 从形式上复现文章里的这个复杂火山图。 Reproduce the complex volcano map in the article in form.",
    "input_data_types": [
      "DNA-seq"
    ],
    "output_types": [
      "火山图",
      "散点图"
    ],
    "technical_methods": [
      "通路分析",
      "差异表达分析"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "高级",
    "code_snippets": [],
    "key_parameters": [
      "rel_heights",
      "label",
      "",
      "colour",
      "width",
      "xmin",
      "ymin",
      "vjust",
      "xmax",
      "labels"
    ]
  },
  {
    "id": "main_FigureYa196PanPie_FigureYa196PanPie",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa196PanPie_FigureYa196PanPie.txt",
    "content": "FigureYa196PanPie\nFigureYa196PanPie\nAuthor(s)\n: Xiaofan Lu\nReviewer(s)\n: Ying Ge,Hui Huang\nDate\n: 2025-10-06\nAcademic Citation\nIf you use this code in your work or research, we kindly request that you cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization Framework for Enhancing Biomedical Data Interpretation and Research Efficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n把分组的数据直接用扇形图来展示不同临床预后分期的分布差异，看起来很漂亮。\nRequirement Description\nIt looks beautiful to use the grouped data directly in a fan chart to show the distribution differences of different clinical prognostic stages.\n出自\nhttps://www.nature.com/articles/s41388-019-1026-9\nFrom\nhttps://www.nature.com/articles/s41388-019-1026-9\nFig. 4 Identification of CNV-driven rRNA metabolism-related genes with clinical relevance. f, g Pie charts showing the Chi-squared test of clinicopathologic factors for PRE in CRC (f) and LUAD (g) tumor samples from the TCGA.\n图 4 具有临床相关性的 CNV 驱动的 rRNA 代谢相关基因的鉴定。f、g饼图显示了来自TCGA的CRC（f）和 LUAD（g）肿瘤样本中 PRE 临床病理因素的卡方检验。\n应用场景\n搞清楚输入数据跟图的对应关系、理解每部分代码所画的内容，就可以套用到更多类型的数据上。\nApplication Scenarios\nOnce you understand the mapping between input data and visual outputs, as well as the role of each code block in generating plots, you can adapt this workflow to broader data types.\n环境设置\nEnvironment Configuration\nsource(\"install_dependencies.R\") # 确保依赖包已安装 # Ensure dependencies are installed\nlibrary(dplyr) # 用于数据操作和处理 # For data manipulation and processing\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # error messages are displayed in English\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # It is forbidden to convert chr into factor\n输入文件\nInput files\neasy_input.txt\n第一列sample ID，每行一个sample，扇形大小对应每一类sample的数量；\n第二列Risk有两类：high和low，对应表格中的两行；\n第三列往后，对应表格中的各列。\neasy_input.txt\nFirst column (Sample ID): Each row represents one sample. The sector size in visualizations corresponds to the number of samples in each category.\nSecond column (Risk): Contains two classes: High and Low, mapped to the two rows in the table.\nThird column onward: Correspond to the columns in the original table.\ndat <- read.table(\"easy_input.txt\",row.names = 1,sep = \"\\t\",header = T,check.names = F,stringsAsFactors = F)\nhead(dat)\n# 按Risk分成High和Low，计算各列数值。\n# The value of each column is calculated according to the risk divided into high and low.\ngname <- \"Risk\"\nvname <- setdiff(colnames(dat), gname)\npie.high <- pie.low <- list()\nfisher.p <- c()\nfor (i in vname) {\n  tmp <- table(dat[,gname], dat[,i])\n  p <- format(fisher.test(tmp)$p.value,digits = 2)\n  names(p) <- i\n  fisher.p <- c(fisher.p, p)\n  \n  pie.dat <- \n    tmp %>% as.data.frame() %>% group_by(Var1) %>% mutate(Pct = Freq/sum(Freq)) %>% as.data.frame()\n  \n  # 表格内的两行对应Risk的两类：Risk high和Risk low\n  # The two rows in the table correspond to the two types of Risk: Risk high and Risk low\n  pie.high[[i]] <- pie.dat[which(pie.dat$Var1 == \"High\"),]\n  pie.low[[i]] <- pie.dat[which(pie.dat$Var1 == \"Low\"),]\n}\n开始画图\nStart plotting\n用base plot画图，如果你要查看某部分代码的效果，请从plot所在的行到当前位置一起，整段运行。\nIf you want to preview the output of a specific code segment, run the entire code block from the line containing the plot() command to the current cursor position.\n# 定义颜色变量\nblack  <- \"#1E1E1B\"\nblue   <- \"#3C4E98\"\nyellow <- \"#E4DB36\"\norange <- \"#E19143\"\ngreen  <- \"#57A12B\"\ncherry <- \"#8D3A86\"\n\n# 设置颜色透明度\nstatus.col <- c(\"grey80\", black)\nstage.col <- sapply(c(0.4, 0.6, 0.8, 1), function(alpha) adjustcolor(blue, alpha.f = alpha))\nM.col <- c(yellow, orange)\nN.col <- sapply(c(0.5, 0.7, 1), function(alpha) adjustcolor(green, alpha.f = alpha))\nT.col <- sapply(c(0.4, 0.6, 0.8, 1), function(alpha) adjustcolor(cherry, alpha.f = alpha))\n\n# 硬核base plot一块一块画，当然也可以把其中的pie chart提取出来后期AI或者PPT拼接也是比较方便的\n# Base plotting system allows manual construction of plots piece by piece. Alternatively, you can export individual pie charts for post-processing and assembly in tools like Adobe Illustrator or PowerPoint—this hybrid workflow offers flexibility.\n\npdf(\"pieTable.pdf\",width = 7, height = 5)\nshowLayout <- F # 默认不在最终pdf的首页显示layout结构，不过建议初次绘制的时候改为TRUE看一下，方便理解。# By default, the layout structure is not displayed on the first page of the final PDF. However, it is recommended to set this option to TRUE during initial plotting to visualize the layout, which aids in comprehension.\n\n# 设置画面布局，相同数字代表同一区块，数字越多代表该区块所占面积越大（一共25个区域）\n# Set the screen layout, the same number represents the same block, and the more numbers represent the larger the area occupied by the block (a total of 25 areas)\nlayout(matrix(c( 1, 1, 1,  2, 2, 2,  3, 3, 3,  4, 4, 4,  5, 5, 5,  6, 6, 6,\n                 7, 7, 7,  8, 8, 8,  9, 9, 9, 10,10,10, 11,11,11, 12,12,12,\n                 7, 7, 7,  8, 8, 8,  9, 9, 9, 10,10,10, 11,11,11, 12,12,12,\n                13,13,13, 14,14,14, 15,15,15, 16,16,16, 17,17,17, 18,18,18,\n                13,13,13, 14,14,14, 15,15,15, 16,16,16, 17,17,17, 18,18,18,\n                19,19,19, 20,20,20, 21,21,21, 22,22,22, 23,23,23, 24,24,24,\n                25,25,25, 25,25,25, 25,25,25, 25,25,25, 25,25,25, 25,25,25),\n              byrow = T,nrow = 7))\n\nif(showLayout) {\n  layout.show(n = 25) # 直观展示画布分布 # Visualize the distribution of canvases\n}\n\n#-------------------------#\n# 画布区域1-6：绘制图抬头 #\n# Canvas area 1-6: Draw the picture on your head #\n#-------------------------#\n\npar(bty=\"n\", mgp = c(0,0,0), mar = c(0,0,0,0), lwd = 2) # 基础参数，各边界距离为0 # For the basic parameters, the distance between each boundary is 0\nplot(1,1,\n     xlab = \"\",xaxt = \"n\", # 不显示x坐标轴 # The x-axis is not displayed\n     ylab = \"\",yaxt = \"n\") # 不显示y坐标轴 # The y-axis is not displayed\nrect(par(\"usr\")[1],par(\"usr\")[3],par(\"usr\")[2],par(\"usr\")[4],col = \"black\") # 背景涂黑 # The background is blackened\ntext((par(\"usr\")[1]+par(\"usr\")[2])/2, # 用par(\"usr\")来获取该画布的绝对位置 # Use par(\"usr\") to get the absolute position of the canvas\n     (par(\"usr\")[3]+par(\"usr\")[4])/2,\n     \"CRC\",cex = 2, col = \"white\") # 显示图标题 # Displays the title of the diagram\n\nplot(1,1,\n     xlab = \"\",xaxt = \"n\", # 不显示x坐标轴 # The x-axis is not displayed\n     ylab = \"\",yaxt = \"n\") # 不显示y坐标轴 # The y-axis is not displayed\nrect(par(\"usr\")[1],par(\"usr\")[3],par(\"usr\")[2],par(\"usr\")[4],col = \"black\") # 背景涂黑 # The background is blackened\ntext((par(\"usr\")[1]+par(\"usr\")[2])/2, # 用par(\"usr\")来获取该画布的绝对位置 # Use par(\"usr\") to get the absolute position of the canvas\n     (par(\"usr\")[3]+par(\"usr\")[4])/2,\n     \"Status\",cex = 2, col = \"white\") # 显示图标题 # Displays the title of the diagram\n\nplot(1,1,\n     xlab = \"\",xaxt = \"n\", # 不显示x坐标轴 # The x-axis is not displayed\n     ylab = \"\",yaxt = \"n\") # 不显示y坐标轴 # The y-axis is not displayed\nrect(par(\"usr\")[1],par(\"usr\")[3],par(\"usr\")[2],par(\"usr\")[4],col = \"black\") # 背景涂黑 # The background is blackened\ntext((par(\"usr\")[1]+par(\"usr\")[2])/2, # 用par(\"usr\")来获取该画布的绝对位置 # Use par(\"usr\") to get the absolute position of the canvas\n     (par(\"usr\")[3]+par(\"usr\")[4])/2,\n     \"Stage\",cex = 2, col = \"white\") # 显示图标题 # Displays the title of the diagram\n\nplot(1,1,\n     xlab = \"\",xaxt = \"n\", # 不显示x坐标轴 # The x-axis is not displayed\n     ylab = \"\",yaxt = \"n\") # 不显示y坐标轴 # The y-axis is not displayed\nrect(par(\"usr\")[1],par(\"usr\")[3],par(\"usr\")[2],par(\"usr\")[4],col = \"black\") # 背景涂黑 # The background is blackened\ntext((par(\"usr\")[1]+par(\"usr\")[2])/2, # 用par(\"usr\")来获取该画布的绝对位置 # Use par(\"usr\") to get the absolute position of the canvas\n     (par(\"usr\")[3]+par(\"usr\")[4])/2,\n     \"M\",cex = 2, col = \"white\") # 显示图标题 # Displays the title of the diagram\n\nplot(1,1,\n     xlab = \"\",xaxt = \"n\", # 不显示x坐标轴 # The x-axis is not displayed\n     ylab = \"\",yaxt = \"n\") # 不显示y坐标轴 # The y-axis is not displayed\nrect(par(\"usr\")[1],par(\"usr\")[3],par(\"usr\")[2],par(\"usr\")[4],col = \"black\") # 背景涂黑 # The background is blackened\ntext((par(\"usr\")[1]+par(\"usr\")[2])/2, # 用par(\"usr\")来获取该画布的绝对位置 # Use par(\"usr\") to get the absolute position of the canvas\n     (par(\"usr\")[3]+par(\"usr\")[4])/2,\n     \"N\",cex = 2, col = \"white\") # 显示图标题 # Displays the title of the diagram\n\nplot(1,1,\n     xlab = \"\",xaxt = \"n\", # 不显示x坐标轴 # The x-axis is not displayed\n     ylab = \"\",yaxt = \"n\") # 不显示y坐标轴 # The y-axis is not displayed\nrect(par(\"usr\")[1],par(\"usr\")[3],par(\"usr\")[2],par(\"usr\")[4],col = \"black\") # 背景涂黑 # The background is blackened\ntext((par(\"usr\")[1]+par(\"usr\")[2])/2, # 用par(\"usr\")来获取该画布的绝对位置 # Use par(\"usr\") to get the absolute position of the canvas\n     (par(\"usr\")[3]+par(\"usr\")[4])/2,\n     \"T\",cex = 2, col = \"white\") # 显示图标题  # Displays the title of the diagram\n\n\n#--------------------------------------#\n# 画布区域7-12：绘制High组抬头和扇形图#\n# Canvas area 7-12: Draw a High group head and fan diagram#\n#--------------------------------------#\n\nplot(1,1,\n     xlab = \"\",xaxt = \"n\", \n     ylab = \"\",yaxt = \"n\") \nrect(par(\"usr\")[1],par(\"usr\")[3],par(\"usr\")[2],par(\"usr\")[4],col = \"black\") \ntext((par(\"usr\")[1]+par(\"usr\")[2])/2,\n     (par(\"usr\")[3]+par(\"usr\")[4])/2,\n     \"High\\n(n = 100)\",cex = 2, col = \"white\") \n\n# High group\n# 高组\npie(pie.high$Status$Pct, \n    col = status.col, \n    border = \"white\",  \n    radius = 1, \n    labels = NA,\n    init.angle = 90)\nsymbols(0,0, circles = .55, inches = FALSE, col = \"white\", bg = \"white\", lty = 0, add = TRUE)\n\npie(pie.high$Stage$Pct, \n    col = stage.col, \n    border = \"white\",  \n    radius = 1, \n    labels = NA,\n    init.angle = 90)\nsymbols(0,0, circles = .55, inches = FALSE, col = \"white\", bg = \"white\", lty = 0, add = TRUE)\n\npie(pie.high$M$Pct, \n    col = M.col, \n    border = \"white\",  \n    radius = 1, \n    labels = NA,\n    init.angle = 90)\nsymbols(0,0, circles = .55, inches = FALSE, col = \"white\", bg = \"white\", lty = 0, add = TRUE)\n\npie(pie.high$N$Pct, \n    col = N.col, \n    border = \"white\",  \n    radius = 1, \n    labels = NA,\n    init.angle = 90)\nsymbols(0,0, circles = .55, inches = FALSE, col = \"white\", bg = \"white\", lty = 0, add = TRUE)\n\npie(pie.high$`T`$Pct, \n    col = T.col, \n    border = \"white\",  \n    radius = 1, \n    labels = NA,\n    init.angle = 90)\nsymbols(0,0, circles = .55, inches = FALSE, col = \"white\", bg = \"white\", lty = 0, add = TRUE)\nabline(v = par(\"usr\")[2], col = \"black\") # 右侧封上黑线 # The right side is covered with a black line\n\n#--------------------------------------#\n# 画布区域13-18：绘制Low组抬头和扇形图 #\n# Canvas area 13-18: Draw a low group head up and fan diagram #\n#--------------------------------------#\n\nplot(1,1,\n     xlab = \"\",xaxt = \"n\", \n     ylab = \"\",yaxt = \"n\") \nrect(par(\"usr\")[1],par(\"usr\")[3],par(\"usr\")[2],par(\"usr\")[4],col = \"black\") # 背景涂黑\ntext((par(\"usr\")[1]+par(\"usr\")[2])/2, # 用par(\"usr\")\n     (par(\"usr\")[3]+par(\"usr\")[4])/2,\n     \"Low\\n(n = 200)\",cex = 2, col = \"white\") \n\n# Low group\n# 低组\npie(pie.low$Status$Pct, \n    col = status.col, \n    border = \"white\",  \n    radius = 1, \n    labels = NA,\n    init.angle = 90)\nsymbols(0,0, circles = .55, inches = FALSE, col = \"white\", bg = \"white\", lty = 0, add = TRUE)\n\npie(pie.low$Stage$Pct, \n    col = stage.col, \n    border = \"white\",  \n    radius = 1, \n    labels = NA,\n    init.angle = 90)\nsymbols(0,0, circles = .55, inches = FALSE, col = \"white\", bg = \"white\", lty = 0, add = TRUE)\n\npie(pie.low$M$Pct, \n    col = M.col, \n    border = \"white\",  \n    radius = 1, \n    labels = NA,\n    init.angle = 90)\nsymbols(0,0, circles = .55, inches = FALSE, col = \"white\", bg = \"white\", lty = 0, add = TRUE)\n\npie(pie.low$N$Pct, \n    col = N.col, \n    border = \"white\",  \n    radius = 1, \n    labels = NA,\n    init.angle = 90)\nsymbols(0,0, circles = .55, inches = FALSE, col = \"white\", bg = \"white\", lty = 0, add = TRUE)\n\npie(pie.low$`T`$Pct, \n    col = T.col, \n    border = \"white\",  \n    radius = 1, \n    labels = NA,\n    init.angle = 90)\nsymbols(0,0, circles = .55, inches = FALSE, col = \"white\", bg = \"white\", lty = 0, add = TRUE)\nabline(v = par(\"usr\")[2], col = \"black\") # 右侧封上黑线\n\n#--------------------------------#\n# 画布区域19-24：绘制空抬头和p值 #\n# Canvas area 19-24: Draw empty headers and p-values#\n#--------------------------------#\n\nplot(1,1,\n     xlab = \"\",xaxt = \"n\", \n     ylab = \"\",yaxt = \"n\") \nrect(par(\"usr\")[1],par(\"usr\")[3],par(\"usr\")[2],par(\"usr\")[4],col = \"black\") \n\nplot(1,1,col = \"white\",\n     xlab = \"\",xaxt = \"n\", \n     ylab = \"\",yaxt = \"n\") \ntext((par(\"usr\")[1]+par(\"usr\")[2])/2,\n     (par(\"usr\")[3]+par(\"usr\")[4])/2,\n     paste0(\"p = \",fisher.p[\"Status\"]),cex = 1.5, col = \"black\") \nabline(h = par(\"usr\")[3], col = \"black\") \n\nplot(1,1,col = \"white\",\n     xlab = \"\",xaxt = \"n\", \n     ylab = \"\",yaxt = \"n\") \ntext((par(\"usr\")[1]+par(\"usr\")[2])/2, \n     (par(\"usr\")[3]+par(\"usr\")[4])/2,\n     paste0(\"p = \",fisher.p[\"Stage\"]),cex = 1.5, col = \"black\") \nabline(h = par(\"usr\")[3], col = \"black\")\n\nplot(1,1,col = \"white\",\n     xlab = \"\",xaxt = \"n\",\n     ylab = \"\",yaxt = \"n\") \ntext((par(\"usr\")[1]+par(\"usr\")[2])/2, \n     (par(\"usr\")[3]+par(\"usr\")[4])/2,\n     paste0(\"p = \",fisher.p[\"M\"]),cex = 1.5, col = \"black\") \nabline(h = par(\"usr\")[3], col = \"black\")\n\nplot(1,1,col = \"white\",\n     xlab = \"\",xaxt = \"n\", \n     ylab = \"\",yaxt = \"n\") \ntext((par(\"usr\")[1]+par(\"usr\")[2])/2, \n     (par(\"usr\")[3]+par(\"usr\")[4])/2,\n     paste0(\"p = \",fisher.p[\"N\"]),cex = 1.5, col = \"black\") \nabline(h = par(\"usr\")[3], col = \"black\")\n\nplot(1,1,col = \"white\",\n     xlab = \"\",xaxt = \"n\", \n     ylab = \"\",yaxt = \"n\") \ntext((par(\"usr\")[1]+par(\"usr\")[2])/2, \n     (par(\"usr\")[3]+par(\"usr\")[4])/2,\n     paste0(\"p = \",fisher.p[\"T\"]),cex = 1.5, col = \"black\") \nabline(h = par(\"usr\")[3], col = \"black\") \nabline(v = par(\"usr\")[2], col = \"black\") \n\n#----------------------#\n# 画布区域25：绘制图例 #\n# Canvas area 25: Draw a legend#\n#----------------------#\n\nplot(0,0,col = \"white\",\n     xlab = \"\",xaxt = \"n\", \n     ylab = \"\",yaxt = \"n\") \nlegend(\"topleft\",\n       legend = c(\"Alive\",\"Dead\",\n                  \"I\",\"II\",\"III\",\"IV\",\n                  \"M0\",\"M1\",\n                  \"N0\",\"N1\",\"N2\",\n                  \"T1\",\"T2\",\"T3\",\"T4\"),\n       fill = c(status.col,\n                stage.col,\n                M.col,\n                N.col,\n                T.col),\n       border = NA, # 图例颜色没有边框 # The legend color has no border\n       bty = \"n\", # 图例没有边框 # The legend has no borders\n       cex = 1.2,\n       #box.lwd = 3,\n       x.intersp = 0.05,\n       y.intersp = 1,\n       text.width = 0.075, # 图例的间隔 # The interval of the legend\n       horiz = T) #  horiz = T) # 图例水平放置 # The legend is placed horizontally\n\n\n# 关闭图像句柄\n# Close the image handle\ninvisible(dev.off())\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa196PanPie_FigureYa196PanPie",
      "title": "FigureYa196PanPie/FigureYa196PanPie.html",
      "html": "FigureYa196PanPie/FigureYa196PanPie.html",
      "text": "texts/main_FigureYa196PanPie_FigureYa196PanPie.txt",
      "folder": "FigureYa196PanPie",
      "thumb": "gallery_compress/FigureYa196PanPie.webp"
    },
    "word_count": 1892,
    "lines_count": 356,
    "title": "FigureYa196PanPie",
    "description": "把分组的数据直接用扇形图来展示不同临床预后分期的分布差异，看起来很漂亮。 Requirement Description It looks beautiful to use the grouped data directly in a fan chart to show the distribution differences of different clinical prognostic stages.",
    "input_data_types": [
      "临床数据"
    ],
    "output_types": [
      "统计表格"
    ],
    "technical_methods": [],
    "biology_areas": [
      "癌症研究",
      "代谢疾病"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "add",
      "intersp",
      "radius",
      "inches",
      "header",
      "lwd",
      "width",
      "n",
      "nrow"
    ]
  },
  {
    "id": "main_FigureYa233genepair_FigureYa233genepair",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa233genepair_FigureYa233genepair.txt",
    "content": "FigureYa233genepair\nFigureYa233genepair\nAuthor(s)\n: Xiaofan Lu\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n想按照文中的方法构建基因对预后模型\nRequirement Description\nI want to construct a gene pair prognostic model according to the\nmethod in this paper\n出自\nhttps://molecular-cancer.biomedcentral.com/articles/10.1186/s12943-017-0666-z\nfrom\nhttps://molecular-cancer.biomedcentral.com/articles/10.1186/s12943-017-0666-z\nFig. 1 Illustration of LncRIndiv method and work-flow of this study.\nb The schematic diagram of\nLncRIndiv method\n. Take\nlncRNA-A as an example to describe the LncRIndiv method. Circles with\ndifferent color represent different lncRNAs. The\nblue and\npurple\nhuman shapes represent the samples\nwith or\nwithout reversal lncRNA pairs in each line\n, respectively. The\nred and green\nhuman shapes represent the samples are\ndetermined as\nwith and without differential expression of\nlncRNA-A\nby the LncRIndiv method.\n应用场景\n【提出问题】DESeq等方法 detect differentially expressed genes (DEGs)\nin\nsub-groups of cancer samples\n, considering the\nhigh heterogeneity\nof lncRNA expression among patients,\nnone have been used in detecting DE lncRNAs in individual\npatients\n.\n【前提假设】作者以前的工作发现 the relative expression rankings of\ngenes (miRNAs) tend to be\nhighly stable in specific\nnormal\nhuman tissues but\nwidely disturbed in the\ncorresponding cancer\ntissues, and the reversal relationship of\nrank between genes (miRNAs) expression level can be used to identify DE\ngenes (miRNAs) in individual patient. 这次用同样的方式来看DE lncRNAs in\nindividual patients\n【解决方案】例文建立了一个方法LncRIndiv（detect DE lncRNAs in\nindividual\npatients），即使用gene-pair进行预后模型构建的方法，也就是通过成对基因来进行预后建模。\n例如A和B基因，A表达量 > B表达量设为1，A表达量 <\nB表达量设为0。筛选出多对基因，都变成0和1的形式，进行预后模型构建。\n本文档带你复现这一方法。\n【优点】基于排序获得的模型具有平台独立性，只要单样本基因之间表达具有可比性就可以了。\n…due to experimental batch effects and platform differences, the\nscore-based signatures\ntend to produce spurious risk\nclassification in independent samples measured by different laboratories\nand are infeasible in clinical application… …we found prognostic\nsignatures derived using the\nrelative genes (miRNAs) expression\nrankings\nwithin samples, rather than the absolute expression\nvalues, are robust in\nindependent datasets from different\nlaboratories and platforms\n.\nApplication Scenarios\n【Ask a question】 DESeq and other methods detect differentially\nexpressed genes (DEGs) in\nsub-groups of cancer samples\n,\nconsidering the\nhigh heterogeneity\nof lncRNA expression\namong patients,\nnone have been used in detecting DE lncRNAs in\nindividual patients\n.\n【Hypothesis】The authors’ previous work found that the relative\nexpression rankings of genes (miRNAs) tend to be\nhighly stable\nin specific normal\nhuman tissues but\nwidely disturbed\nin the corresponding cancer\ntissues, and the reversal\nrelationship of rank between genes (miRNAs) expression level can be used\nto identify DE genes (miRNAs) in individual patient. This time, we will\nlook at DE lncRNAs in individual patients in the same way\n【Solution】In this paper, a method LncRIndiv (detect DE lncRNAs in\nindividual patients) is established, that is, a method of prognostic\nmodel construction using gene-pair, that is, prognostic modeling through\npairs of genes.\nFor example, for genes A and B, the expression level of A > B is\nset to 1, and the expression level of A < B is set to 0. Multiple\npairs of genes were screened out and turned into 0 and 1 forms for\nprognostic model construction.\nI’m going to take you through the repetition of this approach.\n【Advantages】The model obtained based on sequencing is platform\nindependent, as long as the expression of single sample genes is\ncomparable. … due to experimental batch effects and platform\ndifferences, the\nscore-based signatures\ntend to produce\nspurious risk classification in independent samples measured by\ndifferent laboratories and are infeasible in clinical application… … we\nfound prognostic signatures derived using the\nrelative genes\n(miRNAs) expression rankings\nwithin samples, rather than the\nabsolute expression values, are robust in\nindependent datasets\nfrom different laboratories and platforms\n.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nlibrary(matlab)\nlibrary(EnvStats)\nlibrary(pheatmap)\n\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # error messages are displayed in English\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # chr is not allowed to be converted to factor\n自定义函数 Custom functions\ndisplay.progress = function (index, totalN, breakN=20) {\n  if ( index %% ceiling(totalN/breakN)  ==0  ) {\n    cat(paste(round(index*100/totalN), \"% \", sep=\"\"))\n  }\n}\n输入文件\n这里用的数据是原文的测试数据GSE27262，包括50例样本，25肿瘤和25正常。GEO数据下载和预处理方式可参考FigureYa203combat。\nInput files\nThe data used here is the original test data GSE27262, including 50\nsamples, 25 tumors and 25 normal. For details about how to download and\npreprocess GEO data, see FigureYa203combat.\n# 加载样本信息\n# Load sample information\nSinfo <- read.table(\"gse27262.sinfo.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\n# 提取肿瘤和正常样本\n# Tumor and normal samples are extracted\ntumsam <- rownames(Sinfo[which(substr(Sinfo$Title,30,31) == \"T\"),])\nnorsam <- rownames(Sinfo[which(substr(Sinfo$Title,30,31) == \"N\"),])\n\n# 加载表达谱\n# Load the expression spectrum\nExpr <- read.table(\"gse27262.expr.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\nExpr$gene <- sapply(strsplit(rownames(Expr),\" /// \"), \"[\",1)\nExpr <- as.data.frame(apply(Expr[,setdiff(colnames(Expr), \"gene\")], 2, function(x) tapply(x, INDEX=factor(Expr$gene), FUN=mean, na.rm=TRUE)))\n\n# 加载注释文件，用于提取lncRNA\n# Load the annotation file for lncRNA extraction\nGinfo <- read.table(\"overlapTable27.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\n\n# 提取lncRNA\n# Extract lncRNA\nLids <- Ginfo[Ginfo$genetype %in% c(\"non_coding\",\"3prime_overlapping_ncRNA\",\"antisense_RNA\",\"lincRNA\",\"sense_intronic\",\"sense_overlapping\",\"macro_lncRNA\",\"bidirectional_promoter_lncRNA\"),]\nLids <- intersect(rownames(Expr),Lids$genename)\nExpr <- Expr[Lids,]\n使用gene-pair构建预后模型\n第一步：表达谱编秩，然后选取在正常样本中秩序一致率达到95%的基因对，即lncRNA1\n- lncRNA2方向一致（<0）的基因对出现在超过95%以上的正常样本中\nUse gene-pair to build a prognostic model\nStep 1: Expression profile ranking, and then select gene pairs with\n95% order consistency rate in normal samples, that is, gene pairs with\nthe same direction (<0) of lncRNA1 - lncRNA2 appear in more than 95%\nof normal samples\nStep 1: The absolute expression profile of lncRNAs is transformed\ninto\nrank profile\n.\nStable lncRNA pairs\nwere defined as patterns of\nrank, such as lncRNA-A < lncRNA-B, appearing in more than 95% of\nnormal samples (P = 6.26 × 10−23, binomial test, Fig. 1a).\n# 表达谱编秩，transform absolute expression profile into rank profile\n# Expression spectrum ranking,transform absolute expression profile into rank profile\nexpr.rank <- apply(Expr, 2, rank)\n\n# 自定义函数，找出stable lncRNA pairs\n# Customize the function to find stable lncRNA pairs\nslec_stable_pair_nor <- function(expE,cutoff) { \n  \n  gid  <- rownames(expE)\n  exp  <- as.matrix(expE)\n  len  <- length(gid)-1 \n  end  <- length(gid)\n  m    <- length(exp[1,]) \n  pair <- matrix(nrow=choose(length(gid),2),ncol=3) \n  j <- 1 \n  for (i in 1:len) {\n    RE=(exp[i*ones(len-i+1,1),]-exp[(i+1):end,]) < 0 \n    if(i == len) {\n      ratio <- sum(RE)/m\n      pair[j,] <- c(rep(gid[i],end-i),gid[(i+1):end],ratio) \n    } else {\n      ratio <- rowSums(RE)/m \n      pair[j:(j+length(RE[,1])-1),] <- c(rep(gid[i],end-i),gid[(i+1):end],ratio) \n      j <- j + length(RE[,1])\n    }\n  } \n  stable_pair_1 <- pair[pair[,3] >= cutoff,1:2] \n  stable_pair_2 <- pair[pair[,3] <= 1-cutoff,2:1] \n  stable_pair <- rbind.data.frame(stable_pair_1,stable_pair_2) \n  rownames(stable_pair) <- paste0(stable_pair$V1,\"-\",stable_pair$V2)\n  return(list(pair = pair,\n              stable_pair = stable_pair,\n              stable_pair_1 = stable_pair_1,\n              stable_pair_2 = stable_pair_2))\n} \n\n# 找出stable lncRNA pairs in normal samples\n# Find stable lncRNA pairs in normal samples\nstablePairNorm <- slec_stable_pair_nor(expr.rank[,norsam],cutoff = 0.95)$stable_pair\nwrite.table(stablePairNorm,\"output_stable lncRNA pair in normal samples.txt\",sep = \"\\t\",row.names = T,col.names = NA,quote = F)\n第二步：选取在肿瘤样本中显著相反的基因对\nStep 2: Select gene pairs that are significantly opposite in the\ntumor sample\nStep 2:Take lncRNA-A as an example. According to the rules in Fig.\n1a, there are five reversal pairs with lncRNA-A in cancer samples,\nincluding partner lncRNAs lncRNA-B, lncRNA-C, lncRNA-D, lncRNA- E, and\nlncRNA-F. **Only the partner lncRNAs that have the same dysregulation\ndirections as lncRNA-A in the lncRNA-A reversal pairs are retained.*\nHere, the dysregulation directions indicated the expression of lncRNA-A\nis up-regulated in the cancer group comparing with the normal group. In\nFig. 1b, the lncRNA-C is removed because of the down-regulation\ntrend.\n这里构建了如原文图1a右下角表格里的频数矩阵，记录了上述稳定的基因对在肿瘤以及在正常样本中，lncRNA1\n> lncRNA2 和 lncRNA1 < lncRNA2的数目。\nHere, the frequency matrix in the table in the lower right corner of\nFigure 1a is constructed to record the number of lncRNA1 > lncRNA2\nand lncRNA1 < lncRNA2 in tumors and normal samples. The Fisher test\nfor the independence of the frequency matrix was performed in order to\nobtain gene pairs that were significantly opposite in the tumor sample,\nand to enrich lncRNA1 > lncRNA2 in the tumor sample.\n对频数矩阵做独立性fisher检验，为了获取在肿瘤样本中方向显著相反的基因对，及在肿瘤样本中富集lncRNA1\n> lncRNA2。\nThe independent Fisher test was performed on the frequency matrix to\nobtain gene pairs that were significantly opposite in the direction in\nthe tumor sample, and to enrich lncRNA1 > lncRNA2 in the tumor\nsample.\nfdr.cutoff <- 0.1\n\noutTab <- NULL\nfor (i in 1:nrow(stablePairNorm)) {\n  display.progress(index = i, totalN = nrow(stablePairNorm))\n  GP1 <- stablePairNorm[i,\"V1\"]\n  GP2 <- stablePairNorm[i,\"V2\"]\n  label <- rownames(stablePairNorm)[i]\n  res <- data.frame(diff.tum = expr.rank[GP1,tumsam] - expr.rank[GP2,tumsam],\n                    diff.nor = expr.rank[GP1,norsam] - expr.rank[GP2,norsam])\n\n  # 计算当前基因对的失调方向（肿瘤 vs 正常）\n  # Calculate the direction of the current gene pair out of regulation (tumor vs normal)\n  avg1 <- mean(expr.rank[GP1,tumsam]) - mean(expr.rank[GP1,norsam])\n  avg2 <- mean(expr.rank[GP2,tumsam]) - mean(expr.rank[GP2,norsam])\n  \n  res$tum.dirct <- factor(ifelse(res$diff.tum < 0,\"a<b.T\",\"a>b.T\"),levels = c(\"a<b.T\",\"a>b.T\"))\n  res$norm.dirct <- factor(ifelse(res$diff.nor < 0,\"a<b.N\",\"a>b.N\"),levels = c(\"a<b.N\",\"a>b.N\"))\n  \n  # 构建矩阵（原文图1a的右下角表格）\n  # Build the matrix (table in the lower right corner of Figure 1a in the original text)\n  tmp <- matrix(c(as.numeric(table(res$norm.dirct)),as.numeric(table(res$tum.dirct))),\n                nrow = 2,byrow = T,\n                dimnames = list(c(\"Normal\",\"Tumor\"),c(\"a<b\",\"a>b\")))\n  \n  # 生成结果\n  # Generate results\n  outTab <- rbind.data.frame(outTab,\n                             data.frame(V1 = GP1, # 当前基因对的第一个基因 # The first gene of the current gene pair\n                                        V2 = GP2, # 当前基因对的第二个基因 # The second gene of the current gene pair\n                                        avg1 = avg1, # 第一个基因在肿瘤vs正常里的秩水平 # The rank level of the first gene in tumor vs normal\n                                        avg2 = avg2, # 第二个基因在肿瘤vs正常里的秩水平 # The rank level of the second gene in tumor vs. normal\n                                        dirct = ifelse(avg1*avg2 > 0,\"same\",\"different\"), # 若基因对的两个基因的失调方向一致则为same，否则为different # If the two genes of the gene pair are in the same direction of dysregulation, it is same, otherwise it is different\n                                        altb.N = tmp[1,1],\n                                        agtb.N = tmp[1,2],\n                                        altb.T = tmp[2,1],\n                                        agtb.T = tmp[2,2],\n                                        p = fisher.test(tmp)$p.value, # fisher检验结果 # Fisher test results\n                                        row.names = label,\n                                        stringsAsFactors = F),\n                             stringsAsFactors = F)\n}\n# 校正p值并选取在正常和肿瘤样本中有差异的基因对\n# Correct the p-value and select the gene pairs that are different in normal and tumor samples\noutTab$FDR <- p.adjust(outTab$p,method = \"BH\")\noutSel <- outTab[which(outTab$FDR < fdr.cutoff),]\noutSel <- outSel[which(outSel$dirct == \"same\"),]\n\n# 保存到文件\n# Save to file\nwrite.table(outTab,\"output_independency test of lncRNA pair between normal and tumor samples.txt\",sep = \"\\t\",row.names = T,col.names = NA,quote = F)\nwrite.table(outSel,\"output_significant lncRNA pair between normal and tumor samples.txt\",sep = \"\\t\",row.names = T,col.names = NA,quote = F)\n第三步：计算lncRNA.A的所有partner在所有样本里的CV，升序排列取前3个表达最稳定的partner用来表征lncRNA.A\nStep 3: Calculate the CVs of all partners of lncRNA.A in all\nsamples, and select the first 3 partners with the most stable expression\nin ascending order to characterize lncRNA.A\nStep 3:Then, we calculate the\ncoefficient of variation\n(CV)\nof rank across cancer and normal samples for each partner\nlncRNA of lncRNA-A in the lncRNA-A reversal pairs (Fig. 1b).\nWe\nhypothesize\nthat if the rank of partner lncRNA is approximately\nconstant across the cancer and normal samples, the reversal relationship\nof lncRNA-A and partner lncRNA may occur because of the rank change of\nlncRNA-A, which could be used as evidence to determine whether lncRNA-A\nis differentially expressed in individual cancer samples. Then, the\npartner lncRNAs of lncRNA-A are ranked by the CV in increasing order. If\nthere are more than 3 reversal pairs for lncRNA-A, the\ntop 3\nreversal pairs\nare retained; otherwise, all are included for\nthe following analysis. In Fig. 1b, the lncRNA-D, lncRNA-E and lncRNA-F\nare the top three lncRNAs with the smallest CV and are included in\nfollowing analysis.\nn.top <- 3 # 取top3个partner # Take the top 3 partners\n\noutTab2 <- NULL\nlncA <- unique(outSel$V1)\nfor (i in lncA) { # 循环每个lncRNA.A # Cycle each lncRNA.A\n  tmp <- outSel[which(outSel$V1 == i),] # 取出所有pair # Extract all pairs\n  resTab <- NULL\n  for (j in tmp$V2) { # 循环每个可能的partner # Cycle through each possible partner\n    expr <- expr.rank[j,]\n    expr.cv <- cv(expr) # 计算CV # Calculate CV\n    resTab <- rbind.data.frame(resTab,\n                               data.frame(lncRNA.A = i,\n                                          partner = j,\n                                          cv = expr.cv,\n                                          stringsAsFactors = F),\n                               stringsAsFactors = Fa)\n  }\n  resTab <- resTab[order(resTab$cv,decreasing = F),,drop = F] # 升序排列 # Sort in ascending order\n  if(nrow(resTab) >= n.top) { # 只取<=n.top个partner # Only < = n.top partners will be extracted\n    resTab <- resTab[1:n.top,]\n  } \n  outTab2 <- rbind.data.frame(outTab2,\n                              resTab,\n                              stringsAsFactors = F)\n}\nwrite.table(outTab2,\"output_lncRNA partner with cv in all samples.txt\",sep = \"\\t\",row.names = F,col.names = T,quote = F)\n第四步：检测差异lncRNA（若超过半数lncRNA.A >\npartner，则该lncRNA.A在该样本中上调，记为1）\nStep 4: Detect differential lncRNAs (if more than half of the\nlncRNAs.A > partner, the lncRNA.A will be upregulated in the sample\nand denoted as 1)\nStep 4: In this example, the top 3 reversal lncRNA pairs (lncRNA-A\n> lncRNA-D, lncRNA-A > lncRNA-E and lncRNA-A > lncRNA-F) are\nused to determine whether lncRNA-A is differentially expressed in an\nindividual patient.\nIf more than half of the reversal lncRNA\npairs are detected in a patient\n, we conclude that lncRNA-A is\ndifferentially expressed in the patient (red human shape in Fig.\n1b).\ndysTab <- as.data.frame(matrix(NA,nrow = length(lncA),ncol = length(tumsam),byrow = T,\n                 dimnames = list(lncA,tumsam)))\n\nfor (i in tumsam) { # 循环每个肿瘤样本 # Circulate each tumor sample\n  for (j in lncA) { # 循环每个lncRNA.A # Cycle each lncRNA.A\n    tmp <- outTab2[which(outTab2$lncRNA.A == j),] # 取出该lncRNA.A的对应partner # Extract the lncRNA.A's partner\n    pos <- 0\n    for (k in tmp$partner) { # 循环每个partner # Loop each partner\n      if(expr.rank[j,i] - expr.rank[k,i] > 0) { # 判断lncRNA.A的表达是否大于partner的表达 # Determine whether the expression of lncRNA.A is greater than that of partner\n        pos <- pos + 1 # 若大于则增加一次计数 # If it is greater than that, the count will be increased by one time\n      } else {pos <- pos}\n    }\n    \n    if(pos >= ceiling(0.5 * nrow(tmp))) { # 若计数超过半数的partner # If more than half of the partners are counted\n      dysTab[j,i] <- 1 # 则该lncRNA.A在该样本i中为1 # then the lncRNA.A is 1 in the sample i\n      } else {\n      dysTab[j,i] <- 0 # 否则为0 # Otherwise it is 0\n      }\n  }\n}\n\nwrite.table(dysTab,\"output_lncRNA dysregulation matrix in tumor samples.txt\",sep = \"\\t\",row.names = T,col.names = NA,quote = F)\n开始画图\n画个热图瞧一瞧\n上面找到的差异基因在各个sample中的上下调情况。\nStart drawing\nDraw a heatmap and take a look\nThe up-down and down-regulation of the differentially generated genes\nfound above in each sample.\npheatmap(dysTab,\n         border_color = NA,\n         cluster_rows = T,\n         cluster_cols = T,\n         color = c(\"black\",\"yellow\"),\n         show_colnames = T,\n         show_rownames = F,\n         legend_breaks = c(0,0.5,1),\n         legend_labels = c(\"DN.Reg.\",\"\",\"UP.Reg.\"),\n         filename = \"lncRNA dysregulation heatmap.pdf\")\n\nsave.image(file = \"GP.RData\")\ngene-pair关系的展示\n这些gene-pair的关系、CV值，以及上下调方向，可以画个网络图来展示，可参考\nFigureYa199crosslink\n。\n或者用热图、散点图等方式展示基因表达的相关性和p value，Fig. 3\nbc，可参考\nhttps://mp.weixin.qq.com/s/D9wheY5QdnOh4JrjIc8-Cg\n。\n或者用散点图展示基因对在两组样本中的表达趋势，可参考\nFigureYa96R2\nGene-pair relationship display\nThe relationship between these gene-pairs, CV values, and the\ndirection of upward and downward adjustments can be shown by drawing a\nnetwork diagram, which can be referred to ‘FigureYa199crosslink’.\nOr use heat maps, scatter plots, etc. to show the correlation and p\nvalue of gene expression, Fig. 3 bc, refer to\nhttps://mp.weixin.qq.com/s/D9wheY5QdnOh4JrjIc8-Cg\n。\nAlternatively, a scatter plot can be used to show the expression\ntrend of gene pairs in two groups of samples, please refer to\n‘FigureYa96R2’\ngene-pair 作为诊断marker的效果（Performance evaluation）\n生存分析，Fig. 2 abc，可参考\nFigureYa1survivalCurve\n高低风险组基因表达量分布，Fig. 2\nde，可参考\nFigureYa162boxViolin\nCox regression analyses，Table\n2，可参考\nFigureYa47HRtable\nEffect of gene-pair as a diagnostic marker (Performance\nevaluation)\nSurvival analysis, Fig. 2 abc, see ‘FigureYa1survivalCurve’\nGene expression distribution in the high and low risk groups, Fig. 2\nde, see ‘FigureYa162boxViolin’\nCox regression analyses, Table 2, see ‘FigureYa47HRtable’\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa233genepair_FigureYa233genepair",
      "title": "FigureYa233genepair/FigureYa233genepair.html",
      "html": "FigureYa233genepair/FigureYa233genepair.html",
      "text": "texts/main_FigureYa233genepair_FigureYa233genepair.txt",
      "folder": "FigureYa233genepair",
      "thumb": "gallery_compress/FigureYa233genepair.webp"
    },
    "word_count": 2371,
    "lines_count": 450,
    "title": "FigureYa233genepair",
    "description": "想按照文中的方法构建基因对预后模型 Requirement Description I want to construct a gene pair prognostic model according to the",
    "input_data_types": [
      "临床数据",
      "生存数据"
    ],
    "output_types": [
      "热图",
      "箱线图",
      "统计表格",
      "散点图",
      "网络图",
      "生存曲线"
    ],
    "technical_methods": [
      "网络分析",
      "通路分析",
      "生存分析",
      "差异表达分析"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "V1",
      "header",
      "avg2",
      "cluster_cols",
      "nrow",
      "breakN",
      "dirct",
      "cutoff",
      "totalN"
    ]
  },
  {
    "id": "main_FigureYa148SimpleDendrogram_FigureYa148SimpleDendrogram",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa148SimpleDendrogram_FigureYa148SimpleDendrogram.txt",
    "content": "FigureYa148SimpleDendrogram\nFigureYa148SimpleDendrogram\nAuthor(s)\n: Xiaofan Lu\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n绘制带有注释信息的dendrogram。 Draw a dendrogram with annotation\ninformation.\nFIGURE 4 | Validation of LNM signature via supervised clustering. (A)\nDendrogram created by supervised hierarchical clustering using the GEO\ncohort significantly distinguished LN metastasis status (p = 0.048) and\na dendrogram created for the MSKCC cohort in (B) identified two clusters\nwith a tendency whereby LNM signature was associated with (C) OS (p =\n0.075) and (D) PFS (p = 0.098). Cluster C2 was regarded as reference\nwhen calculating HR.\n出自\nhttps://www.frontiersin.org/articles/10.3389/fonc.2019.00488/full\nFrom\nhttps://www.frontiersin.org/articles/10.3389/fonc.2019.00488/full\n思路可参考这篇：\nhttps://mp.weixin.qq.com/s/ul0XPjBDuqMfWRwHi9-TgQ\nFor\nideas, please refer to this article:\nhttps://mp.weixin.qq.com/s/ul0XPjBDuqMfWRwHi9-TgQ\n图的解读\nInterpretation of the\ngraph\n用两套数据对上文找出的淋巴结转移signature（marker\ngenes）做验证：GEO数据（A）已知是否有淋巴结转移，MSKCC（B）已知生存期。用signature做分类，同时把已知信息画在图上，让分类效果一目了然。\nUse two sets of data to verify the lymph node metastasis signature\n(marker genes) found above: GEO data (A) is known to have lymph node\nmetastasis, and MSKCC (B) is known to have survival. Use the signature\nfor classification and draw the known information on the graph to make\nthe classification effect clear at a glance.\n应用场景\nApplication scenario\n用TCGA数据找到的signature，再用其他数据集做验证。可以用这个图展示预测效果。\nUse the signature found by TCGA data and then use other data sets for\nverification. This graph can be used to show the prediction effect.\n环境设置\nEnvironment settings\ninstall.packages(c(\"dendsort\", \"squash\"))\nLoad package\nsource(\"install_dependencies.R\")\nlibrary(ClassDiscovery)\nlibrary(dendsort)\nlibrary(squash)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 #Display English error message\noptions(stringsAsFactors = FALSE) #禁止chr转成factor #Disable chr to factor conversion\n参数设置\nParameter setting\njco <- c(\"#2874C5\",\"#EABF00\")\ncherry <- \"#700353\"\nlightgrey <- \"#dcddde\"\nA图\nA figure\n输入文件\nInput file\neasy_input_set1.txt，带有淋巴结转移信息的GEO数据表达数据。是否淋巴结转移的信息在sample\nID里。 easy_input_set1.txt, GEO data expression data with lymph node\nmetastasis information. Whether the information of lymph node metastasis\nis in the sample ID.\nvad1.expr <- read.table(\"easy_input_set1.txt\",sep = \"\\t\",check.names = F,stringsAsFactors = F,header = T,row.names = 1) # 样本信息在列名中 # Sample information is in the column name\nvad1.expr[1:2,]\n聚类和画图\nClustering and drawing\nindata <- vad1.expr\nhcs <- hclust(distanceMatrix(as.matrix(indata), \"pearson\"), \"ward.D\") # 样本层次聚类\n# Sample hierarchical clustering\nc.clust <- cutree(hcs,k=2) # 切割树为2类 # Cut the tree into 2 categories\nc.clust <- data.frame(clust=as.numeric(c.clust),\n                      group=rep(c(\"+\",\"-\"),times=5)) # 生成聚类信息并添加样本信息\n# Generate clustering information and add sample information\nmy.dend <- dendsort(hcs) # 利用dendsort来排序树，稍微好看一点\n# Use dendsort to sort the tree, which is a little better\n\n# 生成匹配dendrogram的注释文件，并根据信息修改颜色\n# Generate annotation files matching dendrogram and modify colors according to information\nmy.mat <- data.frame(Clust=paste0(\"C\",as.character(c.clust$clust)),\"MetaStatus\"=rep(c(\"LN+\",\"LN-\"),times=5))\nmy.mat$Clust <- ifelse(my.mat$Clust == \"C1\",jco[2],jco[1]) # 聚类结果的颜色 # Color of clustering results\nmy.mat$MetaStatus <- ifelse(my.mat$MetaStatus == \"LN+\",jco[2],jco[1]) # 样本淋巴结转移状态的颜色\n# Color of sample lymph node metastasis status\n\npdf(\"dendrogram for validation 1.pdf\",height = 6,width = 7)\ndendromat(my.dend, my.mat,\n          las = 2,labRow = NA)\nlegend(x=0.4,y=0.9, # 位置（需要微调）\n       legend = c(\"MetaStatus\",\"LN+\",\"LN-\"), # 图例名，第一个为title\n# Legend name, the first one is title\n       fill = c(NA,jco[2:1]), # 颜色，第一个为title所以不需要颜色\n# Color, the first one is title so no color is needed\n       cex=1, border=NA, y.intersp=.8, x.intersp=0.2, # 细节参数，包括大小，横向纵向间距\n# Detail parameters, including size, horizontal and vertical spacing\n       bty = \"n\") # 不绘制图例框 # Do not draw legend frame\nlegend(x=0.4,y=0.72, \n       legend = c(\"Clust\",\"C1\",\"C2\"), \n       fill = c(NA,jco[2:1]),\n       cex=1, border=NA, y.intersp=.8, x.intersp=0.2,\n       bty = \"n\")\ninvisible(dev.off())\nB图\nFigure B\n输入文件\nInput file\neasy_input_set2.txt，MSKCC队列的表达矩阵 easy_input_set2.txt,\nexpression matrix of MSKCC cohort\neasy_input_set2_suv.txt，MSKCC队列的生存信息 easy_input_set2_suv.txt,\nsurvival information of MSKCC cohort\n# 表达数据\n# Expression data\nvad2.expr <- read.table(\"easy_input_set2.txt\",sep = \"\\t\",check.names = F,stringsAsFactors = F,header = T,row.names = 1)\nvad2.expr[1:2,1:4]\n# 生存信息\n# Survival information\nvad2.sinfo <- read.table(\"easy_input_set2_suv.txt\",sep = \"\\t\",check.names = F,stringsAsFactors = F,header = T,row.names = 1)\nvad2.sinfo[1:2,]\n# 两个文件一致性检测\n# Two files consistency check\nif(!identical(colnames(vad2.expr),rownames(vad2.sinfo))) {\n  cat(\"Expression matrix mismatched sample information. Please check!\\n\")\n}\n聚类和画图\nClustering and drawing\nindata <- vad2.expr\nhcs <- hclust(distanceMatrix(as.matrix(indata), \"pearson\"), \"ward.D\") # 样本层次聚类\n# Sample hierarchical clustering\nc.clust <- cutree(hcs,k=2) # 切割树为2类\n# Cut the tree into 2 categories\n\n# 生成聚类信息并添加样本信息\n# Generate clustering information and add sample information\nannCol_val <- data.frame(Clust=paste0(\"C\",as.character(c.clust)), # \n                         OS=vad2.sinfo$OS_STATUS,\n                         PFS=vad2.sinfo$DFS_STATUS,\n                         row.names = names(c.clust),\n                         stringsAsFactors = F)\n\nannCol_val[is.na(annCol_val$OS),\"OS\"]=\"N/A\" # 没有OS设置为N/A # No OS is set to N/A\nannColors_val <- list() # 生成注释文件对应的颜色 # Generate the color corresponding to the annotation file\nannColors_val[[\"Clust\"]] <- c(\"C1\"=jco[1],\"C2\"=jco[2])\nannColors_val[[\"OS\"]] <- c(\"LIVING\"=lightgrey,\"DECEASED\"=cherry,\"N/A\"=\"white\")\nannColors_val[[\"PFS\"]] <- c(\"DiseaseFree\"=lightgrey,\"Recurred/Progressed\"=cherry)\n\nmy.dend <- dendsort(hcs) # 利用dendsort来排序树，稍微好看一点 # Use dendsort to sort the tree, which is a little better\nmy.mat <- annCol_val\n\n# 根据注释信息修改颜色\n# Modify the color according to the annotation information\nmy.mat$Clust <- ifelse(my.mat$Clust == \"C1\",jco[2],jco[1])\nmy.mat$OS <- ifelse(my.mat$OS == \"LIVING\",lightgrey,ifelse(my.mat$OS == \"DECEASED\",cherry,\"white\"))\nmy.mat$PFS <- ifelse(my.mat$PFS == \"DiseaseFree\",lightgrey,cherry)\n\npdf(\"dendrogram for validation 2.pdf\",height = 6,width = 7)\ndendromat(my.dend, my.mat,\n          las = 2,labRow = NA)\nlegend(x=0.4,y=0.9, legend = c(\"PFS\",\"DiseaseFree\",\"Recurred/Progressed\"), fill = c(NA,lightgrey,cherry),cex=1, border=NA, y.intersp=.8, x.intersp=0.2,bty = \"n\")\nlegend(x=0.4,y=0.72, legend = c(\"OS\",\"LIVING\",\"DECEASED\",\"N/A\"), fill = c(NA,lightgrey,cherry,\"white\"),cex=1, border=NA, y.intersp=.8, x.intersp=0.2,bty = \"n\")\nlegend(x=0.4,y=0.54, legend = c(\"Clust\",\"C1\",\"C2\"), fill = c(NA,jco[2:1]),cex=1, border=NA, y.intersp=.8, x.intersp=0.2,bty = \"n\")\ninvisible(dev.off())\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa148SimpleDendrogram_FigureYa148SimpleDendrogram",
      "title": "FigureYa148SimpleDendrogram/FigureYa148SimpleDendrogram.html",
      "html": "FigureYa148SimpleDendrogram/FigureYa148SimpleDendrogram.html",
      "text": "texts/main_FigureYa148SimpleDendrogram_FigureYa148SimpleDendrogram.txt",
      "folder": "FigureYa148SimpleDendrogram",
      "thumb": "gallery_compress/FigureYa148SimpleDendrogram.webp"
    },
    "word_count": 791,
    "lines_count": 171,
    "title": "FigureYa148SimpleDendrogram",
    "description": "Requirement description 绘制带有注释信息的dendrogram。 Draw a dendrogram with annotation information.",
    "input_data_types": [
      "临床数据",
      "表达矩阵",
      "生存数据"
    ],
    "output_types": [
      "统计表格",
      "生存曲线"
    ],
    "technical_methods": [
      "聚类分析"
    ],
    "biology_areas": [],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "intersp",
      "Clust",
      "times",
      "header",
      "width",
      "legend",
      "group",
      "p",
      "k"
    ]
  },
  {
    "id": "main_FigureYa235scDEG_FigureYa235scDEG",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa235scDEG_FigureYa235scDEG.txt",
    "content": "FigureYa235scDEG\nFigureYa235scDEG\nXiao Gu\n2025-9-12\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n单细胞测序分不同的cluster，然后在每个cluster上做DEGs的点图，最好是log2FC为负的标蓝。然后自定义显示想要的点。\n输入数据用seurat用的PBMC那个测试数据吧\nRequirement Description\nSingle-cell sequencing is divided into different clusters, and then a\ndot plot of DEGs is made on each cluster, preferably with a negative\nlog2FC in blue. Then customize the display of the desired points. The\ninput data will be the PBMC test data for the seurat\n出自\nhttps://www.sciencedirect.com/science/article/pii/S0092867419312826?via%3Dihub\nfrom\nhttps://www.sciencedirect.com/science/article/pii/S0092867419312826?via%3Dihub\nFigure 2. Global Spatiotemporal Analysis of Three Cardiac\nDevelopmental Stages (H) Differential gene expression analysis showing\nup- and down-regulated genes across all ten clusters. An adjusted p\nvalue < 0.01 is indicated in red, while an adjusted p value R 0.01 is\nindicated in black.\n应用场景\n分类展示各cluster的marker gene表达趋势变化的分布情况。\n可以像原文那样标注显著上调或下调表达的基因名，或者标注参与某一通路的基因名。\nApplication Scenarios\nThe distribution of marker gene expression trends in each cluster is\ndisplayed by category.\nGene names that are significantly up- or down-regulated, or gene\nnames involved in a pathway, can be labeled as in the original text.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nlibrary(dplyr)\nlibrary(Seurat)\nlibrary(patchwork)\nlibrary(reshape2)\nlibrary(RColorBrewer)\nlibrary(ggplot2)\nlibrary(ggrepel)  # Used to annotate text\nlibrary(magrittr)\n\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # error messages are displayed in English\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # chr is not allowed to be converted to factor\n输入文件及预处理\n输入文件\n这部分与“FigureYa224scMarker”相同\n以Seurat官网PBMC数据为例，跟FigureYa111markerGene和FigureYa160scGSVA用的是同一套数据，出自不同作者之手，可相互参考。\n下载\nhttps://cf.10xgenomics.com/samples/cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz\n，解压到当前文件夹。\n预处理过程参考\nhttps://satijalab.org/seurat/v3.2/pbmc3k_tutorial.html\nInput files and preprocessing\nInput files\nThis part is the same as “FigureYa224scMarker”.\nTaking the PBMC data on the official website of Seurat as an example,\nit uses the same set of data as FigureYa111markerGene and\nFigureYa160scGSVA, which are from different authors and can be\ncross-referenced.\nDownload the\nhttps://cf.10xgenomics.com/samples/cell/pbmc3k/pbmc3k_filtered_gene_bc_matrices.tar.gz\nand extract it to the current folder.\nRefer to\nhttps://satijalab.org/seurat/v3.2/pbmc3k_tutorial.html\nfor the pretreatment process\n# 解压缩\n# Unzip\ntar -zxvf pbmc3k_filtered_gene_bc_matrices.tar.gz\n# Load the PBMC dataset\npbmc.data <- Read10X(data.dir = \"filtered_gene_bc_matrices/hg19/\")\n# Initialize the Seurat object with the raw (non-normalized data).\npbmc <- CreateSeuratObject(counts = pbmc.data, project = \"pbmc3k\", min.cells = 3, min.features = 200)\npbmc\n预处理\nPreprocessing\n# 进行QC\n# 计算mitochondria基因比例\n# Perform QC\n# Calculate the mitochondria gene ratio\npbmc[[\"percent.mt\"]] <- PercentageFeatureSet(pbmc, pattern = \"^MT-\")\n\n# Visualize QC metrics as a violin plot\nVlnPlot(pbmc, features = c(\"nFeature_RNA\", \"nCount_RNA\", \"percent.mt\"), ncol = 3)\nplot1 <- FeatureScatter(pbmc, feature1 = \"nCount_RNA\", feature2 = \"percent.mt\")\nplot2 <- FeatureScatter(pbmc, feature1 = \"nCount_RNA\", feature2 = \"nFeature_RNA\")\nplot1 + plot2\n# Normalizing the data\npbmc <- NormalizeData(pbmc, normalization.method = \"LogNormalize\", scale.factor = 10000)\n#Identification of highly variable features\npbmc <- FindVariableFeatures(pbmc, selection.method = \"vst\", nfeatures = 2000)\n# Identify the 10 most highly variable genes\n# top10 <- head(VariableFeatures(pbmc), 10)\n# plot variable features with and without labels\n# plot1 <- VariableFeaturePlot(pbmc)\n# plot2 <- LabelPoints(plot = plot1, points = top10, repel = TRUE)\n# plot1 + plot2\n\n# Scale the data\nall.genes <- rownames(pbmc)\npbmc <- ScaleData(pbmc, features = all.genes)\n# Perform linear dimensional reduction\npbmc <- RunPCA(pbmc, features = VariableFeatures(object = pbmc))\n#print(pbmc[[\"pca\"]], dims = 1:5, nfeatures = 5)\nVizDimLoadings(pbmc, dims = 1:2, reduction = \"pca\")\nDimPlot(pbmc, reduction = \"pca\")\nDimHeatmap(pbmc, dims = 1:15, cells = 500, balanced = TRUE)\n# NOTE: This process can take a long time for big datasets, comment out for expediency. More\n# approximate techniques such as those implemented in ElbowPlot() can be used to reduce\n# computation time\n\n##以下酌情运行，比较耗时，可以不运行，直接看ElbowPlot\n## The following is run as appropriate, it is more time-consuming, you can not run it, and directly look at ElbowPlot\n#pbmc <- JackStraw(pbmc, num.replicate = 100)\n#pbmc <- ScoreJackStraw(pbmc, dims = 1:20)\n#JackStrawPlot(pbmc,dims = 1:20)\nElbowPlot(pbmc)\nElbowPlot对主要PC进行排序，“拐弯”处之前的PC均可被选择，这里看到第10个PC处出现拐点，所以后续选择前10个PC进行降维\nElbowPlot sorts the main PCs, and the PCs before the “bend” can be\nselected, and here we see that there is an inflection point at the 10th\nPC, so the first 10 PCs are selected for dimensionality reduction\n# Cluster the cells\npbmc <- FindNeighbors(pbmc, dims = 1:10)\npbmc <- FindClusters(pbmc, resolution = 0.5)\n#Run non-linear dimensional reduction (UMAP/tSNE)\npbmc <- RunUMAP(pbmc, dims = 1:10)\npA1 <- DimPlot(pbmc, reduction = \"umap\", label = T)+ NoLegend()\nggsave(\"plotA_1_UMAP_cluster.pdf\", plot = pA1, width = 6, height = 6)\n找cluster biomarkers\nFind cluster biomarkers\n# Finding differentially expressed features (cluster biomarkers)\n\n# find markers for every cluster compared to all remaining cells\npbmc.markers <- FindAllMarkers(pbmc, \n                               min.pct = 0.25, \n                               logfc.threshold = 0.25)\n最新版本的Seurat的cutoff跟以前不一样，Seurat\n3.X.X以下用的是自然对数log，Seurat 4.X.X用的是log2，所以用Seurat\n4.X.X的话，最后画出的图里的点会更多。\nThe cutoff of the latest version of Seurat is different from before,\nSeurat 3.X.X and below use the natural logarithmic log, and Seurat 4.X.X\nuses log2, so if you use Seurat 4.X.X, you will end up with more points\nin the graph.\n# 这里用的Seurat版本是4.0.1\n# 如果你用的是Seurat 3.X.X以下版本，需要把本文档所有的avg_log2FC替换为avg_logFC，或者运行下面这行\n# The Seurat version used here is 4.0.1\n# If you are using Seurat 3.X.X or earlier, you will need to replace all the avg_log2FC in this document with avg_logFC, or run the following line\n#pbmc.markers$avg_log2FC <- pbmc.markers$avg_logFC\n\n# 查看top10 marker gene\n# View the top 10 marker gene\ntop10 <- pbmc.markers %>% group_by(cluster) %>% top_n(n = 10, wt = avg_log2FC)\nDoHeatmap(pbmc, features = top10$gene) + NoLegend()\n鉴定细胞类型\n如果只是为了复现文章中的图，可以不鉴定细胞类型，以下部分可不run，根据结合每个cluster的marker基因和生物学知识确定细胞类型。\n为了接近真实情况并结合示例数据，这里不将细胞类型划分的这么详细，进行以下更改\nIdentify cell types\nIf you don’t need to identify the cell types just to reproduce the\ndiagram in the article, the following section can be done without\nrunning and determine the cell type based on the knowledge of the marker\ngenes and biology that binds each cluster.\nIn order to get close to the real situation and combine the example\ndata, the cell types are not divided into such details here, and the\nfollowing changes are made\n# 给每个cluster标注细胞类型\n# Label each cluster with cell types\nnew.cluster.ids <- c(\"T\", \"Mono\", \"T\", \"B\", \"T\", \"Mono\", \"NK\", \"DC\", \"Platelet\")\nnames(new.cluster.ids) <- levels(pbmc)\npbmc <- RenameIdents(pbmc, new.cluster.ids)\n# 添加细胞类型至meta data\n# Add cell types to meta data\npbmc@meta.data$celltype <- pbmc@active.ident\nDimPlot(pbmc, reduction = \"umap\", label = TRUE, pt.size = 0.5) + NoLegend()\npA2 <-  pA2 <- DimPlot(pbmc, reduction = \"umap\", label = F,group.by = \"celltype\")\nggsave(\"plotA_1_UMAP_celltype.pdf\", plot = pA2, width = 6, height = 6)\n\n# 自定义颜色\n# Custom colors\ncolourCount <- length(unique(pbmc@meta.data$celltype))\ngetPalette <- colorRampPalette(brewer.pal(8, \"Dark2\"))\ncelltype_colors <- getPalette(colourCount)\npA2 <- pA2 <- DimPlot(pbmc, reduction = \"umap\", label = F,group.by = \"celltype\",cols = celltype_colors)\nggsave(\"plotA_1_UMAP_celltype_color.pdf\", plot = pA2, width = 6,height = 6)\n\n## 拼图\n## Puzzles\npA_all <- pA1 + pA2 + plot_layout(ncol = 2, widths = c(1, 1))\n## 保存\n## Save\nggsave(\"plotA_all.pdf\", plot = pA_all, width = 12, height = 6)\n\ncelltype <- c(\"T\",\"Mono\",\"B\",\"NK\",\"DC\",\"Platelet\")\npbmc@meta.data$celltype <- factor(pbmc@meta.data$celltype, celltype)\nsaveRDS(pbmc, \"pbmc_test_final.rds\")\n设置cutoff，定义显著/非显著的上/下调marker gene\nSet cutoff to define significant/non-significant up/down marker\ngene\n# 查看每个cluster的marker gene\n# View the marker gene of each cluster\npbmc.markers %>% group_by(cluster) %>% top_n(n = 2, # 前两个 # The first two\n                                             wt = avg_log2FC)\n# 查看每个cluster的marker基因数量\n# Check the number of marker genes in each cluster\ntable(pbmc.markers$cluster)\n# 根据自己计算的marker基因数量确定log2FC的阈值，这里先定为0.5\n# Determine the threshold of log2FC based on the number of marker genes calculated by yourself, here it is set to 0.5 first\npbmc.markers <- subset(pbmc.markers, p_val_adj < 0.05 & abs(avg_log2FC) > 0.5)\npbmc.markers$threshold <- as.factor(ifelse(pbmc.markers$avg_log2FC > 0 , 'Up', 'Down'))\ndim(pbmc.markers)\ntable(pbmc.markers$threshold)\npbmc.markers$adj_p_signi <- as.factor(ifelse(pbmc.markers$p_val_adj < 0.01 , 'Highly', 'Lowly'))\npbmc.markers$thr_signi <- paste0(pbmc.markers$threshold, \"_\", pbmc.markers$adj_p_signi)\npbmc.markers$cluster %<>% as.vector(.) %>% as.numeric(.)\n\n# 保存到文件\n# Save to file\nwrite.csv(pbmc.markers, \"output_pbmc.markers.csv\", quote = F)\n自定义显示想要展示的基因名\n这里挑选log2FC为top5的基因进行展示\nCustomize the display of the gene name you want to display\nHere, log2FC is selected as the top 5 genes for display\ntop_up_label <- pbmc.markers %>% \n  subset(., threshold%in%\"Up\") %>% \n  group_by(cluster) %>% \n  top_n(n = 5, wt = avg_log2FC) %>% \n  as.data.frame()\n\ntop_down_label <- pbmc.markers %>% \n  subset(., threshold %in% \"Down\") %>% \n  group_by(cluster) %>% \n  top_n(n = -5, wt = avg_log2FC) %>% \n  as.data.frame()\n\ntop_label <- rbind(top_up_label,top_down_label)\ntop_label$thr_signi %<>% \n  factor(., levels = c(\"Up_Highly\",\"Down_Highly\",\"Up_Lowly\",\"Down_Lowly\"))\n\n# 保存到文件，便于小白套用格式\n# Save to a file for easy formatting\n#write.csv(top_label, \"easy_input_label.csv\", quote = F)\n也可以基于output_pbmc.markers.csv文件，手动挑选出想要标注名字的基因，例如标注参与某一通路的基因，然后将文件命名为easy_input_label.csv\nYou can also manually pick out the genes you want to name based on\noutput_pbmc.markers.csv files, such as genes involved in a pathway, and\nthen name the file easy_input_label.csv\n开始画图\nStart drawing\n# 读取修改后的要标注的基因名文件\n# Read the modified gene name file to be labeled\n#top_label <- read.csv(\"easy_input_label.csv\")\n\n### 准备绘制暗灰色背景所需数据 \n### Prepare the data needed to draw a dark gray background\nbackground_position <- pbmc.markers %>%\n  group_by(cluster) %>%\n  summarise(Min = min(avg_log2FC) - 0.2, Max = max(avg_log2FC) + 0.2) %>%\n  as.data.frame()\nbackground_position$cluster %<>% as.vector(.) %>% as.numeric(.)\nbackground_position$start <- background_position$cluster - 0.4\nbackground_position$end <- background_position$cluster + 0.4\n\n### 准备绘制中间区域cluster彩色bar所需数据\n### Prepare the data required to plot the cluster color bar in the middle region\ncluster_bar_position <- background_position\ncluster_bar_position$start <- cluster_bar_position$cluster - 0.5\ncluster_bar_position$end <- cluster_bar_position$cluster + 0.5\ncluster_bar_position$cluster %<>% \n  factor(., levels = c(0:max(as.vector(.))))\n\n## 设置填充颜色\n## Set the fill color\ncols_thr_signi <- c(\"Up_Highly\" = \"#d7301f\",\n                    \"Down_Highly\" = \"#225ea8\",\n                    \"Up_Lowly\" = \"black\",\n                    \"Down_Lowly\" = \"black\")\ncols_cluster <- c(\"0\" = \"#35978f\",\n                  \"1\" = \"#8dd3c7\",\n                  \"2\" = \"#ffffb3\",\n                  \"3\" = \"#bebada\",\n                  \"4\" = \"#fb8072\",\n                  \"5\" = \"#80b1d3\",\n                  \"6\" = \"#fdb462\",\n                  \"7\" = \"#b3de69\",\n                  \"8\" = \"#fccde5\")\n\np <- ggplot() +\n  geom_rect(data = background_position, aes(xmin = start, xmax = end, ymin = Min,\n                                          ymax = Max),\n            fill = \"#525252\", alpha = 0.1) + ###添加灰色背景色 ### Add a gray background color\n  geom_jitter(data = pbmc.markers, aes(x = cluster, y = avg_log2FC, colour = thr_signi),\n              size = 1,position = position_jitter(seed = 1)) +\n  scale_color_manual(values = cols_thr_signi) +\n  scale_x_continuous(limits = c(-0.5, max(pbmc.markers$cluster) + 0.5),\n                     breaks = seq(0, max(pbmc.markers$cluster), 1),\n                     label = seq(0, max(pbmc.markers$cluster),1)) + #修改坐标轴显示刻度 # Modify the axis display scale\n  \n  # 根据top_label标注基因名\n  # Label the gene name according to the top_label\n  geom_text_repel(data = top_label, aes(x = cluster, y = avg_log2FC, label = gene),\n                  position = position_jitter(seed = 1), show.legend = F, size = 2.5,\n                  box.padding = unit(0, \"lines\")) +\n  \n  geom_rect(data = cluster_bar_position, aes(xmin = start, xmax = end, ymin = -0.4,\n                                           ymax = 0.4, fill = cluster), color = \"black\", alpha = 1, show.legend = F) +\n  scale_fill_manual(values = cols_cluster) +\n  labs(x = \"Cluster\", y = \"average log2FC\") +\n  theme_bw()\n\nplot1 <- p + theme(panel.grid.minor = element_blank(), ##去除网格线 ## Remove grid lines\n                   panel.grid.major = element_blank(),\n                   axis.text.y = element_text(colour = 'black', size = 14),\n                   axis.text.x = element_text(colour = 'black', size = 14, vjust = 50), #调整x轴坐标,vjust的值按照最终结果稍加调整 # Adjust the x-axis coordinates, and the value of vjust will be slightly adjusted according to the final result\n                   panel.border = element_blank(), ## 去掉坐标轴 ## Remove the axes\n                   axis.ticks.x = element_blank(), ## 去掉的坐标刻度线 ## Removed coordinate tick marks\n                   axis.line.y = element_line(colour = \"black\")) #添加y轴坐标轴 # Add the y-axis\nggsave(filename = \"Marker_gene_pointplot.pdf\", plot = plot1, width = 9, height = 6)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa235scDEG_FigureYa235scDEG",
      "title": "FigureYa235scDEG/FigureYa235scDEG.html",
      "html": "FigureYa235scDEG/FigureYa235scDEG.html",
      "text": "texts/main_FigureYa235scDEG_FigureYa235scDEG.txt",
      "folder": "FigureYa235scDEG",
      "thumb": "gallery_compress/FigureYa235scDEG.webp"
    },
    "word_count": 1713,
    "lines_count": 323,
    "title": "FigureYa235scDEG",
    "description": "单细胞测序分不同的cluster，然后在每个cluster上做DEGs的点图，最好是log2FC为负的标蓝。然后自定义显示想要的点。 输入数据用seurat用的PBMC那个测试数据吧 Requirement Description",
    "input_data_types": [
      "单细胞"
    ],
    "output_types": [
      "箱线图",
      "热图",
      "统计表格",
      "PCA图",
      "散点图"
    ],
    "technical_methods": [
      "通路分析",
      "标准化"
    ],
    "biology_areas": [
      "药物研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "colour",
      "seed",
      "values",
      "width",
      "xmin",
      "n",
      "Max",
      "object"
    ]
  },
  {
    "id": "main_FigureYa192breakpoint_FigureYa192breakpoint",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa192breakpoint_FigureYa192breakpoint.txt",
    "content": "FigureYa192breakpoint\nFigureYa192breakpoint\nAuthor(s)\n: Xiaofan Lu\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement\n求实现Fig 2，输入seer数据，循环cox模型，lowess平滑并绘图。 To draw\nthe Fig 2, input the seer data, loop the cox model, smooth it with\nlowess and plot it.\n出自\nhttps://ascopubs.org/doi/full/10.1200/JCO.2016.67.5140\nfromhttps://ascopubs.org/doi/full/10.1200/JCO.2016.67.5140\nFig 2. LOWESS smoother fitting curves of stage migration and overall\nsurvival and\ndetermination of structural break points with use\nof the Chow test\n. The fitting bandwidth was 2/3. (A) and (B)\nStage migration was estimated by logistic regression after adjusting for\nT staging, N staging, histology, tumor location, and operation type in\nboth cohorts. (C) and (D) Overall survival was estimated by using the\nCox proportional hazards regression model after adjusting for sex, age,\nT staging, histology, and operation type. ELN, examined lymph node.\n这里画C图，cox。A图logistic就是对OR做平滑，原理都是一样的。 Here is\nFigure C, cox. logistic in Graph A is smoothing out OR, and the\nprinciple is the same for both.\n应用场景\nApplication Scenarios\n大样本下寻找某计数变量对预后风险的变点。 Search for the change point\nof a certain counting variable on prognostic risk in a large sample.\n这里以SEER数据库的数据为例，也可以用于自己的数据。 Here, we take the\ndata from the SEER database as an example, which can also be used for\nour own data.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(survival)\nlibrary(strucchange)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息   # Display an English error message\noptions(stringsAsFactors = FALSE) #禁止chr转成factor  # prohibit chr from being converted to factor\n输入文件的获得\nAcquisition of Input Files\n如果你的数据已经整理成easy_input.csv的格式，就跳过这步，直接进入“输入文件”。\nIf your data has been organized into the format of easy_input.csv, skip\nthis step and go directly to “Input File”.\n加载SEER数据，数据较大，请先解压lung.zip压缩包。 Load the SEER data.\nThe data is quite large. Please extract the lung.zip compressed package\nfirst.\ndat <- read.table(\"lung.txt\",sep = \"\\t\",row.names = NULL,header = T,check.names = F,stringsAsFactors = F)\nView(dat)\n根据例文清洗数据 Clean the data according to the example text\ndat <- dat[which(dat$`Derived AJCC Stage Group, 7th ed (2010-2015)` %in% \n                   c(\"IA\",\"IB\",\"IE\",\"IEA\",\"IEB\",\"II\",\"IIA\",\"IIB\",\"IIE\",\"IIEA\",\"IIEB\",\"III\",\"IIIA\")),]\ndat <- dat[as.numeric(dat$`Regional nodes examined (1988+)`) >= 1,]\n\n# 保留例文中部分cox回归感兴趣的协变量（我不是很清楚histology和operation type应该看哪列，结果和原文不一样）\n# Retain some covariates of interest in cox regression in the example text (I'm not quite sure which column should be looked at for histology and operation type, and the result is different from the original text)\ndat <- dat[,c(\"Regional nodes examined (1988+)\",\n              \"Survival months\",\n              \"Vital status recode (study cutoff used)\",\n              \"Age recode with single ages and 85+\",\n              \"Derived AJCC T, 6th ed (2004-2015)\")]\ncolnames(dat) <- c(\"ELN\",\"futime\",\"fustat\",\"Age\",\"Tstage\")\ndat <- dat[which(dat$Tstage != \"TX\" & dat$Age != \"85+ years\"),]\ndat$Age <- as.numeric(gsub(\" years\",\"\",dat$Age))\ndat$ELN <- as.numeric(dat$ELN)\ndat$Tstage <- ifelse(dat$Tstage %in% c(\"T0\",\"T1\",\"T2\"), \"T012\",\"T34\")\ndat <- dat[which(dat$ELN <= 30),]\ndat$fustat <- ifelse(dat$fustat == \"Alive\", 0 ,1)\ndat$futime <- as.numeric(dat$futime)\n\n# 把清洗后的数据保存到文件，便于套用\n# Save the cleaned data to a file for easy application\nwrite.csv(dat, \"easy_input.csv\", quote = F, row.names = F)\n输入文件\nInput File\neasy_input.csv，每行一个sample，每列一个cox回归感兴趣的协变量。\neasy_input.csv, one sample per row, one covariate of interest for cox\nregression per column.\ndat <- read.csv(\"easy_input.csv\")\nhead(dat)\n循环cox模型\nCyclic cox model\n以ELN为1作参照，分别做其他各ELN计数下的cox proportial hazards\nregression model Taking ELN as 1 as the reference, the cox proportional\nhazards regression models under each other ELN count were conducted\nrespectively\nctrl <- dat[which(dat$ELN == 1),]\nELN.count <- sort(unique(dat$ELN))\nCoxoutput <- NULL\n\nfor (count in ELN.count) {\n  if(count == 1) {\n    next()\n  } else {\n    treat <- dat[which(dat$ELN == count),]\n    tmp <- rbind.data.frame(treat,ctrl)\n    tmp$ELN <- ifelse(tmp$ELN == 1, 0 ,1)\n    cox <- coxph(Surv(futime, fustat) ~ ELN + Age + Tstage, data = tmp)\n    coxSummary <- summary(cox)\n    Coxoutput <- rbind.data.frame(Coxoutput,\n                                  data.frame(ELN.count = count,\n                                             HR = as.numeric(coxSummary$coefficients[,\"exp(coef)\"])[1],\n                                             pvalue = as.numeric(coxSummary$coefficients[,\"Pr(>|z|)\"])[1],\n                                             lower = as.numeric(coxSummary$conf.int[,3][1]),\n                                             upper = as.numeric(coxSummary$conf.int[,4][1]),\n                                             stringsAsFactors = F),\n                       stringsAsFactors = F)\n  }\n}\nhead(Coxoutput)\nlowess平滑并绘图\nLowess smoothing and plotting\n用base\nplot画图。如果想理解某一行代码的含义，就从plot开始到该语句一起运行。\nDraw a plot using base plot. If you want to understand the meaning of a\ncertain line of code, run from plot to that statement together.\n# 设置颜色\n# Set Colors\njcoBlue   <- \"#2874C5\"\njcoYellow <- \"#EABF00\"\n\npdf(\"breakpoint.pdf\",width = 4.5,height = 8)\npar(mfrow = c(2,1)) # 画上下两张图   # Draw two pictures, upper and lower\n\n## 画上图\n## Draw the picture above\n# 计算y轴宽度\n# Calculate the width of the Y-axis\nyrange <- range(c(Coxoutput$upper, Coxoutput$lower))\nymin <- floor(yrange[1] * 10)/10\nymax <- ceiling(yrange[2] * 10)/10\npar(bty = \"o\", mgp = c(2,.6,0), mar = c(3,3,1,1), las = 1, font.axis = 1) # 基础参数\n# foundation parameters\nplot(x = ELN.count,\n     y = c(1, Coxoutput$HR), # 补上以ELN为1时候的HR参考值（均为1）  # Add the HR reference values when ELN is 1 (all are 1)\n     xaxt = \"n\",\n     xlab = \"\",\n     ylab = \"Hazard Ratio\",\n     ylim = c(ymin,ymax),\n     type = \"p\",\n     pch = 19,\n     col = jcoBlue,\n     cex = 1.2)\n\n# 重新补上x轴坐标\n# Re-fill in the X-axis coordinates\n# 用seq(from=0, to=max(ELN.count), by=10)\n# Use seq(from=0, to=max(ELN.count), by=10)\naxis(side = 1, \n     at = seq(from=0, to=max(ELN.count), by=10), #生成以10为间隔的x轴label  # Generate X-axis labels at intervals of 10\n     labels = seq(from=0, to=max(ELN.count), by=10), \n     cex.axis = 0.8) # 字大小  # word size\n\n# 添加误差线\n# Add error lines\n# 垂直线\n# Vertical Line\nsegments(ELN.count[-1], Coxoutput$lower, \n         ELN.count[-1], Coxoutput$upper, \n         lwd = 1.5)\n# 水平封口\n# Horizontal Sealing\narrows(ELN.count[-1], Coxoutput$lower, \n       ELN.count[-1], Coxoutput$upper, \n       lwd = 1.5, angle = 90,\n       code = 3, length = 0.05)\n\n# 添加平滑曲线\n# Add smooth curves\nhr.lowess <- lowess(c(1, Coxoutput$HR)~ELN.count, f = 2/3) # 原文设置f即bandwith为2/3  # The original text sets f as bandwith to 2/3\nlines(hr.lowess, col = jcoYellow, lwd = 2)\n\n## 画下图\n## Draw the following picture\n# 原图靠近横坐标的黄色线，文中没有描述它代表哪个特征，因此没有画。\n# The original image shows the yellow line near the horizontal coordinate. The text does not describe which feature it represents, so it is not drawn.\n# 用Chow test寻找变点并绘图\n# Use Chow test to find the change points and plot\nf <- Fstats(hr.lowess$y ~ ELN.count)\nbk <- breakpoints(f)$breakpoints # bk代表是第几个观测，只是这里恰好等于ELN的数目  # bk represents which observation it is, but here it exactly equals the number of ELN\n# 打印变点的位置\n# Print the position of the change point\nbk\n# 构建平滑点的线性回归\n# Constructing linear regression with smooth points\nlm1 <- lm(hr.lowess$y[1:bk] ~ ELN.count[1:bk]) # y是第1到第bk个平滑值，x是第1到第bk个ELN的数目\n# y is the 1st to the bk smooth value, and x is the number of the 1st to the bk ELN\nlm2 <- lm(hr.lowess$y[bk:length(ELN.count)] ~ ELN.count[bk:length(ELN.count)]) # y是第bk到最后一个平滑值，x是第bk到最后一个ELN的数目   # y is the smooth value from the bk to the last, and x is the number of elNs from the bk to the last\n\nyrange <- range(Coxoutput$HR)\nymin <- floor(yrange[1] * 10)/10\nymax <- ceiling(yrange[2] * 10)/10\npar(bty = \"o\", mgp = c(2,.6,0), mar = c(3,3,0,1), las = 1, font.axis = 1) # 基础参数  # Basic Parameters\nplot(hr.lowess,\n     col = jcoYellow,\n     lwd = 2,\n     type = \"l\",\n     ylim = c(ymin,ymax),\n     xlab = \"ELN Count\",\n     ylab = \"Estimated Hazard Ratio\",\n     xaxt = \"n\")\naxis(side = 1, at = seq(from=0, to=max(ELN.count), by=5), #生成以5为间隔的x轴label  # Generate X-axis labels at intervals of 5\n     labels = seq(from=0, to=max(ELN.count), by=5), \n     cex.axis = 0.8) # 字大小   # word size\n\nlines(ELN.count[1:bk],\n      predict(lm1, x = ELN.count[1:bk]),\n      col = jcoBlue, \n      lty = 2,\n      lwd = 2)\nlines(ELN.count[bk:length(ELN.count)],\n      predict(lm2, x = ELN.count[bk:length(ELN.count)]),\n      col = jcoBlue, \n      lty = 2,\n      lwd = 2)\nlegend(\"topright\", paste0(\"Structural break point\\nELN count = \",ELN.count[bk]), adj = 0.55, bty = \"n\")\n\n# 关闭图像句柄\n# Close the image handle\ninvisible(dev.off())\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa192breakpoint_FigureYa192breakpoint",
      "title": "FigureYa192breakpoint/FigureYa192breakpoint.html",
      "html": "FigureYa192breakpoint/FigureYa192breakpoint.html",
      "text": "texts/main_FigureYa192breakpoint_FigureYa192breakpoint.txt",
      "folder": "FigureYa192breakpoint",
      "thumb": "gallery_compress/FigureYa192breakpoint.webp"
    },
    "word_count": 1181,
    "lines_count": 233,
    "title": "FigureYa192breakpoint",
    "description": "Requirement 求实现Fig 2，输入seer数据，循环cox模型，lowess平滑并绘图。 To draw the Fig 2, input the seer data, loop the cox model, smooth it with",
    "input_data_types": [
      "临床数据",
      "生存数据"
    ],
    "output_types": [
      "统计表格",
      "生存曲线"
    ],
    "technical_methods": [
      "生存分析"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "to",
      "header",
      "count",
      "lwd",
      "width",
      "ylim",
      "pvalue",
      "side",
      "labels"
    ]
  },
  {
    "id": "main_FigureYa30nomogram_update_FigureYa30nomogram_update",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa30nomogram_update_FigureYa30nomogram_update.txt",
    "content": "FigureYa30nomogram_update\nFigureYa30nomogram_update\nAuthor(s)\n: Dongqiang Zeng, Ying Ge; Yijing\nChen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n画出新型nomogram图（d）和对比曲线（f、g）\nDraw the new nomogram (d) and comparison curves (f, g)\n出自\nhttps://linkinghub.elsevier.com/retrieve/pii/S2352396419301884\n图 3. (d-e) 基于 TMRS-RFS (d)、TMRS-OS (e)\n和临床变量预测患者死亡率概率的列线图；(f-g) 图形描述了基于 TMRS-RFS (f)\n和 TMRS-OS (g)\n的列线图的校准情况，即预测结果与观察到的2年、3年和5年结果之间的一致性。相对于代表理想预测的45度线的曲线图显示了列线图的性能；（h-i）基于\nTMRS-RFS（h）和 TMRS-OS\n（i）的列线图对2年、3年和5年风险的决策曲线分析。ADJC，辅助化疗；TMRS，肿瘤微环境风险评分；RFS，无复发生存率；OS，总生存率；Pr，概率；Nomo，列线图。\nc森林图的画法可参考\nFigureYa90subgroup\n来画，h和i图可参考\nFigureYa33DCA_update\n。\nfrom\nhttps://linkinghub.elsevier.com/retrieve/pii/S2352396419301884\nFig. 3. (d–e) Nomograms for predicting the probability of patient\nmortality based on TMRS-RFS (d), TMRS-OS (e) and clinical variables;\n(f–g) Plots depict the calibration of nomograms based on TMRS-RFS (f)\nand TMRS-OS (g) in terms of agreement between predicted and observed\n2-year, 3-year, and 5-year outcomes. Nomogram performance is shown by\nthe plot, relative to the 45-degree line, which represents the ideal\nprediction; (h–i) Decision curve analyses of the nomograms based on\nTMRS-RFS (h) and TMRS-OS (i) for 2-year, 3-year, and 5-year risk. ADJC,\nadjuvant chemotherapy; TMRS, tumour microenvironment risk score; RFS,\nrelapse-free survival; OS, overall survival; Pr, probability; Nomo,\nnomogram.\nThe c forest plot can be drawn by referring to\nFigureYa90subgroup\n, and the h and i plots can be drawn by\nreferring to\nFigureYa33DCA_update\n.\n应用场景\nApplication scenario\n列线图（nomogram，诺莫图）是在平面直角坐标系中用一簇互不相交的线段表示多个独立变量之间函数关系的图。\n将Logistic回归或Cox回归的结果进行可视化呈现，给出其发病风险或比例风险。\nA nomogram is a graph that represents a functional relationship\nbetween multiple independent variables in a plane rectangular coordinate\nsystem using a cluster of disjointed line segments.\nIt visualizes the results of a Logistic regression or Cox regression,\ngiving the risk or proportional risk of developing a disease.\n环境设置\nEnvironment setting\nsource(\"install_dependencies.R\")\nlibrary(survival)\nlibrary(regplot)\nlibrary(rms)\nlibrary(nomogramEx)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 display English error messages\noptions(stringsAsFactors = FALSE) #禁止chr转成factor prohibit the conversion of chr to factor\n输入文件\nInput file\n至少要有临床信息\neasy_input.csv\n，还可以把\nFigureYa31lasso\n输出的\nlasso_output.txt\n作为一列添加进来。\nAt least include the clinical information\neasy_input.csv\n, and also add the\nFigureYa31lasso\noutput\nlasso_output.txt\nas a\ncolumn.\npbc <- read.table(\"easy_input.txt\")\n\npbc$catbili <- cut(pbc$bili, breaks = c(-Inf, 2, 4, Inf),\n                   labels=c(\"low\", \"medium\", \"high\"))\npbc$died <- pbc$status == 2\n\nhead(pbc)\n画nomogram\nDraw nomogram\n这里提供两种风格的nomogram画法，用到不同的包\nHere are two styles of nomogram drawing, using different packages\n经典版\nClassic Edition\ndd <- datadist(pbc)\noptions(datadist=\"dd\")\noptions(na.action=\"na.delete\")\nsummary(pbc$time)\ncoxpbc <- cph(formula = Surv(time,died) ~  age + catbili + sex + copper + stage + trt ,data=pbc,x=T,y=T,surv = T,na.action=na.delete)  #,time.inc =2920\n\nprint(coxpbc)\nsurv <- Survival(coxpbc) \nsurv3 <- function(x) surv(1825,x)\nsurv4 <- function(x) surv(2920,x)\n\nx <- nomogram(coxpbc,fun = list(surv3,surv4),lp=T,\n            funlabel = c('5-year survival Probability','8-year survival Probability'),\n            maxscale = 100,fun.at = c(0.95,0.9,0.8,0.7,0.6,0.5,0.4,0.3,0.2,0.1))\n\npdf(\"nomogram_classical.pdf\",width = 12,height = 10)\nplot(x, lplabel=\"Linear Predictor\",\n     xfrac=.35,varname.label=TRUE, varname.label.sep=\"=\", ia.space=.2, \n     tck=NA, tcl=-0.20, lmgp=0.3,\n     points.label='Points', total.points.label='Total Points',\n     total.sep.page=FALSE, \n     cap.labels=FALSE,cex.var = 1.6,cex.axis = 1.05,lwd=5,\n     label.every = 1,col.grid = gray(c(0.8, 0.95)))\ndev.off()\n输出公式\noutput formula\n#print(x)\nnomogramEx(nomo=x,np=2,digit = 9)\n画新型nomogram\nDraw new nomogram\nregplot\n可以交互式调整nomogram，代码更简单，输出的图形更漂亮。\n把\nregplot\n那段代码粘贴到Console里，回车，就会在Plots窗口出现可以交互的图。\n鼠标点击Esc或按键盘上的Esc可以退出交互模式。\n怎样保存图片？\n点击Export右侧的小三角形，Save as PDF…，保存为PDF文件。\nregplot\ncan interactively adjust the nomogram, the code\nis simpler, the output graph is more beautiful.\nPaste the code\nregplot\ninto Console, enter, then the\ninteractive plot will appear in the Plots window.\nYou can exit the interactive mode by clicking Esc or pressing Esc on\nthe keyboard.\nHow do I save a picture?\nClick on the small triangle on the right side of Export, Save as PDF…\nThe image will be saved as a PDF file.\npbccox <- coxph(formula = Surv(time,died) ~  age + catbili + sex + \n                   copper + stage + trt , data = pbc)\n\nregplot(pbccox,\n        observation=pbc[2,], #对观测2的六个指标在列线图上进行计分展示，也可以不展示 the six indicators for Observation 2 can be scored and displayed on the nomogram, or they may not be displayed.\n        points = TRUE, #如果为FALSE，则显示每个βx贡献的回归分数。否则，贡献将以 0-100 的“点数”刻度表示 If FALSE the regression scores of each βx contribution are shown. Otherwise contributions are represented by a 0-100 \"points\" scale.\n        plots = c(\"density\", #可选\"no plot\" \"density\" \"boxes\" \"ecdf\" \"bars\" \"boxplot\" \"violin\" \"bean\" \"spikes\" optional \"no plot\" \"density\" \"boxes\" \"ecdf\" \"bars\" \"boxplot\" \"violin\" \"bean\" \"spikes\"\n                  \"boxes\"), #可选\"no plot\" \"boxes\" \"bars\" \"spikes\" optional \"no plot\" \"boxes\" \"bars\" \"spikes\"\n        failtime = c(1095,1825), #预测3年和5年的死亡风险，此处单位是day predict the risk of death over 3 and 5 years, with the unit being days.\n        subticks = TRUE, \n        #clickable=TRUE, #可以用鼠标点击 use the mouse to click\n        prfail = TRUE, #cox回归中需要TRUE TRUE is required in cox regression\n        showP = T, #是否展示统计学差异 whether to demonstrate statistical differences\n        droplines = F,#观测2示例计分是否画线 Observation 2 example scoring whether or not to draw a line\n        rank=\"range\", #rank=“range ”表示βx的范围，rank=“sd ”表示βx的标准差 rank=\"range\" is by the range of the βx's, and rank=\"sd\" is by the standard deviation of the βx's. \n        interval=\"confidence\") #展示观测的可信区间 demonstrate confidence intervals for observations\n展示逻辑回归，支持”lm”, “glm”, “coxph”, “survreg” “negbin”\n可参考上图调参数\nDemonstrate logistic regression, support “lm”, “glm”, “coxph”,\n“survreg” “negbin”\nYou can refer to the above figure to adjust the parameters\n绘制calibration curve进行验证\nPlot calibration curve for validation\n采用和nomogram一样的变量进行多因素cox回归\nPerform multivariable Cox regression using the same variables as the\nnomogram\n5年\n5 years\nf5 <- cph(formula = Surv(time,died) ~  age + catbili + sex + copper +stage + trt,data=pbc,x=T,y=T,surv = T,na.action=na.delete,time.inc = 1825) \n\n#参数m=50表示每组50个样本进行重复计算\n#the parameter m=50 means 50 samples in each group for repeated calculations\ncal5 <- calibrate(f5, cmethod=\"KM\", method=\"boot\",u=1825,m=50,B=1000)\npdf(\"calibration_5y.pdf\",width = 8,height = 8)\nplot(cal5,\n     lwd = 2,#error bar的粗细 thickness of the error bar\n     lty = 1,#error bar的类型，可以是0-6 type of the error bar, which can be 0-6.\n     errbar.col = c(\"#2166AC\"),#error bar的颜色 color of the error bar\n     xlim = c(0,1),ylim= c(0,1),\n     xlab = \"Nomogram-prediced OS (%)\",ylab = \"Observed OS (%)\",\n     cex.lab=1.2, cex.axis=1, cex.main=1.2, cex.sub=0.6) #字的大小 font size\nlines(cal5[,c('mean.predicted',\"KM\")], \n      type = 'b', #连线的类型，可以是\"p\",\"b\",\"o\" type of line, which can be “p”, “b”, “o”.\n      lwd = 2, #连线的粗细 thickness of the line\n      pch = 16, #点的形状，可以是0-20 shape of the point, which can be 0-20\n      col = c(\"#2166AC\")) #连线的颜色 color of the line\nmtext(\"\")\nbox(lwd = 1) #边框粗细 border thickness\nabline(0,1,lty = 3, #对角线为虚线 diagonal lines are dashed\n       lwd = 2, #对角线的粗细 diagonal thickness\n       col = c(\"#224444\")#对角线的颜色 diagonal color\n       ) \ndev.off()\n8年\n8 years\nf8 <- cph(formula = Surv(time,died) ~  age + catbili + sex + copper +stage + trt,data=pbc,x=T,y=T,surv = T,na.action=na.delete,time.inc = 2920) \ncal8 <- calibrate(f8, cmethod=\"KM\", method=\"boot\",u=2920,m=50,B=1000)\nplot(cal8,\n     lwd = 2,\n     lty = 1,\n     errbar.col = c(\"#B2182B\"),\n     xlim = c(0,1),ylim= c(0,1),\n     xlab = \"Nomogram-prediced OS (%)\",ylab = \"Observed OS (%)\",\n     col = c(\"#B2182B\"),\n     cex.lab=1.2,cex.axis=1, cex.main=1.2, cex.sub=0.6)\nlines(cal8[,c('mean.predicted',\"KM\")],\n      type= 'b',\n      lwd = 2,\n      col = c(\"#B2182B\"),\n      pch = 16)\nmtext(\"\")\nbox(lwd = 1)\nabline(0,1,lty= 3,\n       lwd = 2,\n       col =c(\"#224444\"))\n同时展示两条curve\nShow two curves at the same time\npdf(\"calibration_compare.pdf\",width = 8,height = 8)\nplot(cal5,lwd = 2,lty = 0,errbar.col = c(\"#2166AC\"),\n     bty = \"l\", #只画左边和下边框 draw only the left and lower borders\n     xlim = c(0,1),ylim= c(0,1),\n     xlab = \"Nomogram-prediced OS (%)\",ylab = \"Observed OS (%)\",\n     col = c(\"#2166AC\"),\n     cex.lab=1.2,cex.axis=1, cex.main=1.2, cex.sub=0.6)\nlines(cal5[,c('mean.predicted',\"KM\")],\n      type = 'b', lwd = 1, col = c(\"#2166AC\"), pch = 16)\nmtext(\"\")\n\nplot(cal8,lwd = 2,lty = 0,errbar.col = c(\"#B2182B\"),\n     xlim = c(0,1),ylim= c(0,1),col = c(\"#B2182B\"),add = T)\nlines(cal8[,c('mean.predicted',\"KM\")],\n      type = 'b', lwd = 1, col = c(\"#B2182B\"), pch = 16)\n\nabline(0,1, lwd = 2, lty = 3, col = c(\"#224444\"))\n\nlegend(\"topleft\", #图例的位置 location of the legend\n       legend = c(\"5-year\",\"8-year\"), #图例文字 legend text\n       col =c(\"#2166AC\",\"#B2182B\"), #图例线的颜色，与文字对应 color of the legend line, corresponding to the text\n       lwd = 2,#图例中线的粗细 thickness of lines in the legend\n       cex = 1.2,#图例字体大小 legend font size\n       bty = \"n\")#不显示图例边框 legend border not displayed\ndev.off()\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa30nomogram_update_FigureYa30nomogram_update",
      "title": "FigureYa30nomogram_update/FigureYa30nomogram_update.html",
      "html": "FigureYa30nomogram_update/FigureYa30nomogram_update.html",
      "text": "texts/main_FigureYa30nomogram_update_FigureYa30nomogram_update.txt",
      "folder": "FigureYa30nomogram_update",
      "thumb": "gallery_compress/FigureYa30nomogram_update.webp"
    },
    "word_count": 1195,
    "lines_count": 252,
    "title": "FigureYa30nomogram_update",
    "description": "Requirement description 画出新型nomogram图（d）和对比曲线（f、g） Draw the new nomogram (d) and comparison curves (f, g)",
    "input_data_types": [
      "临床数据",
      "生存数据"
    ],
    "output_types": [
      "箱线图",
      "统计表格",
      "生存曲线"
    ],
    "technical_methods": [
      "生存分析"
    ],
    "biology_areas": [],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "add",
      "np",
      "nomo",
      "lwd",
      "cmethod",
      "width",
      "grid",
      "u"
    ]
  },
  {
    "id": "main_FigureYa169sigHeatmap_FigureYa169sigHeatmap",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa169sigHeatmap_FigureYa169sigHeatmap.txt",
    "content": "FigureYa169sigHeatmap\nFigureYa169sigHeatmap\nAuthor(s)\n: Xiaofan Lu\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement\n过配对差异表达，画亚型特异性上(下)调基因的对角热图。比如样本分了4-5个组，分析并画出每个组里面上调或下调的热图。\nDraw a diagonal heatmap of subtype-specific up- and down-regulated genes\nbased on paired differential expression. For example, if samples are\ndivided into 4-5 groups, analyze and draw a heatmap of up- and\ndown-regulated genes within each group.\nFigure 2: A) Unsupervised clustering of lncRNAs identified 4\nclusters: cluster I (related to the basal-like breast cancer subtype),\ncluster II (related to the HER-2 enriched subtype), cluster III (related\nto luminal A subtype), and cluster IV (related to luminal A and B\nsubtypes). Correlation with PAM50 classification, estrogen receptor\n(ER), progesterone receptor (PR) and HER2 status are depicted.\n出自\nhttps://www.ncbi.nlm.nih.gov/pubmed/25296969\nSource:\nhttps://www.ncbi.nlm.nih.gov/pubmed/25296969\n应用场景\nApplication Scenario\n在大于等于3组亚型的基础上，得到配对差异表达基因后，计算每个亚型特异性上/下调的基因集，并绘制特异性基因表达热图。\nAfter obtaining paired differentially expressed genes for at least three\nsubtypes, we calculated the set of upregulated/downregulated genes for\neach subtype and plotted a heatmap of specific gene expression.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(ClassDiscovery) # 距离测量 # Distance measurement\nlibrary(edgeR) # 差异表达 # Differential expression\nlibrary(NMF) # 绘制热图 # Heatmap plotting\nlibrary(gplots) # 热图颜色 # Heatmap colors\nlibrary(RColorBrewer) # 热图颜色 # Heatmap colors\n\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # Display English error messages\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # Disable conversion of chr to factors\n自定义配对比较函数 Custom pairwise comparison function\n这里用edgeR，如果用DESeq2或limma，就把FigureYa118MulticlassDESeq2或FigureYa119MulticlassLimma里面相应的函数替换过来，可无缝对接。\nHere, edgeR is used. If you are using DESeq2 or limma, simply replace\nthe corresponding functions in FigureYa118MulticlassDESeq2 or\nFigureYa119MulticlassLimma for seamless integration.\n# 创建需要配对比较的列表\n# Create a list for paired comparison\ncreateList <- function(group=NULL) {\n  \n  tumorsam <- names(group)\n  sampleList = list()\n  treatsamList =list()\n  treatnameList <- c()\n  ctrlnameList <- c()\n  \n  #A-1: 类1 vs 其他\n  #A-1: Class 1 vs. Others\n  sampleList[[1]] = tumorsam\n  treatsamList[[1]] = intersect(tumorsam, names(group[group==\"Cluster1\"])) # 亚型名称需要根据情况修改\n  # The subtype name needs to be modified according to the situation\n  treatnameList[1] <- \"Cluster1\" # 该亚型的命名 # The name of this subtype\n  ctrlnameList[1] <- \"Others\" # 其他亚型的命名 # The name of other subtypes\n  \n  #A-2: 类2 vs 其他\n  #A-2: Class 2 vs. Others\n  sampleList[[2]] = tumorsam\n  treatsamList[[2]] = intersect(tumorsam, names(group[group==\"Cluster2\"]))\n  treatnameList[2] <- \"Cluster2\"\n  ctrlnameList[2] <- \"Others\"\n  \n  #A-3: 类3 vs 其他\n  #A-3: Class 3 vs Others \n  sampleList[[3]] = tumorsam\n  treatsamList[[3]] = intersect(tumorsam, names(group[group==\"Cluster3\"]))\n  treatnameList[3] <- \"Cluster3\"\n  ctrlnameList[3] <- \"Others\"\n  \n  #A-4: 类4 vs 其他\n  #A-4: Class 4 vs Others \n  sampleList[[4]] = tumorsam\n  treatsamList[[4]] = intersect(tumorsam, names(group[group==\"Cluster4\"]))\n  treatnameList[4] <- \"Cluster4\"\n  ctrlnameList[4] <- \"Others\"\n  \n  return(list(sampleList, treatsamList, treatnameList, ctrlnameList))\n  \n}\n\n# 配对edgeR\n# Pair edgeR\ntwoclassedgeR <- function(res.path=NULL, countsTable=NULL, prefix=NULL, complist=NULL, overwt=FALSE) {\n  \n  #Groupinfo could contain \"batch\", which will be considered by edgeR design matrix\n  sampleList <- complist[[1]]\n  treatsamList <- complist[[2]]\n  treatnameList <- complist[[3]]\n  ctrlnameList <- complist[[4]]\n  allsamples <- colnames(countsTable)\n  \n  options(warn=1)\n  for (k in 1:length(sampleList)) { # 循环读取每一次比较的内容 # Loop through each comparison\n    samples <- sampleList[[k]]\n    treatsam <- treatsamList[[k]]\n    treatname <- treatnameList[k]\n    ctrlname <- ctrlnameList[k]\n    \n    compname <- paste(treatname, \"_vs_\", ctrlname, sep=\"\") # 生成最终文件名 # Generate final file name\n    tmp = rep(\"others\", times=length(allsamples))\n    names(tmp) <- allsamples\n    tmp[samples]=\"control\"\n    tmp[treatsam]=\"treatment\"\n    outfile <- file.path( res.path, paste(prefix, \"_edgeR_test_result.\", compname, \".txt\", sep=\"\") )\n    if (file.exists(outfile) & (overwt==FALSE)) { # 因此差异表达分析较慢，因此如果文件存在，在不覆盖的情况下（overwt=F）不再次计算差异表达\n # This slows down differential expression analysis. Therefore, if the file exists, do not recalculate differential expression without overwriting (overwt=F)\n      cat(k, \":\", compname, \"exists and skipped;\\n\")\n      next\n    }\n    \n    saminfo <- data.frame(\"Type\"=tmp[samples],\"SampleID\"=samples,stringsAsFactors = F)\n    \n    group=factor(saminfo$Type,levels = c(\"control\",\"treatment\"))    \n    \n    design <- model.matrix(~group) # 设计矩阵仅包含亚型信息，若有批次效应请修改，例如design <- model.matrix(~group+treat) # The design matrix only contains subtype information. If there are batch effects, please modify it. For example, design <- model.matrix(~group+treat)\n    rownames(design) <- samples\n\n    # 差异表达过程，具体参数细节及输出结果解释，请参阅相关document\n    # Differential expression process. For specific parameter details and output interpretation, please refer   to the relevant documentation.\n    y <- DGEList(counts=countsTable[,samples],group=saminfo$Type)\n    y <- calcNormFactors(y)\n    y <- estimateDisp(y, design, robust=TRUE)\n    fit <- glmFit(y, design)\n    lrt <- glmLRT(fit)\n    ordered_tags <- topTags(lrt, n=100000)\n    allDiff=ordered_tags$table\n    allDiff=allDiff[is.na(allDiff$FDR)==FALSE,]\n    diff=allDiff\n    \n    diff$id <- rownames(diff)\n    res <- diff[,c(\"id\",\"logFC\",\"logCPM\",\"LR\",\"PValue\",\"FDR\")]\n    colnames(res) <- c(\"id\",\"log2FC\",\"logCPM\",\"LR\",\"PValue\",\"FDR\")\n    write.table(res, file=outfile, row.names=F, col.names=T, sep=\"\\t\", quote=F)\n    cat(k, \",\")\n  }\n  options(warn=0)\n}\n自定义画图函数 Custom drawing function\n# 特异性基因计算和热图绘制\n# Specific gene calculation and heat map drawing\nsigheat <- function(featdata=NULL, # 表达谱，注意一般是标准化后的FPKM或者TPM，此时norm选择none\n# Expression spectrum, note that it is usually standardized FPKM or TPM, in this case, norm selects none\n                    DEfiles=NULL, # 差异表达结果文件名 # Differential expression result file name\n                    outfile=NULL, # 输出文件名 # Output file name\n                    hcs=NULL, # 聚类树结构 # Cluster tree structure\n                    heatCol=greenred(128), #热图配色 # Heat map color\n                    # 如果你喜欢橙黄蓝，可以换成下面这行\n# If you prefer orange, yellow, and blue, you can change to the following line:\n                    #heatCol=colorRampPalette(rev(brewer.pal(n = 7, name = \"RdYlBu\")))(100),\n                    annCol=NULL, # 样本注释信息 # Sample annotation information\n                    annColors=NULL, # 注释信息的颜色 # Annotation color\n                    res.path=NULL, # 存储特异性表达的基因集的路径 # Path to store specifically expressed gene sets\n                    fig.path=NULL, # 存储热图的路径 # Path to store heatmap\n                    halfwidth=3, # 表达谱标准化后的上下限cutoff # Normalized expression profile cutoffs\n                    padjcut=0.05, # fdr的阈值 # FDR threshold\n                    log2fccut=1, # log2fc的阈值，默认为1 # Log2fc threshold, default is 1\n                    height=8, # 热图图片高度 # Heatmap image height\n                    width=8, # 热图的宽度 # Heatmap width\n                    norm=\"none\", # 输入数据是否需要标准化，默认不需要，可选择quantile，或者median标准化\n# Whether the input data should be normalized. Default is not. Quantile or median normalization can be selected.\n                    dirct=\"UP\", # 特异性基因的表达方向，默认为上调（推荐），可选择UP或DOWN\n# The expression direction of a specific gene. Default is up-regulated (recommended). UP or DOWN can be selected.\n                    fontsize=8, # 热图的字号 # Heatmap font size.\n                    labRow = F, # 热图是否显示基因名 # Whether the heatmap should display gene names.\n                    labCol = F) {  # 热图是否显示样本名 # Whether the heatmap should display sample names.\n  \n  samabsFlag <- FALSE \n  if (is.null(hcs)) {samabsFlag <- TRUE}\n  \n  if(is.null(DEfiles)) {stop(\"DEfiles is NULL!\")}\n  if (!is.element(norm, c(\"none\", \"median\", \"quantile\"))) {stop( \"norm type error!\") }\n  if (!is.element(dirct, c(\"UP\", \"DOWN\"))) {stop( \"dirct type error!\") }\n  \n  if(dirct==\"UP\") { outlabel <- \"uniquely_significantly_overexpressed.txt\" }\n  if(dirct==\"DOWN\") { outlabel <- \"uniquely_significantly_underexpressed.txt\" }\n  \n  genelist <- c()\n  for (filek in DEfiles) {\n    DEres <- read.table(file.path(res.path, filek), header=T, row.names=NULL, sep=\"\\t\", quote=\"\", stringsAsFactors=F)    \n    DEres <- DEres[!duplicated(DEres[, 1]),]\n    DEres <- DEres[!is.na(DEres[, 1]), ]\n    rownames(DEres) <- DEres[, 1]\n    DEres <- DEres[, -1]\n    \n    if (dirct==\"UP\") {\n      genelist <- c( genelist, rownames(DEres[!is.na(DEres$FDR) & DEres$FDR < padjcut & !is.na(DEres$log2FC) & DEres$log2FC > log2fccut, ]) )\n    }\n    if (dirct==\"DOWN\") {\n      genelist <- c( genelist, rownames(DEres[!is.na(DEres$FDR) & DEres$FDR < padjcut & !is.na(DEres$log2FC) & DEres$log2FC < -log2fccut, ]) )\n    }\n  }\n  unqlist <- setdiff(genelist,genelist[duplicated(genelist)])\n  \n  for (filek in DEfiles) {\n    DEres <- read.table(file.path(res.path, filek), header=T, row.names=NULL, sep=\"\\t\", quote=\"\", stringsAsFactors=F)\n    DEres <- DEres[!duplicated(DEres[, 1]),]\n    DEres <- DEres[!is.na(DEres[, 1]), ]\n    rownames(DEres) <- DEres[, 1]\n    DEres <- DEres[, -1]\n    \n    if(dirct==\"UP\") {\n      outk <- intersect( unqlist, rownames(DEres[!is.na(DEres$FDR) & DEres$FDR < padjcut & !is.na(DEres$log2FC) & DEres$log2FC > log2fccut, ]) )\n    }\n    if(dirct==\"DOWN\") {\n      outk <- intersect( unqlist, rownames(DEres[!is.na(DEres$FDR) & DEres$FDR < padjcut & !is.na(DEres$log2FC) & DEres$log2FC < -log2fccut, ]) )\n    }\n    write.table(outk, file=file.path(res.path, paste(filek, outlabel, sep=\"_\")), row.names=F, col.names=F, sep=\"\\t\", quote=F)\n  }\n  \n  if (sum(!is.element(unqlist, rownames(featdata)))>0) {stop(\"unqlist not found in featdata!\")}\n  \n  samples <- colnames(featdata)\n  if (norm==\"quantile\") {\n    tmp <- normalize.quantiles(as.matrix(featdata))\n    rownames(tmp) <- rownames(featdata)\n    colnames(tmp) <- colnames(featdata)\n  }\n  if (norm==\"median\") {\n    tmp <- sweep(featdata,2, apply(featdata,2,median,na.rm=T))\n  }\n  if(norm==\"none\") {\n    tmp <- featdata\n  }\n  \n  if (samabsFlag) {\n    subdata <- tmp[unqlist, intersect(samples, colnames(tmp))]\n  }else{\n    subdata <- tmp[unqlist, samples]\n  }\n  \n  hcg <- hclust(distanceMatrix(as.matrix(t(subdata)), \"pearson\"), \"ward.D\") \n  plotdata <- t(scale(t(subdata)))\n  plotdata[plotdata > halfwidth] <- halfwidth\n  plotdata[plotdata < - halfwidth] <- -halfwidth\n  \n  pdf(file=file.path(fig.path, outfile), height=height, width=width)\n  Rowv <- NA\n  if (samabsFlag) {\n    if (ncol(annCol)<2) {\n      tmp <- as.data.frame(annCol[colnames(plotdata), ])\n      rownames(tmp) <- colnames(plotdata)\n      colnames(tmp) <- colnames(annCol)\n    }else{\n      tmp <- annCol[colnames(plotdata), ]\n    }\n    if(isTRUE(labRow) & isTRUE(labCol)){\n      aheatmap(plotdata, Rowv=Rowv, Colv=NA, annCol=tmp, annColors=annColors, color=heatCol, revC=TRUE, breaks=0, fontsize=fontsize)\n    }\n    if(isTRUE(labRow) & isFALSE(labCol)){\n      aheatmap(plotdata, Rowv=Rowv, Colv=NA, annCol=tmp, annColors=annColors, color=heatCol, revC=TRUE, breaks=0, fontsize=fontsize, labCol = NA)\n    }\n    if(isFALSE(labRow) & isTRUE(labCol)){\n      aheatmap(plotdata, Rowv=Rowv, Colv=NA, annCol=tmp, annColors=annColors, color=heatCol, revC=TRUE, breaks=0, fontsize=fontsize, labRow = NA)\n    } \n    if(isFALSE(labRow) & isFALSE(labCol)){\n      aheatmap(plotdata, Rowv=Rowv, Colv=NA, annCol=tmp, annColors=annColors, color=heatCol, revC=TRUE, breaks=0, fontsize=fontsize, labCol = NA, labRow = NA)\n    }\n    \n  }else{\n    if (ncol(annCol)<2) {\n      tmp <- as.data.frame(annCol[samples, ])\n      rownames(tmp) <- samples\n      colnames(tmp) <- colnames(annCol)\n    }else{\n      tmp <- annCol[samples, ]\n    }\n    if(sum(hcs$labels!=colnames(plotdata))>0) {stop(\"colnames mismatch for aheatmap!\")}\n    if(isTRUE(labRow) & isTRUE(labCol)){\n      aheatmap(plotdata, Rowv=Rowv, Colv=as.dendrogram(hcs), annCol=tmp, annColors=annColors, color=heatCol, revC=TRUE, breaks=0, fontsize=fontsize)\n    }\n    if(isTRUE(labRow) & isFALSE(labCol)){\n      aheatmap(plotdata, Rowv=Rowv, Colv=as.dendrogram(hcs), annCol=tmp, annColors=annColors, color=heatCol, revC=TRUE, breaks=0, fontsize=fontsize, labCol = NA)\n    }\n    if(isFALSE(labRow) & isTRUE(labCol)){\n      aheatmap(plotdata, Rowv=Rowv, Colv=as.dendrogram(hcs), annCol=tmp, annColors=annColors, color=heatCol, revC=TRUE, breaks=0, fontsize=fontsize, labRow = NA)\n    } \n    if(isFALSE(labRow) & isFALSE(labCol)){\n      aheatmap(plotdata, Rowv=Rowv, Colv=as.dendrogram(hcs), annCol=tmp, annColors=annColors, color=heatCol, revC=TRUE, breaks=0, fontsize=fontsize, labCol = NA, labRow = NA)\n    }\n  }\n  invisible(dev.off())\n  \n  # return(unqlist)\n}\n输入文件\nInput files\neasy_input_counts.txt，easy_input_FPKM.txt，表达矩阵，分别是read\ncount和FPKM。这里以read count为输入，用edgeR做配对比较，用FPKM画图。\neasy_input_counts.txt and easy_input_FPKM.txt are expression matrices,\nrepresenting read counts and FPKM, respectively. Here, read counts are\nused as input, and edgeR is used for pairwise comparisons and FPKM is\nused for plotting.\n# 设置文件路径\n# Set the file path\nworkdir <- \".\"\n\n# 读取SKCM表达谱(count和对应的FPKM，或者TPM文件)\n# Read the SKCM expression profile (counts and corresponding FPKMs, or TPM files)\ncountstable <- read.table(\"easy_input_counts.txt\",sep = \"\\t\",row.names = 1,header = T,check.names = F,stringsAsFactors = F)\n\n# FPKM与counts对应。如果你要把count转换为FPKM，可参考FigureYa34count2FPKM\n# FPKM corresponds to counts. If you need to convert counts to FPKM, refer to FigureYa34count2FPKM\nFPKM <- read.table(\"easy_input_FPKM.txt\",sep = \"\\t\",row.names = 1,header = T,check.names = F,stringsAsFactors = F) #\n\n# 如果你只有FPKM数据，打算用FigureYa119Multiclasslimma做配对比较，则只需提供easy_input_FPKM.txt\n# 运行下面这行，不运行本段第一行\n#countstable <- FPKM\n\n# If you only have FPKM data and plan to use FigureYa119Multiclasslimma for pairwise comparisons, only provide easy_input_FPKM.txt.\n# Run the following line; skip the first line of this section.\n#countstable <- FPKM\n\nall(colnames(countstable) == colnames(FPKM)) # 检查一下样本名 # Check sample names\nall(rownames(countstable) == rownames(FPKM)) # 检查一下基因名 # Check gene names\n聚类和配对差异表达分析\nClustering and pairwise differential expression analysis\n# 样本聚类 #\n# Sample clustering #\ninput <- log2(FPKM + 1) # 数据对数化 # Logarithmize the data\nhcs <- hclust(distanceMatrix(as.matrix(input), \"pearson\"), \"ward.D\") # 样本聚类，更多聚类请参阅FigureYa91cluster_heatmap\n# Cluster the samples. For more information on clustering, see FigureYa91cluster_heatmap\n\ngroup <- cutree(hcs, k = 4) # 样本分4类（实际上大于等于3类就可以）\n# Categorize the samples into 4 categories (actually, 3 or more categories are sufficient)\ngroup <- paste0(\"Cluster\",as.numeric(group))\nnames(group) <- colnames(countstable)\n\n#--------------#\n# 配对差异表达 #\n# Pairwise differential expression #\n# 注意：该处使用的是FigureYa120MulticlassedgeR，若需使用其他差异表达算法请参阅FigureYa118MulticlassDESeq2，FigureYa119Multiclasslimma\n# Note: FigureYa120MulticlassedgeR is used here. For other differential expression algorithms, see FigureYa118MulticlassDESeq2 and FigureYa119Multiclasslimma\ncomplist <- createList(group=group)\ntwoclassedgeR(res.path = \".\", #所有配对差异表达结果都会输出在res.path路径下 # All pairwise differential expression results will be output in the res.path path\n              countsTable = countstable,\n              prefix = \"SKCM\", #文件名以SKCM开头\n              complist = complist,\n              overwt = F)\n开始画图\nStart plotting\n#--------------------------------------#\n# 创建样本注释和注释颜色以显示在热图上 #\n# Create sample annotations and annotation colors for display on the heatmap #\nannCol <- data.frame(Group = group,\n                     row.names = names(group),\n                     stringsAsFactors = F)\nannColors <- list(Group = c(\"Cluster1\"=\"yellow\",\n                            \"Cluster2\"=\"blue\",\n                            \"Cluster3\"=\"green\",\n                            \"Cluster4\"=\"red\")) #如果你有更多类，就依此规律继续添加 # If you have more clusters, continue adding them in this order.\n\n#----------------------------#\n# 计算特异性上调基因并画热图 #\n# Calculate specifically upregulated genes and plot heatmap #\nsigheat(featdata = log2(FPKM + 1), # 数据已标准化\n        # 注意：DEfiles的顺序是要进行调整的，当第一次输出热图后观察对应亚型色块所在的位置调整文件读入顺序\n        # Note: The order of the DE files needs to be adjusted. After outputting the heatmap for the first time, observe the position of the corresponding subtype color blocks and adjust the order of file imports.\n        DEfiles = c(\"SKCM_edgeR_test_result.Cluster4_vs_Others.txt\",\n                    \"SKCM_edgeR_test_result.Cluster1_vs_Others.txt\",\n                    \"SKCM_edgeR_test_result.Cluster2_vs_Others.txt\",\n                    \"SKCM_edgeR_test_result.Cluster3_vs_Others.txt\"),\n        hcs = hcs, # 样本聚类信息 # Sample annotations\n        annCol = annCol[colnames(FPKM),,drop = F], # 样本注释 # Sample annotations\n        annColors = annColors, # 样本注释颜色 # Sample annotation colors\n        res.path = workdir,\n        fig.path = workdir,\n        outfile = \"skcm_sigheatmap_upexpressed.pdf\",\n        halfwidth = 2,\n        padjcut = 0.05,\n        log2fccut = 1,\n        norm = \"none\", # 不标准化 # No normalization\n        dirct = \"UP\", # 上调 # Upregulated\n        width = 8,\n        height = 8)\n\n#----------------------------#\n# 计算特异性下调基因并画热图 #\n# Calculate specifically downregulated genes and draw a heatmap #\nsigheat(featdata = log2(FPKM + 1), # 数据已标准化 # Data normalized\n        # 注意：DEfiles的顺序是要进行调整的，当第一次输出热图后观察对应亚型色块所在的位置调整文件读入顺序\n        # Note: The order of the DE files needs to be adjusted. After outputting the heatmap for the first time, observe the positions of the corresponding subtype blocks and adjust the order of file imports.\n        DEfiles = c(\"SKCM_edgeR_test_result.Cluster4_vs_Others.txt\",\n                    \"SKCM_edgeR_test_result.Cluster1_vs_Others.txt\",\n                    \"SKCM_edgeR_test_result.Cluster2_vs_Others.txt\",\n                    \"SKCM_edgeR_test_result.Cluster3_vs_Others.txt\"),\n        hcs = hcs, # 样本聚类信息 # Sample clustering information\n        annCol = annCol[colnames(FPKM),,drop = F], # 样本注释 # Sample annotations\n        annColors = annColors, # 样本注释颜色 # Sample annotation colors\n        res.path = workdir,\n        fig.path = workdir,\n        outfile = \"skcm_sigheatmap_downexpressed.pdf\",\n        halfwidth = 2,\n        padjcut = 0.05,\n        log2fccut = 1,\n        norm = \"none\", # 不标准化 # No normalization\n        dirct = \"DOWN\", # 下调（不推荐） # Downscaling (not recommended)\n        width = 8,\n        height = 8)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa169sigHeatmap_FigureYa169sigHeatmap",
      "title": "FigureYa169sigHeatmap/FigureYa169sigHeatmap.html",
      "html": "FigureYa169sigHeatmap/FigureYa169sigHeatmap.html",
      "text": "texts/main_FigureYa169sigHeatmap_FigureYa169sigHeatmap.txt",
      "folder": "FigureYa169sigHeatmap",
      "thumb": "gallery_compress/FigureYa169sigHeatmap.webp"
    },
    "word_count": 1971,
    "lines_count": 417,
    "title": "FigureYa169sigHeatmap",
    "description": "Requirement 过配对差异表达，画亚型特异性上(下)调基因的对角热图。比如样本分了4-5个组，分析并画出每个组里面上调或下调的热图。 Draw a diagonal heatmap of subtype-specific up- and down-regulated genes",
    "input_data_types": [
      "临床数据",
      "表达矩阵"
    ],
    "output_types": [
      "火山图",
      "热图",
      "统计表格",
      "散点图"
    ],
    "technical_methods": [
      "聚类分析",
      "标准化",
      "差异表达分析"
    ],
    "biology_areas": [
      "癌症研究",
      "药物研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "heatCol",
      "outfile",
      "times",
      "header",
      "complist",
      "width",
      "n",
      "log2fccut",
      "pvalue"
    ]
  },
  {
    "id": "main_FigureYa20mortality_FigureYa20mortalityV2",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa20mortality_FigureYa20mortalityV2.txt",
    "content": "FigureYa20 mortality\nFigureYa20 mortality\nAuthor(s)\n: Guangchuang Yu; Ying Ge, Yijing\nChen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n用R代码画出paper里的图。\nUse R code to draw the plot in paper.\n出自\nhttp://ascopubs.org/doi/abs/10.1200/JCO.2010.29.5907?url_ver=Z39.88-2003&rfr_id=ori:rid:crossref.org&rfr_dat=cr_pub%3dpubmed\nfrom\nhttp://ascopubs.org/doi/abs/10.1200/JCO.2010.29.5907?url_ver=Z39.88-2003&rfr_id=ori:rid:crossref.org&rfr_dat=cr_pub%3dpubmed\n使用场景\nUsage scenario\n根据肿瘤大小分组，以存活时间作为输入，计算死亡率。\n展示死亡率与肿瘤大小的关系。\n还可以用来展示转移率与肿瘤大小的关系。\nGroup by tumor size, use survival time as input, and calculate the\nmortality rate.\nDemonstrate the relationship between mortality and tumor size.\nIt can also be used to demonstrate the relationship between\nmetastasis rate and tumor size.\n输入数据及处理\nInput data and processing\nsource(\"install_dependencies.R\")\nx = read.csv(\"easy_input.csv\")\nhead(x)\n开始画图\nStart drawing\nrequire(ggplot2)\np1 <-ggplot(y, aes(Tumor.size, ratio)) +\n     geom_ribbon(aes(ymin=ratio-int95, ymax=ratio+int95), fill=\"grey\") + \n     geom_line() + xlab(\"Tumor Size (mm)\") +\n     ylab(\"5-Year XXX Mortality\") + theme_minimal()\np1\n这个图不够平滑，因为Tumor.size是正整数的，都是离散点。\n可以使用Local Regression，也就是LOESS来处理，使之平滑。\nThe plot is not smooth enough because Tumor.size comprises positive\nintegers, which are discrete points.\nThis can be smoothed by using Local Regression, also known as\nLOESS.\n#可以试着更改一下span参数，指定多少的smoothing span\n#try changing the span parameter to specify how much of a smoothing span\nspan <- 0.5\nloess_ratio <- loess(ratio ~ Tumor.size, data=y, span=span) \nloess_ci <- loess(int95 ~ Tumor.size, data=y, span=span) \n\ny$ratiop = predict(loess_ratio)\ny$int95p = predict(loess_ci)\n\np2 <-ggplot(y, aes(Tumor.size, ratiop)) +\n     geom_ribbon(aes(ymin=ratiop-int95p, ymax=ratiop+int95p), fill=\"grey\") + \n     geom_line() + xlab(\"Tumor Size (mm)\") +\n     coord_cartesian(xlim = c(0,51),ylim = c(0,0.3)) + #设置坐标轴范围 set the axis range\n     scale_x_continuous(expand = c(0, 0)) + scale_y_continuous(expand = c(0, 0)) +#让x和y轴都从0开始 let both the x and y axes start at 0\n     theme_bw() + #去除背景色 remove background color\n     theme(panel.grid =element_blank()) + #去除网格线 remove gridlines\n     theme(panel.border = element_blank()) + #去除外层边框 remove outer border\n     theme(axis.line = element_line(colour = \"black\")) + #坐标轴画成黑色 coordinate axes are drawn in black\n     ylab(\"5-Year XXX Mortality\")\np2\nggsave(\"mortality.pdf\",width = 6,height = 4)\np2画出来就非常好看了\n把没做smoothing的叠加上去看看：\np2 looks great when drawn\nOverlay the version without smoothing to take a look:\np2 + geom_ribbon(aes(ymin=ratio-int95, ymax=ratio+int95), fill=\"steelblue\", alpha=.3) + \n     geom_line(aes(Tumor.size, ratio), color='red') + xlab(\"Tumor Size (mm)\") +\n     ylab(\"5-Year XXX Mortality\") + theme_minimal()\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa20mortality_FigureYa20mortalityV2",
      "title": "FigureYa20mortality/FigureYa20mortalityV2.html",
      "html": "FigureYa20mortality/FigureYa20mortalityV2.html",
      "text": "texts/main_FigureYa20mortality_FigureYa20mortalityV2.txt",
      "folder": "FigureYa20mortality",
      "thumb": "gallery_compress/FigureYa20mortality.webp"
    },
    "word_count": 343,
    "lines_count": 80,
    "title": "FigureYa20 mortality",
    "description": "Requirement description 用R代码画出paper里的图。 Use R code to draw the plot in paper.",
    "input_data_types": [
      "生存数据"
    ],
    "output_types": [
      "生存曲线"
    ],
    "technical_methods": [],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "url_ver",
      "span",
      "colour",
      "width",
      "ylim",
      "rfr_dat",
      "grid",
      "xlim",
      "ymin",
      "rfr_id"
    ]
  },
  {
    "id": "main_FigureYa97correlationV3_FigureYa97correlationV3",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa97correlationV3_FigureYa97correlationV3.txt",
    "content": "FigureYa97correlationV3\nFigureYa97correlationV3\nAuthor(s)\n: Shipeng Guo, Taojun Ye\nReviewer(s)\n: Ying Ge\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n计算多个基因和免疫浸润的相关性，画出类似于文章中这种热图，用颜色展示相关系数，用**标出显著的。\nRequirement description\nCalculate the correlation between multiple genes and immune\ninfiltration, draw a heatmap similar to the one in the article, display\nthe correlation coefficients with colors, and mark the significant ones\nwith * *.\n出自\nhttps://www.nature.com/articles/s41586-019-1032-7\nfrom\nhttps://www.nature.com/articles/s41586-019-1032-7\n应用场景\n评价基因对免疫浸润的影响，甚至可以批量筛选出影响免疫浸润的候选基因。\n其本质是计算两种特征之间的相关性，此处的免疫浸润可以换成其他变量，例如临床表型等等。\n如果要同时展示两个基因之间的相关性，及其与免疫浸润之间的关系，请参考“FigureYa96R2”。\nApplication scenarios\nEvaluate the impact of genes on immune infiltration, and even screen\ncandidate genes that affect immune infiltration in batches.\nIts essence is to calculate the correlation between two features,\nwhere immune infiltration can be replaced with other variables such as\nclinical phenotype, etc.\nIf you want to simultaneously demonstrate the correlation between two\ngenes and their relationship with immune infiltration, please refer to\n“FigureYa96R2”.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\n# 加载ggplot2包，用于数据可视化\n# Load the ggplot2 package for data visualization\nlibrary(ggplot2)\n\n# 加载dplyr包，用于数据处理和转换\n# Load the dplyr package for data manipulation and transformation\nlibrary(dplyr)\n# 设置环境变量，使R显示英文错误信息（便于搜索解决方案）\n# Set environment variable to display error messages in English (easier for searching solutions)\nSys.setenv(LANGUAGE = \"en\")\n\n# 全局选项设置：禁止将字符型变量自动转换为因子类型\n# Global option setting: prevent automatic conversion of character variables to factors\noptions(stringsAsFactors = FALSE)\n输入文件\n要求前两个文件的样本名一致\nssGSEA_output.csv，免疫细胞矩阵，列是免疫细胞，行是样本，由FigureYa71ssGSEA产生。如果对免疫浸润不感兴趣，就把ssGSEA_output.csv换成其他类型的数据，例如临床指标什么的，只要保证样品名跟easy_input_expr.csv一致就好了。\neasy_input_expr.csv，基因表达矩阵，列是样本，行是基因。行也可以是转录本，甚至是临床信息。\ngenelist.txt，基因名，将要计算这些基因跟免疫浸润的相关性。要求跟easy_input_expr.csv里的基因名一致。\nInput file\nRequire the sample names of the first two files to be consistent\nssGSEA_output.csv， Immune cell matrix, with columns representing\nimmune cells and rows representing samples, generated by\nFigureYa71ssGSEA. If you are not interested in immune infiltration, you\ncan replace ssGSEA_output. csv with other types of data, such as\nclinical indicators, as long as the sample name is consistent with\neasyinput.exe. csv.\neasy_input_expr.csv， Gene expression matrix, with columns\nrepresenting samples and rows representing genes. It can also be a\ntranscript or even clinical information.\ngenelist.txt， The gene names will be used to calculate the\ncorrelation between these genes and immune infiltration. Require the\ngene name to be consistent with the one in easy_input-expr.csv.\n批量计算相关性\n先写一个函数\n输入一个基因，即可返回跟免疫基因的相关性、p值\n其中method可以改为”pearson”或”kendall”\nBatch calculation of correlation\nWrite a function first\nEnter a gene to return the correlation and p-value with immune\ngenes\nThe method can be changed to “Pearson” or “Kendall”\n# 将感兴趣的基因列表赋值给变量gene\n# Assign the list of genes of interest to variable gene\ngene <- genelist\n\n# 定义免疫评分函数，计算指定基因表达量与免疫细胞浸润得分的相关性\n# Define the immune score function to calculate the correlation between the expression of a specified gene \n# and the infiltration score of immune cells\nimmuscore <- function(gene){\n  # 提取该基因在所有样本中的表达量数据\n  # Extract the expression data of this gene across all samples\n  y <- as.numeric(tcga_expr[gene,])\n  # 获取免疫细胞类型列表（即tcga_gsva的列名）\n  # Get the list of immune cell types (i.e., column names of tcga_gsva)\n  colnames <- colnames(tcga_gsva)\n  # 对每种免疫细胞类型，计算其与基因表达量的Spearman相关性\n  # For each immune cell type, calculate its Spearman correlation with gene expression\n  do.call(rbind,lapply(colnames, function(x){\n    # 执行Spearman相关性检验\n    # Perform Spearman correlation test\n    dd  <- cor.test(as.numeric(tcga_gsva[,x]), y , method=\"spearman\")\n    # 构建包含基因名、免疫细胞类型、相关系数和p值的数据框\n    # Construct a data frame containing gene name, immune cell type, correlation coefficient, and p-value\n    data.frame(gene=gene,immune_cells=x,cor=dd$estimate,p.value=dd$p.value )\n  }))\n}\n\n# 以FOXP3基因为例，测试免疫评分函数\n# Test the immune score function using the FOXP3 gene as an example\nimmuscore(\"FOXP3\")\n批量计算genelist跟免疫浸润相关性的结果\nBatch calculation of the correlation between genelist and immune\ninfiltration results\n# 对基因列表中的每个基因应用免疫评分函数，并将结果合并为一个数据框\n# Apply the immune score function to each gene in the gene list and combine the results into a single data frame\ndata <- do.call(rbind,lapply(genelist,immuscore))\n# 查看结果数据框的前几行\n# View the first few rows of the resulting data frame\nhead(data)\n# 保存到文件\n# 将相关性分析结果保存为CSV文件\n# Save the correlation analysis results to a CSV file\nwrite.csv(data, \"correlation.csv\", \n          quote = F,  # 不使用引号包裹字符串\n          # Do not enclose strings in quotes\n          row.names = F)  # 不保存行名\n          # Do not save row names\n增加一列，区分p值的大小\n使用两个ifelse实现三分类\nAdd a column to distinguish the size of p-values\nImplement three classification using two ifelses\n# 根据p值添加显著性标记：p<0.05标记为*，p<0.01标记为**，否则为空\n# Add significance markers based on p-values: * for p<0.05, ** for p<0.01, otherwise empty\ndata$pstar <- ifelse(data$p.value < 0.05,\n                     ifelse(data$p.value < 0.01, \"**\", \"*\"),  # p<0.01时标记为双星号，p<0.05时标记为单星号\n                     # Mark with double asterisk if p<0.01, single asterisk if p<0.05\n                     \"\")  # 不显著的结果不添加标记\n                     # No marker for non-significant results\n\n# 查看前20个结果的显著性标记\n# View significance markers for the first 20 results\ndata$pstar[1:20]\n开始画图\n使用ggplot2画图，主要用到的是geom_tile函数：\n相关性用颜色的不同来表示，相关性的大小用颜色的深浅来反映；\n有差异的把*号打印在热图上\nStart drawing\nWhen using ggplot2 for drawing, the main function used is the\ngeom_tile function:\n-Correlation is represented by different colors, and the magnitude of\ncorrelation is reflected by the depth of color;\n-Print the * symbol on the heat map if there are differences\n# 你可能想要改变横轴细胞的顺序，那就把细胞按照你想要的顺序写入levels = c()的括号里。\n# If you want to change the order of immune cells on the x-axis, specify the desired order in levels = c()\n# 查看细胞名\n# View unique immune cell names\n# unique(data$immune_cells)\n\n# 将免疫细胞列转换为因子，并按指定顺序排列\n# Convert the immune cell column to a factor with specified order\n# data$immune_cells <- factor(data$immune_cells, \n#                            levels = c(\"第一种细胞\",\"第二种细胞\",,,,))\n\n# 使用ggplot2绘制热图，展示基因与免疫细胞的相关性\n# Create a heatmap using ggplot2 to show correlations between genes and immune cells\nggplot(data, aes(immune_cells, gene)) + \n  # 绘制热力图瓦片，填充颜色根据相关系数决定\n  # Draw heatmap tiles with color filled by correlation coefficient\n  geom_tile(aes(fill = cor), colour = \"white\", size=1) +\n  # 设置渐变色：蓝色表示负相关，白色为中性，红色表示正相关\n  # Set gradient color: blue for negative correlation, white for neutral, red for positive correlation\n  scale_fill_gradient2(low = \"#2b8cbe\", mid = \"white\", high = \"#e41a1c\") +\n  # 在每个瓦片上添加显著性标记\n  # Add significance markers on each tile\n  geom_text(aes(label=pstar), col =\"black\", size = 5) +\n  # 使用简约主题\n  # Apply minimal theme\n  theme_minimal() + \n  # 自定义主题元素\n  # Customize theme elements\n  theme(\n    axis.title.x = element_blank(),  # 隐藏x轴标题\n    # Hide x-axis title\n    axis.ticks.x = element_blank(),  # 隐藏x轴刻度线\n    # Hide x-axis tick marks\n    axis.title.y = element_blank(),  # 隐藏y轴标题\n    # Hide y-axis title\n    axis.text.x = element_text(angle = 45, hjust = 1),  # 调整x轴文字角度\n    # Adjust x-axis text angle\n    axis.text.y = element_text(size = 8)  # 调整y轴文字大小\n    # Adjust y-axis text size\n  ) +\n  # 调整图例\n  # Adjust legend\n  labs(fill = paste0(\" * p < 0.05\", \"\\n\\n\", \"** p < 0.01\", \"\\n\\n\", \"Correlation\"))\n# 保存图表到PDF文件\n# Save the plot to a PDF file\nggsave(\"correlation.pdf\", width = 8, height = 4)\ngeom_tile函数中的colour可以改变颜色，例如black\nThe color in the geome_tile function can change the color, such as\nblack\n# 使用ggplot2创建基因与免疫细胞相关性热图\n# Create a heatmap showing correlations between genes and immune cells using ggplot2\nggplot(data, aes(immune_cells, gene)) + \n  # 绘制热力图瓦片，设置边框颜色为黑色，边框粗细为1\n  # Draw heatmap tiles with black borders of size 1\n  geom_tile(aes(fill = cor), colour = \"black\", size=1) +\n  # 设置渐变色填充：蓝色表示负相关，白色为中性，红色表示正相关\n  # Set gradient color: blue for negative correlation, white for neutral, red for positive correlation\n  scale_fill_gradient2(low = \"#2b8cbe\", mid = \"white\", high = \"#e41a1c\") +\n  # 在每个瓦片上添加显著性标记（*或**）\n  # Add significance markers (* or **) on each tile\n  geom_text(aes(label=pstar), col =\"black\", size = 5) +\n  # 应用简约主题（无背景网格线）\n  # Apply minimal theme (no background gridlines)\n  theme_minimal() +\n  # 自定义主题元素\n  # Customize theme elements\n  theme(\n    axis.title.x = element_blank(),  # 隐藏x轴标题\n    # Hide x-axis title\n    axis.ticks.x = element_blank(),  # 隐藏x轴刻度线\n    # Hide x-axis tick marks\n    axis.title.y = element_blank(),  # 隐藏y轴标题\n    # Hide y-axis title\n    axis.text.x = element_text(angle = 45, hjust = 1),  # x轴标签旋转45度并右对齐\n    # Rotate x-axis labels 45 degrees and align to the right\n    axis.text.y = element_text(size = 8)  # 设置y轴标签字体大小\n    # Set y-axis label font size\n  ) +\n  # 调整图例标题，包含显著性标记说明\n  # Adjust legend title with significance level explanations\n  labs(fill = paste0(\" * p < 0.05\", \"\\n\\n\", \"** p < 0.01\", \"\\n\\n\", \"Correlation\"))\n如果colour缺失，就没有边框的颜色\nIf color is missing, there will be no border color\n# 使用ggplot2创建基因与免疫细胞相关性热图\n# Create a heatmap showing correlations between genes and immune cells using ggplot2\nggplot(data, aes(immune_cells, gene)) + \n  # 绘制热力图瓦片，根据相关系数填充颜色，边框粗细为1（默认透明）\n  # Draw heatmap tiles filled by correlation coefficient with border size 1 (default transparent)\n  geom_tile(aes(fill = cor), size=1) +\n  # 设置渐变色填充：蓝色表示负相关，白色为中性，红色表示正相关\n  # Set gradient color: blue for negative correlation, white for neutral, red for positive correlation\n  scale_fill_gradient2(low = \"#2b8cbe\", mid = \"white\", high = \"#e41a1c\") +\n  # 在每个瓦片上添加显著性标记（*或**）\n  # Add significance markers (* or **) on each tile\n  geom_text(aes(label=pstar), col =\"black\", size = 5) +\n  # 应用简约主题（无背景网格线）\n  # Apply minimal theme (no background gridlines)\n  theme_minimal() +\n  # 自定义主题元素\n  # Customize theme elements\n  theme(\n    axis.title.x = element_blank(),  # 隐藏x轴标题\n    # Hide x-axis title\n    axis.ticks.x = element_blank(),  # 隐藏x轴刻度线\n    # Hide x-axis tick marks\n    axis.title.y = element_blank(),  # 隐藏y轴标题\n    # Hide y-axis title\n    axis.text.x = element_text(angle = 45, hjust = 1),  # x轴标签旋转45度并右对齐\n    # Rotate x-axis labels 45 degrees and align to the right\n    axis.text.y = element_text(size = 8)  # 设置y轴标签字体大小\n    # Set y-axis label font size\n  ) +\n  # 调整图例标题，包含显著性标记说明\n  # Adjust legend title with significance level explanations\n  labs(fill = paste0(\" * p < 0.05\", \"\\n\\n\", \"** p < 0.01\", \"\\n\\n\", \"Correlation\"))\n如果把其他变量映射到size参数，可以实现热图小方块的大小改变\n本次不推荐，我觉得不好看\nIf other variables are mapped to the size parameter, it is possible\nto change the size of the small squares in the heatmap\nNot recommended this time, I don’t think it looks good\n# 使用ggplot2创建基因与免疫细胞相关性热图\n# Create a heatmap showing correlations between genes and immune cells using ggplot2\nggplot(data, aes(immune_cells, gene)) + \n  # 绘制热力图瓦片，同时根据相关系数映射填充颜色和边框粗细\n  # Draw heatmap tiles with color and border size mapped to correlation coefficient\n  geom_tile(aes(fill = cor, size = cor), colour = \"white\") +\n  # 设置渐变色填充：蓝色表示负相关，白色为中性，红色表示正相关\n  # Set gradient color: blue for negative correlation, white for neutral, red for positive correlation\n  scale_fill_gradient2(low = \"#2b8cbe\", mid = \"white\", high = \"#e41a1c\") +\n  # 设置边框粗细的连续范围，从0到6\n  # Set continuous range for border size from 0 to 6\n  scale_size_continuous(range = c(0, 6)) +\n  # 在每个瓦片上添加显著性标记（*或**）\n  # Add significance markers (* or **) on each tile\n  geom_text(aes(label=pstar), col =\"black\", size = 5) +\n  # 应用简约主题\n  # Apply minimal theme\n  theme_minimal() +\n  # 自定义主题元素\n  # Customize theme elements\n  theme(\n    axis.title.x = element_blank(),  # 隐藏x轴标题\n    # Hide x-axis title\n    axis.text.x = element_text(angle = 45, hjust = 1),  # x轴标签旋转45度并右对齐\n    # Rotate x-axis labels 45 degrees and align to the right\n    axis.ticks.x = element_blank(),  # 隐藏x轴刻度线\n    # Hide x-axis tick marks\n    axis.title.y = element_blank(),  # 隐藏y轴标题\n    # Hide y-axis title\n    axis.text.y = element_text(size = 8)  # 设置y轴标签字体大小\n    # Set y-axis label font size\n  ) +\n  # 调整图例标题，包含显著性标记说明和相关系数说明\n  # Adjust legend titles with significance levels and correlation explanation\n  labs(\n    fill = paste0(\"* p < 0.05\", \"\\n\\n\", \"** p < 0.01\", \"\\n\\n\", \"Correlation\"),\n    size = \"Correlation\"  # 修改大小图例的标题\n    # Modify the title of the size legend\n  )\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa97correlationV3_FigureYa97correlationV3",
      "title": "FigureYa97correlationV3/FigureYa97correlationV3.html",
      "html": "FigureYa97correlationV3/FigureYa97correlationV3.html",
      "text": "texts/main_FigureYa97correlationV3_FigureYa97correlationV3.txt",
      "folder": "FigureYa97correlationV3",
      "thumb": "gallery_compress/FigureYa97correlationV3.webp"
    },
    "word_count": 1670,
    "lines_count": 316,
    "title": "FigureYa97correlationV3",
    "description": "计算多个基因和免疫浸润的相关性，画出类似于文章中这种热图，用颜色展示相关系数，用**标出显著的。 Requirement description Calculate the correlation between multiple genes and immune",
    "input_data_types": [
      "临床数据",
      "表达矩阵"
    ],
    "output_types": [
      "散点图",
      "热图"
    ],
    "technical_methods": [],
    "biology_areas": [
      "免疫学"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "gene",
      "colour",
      "width",
      "那就把细胞按照你想要的顺序写入levels",
      "col",
      "mid",
      "method",
      "angle"
    ]
  },
  {
    "id": "main_FigureYa267scCellChat_FigureYa267scCellChat",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa267scCellChat_FigureYa267scCellChat.txt",
    "content": "FigureYa267scCellChat\nFigureYa267scCellChat\nXiao Gu, Taojun Ye\n2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n希望用cellchat来实现：\nRequirement description\nI hope to use CellChat to achieve:\n出自\nhttps://aacrjournals.org/cancerdiscovery/article/12/1/134/675646/Spatiotemporal-Immune-Landscape-of-Colorectal\nfrom\nhttps://aacrjournals.org/cancerdiscovery/article/12/1/134/675646/Spatiotemporal-Immune-Landscape-of-Colorectal\nFigure 3. MRC1+ CCL18+ macrophages in metastatic tumors exhibited\nterminally differentiated and suppressive states. A, The ranked\ndifferential tumor–immune cell cross-talk [liver metastasis (LM)\nvs. colorectal cancer (CRC)] shows MRC1+ CCL18+ M2-like macrophages\nranked the second among all ligand–receptor pairs.\n本文档作者古潇的comments:\n例文提出假设“Given the enrichment of macrophage subpopulations in\nliver metastasis, we hypothesized that those liver metastasis–enriched\nmacrophages might be functionally distinct across different tissues.”\n怎样验证这个假设呢？\n作者用CellPhoneDB分析 +\ncirclize可视化来解决。由于CellPhoneDB不能直接处理两组间的关系，所以作者用了一个变通的方法：\n把直肠癌的所有细胞类型combined到一起，相当于一种细胞类型，命名为tumor，这样就可以克服cellphonedb无法一次性比较两组间的关系的困难。\n这个方法其实我不太认可，这样抹掉了结肠癌的细胞类型的信息。我个人认为cellchat的算法是优于cellphonedb的，尤其是在有对照处理的分析中。\n提需求的小伙伴要求用cellchat来实现，用cellchat的确可以很方便的实现。详见“开始画图”结尾的“结果解读”。\nComments from the author of this document, Xiao Gu:\nGiven the enrichment of macrophage subpopulations in liver\nmetastasis, we hypothesize that those liver metastases – enriched\nmacrophages may be functionally distinct across How to test this\nhypothesis for ‘different disorders’?\nThe author uses CellPhoneDB analysis and circlize visualization to\nsolve the problem. Due to CellPhoneDB’s inability to directly handle the\nrelationship between two groups, the author used an alternative\napproach:\n-Combining all cell types of rectal cancer together, equivalent to\none cell type, named tumor, can overcome the difficulty of cellphonedb\nin comparing the relationship between two groups at once.\nI actually don’t quite agree with this method, as it erases\ninformation about the cell types of colon cancer. I personally believe\nthat Cellchat’s algorithm is superior to Cellphonedb, especially in\nanalyses with control processing.\nThe friend who raised the request requested to use Cellchat to\nimplement it, which can indeed be very convenient. See “Interpretation\nof Results” at the end of “Start Drawing” for details.\n应用场景\n单细胞RNA-seq数据，对比两组样本（例文的原发vs.转移、不同亚型、不同发育时期等）之间，基于“受体-配体”的差异，用cellchat来实现。\n另外，CellPhoneDB的用法可参考FigureYa178receptorLigand\nApplication scenarios\nSingle cell RNA seq data was compared between two groups of samples\n(e.g. primary vs. metastasis, different subtypes, different\ndevelopmental stages, etc.) using cellchat based on the differences in\n“receptor ligand”.\nIn addition, the usage of CellPhoneDB can refer to\nFigureYa178receptorLigand<\nhttps://k.youshop10.com/YICoy-XB\n>\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\n# 加载Seurat包用于单细胞数据分析（Load the Seurat package for single-cell RNA-seq data analysis）\nlibrary(Seurat)\n# 加载SeuratData包用于获取示例数据集（Load the SeuratData package for accessing example datasets）\nlibrary(SeuratData)\n# 加载RColorBrewer包用于创建自定义配色方案（Load the RColorBrewer package for creating color palettes）\nlibrary(RColorBrewer)\n# 加载dplyr包用于数据处理和转换（Load the dplyr package for data manipulation and transformation）\nlibrary(dplyr)\n# 加载magrittr包以使用管道操作符（Load the magrittr package to use pipe operators）\nlibrary(magrittr)\n# 加载CellChat包用于细胞间通讯分析（Load the CellChat package for cell-cell communication analysis）\nlibrary(CellChat)\n# 加载patchwork包用于组合多个ggplot2图形（Load the patchwork package for combining multiple ggplot2 plots）\nlibrary(patchwork)\nlibrary(ifnb.SeuratData)\nlibrary(presto)\n# 设置系统环境以显示英文错误信息（Set system environment to display error messages in English）\nSys.setenv(LANGUAGE = \"en\") \n# 禁止自动将字符串转换为因子类型（Prevent automatic conversion of strings to factors）\noptions(stringsAsFactors = FALSE)\n输入数据预处理\nifnb\n- A Seurat object with the PBMC\ncontrol/IFNB-stimulated dataset。出自\nhttps://pubmed.ncbi.nlm.nih.gov/29227470/\n，已被打包到SeuratData里，我们直接安装、加载它。\n示例数据ifnb有STIM和CTRL两组：\n先拆分成两个seurat\nobject，对两个数据集单独进行normalize并识别各自的高变异基因，使用高变异基因在两个基因集中分别执行PCA。\n然后对两个数据集进行整合，进行常规数据预处理，存入immune.combined，以便进行后续分析。\nInput data preprocessing\nifnb\n- A Seurat object with the PBMC\ncontrol/IFNB-stimulated dataset。 From<\nhttps://pubmed.ncbi.nlm.nih.gov/29227470/\n>, has been\npackaged into SeuratData, we can directly install and load it.\nThe example data ifnb has two groups: STIM and CTRL:\n-First, split it into two seurat objects, normalize the two datasets\nseparately and identify their respective highly variable genes. Use the\nhighly variable genes to perform PCA on the two gene sets separately.\n-Then integrate the two datasets, perform regular data preprocessing,\nand store them in immunembined for subsequent analysis.\n提取数据分别创建CellChat对象\nSTIM和CTRL两组，分别提取数据，创建CellChat对象。\n运行时间约10min\nExtract data and create CellChat objects separately\nExtract data from STIM and CTRL groups respectively, and create\nCellChat objects.\nRunning time is about 10 minutes\n开始画图\nStart drawing\n细胞间互作次数bar图\nBar chart of intercellular interaction frequency\nComparing the number of inferred communication links between\ndifferent datasets\n# 比较两组间的细胞通讯相互作用（默认使用通讯频率）\n# Compare cell-cell communication interactions between two groups (default: communication frequency)\ngg1 <- compareInteractions(cellchat, show.legend = F, group = c(1,2))\n# 比较两组间的细胞通讯相互作用（使用通讯权重）\n# Compare cell-cell communication interactions between two groups (using communication weight)\ngg2 <- compareInteractions(cellchat, show.legend = F, group = c(1,2), measure = \"weight\")\n\n# 保存比较结果为PDF文件\n# Save the comparison results as a PDF file\npdf(\"compareInteractions.pdf\", height = 5, width = 8)\n# 组合两个图形\n# Combine the two graphs\ngg1 + gg2\n# 关闭图形设备\n# Close the graphics device\ndev.off()\n细胞间互作次数网络图\nCircle plot showing differential cell-cell communication network\nbetween two datasets\n红色为STIM组相比CTRL组互作次数和互作强度增加，线越粗表示差异越大；蓝色则表示减少。\n两个数据集之间的细胞-细胞通信网络中的交互或交互强度的差异数量可以使用圆形图来可视化，其中红色(或蓝色)边表示第二个数据集相比于第一个数据集增加(或减少)的信号。\nNetwork diagram of intercellular interaction frequency\nCircle plot showing differential cell-cell communication network\nbetween two datasets\nThe red color indicates an increase in the number and intensity of\ninteractions between the STIM group and the CTRL group, with thicker\nlines indicating greater differences; Blue indicates a decrease.\nThe difference in the number of interactions or interaction strengths\nin the cell-cell communication network between two datasets can be\nvisualized using a circular graph, where the red (or blue) edges\nrepresent the signal increase (or decrease) in the second dataset\ncompared to the first dataset.\n# 创建PDF文件用于保存差异相互作用网络图\n# Create a PDF file to save differential interaction network plots\npdf(\"netVisual_diffInteraction.pdf\", height = 8, width = 8)\n# 设置图形布局为1行1列，并允许图形元素超出绘图区域\n# Set plot layout to 1 row and 1 column, allow elements to extend beyond plot area\npar(mfrow = c(1,1), xpd = TRUE)\n\n# 可视化两组间的差异细胞通讯相互作用（基于通讯概率）\n# Visualize differential cell-cell communication interactions between groups (based on communication probability)\nnetVisual_diffInteraction(cellchat, weight.scale = T)\n# 可视化两组间的差异细胞通讯相互作用（基于通讯权重）\n# Visualize differential cell-cell communication interactions between groups (based on communication weight)\nnetVisual_diffInteraction(cellchat, weight.scale = T, measure = \"weight\")\n\n# 关闭PDF设备\n# Close the PDF device\ndev.off()\n结果解读：\nInterpretation of Results:\n红色表示处理 vs 对照后受体-配体对增加，蓝色表示降低。 可以看到CD14\nMono的线很粗，线越粗数量越多。这样就可以回答文中提出的假设了。\n把圆形网络拉开看更明显：\nRed indicates an increase in receptor ligand pairs after treatment\ncompared to control, while blue indicates a decrease. It can be seen\nthat the lines of CD14 Mono are very thick, and the thicker the lines,\nthe more they are. This will answer the hypothesis proposed in the\narticle.\nPull open the circular network to see more clearly:\n# 计算STIM组与CTRL组之间细胞通讯次数的差异矩阵\n# Calculate the difference matrix of cell-cell communication counts between STIM and CTRL groups\ndiff.count <- cellchat@net$STIM$count - cellchat@net$CTRL$count\n\n# 将STIM组和CTRL组的通讯次数矩阵保存为CSV文件\n# Save communication count matrices of STIM and CTRL groups to CSV files\nwrite.csv(cellchat@net$STIM$count, \"output_STIMcount.csv\", quote = F)\nwrite.csv(cellchat@net$CTRL$count, \"output_CTRLcount.csv\", quote = F)\n\n# 加载pheatmap包用于绘制热图\n# Load the pheatmap package for heatmap visualization\nlibrary(pheatmap)\n\n# 绘制差异通讯次数热图，展示两组间细胞通讯的变化\n# Plot heatmap of differential communication counts to show changes between groups\npheatmap(diff.count,\n         treeheight_row = 0,    # 不显示行聚类树 (Suppress row clustering tree)\n         treeheight_col = 0,    # 不显示列聚类树 (Suppress column clustering tree)\n         cluster_rows = TRUE,   # 对行进行聚类 (Cluster rows)\n         cluster_cols = TRUE)   # 对列进行聚类 (Cluster columns)\n热图虽然朴素，更直观。或者自己用cytoscape画，更自如一点。\n另外，cellchat里有丰富的“受体-配体”分析结果，可以运行下面这行查看。结合自己的假设，设计合适的图形展示数据。\nAlthough heat maps are simple, they are more intuitive.\nAlternatively, you can use Cytoscape to draw on your own, which would be\nmore comfortable.\nIn addition, CellChat provides rich results of “receptor ligand”\nanalysis, which can be viewed by running the following line. Design\nappropriate graphics to display data based on one’s own assumptions.\n# 在RStudio中打开交互式查看器查看CellChat对象的结构和内容\n# Open an interactive viewer in RStudio to explore the structure and contents of the CellChat object\nView(cellchat)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa267scCellChat_FigureYa267scCellChat",
      "title": "FigureYa267scCellChat/FigureYa267scCellChat.html",
      "html": "FigureYa267scCellChat/FigureYa267scCellChat.html",
      "text": "texts/main_FigureYa267scCellChat_FigureYa267scCellChat.txt",
      "folder": "FigureYa267scCellChat",
      "thumb": "gallery_compress/FigureYa267scCellChat.webp"
    },
    "word_count": 1135,
    "lines_count": 217,
    "title": "FigureYa267scCellChat",
    "description": "希望用cellchat来实现： Requirement description I hope to use CellChat to achieve:",
    "input_data_types": [
      "临床数据",
      "单细胞"
    ],
    "output_types": [
      "热图",
      "统计表格",
      "网络图"
    ],
    "technical_methods": [
      "聚类分析",
      "网络分析"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学",
      "药物研究",
      "发育生物学"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "LANGUAGE",
      "group",
      "stringsAsFactors",
      "measure",
      "xpd",
      "quote",
      "mfrow",
      "cluster_rows",
      "width"
    ]
  },
  {
    "id": "main_FigureYa312CellPreference_FigureYa312CellPreference",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa312CellPreference_FigureYa312CellPreference.txt",
    "content": "FigureYa312CellPreference\nFigureYa312CellPreference\nAuthor(s)\n: Xiaofan Lu; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nDemand description\n想复现算这个preference的值，复现图Fig3c\nWe want to reproduce the calculation of preference values and\nrecreate Fig3c.\n出自：\nhttps://www.nature.com/articles/s41586-022-05400-x\n图3. 人类中性粒细胞的异质性及功能验证 b.\n通过\nRo/e值(观察细胞数与期望细胞数的比值)\n揭示的人类中性粒细胞簇组织偏好性\nSource:\nhttps://www.nature.com/articles/s41586-022-05400-x\nFig. 3 | Neutrophil heterogeneity and functional validation in\nhumans. b, Tissue preference of neutrophil clusters in humans, revealed\nby\nRo/e (ratio of observed cell number to expected cell\nnumber)\n.\n类似的图：\nSimilar figure:\n出自：\nhttps://www.cell.com/cell/fulltext/S0092-8674(20)30341-X?_returnURL=https%3A%2F%2Flinkinghub.elsevier.com%2Fretrieve%2Fpii%2FS009286742030341X%3Fshowall%3Dtrue\n图2. 通过单细胞RNA测序技术对人类结直肠癌中肿瘤浸润性髓系细胞的表征\n(C)\n采用Ro/e评分(103个单细胞RNA测序样本)估算的组织分布情况(STAR方法部分)。\nSource:\nhttps://www.cell.com/cell/fulltext/S0092-8674(20)30341-X?_returnURL=https%3A%2F%2Flinkinghub.elsevier.com%2Fretrieve%2Fpii%2FS009286742030341X%3Fshowall%3Dtrue\nFigure 2. Characterization of Tumor-Infiltrating Myeloid Cells by\nscRNA-seq in Human CRC (C) Tissue prevalence estimated by Ro/e score\n(103 scRNA-seq) (STAR Methods).\n应用场景\nApplication scenarios\n计算各细胞类型（Celltypes）在各组织（Tissue）的偏好性/富集程度，并绘制热图。\nRo/e (ratio of observed cell number to expected cell number)\n偏好性计算方法：实际细胞数目/期望细胞数目，期望细胞数为各组织中各细胞类型均匀分布下的细胞数目\nCalculate the preference/enrichment level of each cell type\n(Celltypes) across different tissues (Tissue), and visualize the results\nwith a heatmap.\nRo/e (ratio of observed cell number to expected cell number)\nCalculation method: Actual cell count / Expected cell count, where\nthe expected cell count represents the uniformly distributed cell number\nfor each cell type across tissues.\n环境设置\nRequirements Description\nsource(\"install_dependencies.R\")\nlibrary(epitools)\nlibrary(ComplexHeatmap)\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n输入文件\nInput Files\nneu-CountBySample.csv和neu-CountByTissue.csv，频数统计表，为例文作者提供的注释数据。每一行为各细胞类型，每一列为各组织。\n对于自己的单细胞测序数据，这样得到observe.data：\nas.matrix(as.data.frame.matrix(table(seu.obj$Tissue, seu.obj$Celltypes)))\n# 这里读取例文作者提供的注释数据\n# 数值为特定组织中特定细胞类型的实际细胞数目\n# Here we read the annotation data provided by the example paper authors\n# The values are actual cell counts of specific cell types in specific tissues\ndata1 <- read.csv(\"neu-CountBySample.csv\", row.names = 1)\ndata1 <- split(data1, substr(rownames(data1), 6, 8))\ndata1 <- data1[c(\"HCC\", \"ICC\", \"CHC\")]\ndata1 <- lapply(data1, colSums)\ndata1 <- as.data.frame(do.call(rbind, data1))\n\ndata2 <- read.csv(\"neu-CountByTissue.csv\", row.names = 1)\ndata2 <- data2[c(\"AL\", \"PB\"), ]\n\nobserve.data <- t(rbind(data2, data1))\n生成细胞数目分布频数统计表observe.data\nGenerate Cell Count Frequency Table observe.data\n# 生成期望频数表\n# Generate expected frequency table\nexpected.data <- expected(observe.data) \n\n# 计算实际细胞数目与期望细胞数目的比值\n# Calculate ratio of actual to expected cell counts\nplot.data <- observe.data/expected.data\n开始画图\nPlotting\nplot.data[plot.data>3] = 3\n\n# 绘图数据的列顺序\n# Column order for plotting data\ncol.order <- c(\"PB\", \"AL\", \"HCC\", \"CHC\", \"ICC\") \n\n# 对绘图数据列进行排序\n# Sort plotting data columns\nplot.data <- plot.data[, col.order] \n\n# 对绘图数据行进行排序\n# Sort plotting data rows\nplot.data <- plot.data[order(apply(plot.data, 1, which.max), decreasing = T), ] \n# 如果想深色色块在主对角线使用which.min，在副对角线则使用which.max\n# If you want darker blocks on main diagonal use which.min, for secondary diagonal use which.max\n\nrownames(plot.data) <- substr(rownames(plot.data), 5, 6)\n\n# 热图颜色设定\n# Heatmap color settings\ncols <- setNames(object = c(\"#FEE6CE\", \"#FDC08C\", \"#F5904B\", \"#E6550D\"),\n                 nm = c(\"1\", \"1.5\", \"3\", \">5\"))\n\ncell_fun = function(j, i, x, y, width, height, fill) {\n  if(plot.data[i,j] < as.numeric(names(cols)[1])) {\n    grid.rect(x = x, y = y, width = width, height = height, gp = gpar(col = cols[1], fill = cols[1]))\n    grid.text(\"\\u00B1\", x = x, y = y)\n  } else if(plot.data[i,j] < as.numeric(names(cols)[2])) {\n    grid.rect(x = x, y = y, width = width, height = height, gp = gpar(col = cols[2], fill = cols[2]))\n    grid.text(\"+\", x = x, y = y)\n  } else if(plot.data[i,j] < as.numeric(names(cols)[3])) {\n    grid.rect(x = x, y = y, width = width, height = height, gp = gpar(col = cols[3], fill = cols[3]))\n    grid.text(\"++\", x = x, y = y)\n  } else {\n    grid.rect(x = x, y = y, width = width, height = height, gp = gpar(col = cols[4], fill = cols[4]))\n    grid.text(\"+++\", x = x, y = y)\n  }\n}\n\n# 生成热图\n# Generate heatmap\nhm = Heatmap(plot.data, cell_fun = cell_fun,\n             cluster_rows = F, cluster_columns = F,\n             width = unit(5, \"cm\"), height = unit(11, \"cm\"), \n             show_heatmap_legend = F)\n\n# 生成图例\n# Generate legend\nlgd = Legend(labels = names(cols), title = expression(R[o/e]), legend_gp = gpar(fill = cols))\n\ndraw(hm, annotation_legend_list = lgd)\n# 输出到文件\n# Output to file\npdf(\"RatioHeatmap.pdf\", width = 8, height = 6)\ndraw(hm, annotation_legend_list = lgd)\ninvisible(dev.off())\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa312CellPreference_FigureYa312CellPreference",
      "title": "FigureYa312CellPreference/FigureYa312CellPreference.html",
      "html": "FigureYa312CellPreference/FigureYa312CellPreference.html",
      "text": "texts/main_FigureYa312CellPreference_FigureYa312CellPreference.txt",
      "folder": "FigureYa312CellPreference",
      "thumb": "gallery_compress/FigureYa312CellPreference.webp"
    },
    "word_count": 651,
    "lines_count": 158,
    "title": "FigureYa312CellPreference",
    "description": "Demand description 想复现算这个preference的值，复现图Fig3c We want to reproduce the calculation of preference values and",
    "input_data_types": [
      "临床数据",
      "单细胞"
    ],
    "output_types": [
      "热图",
      "统计表格"
    ],
    "technical_methods": [
      "通路分析"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "show_heatmap_legend",
      "width",
      "cluster_columns",
      "object",
      "labels",
      "nm",
      "col",
      "annotation_legend_list",
      "decreasing"
    ]
  },
  {
    "id": "main_FigureYa276panSNV_FigureYa276panSNV",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa276panSNV_FigureYa276panSNV.txt",
    "content": "FigureYa276panSNV\nFigureYa276panSNV\nAuthor(s)\n: Xiaofan Lu; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-05-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nDemand description\n我们希望复现pancancer SNV\nWe desired to reproduce pan-cancer SNV analysis\n出自：\nhttps://onlinelibrary.wiley.com/doi/10.1111/jpi.12758\n图2 褪黑素调节因子的单核苷酸变异(SNV)频率及变异类型。 (A)\n褪黑素调节因子的突变频率。数值表示特定癌症中对应基因发生突变的样本数量。“0”表示该基因编码区未检测到突变，空白则表示该基因任何区域均未发现突变。\n(B) SNV突变景观图。展示褪黑素调节因子突变分布及SNV类型分类的热图。\nSource:\nhttps://onlinelibrary.wiley.com/doi/10.1111/jpi.12758\nFIGURE 2 Single nucleotide variation(SNV) frequency and variant types\nof melatonergic regulators. (A)Mutation frequency of melatonergic\nregulators. Numbers represent the number of samples that have the\ncorresponding mutated gene for a given cancer. “0” indicates that there\nwas no mutation in the gene coding region, and no number indicates there\nwas no mutation in any region of the gene. (B) SNV oncoplot. An oncoplot\nshowing the mutation distribution of melatonergic regulators and a\nclassification of SNV types.\n应用场景\nApplication scenarios\n分析泛癌中特定通路基因的突变情况。\nAnalysis of mutation patterns in specific pathway genes across\npan-cancer.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(tidyverse)\nlibrary(magrittr)\nlibrary(readxl)\nlibrary(stringr)\nlibrary(ggplot2)\nlibrary(maftools)\nlibrary(dplyr)\nlibrary(reshape2)\nlibrary(RColorBrewer)\n\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n输入文件\nInput Files\nmc3.v0.2.8.PUBLIC.maf.gz，TCGA pancancer突变数据，下载自\nhttps://gdc.cancer.gov/about-data/publications/pancanatlas\nMutations，下载地址\nhttp://api.gdc.cancer.gov/data/1c8cfe5f-e52d-41ba-94da-f15ea1337efc\nmerged_sample_quality_annotations.tsv，下载自\nhttps://gdc.cancer.gov/about-data/publications/pancanatlas\n，下载地址\nhttp://api.gdc.cancer.gov/data/1a7d7be8-675d-4e60-a105-19d4121bdebf\n。跟FigureYa263panDiff、FigureYa265panCNV、FigureYa268panCNVexpr使用的是同一套数据，已经下载的小伙伴就不用重复下载了。\nmc3.v0.2.8.PUBLIC.maf.gz, TCGA pancancer mutation data, downloaded\nfrom\nhttps://gdc.cancer.gov/about-data/publications/pancanatlas\n.\nMutations, download link\nhttp://api.gdc.cancer.gov/data/1c8cfe5f-e52d-41ba-94da-f15ea1337efc\n.\nmerged_sample_quality_annotations.tsv, downloaded from\nhttps://gdc.cancer.gov/about-data/publications/pancanatlas\n,\ndownload link\nhttp://api.gdc.cancer.gov/data/1a7d7be8-675d-4e60-a105-19d4121bdebf\n.\nThe same dataset is used in FigureYa263panDiff, FigureYa265panCNV, and\nFigureYa268panCNVexpr. Friends who have already downloaded it don’t need\nto download again.\n# 修正TCGA名称\n# Correcting TCGA names\nrawAnno <- read.delim(\"merged_sample_quality_annotations.tsv\",sep = \"\\t\",row.names = NULL,check.names = F,stringsAsFactors = F,header = T)\nrawAnno$simple_barcode <- substr(rawAnno$aliquot_barcode,1,15)\n\n# 去重并过滤空值\n# Remove duplicates and filter empty values\nsamAnno <- rawAnno[!duplicated(rawAnno$simple_barcode),c(\"cancer type\", \"simple_barcode\")]\nsamAnno <- samAnno[which(samAnno$`cancer type` != \"\"),]\n\n# 保存结果\n# Save results\nwrite.table(samAnno,\"simple_sample_annotation.txt\",sep = \"\\t\",row.names = F,col.names = T,quote = F)\n\n# 加载泛癌突变MAF文件\n# Loading pan-cancer mutation MAF file\npanmaf <- read_tsv(\"mc3.v0.2.8.PUBLIC.maf.gz\", comment = \"#\")\nunique(panmaf$Variant_Classification)\n# 感兴趣基因列表\n# List of genes of interest\ngenelist <- c(\"PER3\",\"PER2\",\"GPR50\",\"CYP2C19\",\"MTNR1B\",\"CLOCK\",\"CYP1A2\",\"RORA\",\"ARNTL\",\"MTNR1A\",\"ASMT\",\"AANAT\")\n计算累积突变样本量\nCalculating cumulative mutation sample counts\n# 设置coding区域的突变以及非coding区域的突变\n# Define coding and non-coding mutations\n\n## Coding区域（个人认为是非沉默突变）\n## Coding mutations (considered non-synonymous) \nvc_nonSyn <- c(\"Frame_Shift_Del\",\n               \"Frame_Shift_Ins\",\n               \"Splice_Site\",\n               \"Translation_Start_Site\",\n               \"Nonsense_Mutation\",\n               \"Nonstop_Mutation\",\n               \"In_Frame_Del\",\n               \"In_Frame_Ins\",\n               \"Missense_Mutation\")\n\n## 非coding区域（个人认为是沉默突变）\n## Non-coding mutations (considered synonymous) \nvc_Syn <- c(\"3'UTR\",\n            \"5'UTR\",\n            \"3'Flank\",\n            \"5'Flank\",\n            \"IGR\",\n            \"Intron\",\n            \"Silent\")\n\n# 创建样本ID映射表\n# Create sample ID mapping table\nmafsam <- data.frame(samID = panmaf$Tumor_Sample_Barcode,\n                     simple_barcode = substr(panmaf$Tumor_Sample_Barcode,1,15),\n                     stringsAsFactors = F)\n\n# 去重并合并临床注释\n# Remove duplicates and merge clinical annotations\nmafsam <- mafsam[!duplicated(mafsam$simple_barcode),]\nmafsam <- merge(mafsam,samAnno, by = \"simple_barcode\", all.x = TRUE)\nmafsam <- as.data.frame(na.omit(mafsam))\n\n# 添加带样本数的癌症类型标签\n# Add cancer type labels with sample counts\ntxt <- data.frame(label = paste0(names(table(mafsam$`cancer type`)),\" (n=\", as.numeric(table(mafsam$`cancer type`)),\")\"),\n                  \"cancer type\" = names(table(mafsam$`cancer type`)),\n                  check.names = F) \n\nmafsam <- merge(mafsam, txt, by = \"cancer type\", all.x = TRUE)\nrownames(mafsam) <- mafsam$simple_barcode\n\n# 取感兴趣的突变子集\n# Extract the subset of mutations of interest\n# is.element(genelist, panmaf$Hugo_Symbol)\npanmaf <- panmaf[which(panmaf$Hugo_Symbol %in% genelist),]\npanmaf$Tumor_Sample_Barcode <- substr(panmaf$Tumor_Sample_Barcode,1,15)\nwrite.table(panmaf, file = \"maf of genes of interest.txt\",sep = \"\\t\",row.names = F,col.names = T,quote = F)\n\n# 重新读取确保数据一致性\n# Re-read to ensure data consistency\npanmaf <- read_tsv(\"maf of genes of interest.txt\", comment = \"#\")\n# 初始化突变计数矩阵\n# Initialize mutation count matrices\nnonSyncount <- matrix(0, nrow = length(genelist), ncol = length(mafsam$simple_barcode),\n                   dimnames = list(genelist, mafsam$simple_barcode))\nSyncount <- matrix(0, nrow = length(genelist), ncol = length(mafsam$simple_barcode),\n                   dimnames = list(genelist, mafsam$simple_barcode))\n\n# 转置矩阵以便后续处理\n# Transpose matrices for downstream processing\nnonSyncount <- as.data.frame(t(nonSyncount))\nSyncount <- as.data.frame(t(Syncount))\n\n# 逐个基因填充突变矩阵\n# Populate mutation matrices gene by gene\nfor (i in genelist) {\n  message(i,\" starts...\")\n  \n  # 取出当前基因的突变\n  # Extract mutations for the current gene\n  submaf <- panmaf[which(panmaf$Hugo_Symbol == i),] \n  for (j in 1:nrow(submaf)) { # 循环每一行\n    tmp <- submaf[j,]\n    \n    # 获取当前突变的基因\n    # Get the current mutated gene\n    mutGene <- i \n    \n    # 获取当前突变的样本\n    # Get the current mutated sample\n    mutSam <- tmp$Tumor_Sample_Barcode \n    \n    if(is.element(tmp$Variant_Classification, vc_nonSyn)) { \n      # 如果突变类型为coding类，则coding计数矩阵设为1\n      # If mutation type is coding, the coding count matrix is set to 1\n      nonSyncount[mutSam, mutGene] <- 1 \n    }\n    if(is.element(tmp$Variant_Classification, vc_Syn)) { \n      # 如果突变类型为非coding类，则非coding计数矩阵设为1\n      # If mutation type is non-coding, the non-coding count matrix is set to 1\n      Syncount[mutSam, mutGene] <- 1  \n    }\n  }\n}\n# 根据癌种计算累积突变样本量\n# Calculate cumulative mutation sample counts by cancer type\nnonSyncount$tumor <- mafsam[rownames(nonSyncount),\"label\"]\nSyncount$tumor <- mafsam[rownames(Syncount),\"label\"]\n\n# 按癌症类型汇总非沉默突变\n# Aggregate non-synonymous by cancer type\nnonSyncount.tumor <- as.data.frame(apply(nonSyncount[,setdiff(colnames(nonSyncount), \"tumor\")], 2, function(x) tapply(x, INDEX=factor(nonSyncount$tumor), FUN=sum, na.rm=TRUE))) \n\n# 对同一种癌种的沉默突变求和\n# Sum synonymous mutations for each cancer type\nSyncount.tumor <- as.data.frame(apply(Syncount[,setdiff(colnames(Syncount), \"tumor\")], 2, function(x) tapply(x, INDEX=factor(Syncount$tumor), FUN=sum, na.rm=TRUE))) \n\n# 初始化结果矩阵\n# Initialize result matrices\nmutCount <- matrix(NA, nrow = length(genelist), ncol = length(unique(mafsam$label)),\n                   dimnames = list(genelist, unique(mafsam$label)))\nmutCount <- as.data.frame(mutCount)\nmutFreq <- mutCount\n\n# 填充最终结果矩阵\n# Populate final result matrices\nfor (i in genelist) {\n  for(j in unique(mafsam$label)) {\n    tumor <- sapply(strsplit(j,\" (\", fixed = T),\"[\",1)\n    \n    # 情况1：存在非沉默突变\n    # Case 1: Non-synonymous mutations exist\n    if(nonSyncount.tumor[j,i] > 0) { \n      \n      # 记录该癌种的非沉默突变数\n      # Record non-synonymous mutation count for this cancer type\n      mutCount[i,j] <- nonSyncount.tumor[j,i] \n      \n      # 根据该癌种的样本数计算突变频率（个人认为原文并没有如此计算，原文的颜色映射似乎是按照突变数目来的，而不是突变频率）\n      # Calculate mutation frequency based on sample count (Note: The original paper may not have calculated this way; the color mapping seems based on mutation counts rather than frequency)\n      mutFreq[i,j] <- nonSyncount.tumor[j,i]/as.numeric(table(mafsam$`cancer type`)[tumor]) * 100 \n    }\n    \n    # 情况2：仅存在沉默突变\n    # Case 2: Only synonymous mutations exist\n    if(nonSyncount.tumor[j,i] == 0 & Syncount.tumor[j,i] > 0) { \n      # 若非沉默突变不存在，而沉默突变存在，则记录该癌种的突变数目为0，突变频率为0\n      # If no non-synonymous mutations exist but synonymous mutations do, record mutation count as 0 and mutation frequency as 0 for this cancer type\n      mutCount[i,j] <- 0  \n      mutFreq[i,j] <- 0  \n    }\n    \n    # 情况3：无任何突变\n    # Case 3: No mutations detected\n    if(nonSyncount.tumor[j,i] == 0 & Syncount.tumor[j,i] == 0) { \n      # 若非沉默突变不存在，沉默突变也不存在，则此单元为空值，突变频率为0\n      # If neither non-synonymous nor synonymous mutations exist, mark this cell as NA and set mutation frequency to 0\n      mutCount[i,j] <- NA  \n      mutFreq[i,j] <- 0 \n    }\n  }\n}\n开始画图\nPlotting\n图2A - 褪黑素调节因子的突变频率\nFigure 2A - Mutation frequency of melatonergic regulators\n# 数据重塑：将突变计数和频率矩阵转换为长格式\n# Data reshaping: Convert mutation count and frequency matrices to long format\nggCount <- reshape2::melt(as.matrix(mutCount), varnames = c(\"Cancer\", \"Gene\"), as.is = T) \nggFreq <- reshape2::melt(as.matrix(mutFreq), varnames = c(\"Cancer\", \"Gene\"), as.is = T) \n\n# 合并计数和频率数据\n# Combine count and frequency data\nggData <- cbind.data.frame(ggCount, Freq = ggFreq$value)\ncolnames(ggData) <- c(\"Cancer\",\"Gene\",\"Count\",\"Freq\")\n\n# 创建热图 \n# Create heatmap\np <- \n  ggplot(data = ggData) +\n  geom_tile(mapping = aes(Gene, Cancer, fill = Freq), col = \"grey80\") +\n  geom_text(mapping = aes(Gene, Cancer, label = Count), size =3) +\n  scale_fill_gradient(low = \"white\",\"high\" = \"red\") + \n  scale_x_discrete(position = \"top\") +\n  labs(fill = \"Mutation Frequency (%)\") + \n  theme_bw() + #theme(axis.text.x = element_text(angle = 45))\n  theme(axis.title = element_blank(),\n        axis.text.x = element_text(hjust = 0, size = 10, color = \"black\", angle = 45),\n        axis.text.y = element_text(hjust = 1, size = 10, color = \"black\"),\n        axis.ticks = element_line(size=0.2, color=\"black\"),\n        axis.ticks.length = unit(0.2, \"cm\"),\n        panel.background = element_blank(),\n        panel.grid = element_blank())\n# 保存为PDF\n# Save as PDF\nggsave(p, filename = \"frequency heatmap.pdf\", width = 10,height = 4)\n图2B - SNV突变景观图\nFigure 2B - SNV oncoplot\n# 读取感兴趣的基因子集突变文件\n# Read mutation file for genes of interest subset\npanmaf <- read.maf(maf = \"maf of genes of interest.txt\",\n                   removeDuplicatedVariants = TRUE,\n                   isTCGA = FALSE,\n                   vc_nonSyn = c(\"Frame_Shift_Del\",\n                                 \"Frame_Shift_Ins\",\n                                 \"Splice_Site\",\n                                 \"Translation_Start_Site\",\n                                 \"Nonsense_Mutation\",\n                                 \"Nonstop_Mutation\",\n                                 \"In_Frame_Del\",\n                                 \"In_Frame_Ins\",\n                                 \"Missense_Mutation\"))\n# 匹配样本注释信息\n# Match sample annotation\nmafAnno <- mafsam[which(mafsam$simple_barcode %in% panmaf@data$Tumor_Sample_Barcode),]\ncolnames(mafAnno)[1:2] <- c(\"Cancer\",\"Tumor_Sample_Barcode\")\n\n# 设置突变颜色\n# Set mutation colors\nmutcol <- brewer.pal(n = 10, name = 'Paired')\nnames(mutcol) <- c('Frame_Shift_Del','Missense_Mutation', 'Nonsense_Mutation', 'Frame_Shift_Ins','In_Frame_Ins', 'Splice_Site', 'In_Frame_Del','Nonstop_Mutation','Translation_Start_Site','Multi_Hit')\n\n# 设置癌症类型颜色\n# Set cancer type colors\ncancercolors <- NMF:::ccRamp(brewer.pal(n = 12,name = 'Paired'), length(unique(mafAnno$Cancer)))\nnames(cancercolors) <- unique(mafAnno$Cancer)\n\n# 创建注释颜色列表\n# Create annotation color list\nannocolors = list(Cancer = cancercolors)\n\n# 生成oncoprint图\n# Generate oncoprint plot\npdf(file = \"oncoprint.pdf\", width = 10, height = 5)\noncoplot(maf = panmaf, \n         colors = mutcol, \n         minMut = 0.05 * nrow(mafAnno), \n         bgCol = \"grey95\", \n         borderCol = NA, \n         annotationDat = mafAnno, \n         annotationColor = annocolors,\n         clinicalFeatures = \"Cancer\", \n         sortByAnnotation = T) \ninvisible(dev.off())\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa276panSNV_FigureYa276panSNV",
      "title": "FigureYa276panSNV/FigureYa276panSNV.html",
      "html": "FigureYa276panSNV/FigureYa276panSNV.html",
      "text": "texts/main_FigureYa276panSNV_FigureYa276panSNV.txt",
      "folder": "FigureYa276panSNV",
      "thumb": "gallery_compress/FigureYa276panSNV.webp"
    },
    "word_count": 1283,
    "lines_count": 350,
    "title": "FigureYa276panSNV",
    "description": "Demand description 我们希望复现pancancer SNV We desired to reproduce pan-cancer SNV analysis",
    "input_data_types": [
      "临床数据",
      "突变数据"
    ],
    "output_types": [
      "热图",
      "统计表格"
    ],
    "technical_methods": [
      "通路分析",
      "质量控制"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "ticks",
      "bgCol",
      "annotationDat",
      "header",
      "vc_nonSyn",
      "width",
      "grid",
      "n"
    ]
  },
  {
    "id": "main_FigureYa302NTPPAM_FigureYa302NTPPAM",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa302NTPPAM_FigureYa302NTPPAM.txt",
    "content": "FigureYa302NTPPAM\nFigureYa302NTPPAM\nAuthor(s)\n: Xiaofan Lu; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-05-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nDemand description\n我想实现个找出分子亚型中的特异marker并用NTP预测外部数据亚型的，分别是这两篇文章中的方法，作者是同一个人。\nI want to identify specific markers in molecular subtypes and use NTP\nto predict the subtypes of external data, following the methods\ndescribed in these two papers, which are authored by the same\nperson.\n出自：\nhttps://www.nature.com/articles/ncomms15107\nSource:\nhttps://www.nature.com/articles/ncomms15107\n出自：\nhttps://www.nature.com/articles/ng.3224\n就是从表达谱数据已知样本分型情况下，找出每个亚型特异的marker，再用NTP预测亚型，其中的PAM过程不懂。\n这篇文章也是差不多的方法，方法写在文章附件里：\nSource:\nhttps://www.nature.com/articles/ng.3224\nIt involves identifying subtype-specific markers from expression\nprofile data with known sample classifications, then using NTP (Nearest\nTemplate Prediction) to predict subtypes—though I don’t fully understand\nthe PAM (Prediction Analysis of Microarrays) step.\nThis paper uses a similar approach, with the methods detailed in the\nsupplementary materials:\n出自：\nhttps://www.nature.com/articles/nm.3175\nMOVICS包其实有NTP预测亚型的，但是他是直接选亚型特异表达的靠前的基因，没有用PAM这些筛选方法。这里将实现用PAM筛选。\nSource:\nhttps://www.nature.com/articles/nm.3175\nThe MOVICS package actually includes NTP-based subtype prediction,\nbut it directly selects the top differentially expressed genes (DEGs)\nfor each subtype without using filtering methods like PAM. Here, we will\nimplement PAM-based gene selection.\n应用场景\nApplication scenarios\n利用PAM算法根据某感兴趣分类筛选特异性marker，生成模版后利用NTP算法进行分类预测。\n问题挺好的，用模型的方式找marker再预测，而不是直接定义前多少位高表达或低表达来构建marker。\n参考资料见Literatures文件夹。\nUsing the PAM algorithm to screen for specific markers based on a\nclassification of interest, then generating a template for NTP-based\nclassification prediction.\nThis is a solid approach—using a model-based method to identify\nmarkers before prediction, rather than simply defining markers based on\nthe top/bottom differentially expressed genes.\nReferences available in the “Literatures” folder.\n环境设置\nEnvironment Setup\n使用国内镜像安装包。\nUsing domestic mirrors for package installation.\nsource(\"install_dependencies.R\")\nsource(\"CMScaller.R\") # From CMScaller package, https://github.com/peterawe/CMScaller\nsource(\"replaceGeneId.R\") # From CMScaller package, https://github.com/peterawe/CMScaller\nlibrary(CMScaller)\nlibrary(pamr)\nlibrary(cluster)\n\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n输入文件\nInput Files\ngse17536.expr.txt - GEO结直肠癌表达谱文件。/ A GEO colorectal cancer\nexpression profile file.\n# 读取GEO结直肠癌表达谱文件\n# Read GEO colorectal cancer expression profile file\nexpr <- read.delim(file = \"gse17536.expr.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\n\n# 对行名进行标准化，重复基因取均值\n# Standardize row names - take mean for duplicate genes\nexpr$gene <- sapply(strsplit(rownames(expr),\" /// \"), \"[\",1)\nexpr <- apply(expr[,setdiff(colnames(expr), \"gene\")], 2, function(x) tapply(x, INDEX=factor(expr$gene), FUN=mean, na.rm=TRUE))\nexpr <- as.data.frame(expr)\n利用PAM算法筛选特异性marker\nUsing PAM algorithm to identify specific markers\n# 先使用CMScaller算法内置的模版来确定该结直肠癌的分型（默认为金标准）\n# First use the built-in template from CMScaller algorithm to determine colorectal cancer subtypes (default as gold standard)\ncms.true <- CMScaller(\n  emat = t(scale(t(expr), center = T, scale = T)), \n  templates = CMScaller::templates.CMS, \n  rowNames = \"symbol\", \n  RNAseq = FALSE, \n  nPerm = 1000, \n  seed = 123456, \n  FDR = 1, \n  doPlot = TRUE,\n  verbose = TRUE\n)\ncms.df <- data.frame(samID = colnames(expr),\n                     CMS.true = as.character(cms.true$prediction),\n                     row.names = colnames(expr))\n\n# 构建PAM算法所需要的输入\n# Prepare input data structure for PAM algorithm\nmydata <- list(x = as.matrix(expr),     \n               y = cms.df$CMS,          \n               geneid = rownames(expr)) \n\n# 生成pam score\n# Generate pam scores\n\n# 训练模型\n# Train model\npam.res <- pamr.train(mydata)\n# 交叉验证选择最优阈值\n# Cross-validation to select optimal threshold\npam.res.cv <- pamr.cv(fit = pam.res, data = mydata)\n# 计算各特征的pam score\n# Calculate pam scores for features\npam.score <- pamr.listgenes(fit = pam.res, data = mydata,  \n                            threshold = pam.res.cv$threshold[which.min(pam.res.cv$error)])\n# 保存到文件\n# Save results to file\nwrite.table(pam.score, \"output_pam.score.txt\", row.names = F, sep = \"\\t\", quote = F)\n利用NTP算法进行分类预测\nPerforming classification prediction using NTP algorithm\n自定义函数以读取pam矩阵，生成NTP模板。\nCustom function to process PAM matrix and generate NTP template.\nFilterPAM <- function(pam.df, probeCol = \"id\"){ \n  # pam.df：pamr生成的pam数据框,应当只保留特征名列和各类的pam得分\n  # probeCol：pam.df中表征特征名称的列\n  # pam.df: PAM-generated dataframe containing only feature names and PAM scores for each class\n  # probeCol: Column name in pam.df representing feature identifiers\n  pamCol <- match(setdiff(colnames(pam.df), probeCol), colnames(pam.df)) \n  \n  # 基因的筛选标准\n  # Gene filtering criteria\n  keepGene <- apply(pam.df[, pamCol], 1, function(x){  \n    x = sort(x, decreasing = T)\n    \n    # 保留只在一个类里pam得分为正的特征\n    # Keep features with positive PAM score in only one class\n    if (sum(x>0) == 1) return(T)\n    \n    # 保留即使有在多个类别里pam得分为正，但是最大值比第二大的值多超过0.1的特征\n    # Keep features where maximum score exceeds second highest by >0.1\n    else if (sum(x>0) > 1 & (x[1]-x[2])>0.1) return(T)    \n    \n    # 除此之外剔除\n    # Otherwise discard\n    else return(F)                                       \n  })\n  message(sum(keepGene), \" genes are identified as predictors\")\n  \n  # 剔除不保留的特征\n  # Remove filtered-out features\n  pam.df <- pam.df[keepGene, ]      \n  \n  # 重整为基因-特征-pam得分列表\n  # Reshape to gene-feature-score format\n  pam.df <- reshape2::melt(pam.df, id.vars = probeCol)   \n  \n  pam.df <- dplyr::arrange(pam.df, -pam.df$value)\n  \n  # 保留各基因pam得分最高的类别\n  # Retain highest-scoring class per gene\n  pam.df <- pam.df[!duplicated(pam.df[[probeCol[1]]]), -ncol(pam.df)] \n  \n  colnames(pam.df) <- c(\"probe\", \"class\")\n  return(pam.df)\n}\n使用FilterPAM函数将pam score转化为NTP模板\nConvert PAM scores to NTP templates using FilterPAM function\n# 读取pam.score（不读取可能导致数据存在双引号，运行函数会报错）\n# Read PAM scores (must read with header=T to avoid quotation mark issues that may cause function errors)\npam.score <- read.table(\"output_pam.score.txt\", sep = \"\\t\", header = T) \n\n# 将pam score转化为NTP模板\n# Transform PAM scores into NTP templates\ntemplates <- FilterPAM(pam.df = pam.score, probeCol = c(\"id\"))\ntable(templates$class)\n应用此时构建的模版，再次利用NTP进行预测\nApply the constructed template to perform NTP prediction again\n# emat的行名，应当与模板的probe列为同一类型\n# Row names of emat should match the probe column in templates\ncms.pred <- ntp(emat = t(scale(t(expr), center = T, scale = T)), \n                templates = templates, \n                nPerm = 1000,\n                seed = 123456,\n                doPlot = TRUE,\n                verbose = TRUE\n)\ndev.copy2pdf(file = \"ntpheatmap using pam selected template.pdf\", width = 5,height = 5)\ncms.df$CMS.pred <- as.character(cms.pred$prediction)\n\n # 基因完美预测\n# Perfect gene prediction\ntable(cms.df$CMS.true, cms.df$CMS.pred)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa302NTPPAM_FigureYa302NTPPAM",
      "title": "FigureYa302NTPPAM/FigureYa302NTPPAM.html",
      "html": "FigureYa302NTPPAM/FigureYa302NTPPAM.html",
      "text": "texts/main_FigureYa302NTPPAM_FigureYa302NTPPAM.txt",
      "folder": "FigureYa302NTPPAM",
      "thumb": "gallery_compress/FigureYa302NTPPAM.webp"
    },
    "word_count": 838,
    "lines_count": 207,
    "title": "FigureYa302NTPPAM",
    "description": "Demand description 我想实现个找出分子亚型中的特异marker并用NTP预测外部数据亚型的，分别是这两篇文章中的方法，作者是同一个人。 I want to identify specific markers in molecular subtypes and use NTP",
    "input_data_types": [
      "临床数据"
    ],
    "output_types": [
      "热图",
      "统计表格"
    ],
    "technical_methods": [
      "标准化"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "probeCol",
      "seed",
      "RNAseq",
      "header",
      "center",
      "width",
      "df",
      "samID",
      "nPerm"
    ]
  },
  {
    "id": "main_FigureYa246supervisedGDSC_FigureYa246supervisedGDSC",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa246supervisedGDSC_FigureYa246supervisedGDSC.txt",
    "content": "FigureYa246supervisedGDSC\nFigureYa246supervisedGDSC\nXiaofan Lu\n2025-5-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n想实现图5A B,\n首先对TCGA数据集进行聚类分析，之后将GDSC细胞系按照TCGA聚类结果进行分组，分组后比较分组的药物敏感性，用AUC定量分析。\nTo crowdsource Figure 5A and B: first perform clustering on the TCGA\ndataset; then group GDSC cell lines according to the TCGA clustering\nresults; after grouping, compare drug sensitivity between groups using\nAUC for quantitative analysis.\n出自\nhttps://www.mdpi.com/2072-6694/13/9/2128\nFrom\nhttps://www.mdpi.com/2072-6694/13/9/2128\nFigure 5. Drug discovery and immune characterization in essential\ngene-classified clusters of lung adenocarcinoma (LUAD). (A) Heatmap\nshowing essential gene-stratified-clusters exhibiting distinct\nexpressions in GDSC lung cancer cells. (B) Drug response area under the\nreceiver operator characteristics curve (AUC) of SN-38 and talazoparib\nwithin essential geneclassified clusters demonstrated as a boxplot.\nTo identify\ndrugs\nthat exhibited distinct\nefficacy in essential gene-classified clusters\n, the\nprediction model was applied to the GDSC database (Figure 5A). Areas\nunder the receiver operator characteristics curve (AUC) of drug\nresponses within clusters were compared. Totally, the GDSC database\ncontains 367 compounds. Only 257 compounds which were tested on more\nthan 75% of the LUAD cell lines were used for analyses (Tables S8 and\nS9). AUCs of\nSN-38, a topoisomerase I inhibitor, and\ntalazoparib, a poly(ADP ribose) polymerase (PARP) inhibitor, were\nsignificantly lower in cluster 1 LUAD cells\n(Figure 5B). This\nsuggested that cluster 1 tumors with highly proliferative signatures\nwere vulnerable to drugs targeting DNA-replication mechanisms.\n应用场景\n跟FigureYa240CRISPR是同一篇文章，FigureYa240CRISPR用CRISPR\nscreening数据库找到肺癌细胞存活必需的31个基因，推演到TCGA数据库，发现这些基因在TCGA癌症vs正常时的确差异显著。\nThis is the same paper as FigureYa240CRISPR. FigureYa240CRISPR used a\nCRISPR screening database to find 31 genes essential for lung cancer\ncell survival, extrapolated to the TCGA database, and found these genes\nwere indeed significantly different between TCGA cancer vs. normal.\n这又有什么意义呢？能指导临床吗？ What’s the significance? Can it\nguide clinical practice?\n这次从TCGA表达谱分出的亚型推演到GDSC数据库里的细胞系，由此推出各亚型的药物敏感性。\nThis time, subtypes derived from the TCGA expression profile are\nextrapolated to GDSC cell lines, thereby inferring drug sensitivity for\neach subtype.\n环境设置\nsource(\"install_dependencies.R\")\nlibrary(pheatmap)\nlibrary(data.table)\nlibrary(ConsensusClusterPlus)\nlibrary(ComplexHeatmap)\nlibrary(lolR)\nlibrary(impute)\nlibrary(ggplot2)\nlibrary(ggpubr)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息\noptions(stringsAsFactors = FALSE) #禁止chr转成factor\n自定义函数 Custom function\nstandarize.fun <- function(indata=NULL, halfwidth=NULL, centerFlag=T, scaleFlag=T) {\n  outdata=t(scale(t(indata), center=centerFlag, scale=scaleFlag))\n  if (!is.null(halfwidth)) {\n    outdata[outdata>halfwidth]=halfwidth\n    outdata[outdata<(-halfwidth)]= -halfwidth\n  }\n  return(outdata)\n}\n输入文件\nTCGA-LUAD.htseq_fpkm.tsv.gz，TCGA-LUAD的表达谱数据以及基因注释，源于\nhttps://xenabrowser.net/datapages/?dataset=TCGA-LUAD.htseq_fpkm.tsv&host=https%3A%2F%2Fgdc.xenahubs.net&removeHub=https%3A%2F%2Fxena.treehouse.gi.ucsc.edu%3A443\n细胞系数据下载自DepMap，\nhttps://depmap.org/portal/download/\n： Cell line data\ndownloaded from DepMap:\nCCLE_RNAseq_rsem_genes_tpm_20180929.txt.gz，细胞系表达谱数据，源于\nhttps://depmap.org/portal/download/api/download?file_name=ccle%2Fccle_2019%2FCCLE_RNAseq_rsem_genes_tpm_20180929.txt.gz&bucket=depmap-external-downloads\nCell_lines_annotations_20181226.txt，细胞系信息数据，源自\nhttps://depmap.org/portal/download/api/download?file_name=ccle%2Fccle_2019%2FCell_lines_annotations_20181226.txt&bucket=depmap-external-downloads\nsanger-dose-response.csv，GDSC细胞系药物敏感性数据源自\nhttps://depmap.org/portal/download/api/download?file_name=processed_portal_downloads%2Fgdsc-drug-set-export-658c.5%2Fsanger-dose-response.csv&bucket=depmap-external-downloads\n# 加载TCGA-LUAD数据并处理\n# Load and process TCGA-LUAD data\nluad.expr <- fread(\"TCGA-LUAD.htseq_fpkm.tsv.gz\",sep = \"\\t\",check.names = F,stringsAsFactors = F,header = T,data.table = F)\nrownames(luad.expr) <- luad.expr$Ensembl_ID; \nluad.expr <- luad.expr[,setdiff(colnames(luad.expr),\"Ensembl_ID\")]\nGinfo <- read.delim(\"gencode.v22.annotation.gene.probeMap\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\n\ncomgene <- intersect(rownames(luad.expr),rownames(Ginfo)) # 取出表达谱和基因注释的相同基因\n# Intersect genes between expression and gene annotation\nluad.expr <- luad.expr[comgene,]\nGinfo <- Ginfo[comgene,]\nluad.expr$gene <- Ginfo$gene\nluad.expr <- luad.expr[!duplicated(luad.expr$gene),]; rownames(luad.expr) <- luad.expr$gene; luad.expr <- luad.expr[,setdiff(colnames(luad.expr),\"gene\")] # 去重\n# Remove duplicates by gene symbol\n\ntumsam <- colnames(luad.expr)[substr(colnames(luad.expr),14,16) == \"01A\"] # 提取TCGA-LUAD的肿瘤样本\n# Extract TCGA-LUAD tumor samples\nTCGA数据分型 - 无监督共识聚类 TCGA Data Typing - Unsupervised\nConsensus Clustering\n使用原文定义的36个essential\ngenes（筛选基因的方法可参考FigureYa240CRISPR），为TCGA的patient进行无监督共识聚类（consensus\nclustering），这里分成3个亚型，然后画个热图看效果。 Using the 36\nessential genes defined in the original paper (see FigureYa240CRISPR for\nthe selection method), perform unsupervised consensus clustering on TCGA\npatients into 3 subtypes, then plot a heatmap to visualize.\n# 设置颜色 | set colors\nred <- \"#E53837\"\nblue <- \"#6AADF0\"\nyellow <- \"#F7A400\"\nheatmap.BLYW <- c(\"#3F047D\",\"white\",\"#B05900\")\n\ngenes <- c(\"NUF2\",\"GINS1\",\"TOP2A\",\"CDC6\",\"NDC80\",\"RRM2\",\n           \"CCNA2\",\"KIF11\",\"PRC1\",\"BUB1B\",\"CDCA8\",\"TPX2\",\n           \"PLK1\",\"CDC45\",\"CDC20\",\"BIRC5\",\"ECT2\",\"PCNA\",\n           \"CHAF1B\",\"TIMELESS\",\"GINS2\",\"ORC6\",\"CDT1\",\"MCM2\",\n           \"MCM4\",\"RCC1\",\"BOP1\",\"ALDOA\",\"PSMG3\",\"DKC1\",\n           \"HSPD1\",\"BYSL\",\"RPP40\",\"SNRPE\",\"HSPE1\",\"CCT3\")\n\nindata <- luad.expr[genes,tumsam]\ncc <- ConsensusClusterPlus(d = as.matrix(indata),\n                           maxK = 3, # 最大3类 | maximum K=3\n                           reps = 1000, # 1000次扰动 | 1000 permutations\n                           pItem = 0.95, # 每次对基因进行95%重抽样 | 95% resampling of genes each iteration\n                           clusterAlg = \"pam\", # 采用PAM算法 | use PAM\n                           seed = 19991018,\n                           title = \".\",\n                           plot = \"pdf\")\ngroup <- paste0(\"Cluster\",cc[[3]]$consensusClass); names(group) <- tumsam # 取出三个亚型的结果 | retrieve 3-cluster labels\ngroup <- sort(group) # 按照类排序 | sort by cluster\n画个热图看分型效果 Draw a heatmap to inspect subtype separation\nplotdata <- standarize.fun(indata[,names(group)],halfwidth = 2) # 绘图数据标准化（z-score并将绝对值超过2的数值截断） | z-score and cap at |2|\n\nannCol.tcga <- data.frame(Cluster = as.character(group), # 构建样本注释 | build sample annotation\n                          row.names = names(group),\n                          stringsAsFactors = F)\nannColors <- list(\"Cluster\" = c(\"Cluster1\" = red,\"Cluster2\" = yellow,\"Cluster3\" = blue)) # 构建颜色注释 | annotation colors\n\n# 绘制热图 | draw heatmap\npheatmap(plotdata,\n         color = NMF:::ccRamp(x = heatmap.BLYW,n=64) , # 原文颜色模版 | color scheme as in paper\n         annotation_col = annCol.tcga[colnames(plotdata),,drop = F],\n         annotation_colors = annColors,\n         cluster_cols = FALSE, # 样本不聚类，按照亚型顺序排列 | keep TCGA columns ordered by subtype\n         cluster_rows = TRUE, # 行聚类 | cluster rows\n         border_color = NA,\n         treeheight_row = 20, # 修改行树高 | row dendrogram height\n         cellheight = 10, # 修改每个单元的高度 | cell height\n         cellwidth = 0.6, # 修改每个单元的宽度 | cell width\n         show_rownames = TRUE, # 显示行名 | show rownames\n         show_colnames = FALSE, # 不显示列名 | hide colnames\n         filename = \"heatmap of essential genes in tcga luad.pdf\")\n细胞系数据处理 Cell Line Data Processing\n筛选出同时具有药敏数据和表达数据的LUAD细胞系 Select LUAD cell lines that\nhave both drug sensitivity and expression data\nrownames(gdsc.auc) <- gdsc.auc$ARXSPAN_ID; gdsc.auc <- gdsc.auc[,-1]\ncolnames(gdsc.auc) <- gsub(\"AUC_PUBLISHED.\",\"\",colnames(gdsc.auc),fixed = T) # 生成行为细胞系，列为药物，入值为AUC的矩阵 | matrix rows=cell lines, cols=drugs\n\ncomdep <- intersect(rownames(gdsc.auc),ccle.anno$depMapID) # 取出有药敏并且为LUAD的细胞系 | LUAD lines with drug data\ngdsc.auc <- gdsc.auc[comdep,]\nrmdrug <- colnames(gdsc.auc)[apply(gdsc.auc,2, function(x) {sum(is.na(x)) > 0.10 * length(comdep)})] # 获得要去除的药物（去除药敏在大于10%的样本中药物（原文是25%）） | remove drugs missing in >10% lines (paper used 25%)\ngdsc.auc <- gdsc.auc[,setdiff(colnames(gdsc.auc),rmdrug)]  # 去掉这些药物 | drop these drugs\ngdsc.auc <- as.data.frame(impute.knn(t(gdsc.auc))$data) # 对剩余空值进行KNN填补 | KNN-impute remaining missing\n\nindex <- match(colnames(gdsc.auc),ccle.anno$depMapID) # 将DepmapID和细胞系名称匹配 | match DepMap IDs to line names\ncolnames(gdsc.auc) <- rownames(ccle.anno)[index] # 替换DepmapID | replace with line names\n\n## 读取细胞系表达谱 | read cell line expression\nccle.expr <- fread(\"CCLE_RNAseq_rsem_genes_tpm_20180929.txt.gz\",sep = \"\\t\",check.names = F,stringsAsFactors = F,header = T,data.table = F)\nrownames(ccle.expr) <- ccle.expr$gene_id\nccle.expr <- ccle.expr[,-c(1:2)]; rownames(ccle.expr) <- sapply(strsplit(rownames(ccle.expr),\".\",fixed = T),\"[\",1) # ENSEMBL ID的匹配 | harmonize Ensembl IDs\nGinfo2 <- Ginfo; rownames(Ginfo2) <- sapply(strsplit(rownames(Ginfo2),\".\",fixed = T), \"[\",1)\ncomgene <- intersect(rownames(ccle.expr),rownames(Ginfo2))\nccle.expr <- ccle.expr[comgene,]\nGinfo2 <- Ginfo2[comgene,]\nccle.expr$gene <- Ginfo2$gene\nccle.expr <- ccle.expr[!duplicated(ccle.expr$gene),]; rownames(ccle.expr) <- ccle.expr$gene; ccle.expr <- ccle.expr[,setdiff(colnames(ccle.expr),\"gene\")] # 去重 | remove duplicates by gene symbol\n\n## 筛选同时具有药敏和表达的LUAD细胞系 | select LUAD lines with both drug and expression\ncomccle <- intersect(intersect(rownames(ccle.anno),colnames(ccle.expr)),colnames(gdsc.auc)) # 筛选同时具有表达和药敏的LUAD细胞系 | intersection across meta/expression/drug\ncomgene <- intersect(genes,rownames(ccle.expr))\nccle.expr <- log2(ccle.expr[comgene,comccle] + 1) # 表达谱取对数 | log2-transform expression\nccle.anno <- ccle.anno[comccle,]\n构建nearest centroid classifier，给细胞系分型\nBuild nearest centroid classifier and assign cell line subtypes\n构建nearest centroid\nclassifier，然后用classifier预测GDSC细胞系数据，让细胞系按照TCGA分型结果分成对应的三组。\n构建nearest centroid\nclassifier，然后用classifier预测GDSC细胞系数据，让细胞系按照TCGA分型结果分成对应的三组。\nBuild a nearest centroid classifier from TCGA and use it to predict GDSC\ncell lines, assigning them to the three TCGA-derived groups.\n# 中位数中心化\n#indata <- sweep(luad.expr[comgene,names(group)], 1, apply(luad.expr[comgene,names(group)], 1, median))\n# 中位数中心化 | median-centering\n#indata <- sweep(luad.expr[comgene,names(group)], 1, apply(luad.expr[comgene,names(group)], 1, median))\n原文采用中心化来构建预测模型，但是我这里的结果不是很好，所以换用z-score标准化的结果。\nThe original paper used centering to build the classifier; results here\nwere suboptimal, so z-score standardization was used instead.\nindata <- t(scale(t(luad.expr[comgene,names(group)]))) #z-score标准化 | z-score standardization\n\n# 构建nearest centroid classifier | build nearest centroid classifier\nclassifier <- lol.classify.nearestCentroid(t(indata), as.numeric(factor(group))) \n\n#testdata <- sweep(ccle.expr[comgene,], 1, apply(ccle.expr[comgene,], 1, median))\ntestdata <- t(scale(t(ccle.expr))) # z-score标准化测试集 | z-score the test set\n\n# 在细胞系应用classifier | apply classifier to cell lines\nccle.group <- paste0(\"Cluster\",predict(classifier, t(testdata))); names(ccle.group) <- colnames(testdata) \nccle.group <- sort(ccle.group) # 将预测的亚型排序 | sort predicted labels\n画个热图看效果 Draw a heatmap to inspect the assignment\nplotdata <- standarize.fun(ccle.expr[,names(ccle.group)],halfwidth = 2) # 绘图数据标准化 | standardize for plotting\n\nannCol.ccle <- data.frame(Cluster = as.character(ccle.group), # 构建细胞系的样本注释 | build cell line annotations\n                          row.names = names(ccle.group),\n                          stringsAsFactors = F)\npheatmap(plotdata,\n         color = NMF:::ccRamp(x = heatmap.BLYW,n=64),\n         annotation_col = annCol.ccle[colnames(plotdata),,drop = F],\n         annotation_colors = annColors,\n         cluster_cols = FALSE,\n         cluster_rows = TRUE,\n         border_color = NA,\n         treeheight_row = 20,\n         cellheight = 10,\n         cellwidth = 10,\n         show_rownames = TRUE,\n         show_colnames = FALSE,\n         filename = \"heatmap of essential genes in ccle luad.pdf\")\n药物敏感性的Kruskal检验 Kruskal-Wallis test for drug\nsensitivity\n计算GDSC细胞系各亚型对每种药物的敏感性，输出统计结果并画图。 Compute\nsensitivity per subtype for each drug, output stats, and plot.\n由GDSC细胞系各亚型的敏感性结果可以反推出TCGA各亚型对药物对敏感性。\nSensitivity patterns in GDSC-assigned subtypes can be extrapolated back\nto TCGA subtypes.\noutTab <- NULL\nfor(drug in rownames(gdsc.auc)) {\n  tmp <- data.frame(auc = as.numeric(gdsc.auc[drug,names(ccle.group)]),\n                    group = as.character(ccle.group))\n  avg <- with(tmp, tapply(auc, group, mean)) # 得到各亚型的AUC均值 | mean AUC per subtype\n  kt <- kruskal.test(auc~group, data = tmp) # kruskal检验 | Kruskal-Wallis test\n  outTab <- rbind.data.frame(outTab,\n                             data.frame(drug = drug,\n                                        avg1 = avg[1],\n                                        avg2 = avg[2],\n                                        avg3 = avg[3],\n                                        pvalue = kt$p.value,\n                                        stringsAsFactors = F),\n                             stringsAsFactors = F)\n\n  if(kt$p.value < 0.05) {\n    message(drug,\" pass statistical significance...\")\n\n    # 将通过显著性检验的药物绘制箱型图 | plot boxplot for significant drugs\n    p <- ggplot(tmp, aes(group, auc, fill=group)) +\n      geom_boxplot(outlier.shape = NA) +\n      geom_point(shape = 21, size=2,\n                 position = position_jitterdodge(),\n                 aes(color=group), alpha = 0.6) +\n      scale_fill_manual(values = c(red,yellow,blue)) +\n      scale_color_manual(values = c(red,yellow,blue)) +\n      xlab(NULL) + ylab(paste0(\"AUC of \", drug)) +\n      theme_bw() +\n      theme(axis.text.x = element_blank(),\n            axis.text.y = element_text(size = 10, color = \"black\"),\n            axis.ticks.x = element_blank(),\n            panel.background = element_blank(),\n            panel.grid = element_blank(),\n            legend.position = \"right\",\n            legend.title = element_blank()) +\n      stat_compare_means(method = \"kruskal.test\", \n                         label.y = 0.98) # 根据自己的数据调整文字所在的位置，或者用AI等矢量图软件打开PDF文件，调整文字位置 | adjust label position as needed or later in a vector editor\n    ggsave(filename = paste0(\"boxplot of estimated auc in \",drug,\".pdf\"), \n           width = 4,height = 3.5)\n  }\n}\ndrugs <- outTab[outTab$pvalue < 0.05, \"drug\"]\n\nwrite.table(outTab, file = \"output_kruskal test of estimated auc among cell lines.txt\",sep = \"\\t\",row.names = F,col.names = T,quote = F)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa246supervisedGDSC_FigureYa246supervisedGDSC",
      "title": "FigureYa246supervisedGDSC/FigureYa246supervisedGDSC.html",
      "html": "FigureYa246supervisedGDSC/FigureYa246supervisedGDSC.html",
      "text": "texts/main_FigureYa246supervisedGDSC_FigureYa246supervisedGDSC.txt",
      "folder": "FigureYa246supervisedGDSC",
      "thumb": "gallery_compress/FigureYa246supervisedGDSC.webp"
    },
    "word_count": 1462,
    "lines_count": 292,
    "title": "FigureYa246supervisedGDSC",
    "description": "想实现图5A B, 首先对TCGA数据集进行聚类分析，之后将GDSC细胞系按照TCGA聚类结果进行分组，分组后比较分组的药物敏感性，用AUC定量分析。 To crowdsource Figure 5A and B: first perform clustering on the TCGA",
    "input_data_types": [
      "临床数据",
      "突变数据",
      "生存数据"
    ],
    "output_types": [
      "热图",
      "统计表格",
      "箱线图",
      "生存曲线"
    ],
    "technical_methods": [
      "聚类分析",
      "标准化"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学",
      "药物研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "bucket",
      "clusterAlg",
      "drug",
      "seed",
      "values",
      "annotation_col",
      "center",
      "header",
      "avg2"
    ]
  },
  {
    "id": "main_FigureYa152DouleCorPlot_FigureYa152DouleCorPlot",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa152DouleCorPlot_FigureYa152DouleCorPlot.txt",
    "content": "FigureYa152DouleCorPlot\nFigureYa152DouleCorPlot\nAuthor(s)\n: Hao Li\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\nLoading the package\nlibrary(ComplexHeatmap)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 #Display English error messages\noptions(stringsAsFactors = FALSE) #禁止chr转成factor #Disable conversion of chr to factor\n输入文件的获得\nObtaining the Input File\n如果你的数据已经整理成easy_input*P.csv和easy_input*R.csv的格式，就可以跳过这步，直接进入“输入文件”\nIf your data has already been organized into easy_input*P.csv and\neasy_input*R.csv formats, you can skip this step and proceed directly to\n“Input Files.”\n相关性分析\nCorrelation Analysis\n这里借用FigureYa71ssGSEA输出的ssGSEA_output.csv，用来展示相关系数和p\nvalue的计算方法，生成所需的easy_input*P.csv和easy_input*R.csv。 Here, we\nuse the ssGSEA_output.csv file (Figure Ya71) to demonstrate how to\ncalculate the correlation coefficient and p-value, and to generate the\nrequired easy_input*P.csv and easy_input*R.csv files.\nssGSEA_output.csv，免疫细胞矩阵，列是免疫细胞，行是样本。可以换成其他类型的数据，例如基因表达矩阵。\nssGSEA_output.csv is an immune cell matrix, with immune cells as\ncolumns and samples as rows. This can be replaced with other data types,\nsuch as a gene expression matrix.\ntcga_gsva <- read.csv(\"ssGSEA_output.csv\", row.names = 1, check.names = F)\ntcga_gsva[1:3,1:3]\n#这里将计算每列之间的相关性\n# This will calculate the correlation between each column.\n#如果要计算行之间的相关性就运行下面这行转置（把行变成列，列变成行）\n# To calculate the correlation between rows, run the following transposition line (convert rows to columns and columns to rows).\n# tcga_gsva <- t(tcga_gsva)\n\n# 计算相关系数\n# Calculate the correlation coefficient\ncor_r <- cor(tcga_gsva)\ncor_r[1:3,1:3]\nwrite.csv(cor_r, \"easy_input_R.csv\", quote = F)\n\n# 计算p value\n# Calculate the p value\ncor_p <- matrix(0, nrow = ncol(tcga_gsva), ncol = ncol(tcga_gsva))\nrownames(cor_p) <- colnames(tcga_gsva)\ncolnames(cor_p) <- colnames(tcga_gsva)\nfor (i in 1:ncol(tcga_gsva)){\n  for (j in 1:ncol(tcga_gsva)){\n      p <- cor.test(tcga_gsva[,i],tcga_gsva[,j])\n      cor_p[i,j] <- p$p.value\n  }\n}\nwrite.csv(cor_p, \"easy_input_P.csv\", quote = F)\n两组数据都按照这个方式运行，分别算出两组相关系数和pvalue，作为输入文件。\nBoth sets of data are run in this manner, and two sets of correlation\ncoefficients and pvalues are calculated as input files.\n输入文件\nInput File\n这里我们直接用TCGA当中\nKICH\n以及\nKIRC\n内的免疫细胞之间相关分析的结果来进行绘图展示。\nHere, we directly use the results of the correlation analysis between\nimmune cells in\nKICH\nand\nKIRC\nfrom\nTCGA to plot and display.\n输入文件分别是两个癌症的相关系数\neasy_input*_R.csv\n和P值\neasy_input*_P.csv\n。\nThe input files are\neasy_input*_R.csv\nand\neasy_input*_P.csv\n, respectively, for the correlation\ncoefficients of the two cancer types.\nKICHR <- read.csv(\"easy_input1_R.csv\", row.names = 1)\nKICHR[1:3,1:3]\nKICHP <- read.csv(\"easy_input1_P.csv\", row.names = 1)\nKICHP[1:3,1:3]\nKIRCR <- read.csv(\"easy_input2_R.csv\", row.names = 1)\nKIRCP <- read.csv(\"easy_input2_P.csv\", row.names = 1)\n合并数据\nMerging Data\n由于要做对两个数据集进行一起做图，所以需要把两个数据集整合到一起。由于两个数据集都是经过相关算法计算的结果，所以变量顺序也一样，所以我们就不检查其顺序是否一样。如果是自己的数据记得使用\nidentical\n检查一下列名和行名的顺序是否一样。\nSince we want to plot two datasets together, we need to merge them.\nSince both datasets are calculated using the correlation algorithm, the\nvariable order is the same, so we won’t check whether the order is the\nsame. If you’re using your own data, remember to use\nidentical\nto check that the order of the column and row\nnames is the same.\n这里在相关图里面的右上半部分来展示\nKICH\n的相关系数，左下半部分来展示\nKIRC\n的相关系数。\nThe top right half of the correlation plot shows the\nKICH\ncorrelation coefficient, and the bottom left half\nshows the\nKIRC\ncorrelation coefficient.\n# P>= 0.05时，把相关系数设为NA\ndatR[datP > 0.05] <- NA\n开始画图\nStart plotting\n用\nComplexHeatmap\n画图 Plot using\nComplexHeatmap\np1\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa152DouleCorPlot_FigureYa152DouleCorPlot",
      "title": "FigureYa152DouleCorPlot/FigureYa152DouleCorPlot.html",
      "html": "FigureYa152DouleCorPlot/FigureYa152DouleCorPlot.html",
      "text": "texts/main_FigureYa152DouleCorPlot_FigureYa152DouleCorPlot.txt",
      "folder": "FigureYa152DouleCorPlot",
      "thumb": "gallery_compress/FigureYa152DouleCorPlot.webp"
    },
    "word_count": 491,
    "lines_count": 129,
    "title": "FigureYa152DouleCorPlot",
    "description": "Correlation Analysis 这里借用FigureYa71ssGSEA输出的ssGSEA_output.csv，用来展示相关系数和p value的计算方法，生成所需的easy_input*P.csv和easy_input*R.csv。 Here, we",
    "input_data_types": [
      "临床数据",
      "表达矩阵"
    ],
    "output_types": [
      "散点图",
      "热图"
    ],
    "technical_methods": [],
    "biology_areas": [
      "癌症研究",
      "免疫学"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "LANGUAGE",
      "quote",
      "stringsAsFactors",
      "ncol",
      "pvalue",
      "names",
      "nrow"
    ]
  },
  {
    "id": "main_FigureYa298ecdfPvalue_FigureYa298ecdfPvalue",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa298ecdfPvalue_FigureYa298ecdfPvalue.txt",
    "content": "FigureYa298ecdfPvalue\nFigureYa298ecdfPvalue\nAuthor(s)\n: Qian Liu; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirements Description\n重点是p值如何算出来的\nFocus on how p-values are calculated\n出自：\nhttps://www.nature.com/articles/s41556-018-0045-z\n图2 | IGF2BPs调控全转录组mRNA水平。 (b)\nIGF2BP基因沉默后，非靶标基因、CLIP靶标基因及CLIP+RIP靶标基因的mRNA\nlog2倍数变化累积频率分布。P值采用\n双尾Wilcoxon与Mann–Whitney检验\n计算。\nSource:\nhttps://www.nature.com/articles/s41556-018-0045-z\nFig. 2 | IGF2BPs regulate transcriptome-wide mRNA levels. (b)\nCumulative frequency of mRNA log2 FC in non-target, CLIP target and CLIP\n+ RIP target genes upon IGF2BP silencing. P values were calculated using\ntwo-sided Wilcoxon and Mann–Whitney test\n.\nFigureYa290BarGraph所在的文章里也用到了类似的图：\nThe article where the FigureYa290BarGraph is located also uses a\nsimilar graph:\n出自：\nhttps://www.nature.com/articles/s41586-021-03626-9\n图3 | TIM-3缺陷增强树突细胞功能并促进抗原特异性抗肿瘤免疫。 (d)\nHavcr2fl/fl(灰色)与Havcr2cko(红色)迁移性树突细胞中mregDC特征基因集富集分数的经验累积分布(ECDF)图(P=9.4×10⁻⁴)\n(e) MHC I类抗原呈递特征基因集的ECDF图(P=1.01×10⁻³)\nHavcr2fl/fl与Havcr2cko组间基因特征活性水平的差异采用Wilcoxon秩和检验分析，并通过小提琴图或ECDF图可视化\nSource:\nhttps://www.nature.com/articles/s41586-021-03626-9\nFig. 3 | TIM-3 deficiency promotes DC functionality and enhances\nantigen-specific anti-tumour immunity. (d) Empirical cumulative\ndistribution function (ECDF) plot of enrichment score for mregDC\nsignature in Havcr2fl/fl (grey) or Havcr2cko (red) migDCs, (P = 9.4 ×\n10−4). (e) ECDF plot of MHC class I presentation signature (P = 1.01 ×\n10−3). The difference in gene signature score activity levels between\nHavcr2fl/fl and Havcr2cko was examined using\nWilcoxon rank-sum\ntest\nand visualized using violin or ECDF plots.\n以上两篇文章用到的检验方法\ntwo-sided Wilcoxon and Mann–Whitney test\n和\nWilcoxon rank-sum test\n是一回事。\nThe two testing methods mentioned in the above articles,\ntwo-sided Wilcoxon and Mann–Whitney test\nand\nWilcoxon rank-sum test\n, refer to the same thing.\n应用场景\nApplication Scenario\n用经验累积分布函数empirical cumulative distribution\nfunction(ECDF)对比分布，并计算两种分布的p value。\nECDF图具有两大核心优势：\n与直方图或核密度估计不同，它直接呈现每个数据点。这意味着无需考虑分组区间宽度或平滑参数的选择。\n由于曲线具有单调递增特性，这种图表特别适合进行多组分布的比较。\n出自：\nhttps://seaborn.pydata.org/tutorial/distributions.html#tutorial-ecdf\n，里面有关于其他分布的介绍，推荐扩展阅读。\n我们在FigureYa278heatmapPoints中也有类似的一个需求，用的是\nkruskal.test\n，这种统计方法也可用来计算两种分布的P值.\nCompare distributions using the empirical cumulative distribution\nfunction (ECDF) and calculate the p-value between the two\ndistributions.\nThe ECDF plot has two key advantages.\nUnlike the histogram or KDE, it directly represents each datapoint.\nThat means there is no bin size or smoothing parameter to consider.\nAdditionally, because the curve is monotonically increasing, it is\nwell-suited for comparing multiple distributions.\nThis is from\nhttps://seaborn.pydata.org/tutorial/distributions.html#tutorial-ecdf\n,\nwhich includes an introduction to other distributions—recommended for\nfurther reading.\nWe had a similar requirement in FigureYa278heatmapPoints , where we\nused the\nkruskal.test\n. This statistical method can also be\nused to compute the p-value between two distributions.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(tidyverse)\nlibrary(rstatix)\nlibrary(glue)\nlibrary(ggtext) \n\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n输入文件\nInput Files\neasy_input.csv，包含两列，第一列是数值，第二列是分组信息（a、b、c三组）。\nThe file easy_input.csv contains two columns: the first column stores\nnumerical values, and the second column contains group labels (with\nthree categories: a, b, and c).\n# 生成输入文件\n# 设置随机数种子，以便我们都能复现结果\n# 在所有涉及到随机数据的产生，大家一定都要记得设置随机数种子\n# Generate input file\n# Set random seed for reproducible results\n# Always remember to set random seed when generating any random data\nset.seed(2022)\n\ndf <- data.frame(\n  x = c(rnorm(100, 0, 3), rnorm(100, 0, 10), rnorm(100, 0, 10)),\n  g = gl(3, 100, labels = c(\"a\", \"b\", \"c\"))\n)\n\nwrite.csv(df, \"easy_input.csv\", quote = F, row.names = F)\n# 加载输入文件\n# Load input file\ndf <- read.csv(\"easy_input.csv\")\n\n# 指定线条颜色\n# Specify line colors\ncols = c(\"red\", \n         \"forestgreen\", \n         \"darkblue\")\n\n# 图中文字都是带有颜色的，而且与所对应的组别颜色都是一致的，这里我们利用 Y 叔的 ggtext 巧妙的构建组别：\n# All text elements in the plot are color-coded to match their corresponding group colors. Here we cleverly construct the groups using Dr.Y's ggtext package\ndf1 <- df %>%\n  mutate(\n    col = rep(cols, each = 100),\n    Group = glue(\"<i style='color:{col}'>{g}</i>\"),\n    Group = factor(\n      Group, \n      \n      levels = c(\n        \"<i style='color:red'>a</i>\", \n        \"<i style='color:forestgreen'>b</i>\", \n        \"<i style='color:darkblue'>c</i>\"),\n      \n      labels = c(\n        \"<i style='color:red'>Non-targets\\n(100)\\n</i>\", \n        \"<i style='color:forestgreen'>CLIP targets\\n(100)\\n</i>\", \n        \"<i style='color:darkblue'>CLIP + RIP targets\\n(100)\\n</i>\"\n        )\n      )\n  )\n\nhead(df1)\n计算P值\nP-value Calculation\n这里用的是two-sided Wilcoxon and Mann–Whitney test。\n这里大家有兴趣一定要去get到统计包\nrstatix\n的精髓\nhttps://rdrr.io/cran/rstatix/man/\n，对于批量进行统计分析太方便了。\nThe two-sided Wilcoxon and Mann-Whitney tests are used here.\nIf you’re interested, I highly recommend mastering the essence of the\nstatistics package rstatix\nhttps://rdrr.io/cran/rstatix/man/\n—it makes batch\nstatistical analysis incredibly convenient.\nPvalue_data <- df %>% \n  rstatix::wilcox_test(x ~ g, alternative = \"two.sided\") \n\n(CLIP_P <- Pvalue_data$p[1])\n(CLIP.RIP_P <- Pvalue_data$p[2])\nkruskal-wallis rank sum statistic\n我们在\nFigureYa278heatmapPoints\n中也有类似的一个需求，用的是\nkruskal.test\n，这种统计方法也可用来计算两种分布的P值。\nWe had a similar requirement in\nFigureYa278heatmapPoints\nwhere we used\nkruskal.test\n. This statistical method can\nalso be employed to calculate p-values between two distributions.\n# 采用kruskal-wallis rank sum statistic计算p值\n# kruskal-wallis rank sum statistic used to compute the p-value\nkruskal_Pvalue_data <- df %>% \n  filter(g %in% c(\"a\", \"b\")) %>%\n  kruskal_test(x ~ g) \n(CLIP_P <- kruskal_Pvalue_data$p)\nkruskal_Pvalue_data <- df %>% \n  filter(g %in% c(\"a\", \"c\")) %>%\n  kruskal_test(x ~ g)\n(CLIP.RIP_P <- kruskal_Pvalue_data$p)\n两种方法得到的 p value 都是一样的。\nBoth methods yield identical p-values.\n开始画图\nPlotting\n首先绘制不标\nP\n值的图\nFirst, generate the plot without displaying P-values.\np1 <- ggplot(df1, aes(x, color = Group)) +\n  stat_ecdf(geom = \"step\", size = 1) + # or geom = \"point\"\n  scale_color_manual(\n    values = cols,\n    # labels = c(\"Non-targets\\n(100)\\n\", \"CLIP targets\\n(100)\\n\", \"CLIP + RIP targets\\n(100)\\n\"),\n    name = \"\"\n  ) +\n  labs(\n    x = expression(~log[2]~FC (shIGF2BP1/shNS)),\n    y = \"Cumulative fraction\"\n  ) +\n  theme_bw() +\n  theme(\n    legend.position = c(0.8, 0.4),\n    legend.background = element_blank(),\n    panel.grid = element_blank(),\n    legend.text = element_markdown()\n  )\np1\n在图中标注\nP\n值，用\nannotate()\n函数实现\nAnnotate P-values on the plot using the annotate() function\np2 <- p1 +\n  annotate(\n    geom = \"text\",\n    x = -20, y = 0.7,\n    label = sprintf(\"P = %.3f\", CLIP_P),\n    color = cols[2],\n    size = 6\n  ) +\n  annotate(\n    geom = \"text\",\n    x = -20, y = 0.6,\n    label = sprintf(\"P = %.3f\", CLIP.RIP_P),\n#    parse = TRUE,\n    color = cols[3],\n    size = 6\n  )\np2\n# 保存图片\n# Save plot \nggsave(\"ecdf_add_Pvalue.pdf\", p2, height = 7, width = 7, device = \"pdf\")\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa298ecdfPvalue_FigureYa298ecdfPvalue",
      "title": "FigureYa298ecdfPvalue/FigureYa298ecdfPvalue.html",
      "html": "FigureYa298ecdfPvalue/FigureYa298ecdfPvalue.html",
      "text": "texts/main_FigureYa298ecdfPvalue_FigureYa298ecdfPvalue.txt",
      "folder": "FigureYa298ecdfPvalue",
      "thumb": "gallery_compress/FigureYa298ecdfPvalue.webp"
    },
    "word_count": 906,
    "lines_count": 259,
    "title": "FigureYa298ecdfPvalue",
    "description": "Requirements Description 重点是p值如何算出来的 Focus on how p-values are calculated",
    "input_data_types": [
      "RNA-seq"
    ],
    "output_types": [
      "热图",
      "统计表格",
      "箱线图"
    ],
    "technical_methods": [
      "通路分析",
      "生存分析"
    ],
    "biology_areas": [
      "免疫学"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "values",
      "g",
      "width",
      "grid",
      "pvalue",
      "labels",
      "col",
      "P"
    ]
  },
  {
    "id": "main_FigureYa315SingleRFraction_FigureYa315SingleRFraction",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa315SingleRFraction_FigureYa315SingleRFraction.txt",
    "content": "FigureYa315SingleRFraction\nFigureYa315SingleRFraction\nAuthor(s)\n: Xiaofan Lu; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-05-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nDemand description\n在单细胞数据中，怎么用singleR预测不同细胞亚群之间的相关性。\nIn single-cell data, how to use SingleR to predict the correlations\nbetween different cell subpopulations.\n出自：\nhttps://www.cell.com/cell/fulltext/S0092-8674(21)00010-6?_returnURL=https%3A%2F%2Flinkinghub.elsevier.com%2Fretrieve%2Fpii%2FS0092867421000106%3Fshowall%3Dtrue\n图S5. LAMP3+ cDC细胞的起源与调控（与图4相关）。 (D)\n箱线图展示不同癌症类型中，cDC2来源的LAMP3+ cDC细胞占所有LAMP3+\ncDC细胞的比例。Kruskal-Wallis检验。\nSource:\nhttps://www.cell.com/cell/fulltext/S0092-8674(21)00010-6?_returnURL=https%3A%2F%2Flinkinghub.elsevier.com%2Fretrieve%2Fpii%2FS0092867421000106%3Fshowall%3Dtrue\nFigure S5. Origins and regulation of LAMP3+ cDCs, related to Figure\n4. (D) Boxplot showing the fractions of cDC2-derived LAMP3+ cDCs in all\nLAMP3+ cDCs across different cancer types. Kruskal-Wallis test.\n应用场景\nApplication scenarios\n例文针对\norigins of the LAMP3+ cDCs\n的问题做了多个角度的探讨，可以灵活运用到自己感兴趣的细胞类型中。\n本文档使用SingleR计算cDC3_LAMP3来源于cDC2的占比，实现Figure S5D。\n同一篇文章的Figure S5B（Stratification of cDC transcriptomes by\nscores generated from signature genes of three cDC\nsubsets）可以用FigureYa314SingleRScore来计算和画图。\nThe example text explores the question of\norigins of the LAMP3+ cDCs\nfrom multiple perspectives,\nwhich can be flexibly applied to other cell types of interest.\nThis document uses SingleR to calculate the proportion of cDC3_LAMP3\nderived from cDC2, reproducing Figure S5D.\nFor Figure S5B of the same paper (Stratification of cDC\ntranscriptomes by scores generated from signature genes of three cDC\nsubsets), the FigureYa314SingleRScore can be used for calculation and\nplotting.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(Matrix)\nlibrary(Seurat)\n# 基于参考数据集对新细胞进行类型标注\n#labels new cells from a test dataset based on similarity to the reference\nlibrary(SingleR)\nlibrary(ggplot2) \n\n# 用于实现Kruskal-Wallis test\n# Provides Kruskal-Wallis test\nlibrary(ggpubr) \n\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n输入文件\nInput Files\n原文图中有14个cohort，作者上传到GEO数据库的只有9个，\nhttps://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE154763\n。我们从Supplementary\nfile表格里下载csv.gz文件，放到当前目录下的InputData文件夹。\nThe original figure included data from 14 cohorts, but only 9 cohorts\nwere uploaded by the authors to the GEO database,\nhttps://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE154763\n.\nWe downloaded the csv.gz files from the Supplementary file table and\nsaved them in the\nInputData\nfolder under the current\ndirectory.\n实际应用中，直接跳到下一步“SingleR”，加载自己的seurat对象。\nIn practice, you can directly proceed to the next step “SingleR” and\nload your own Seurat object.\ndata.path <- file.path(\"InputData\")\n\n# 读取表达谱\n# Read expression matrices\nemats <- lapply(list.files(data.path, pattern = \"expression\", full.names = T), function(x){\n  emat = data.table::fread(x, data.table = F, sep = \",\")\n  rownames(emat) = emat$index; emat$index = NULL\n  emat = as(as.matrix(t(emat)), \"dgCMatrix\")\n  return(emat)\n})\n\neinfos <- lapply(list.files(data.path, pattern = \"metadata\", full.names = T), function(x){\n  einfo = read.csv(x)\n  rownames(einfo) = einfo$index\n  return(einfo)\n})\n\nseu.objs <- mapply(function(x, y){\n  seu = CreateSeuratObject(x, meta.data = y)\n}, emats, einfos)\nseu <- merge(seu.objs[[1]], seu.objs[-1])\n# 目的是看cDC3中cDC2来源的占比，如果队列里没有cDC3细胞的话，画图时不会出现这个队列\n# 运行这句就可以看到哪些队列里有cDC3了\n# Purpose: To check the proportion of cDC2-derived cells in cDC3. Cohorts without cDC3 cells will be automatically excluded in plotting.\n# Run this to identify cohorts containing cDC3 cells\ntable(seu$cancer[seu$MajorCluster==\"M04_cDC2_CD1C\"])\n# 取子集来降低计算量\n# Subset data to reduce computational load\nseu <- subset(seu, MajorCluster %in% c(\"M03_cDC1_CLEC9A\", \"M04_cDC2_CD1C\", \"M05_cDC3_LAMP3\"))\nSingleR评估cDC3（LAMP3+ cDCs）的cDC2来源占比\nUsing SingleR to evaluate the proportion of cDC2-derived cDC3\n(LAMP3+ cDCs)\n原文：我们以\ncDC1和cDC2的转录组作为参考\n，预测\n各数据集中LAMP3+\ncDCs的细胞来源\n。\nOriginal Text：Here, we used the\ntranscriptomes of cDC1s and\ncDC2s as a reference\nto predict the\norigin of LAMP3+\ncDCs in each dataset\n.\n# 由单细胞转录组数据生成cDC1、cDC2参考集\n# Generate cDC1 and cDC2 reference sets from single-cell RNA-seq data \ntrain <- AverageExpression(seu, group.by = \"MajorCluster\", layer = \"counts\")[[1]]\ntrain <- train[, c(\"M03-cDC1-CLEC9A\", \"M04-cDC2-CD1C\")]\n\n# 检查RNA assay中是否存在counts数据层  \n# Check if counts layers exist in RNA assay \ncounts_layers <- Layers(seu, assay = \"RNA\", search = \"counts\")\nif (length(counts_layers) == 0) {\n  stop(\"No counts layers found in the RNA assay!\")\n}\n\n# 获取所有counts层的基因名  \n# Get gene names from all counts layers\nall_genes <- lapply(counts_layers, function(layer) {\n  rownames(LayerData(seu, assay = \"RNA\", layer = layer))\n})\n\n# 取交集（共同）基因  \n# Get intersecting (common) genes  \ncommon_genes <- Reduce(intersect, all_genes)\n\n# 仅提取共同基因的表达矩阵  \n# Extract expression matrix with common genes only  \nall_counts <- do.call(cbind, lapply(counts_layers, function(layer) {\n  mat <- LayerData(seu, assay = \"RNA\", layer = layer)\n  mat[common_genes, ] \n}))\n\n# 评估cDC3（LAMP3+ cDCs）的cDC2来源占比\n# Evaluate the proportion of cDC2-derived cells in cDC3 (LAMP3+ cDCs)  \ncell_idx <- colnames(all_counts) %in% rownames(seu@meta.data[seu$MajorCluster == \"M05_cDC3_LAMP3\", ])\ntest <- all_counts[, cell_idx]\n\n# 使用SingleR进行细胞来源预测  \n# Predict cell origin using SingleR \ntest.label <- as.data.frame(SingleR(test = test, #M05-cDC3-LAMP3\n                                    ref = train, #M03-cDC1-CLEC9A and M04-cDC2-CD1C\n                                    labels = colnames(train)))\n\n# 添加队列和患者信息  \n# Add cohort and patient information  \ntest.label$cohort <- seu$cancer[match(rownames(test.label), colnames(seu))]\ntest.label$patient <- seu$patient[match(rownames(test.label), colnames(seu))]\n\n# 按队列分组计算cDC2来源比例  \n# Calculate cDC2-derived proportion by cohort\nplot.data <- split(test.label, test.label$cohort)\nplot.data <- lapply(plot.data, function(x) {\n  tbl <- table(x$patient, x$pruned.labels)\n  df <- as.data.frame.matrix(tbl)\n  prop <- df[[\"M04-cDC2-CD1C\"]] / rowSums(df)\n  data.frame(patient = rownames(df), prop = prop)\n})\n\n# 合并所有队列数据并整理格式  \n# Combine all cohort data and reformat\nplot.data <- do.call(rbind, plot.data)\nplot.data$cohort <- gsub(\"(.+)\\\\.(.+)\", \"\\\\1\", rownames(plot.data))\n开始画图\nPlotting\n基础版\nBasic version\nggplot(plot.data, aes(x = cohort, y = prop*100, color = cohort)) + \n  geom_boxplot() + \n  geom_point(shape = 16, \n             position = position_jitterdodge()) +\n  scale_colour_brewer(palette = \"Paired\") + \n  geom_hline(yintercept = 50, color=\"black\",\n             linetype=\"longdash\", lwd = 0.5) + \n  theme_classic() + \n  guides(colour = \"none\") + \n  labs(x = \"\", y = \"Proportion\") + \n  ggtitle(\"cDC2-derived LAMP3+ CDC\") +\n  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, \n                                   color = \"black\"),\n        axis.title.y = element_text(hjust = 0.5, color = \"black\"),\n        axis.text.y = element_text(hjust = 0.5, color = \"black\"),\n        axis.ticks = element_line(color=\"black\"),\n        axis.ticks.length = unit(0.2, \"cm\"),\n        panel.background = element_blank(),\n        panel.grid = element_blank(),\n        legend.position = \"top\",\n        axis.title = element_text(size = 10),\n        axis.text = element_text(size = 10)) +\n  stat_compare_means(method = \"kruskal.test\")\nggsave(\"Proption.pdf\", width = 5, height = 4)\n升级版\nEnhanced version\nggplot(plot.data, aes(x = cohort, y = prop*100, fill = cohort)) + \n  geom_violin(alpha = 0.4, position = position_dodge(width = .75), \n              size = 0.8, color=\"white\") + \n  geom_boxplot(notch = F, outlier.size = -1, \n               color=\"black\", lwd = 0.6, alpha = 0.7) + \n  geom_boxplot() + \n  geom_point(shape = 21, size=1.2, \n             position = position_jitterdodge(), alpha = 0.6) + \n  scale_fill_brewer(palette = \"Paired\") + \n  geom_hline(yintercept = 50, color=\"black\",\n             linetype=\"longdash\", lwd = 0.5) + \n  theme_classic() + \n  guides(fill = \"none\") + \n  labs(x = \"\", y = \"Proportion\") + \n  ggtitle(\"cDC2-derived LAMP3+ CDC\") +\n  theme(axis.text.x = element_text(angle = 45, vjust = 1, hjust=1, \n                                   color = \"black\"),\n        axis.title.y = element_text(hjust = 0.5, color = \"black\"),\n        axis.text.y = element_text(hjust = 0.5, color = \"black\"),\n        axis.ticks = element_line(color=\"black\"),\n        axis.ticks.length = unit(0.2, \"cm\"),\n        panel.background = element_blank(),\n        panel.grid = element_blank(),\n        legend.position = \"top\",\n        axis.title = element_text(size = 10),\n        axis.text = element_text(size = 10)) +\n  stat_compare_means(method = \"kruskal.test\")\nggsave(\"Proption_plus.pdf\", width = 5, height = 4)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa315SingleRFraction_FigureYa315SingleRFraction",
      "title": "FigureYa315SingleRFraction/FigureYa315SingleRFraction.html",
      "html": "FigureYa315SingleRFraction/FigureYa315SingleRFraction.html",
      "text": "texts/main_FigureYa315SingleRFraction_FigureYa315SingleRFraction.txt",
      "folder": "FigureYa315SingleRFraction",
      "thumb": "gallery_compress/FigureYa315SingleRFraction.webp"
    },
    "word_count": 1019,
    "lines_count": 252,
    "title": "FigureYa315SingleRFraction",
    "description": "Demand description 在单细胞数据中，怎么用singleR预测不同细胞亚群之间的相关性。 In single-cell data, how to use SingleR to predict the correlations",
    "input_data_types": [
      "单细胞",
      "表达矩阵",
      "RNA-seq"
    ],
    "output_types": [
      "散点图",
      "箱线图",
      "统计表格"
    ],
    "technical_methods": [],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "colour",
      "ticks",
      "acc",
      "pattern",
      "lwd",
      "width",
      "grid",
      "vjust",
      "labels"
    ]
  },
  {
    "id": "main_FigureYa290BarGraph_FigureYa290BarGraph",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa290BarGraph_FigureYa290BarGraph.txt",
    "content": "FigureYa290BarGraph\nFigureYa290BarGraph\nAuthor(s)\n: Xiaofan Lu; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-05-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nDemand description\n想实现这两个柱状图，重点是不知道一个柱子的不同百分比是怎么做的统计检验。\nWe want to reproduce these bar graphs, particularly focusing on\nstatistical tests for different percentages within each bar\n出自\nhttps://www.ncbi.nlm.nih.gov/pmc/articles/PMC8627694\n扩展数据图4 | Havcr2fl/fl和Havcr2cko CD45+细胞的单细胞RNA测序。(e)\n显示每个cluster中Havcr2fl/fl(蓝)和Havcr2cko(橙)细胞比例的柱状图。\nSource:\nhttps://www.ncbi.nlm.nih.gov/pmc/articles/PMC8627694\nExtended Data Fig. 4 |. scRNA-seq of Havcr2fl/fl and Havcr2cko total\nCD45+ cells. (e) Bar graph showing frequency of Havcr2fl/fl (blue) and\nHavcr2cko (orange) cells in each cluster.\n应用场景\nApplication scenarios\n对单细胞数据进行处理和分型，绘制细胞比例柱状图并做富集检验。\nThe single-cell data were processed and typed, the cell proportion\nbar chart was drawn and enrichment tests were conducted.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(ggplot2)\nlibrary(rstatix)\nlibrary(Seurat)\nlibrary(SeuratDisk)\nlibrary(Matrix)\n\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n输入文件\nInput Files\n例文数据已上传至GEO（GSE151914），下载地址：\nhttps://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE151914\nData available on GEO (GSE151914), download from:\nhttps://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE151914\n# 读取count矩阵、细胞Barcode、基因名和细胞对应的样本信息\n# Read count matrix, cell barcodes, gene names and sample metadata\nmtx <- readMM(\"GSE151914_expression_matrix.mtx.gz\")\ncellID <- read.table(\"GSE151914_cellIDs.txt.gz\")\ngeneID <- read.table(\"GSE151914_genes.txt.gz\")\nmetadata <- read.table(\"GSE151914_metadata.txt.gz\", header = T, sep = \",\")\n\n# 检查count矩阵大小是否与细胞Barcode/基因名一致\n# Check matrix dimensions match cell barcode/gene identifiers\ndim(mtx)\nall(metadata$Index == cellID$V1)\n# 修改count行列名\n# Modify matrix row/column names\nrownames(mtx) <- geneID$V1; colnames(mtx) = cellID$V1\nsummary(rowSums(mtx>0))\nsummary(colSums(mtx>0))\n# 制作seurat对象，根据原文该分析只用到肿瘤样本(使用原文的参数 nfeatures = 1000, dim.to.use = 1:12)\n# To create the seurat object, according to the original text, this analysis only uses tumor samples (using the original text parameters nfeatures = 1000, dim.to.use = 1:12).\nseu <- CreateSeuratObject(mtx)\nseu$Sample = metadata$Sample\nseu <- subset(seu, Sample %in% c(\"Tum_963_WT\", \"Tum_650_KO\", \"Tum_877_WT\", \"Tum_685_KO\"))\nseu <- NormalizeData(seu)\n# 寻找高变异基因\n# Find HVGs\nseu <- FindVariableFeatures(seu, nfeatures = 1000)\n# 可视化高变异基因\n# Visualize HVGs \nVariableFeaturePlot(seu)\n# 标准化\n# Standardization \nseu <- ScaleData(seu)\n# 降维\n# Dimensionality reduction\nseu <- RunPCA(seu)\ndim.to.use = 1:12\nseu <- RunUMAP(seu, dims = dim.to.use)\nDimPlot(seu)\n非监督聚类\nUnsupervised Clustering\n# 进行非监督聚类\n# Perform unsupervised clustering\nseu <- FindNeighbors(seu, dims = dim.to.use)\nseu <- FindClusters(seu)\nDimPlot(seu)\nsaveRDS(seu, \"seu.rds\")\n\n# 提取细胞分类信息\n# Sample：由GSE151914_metadata.txt.gz提供的样本信息\n# 规律为：样本组织来源_样本测序时使用通道_样本分组，如Tum_963_WT\n# GSE151914 Series Matrix File(s)显示963对应R1，650对应R2\n# 使用正则表达式(gsub)进行将Sample列进行分割\n# 使用按位置替换(substr)或字符切割(strsplit)也可起到类似结果\n# Extract cell classification information\n# Sample: Provided by GSE151914_metadata.txt.gz\n# Pattern: TissueSource_SequencingLane_ExperimentalGroup, e.g. Tum_963_WT\n# GSE151914 Series Matrix File(s) shows 963 corresponds to R1, 650 to R2\n# Using regular expressions (gsub) to split the Sample column\n# Using position-based replacement (substr) or string splitting (strsplit) can achieve similar results\ncellinfo <- FetchData(seu, vars = c(\"Sample\", \"seurat_clusters\"))\ncellinfo$Run <- gsub(\"(\\\\w+)(_)(\\\\d+)(_)(\\\\w+)\", \"\\\\3\", cellinfo$Sample)\ncellinfo$Run <- ifelse(test = cellinfo$Run %in% c(\"963\", \"650\"),\n                       yes = \"R1\", no = \"R2\")\ncellinfo$Group <- gsub(\"(\\\\w+)(_)(\\\\d+)(_)(\\\\w+)\", \"\\\\5\", cellinfo$Sample)\nstr(cellinfo)\nwrite.table(cellinfo, \"cellinfo.txt\", row.names = F, col.names = T, quote = F, sep = \"\\t\")\n开始画图\nPlotting\n# cellinfo <- Seurat::FetchData(seu, vars = c(\"Sample\", \"seurat_clusters\", \"Run\", \"Group\"))\ncellinfo <- read.table(\"cellinfo.txt\", header = T, stringsAsFactors = T)\nstr(cellinfo)\n# 设置分组颜色\n# Set group colors\ncell.col <- setNames(object = c(\"#1A63A8\", \"#FC6910\"),\n                     nm = c(\"WT\", \"KO\"))\n绘制堆叠柱状图\nStacked Bar Plot\n# 制作列联表\n# Create contingency table\nplot.data <- as.data.frame(table(cellinfo$seurat_clusters, cellinfo$Run, cellinfo$Group))\n\np1 <- ggplot(plot.data, aes(x = Var2, y = Freq, fill = Var3)) +\n  \n  # 绘制堆叠比例柱状图\n  # Stacked proportion plot\n  geom_bar(stat = \"identity\", position = position_fill(reverse = T)) + \n  \n  # 设置分组颜色\n  # Set group colors\n  scale_fill_manual(values = cell.col) +   \n  \n  facet_wrap(~Var1, nrow = 1) +                                                           \n  theme_classic() +                                                                       \n  xlab(\"Replicate\") +                                                                     \n  ylab(\"Fraction of Cells\") +                           \n  theme(strip.background = element_rect(fill=\"grey\", color = \"white\", size = 1),         \n        strip.text = element_text(size = 12, colour=\"black\"),                             \n        legend.title = element_blank(),                                                   \n        axis.title = element_text(size = 15))\np1\nggsave(\"p1.pdf\", width = 12, height = 4)\n绘制带有显著性符号的柱状图\nBar Plot with Significance\n# 构建seurat_clusters和Group的列联表\n# Build contingency table of seurat_clusters vs Group\ntbl <- table(cellinfo$seurat_clusters, cellinfo$Group)\ntbl\n# 进行fisher精确检验和post hoc检验\n# post hoc检验：对各组样本进行 one vs other的fisher检验，进行多重性校正，得到各组的p-adj\n# Perform Fisher's exact test and post hoc test\n# Post hoc test: Conducts Fisher's exact test for each group (one vs others) with multiple testing correction to obtain adjusted p-values (p-adj)\nfisher.test(tbl, simulate.p.value = T)\npost.hoc <- row_wise_fisher_test(tbl) \n\n# 调整显著性显示标签\n# Adjust significance display labels\npost.hoc$sig.label <- ifelse(test = post.hoc$p.adj.signif == \"ns\", \n                             yes = \"\", no = post.hoc$p.adj.signif) \nstr(post.hoc)\nhead(post.hoc)\n# 准备绘图数据\n# Prepare plot data\nplot.data <- as.data.frame(tbl)\nhead(plot.data)\np2 <- ggplot(plot.data, aes(x = Var1, y = Freq, fill = Var2)) + \n  geom_bar(stat = \"identity\", position = position_fill(reverse = T)) +  \n  scale_fill_manual(values = cell.col) +                                \n  scale_y_continuous(breaks = seq(0, 1, by = 0.25)) +                   \n  geom_text(data = post.hoc,                                           \n            aes(x = group, y = 1.1, label = sig.label),                 \n            inherit.aes = F) +                                          \n  xlab(\"Cluster\") +                                                    \n  ylab(\"Fraction of Cells\") +\n  theme_classic() +                                                     \n  theme(legend.title = element_blank(),                                \n        axis.text = element_text(size = 10),                            \n        axis.title = element_text(size = 15))                          \np2\nggsave(filename = \"p2.pdf\", width = 8, height = 4)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa290BarGraph_FigureYa290BarGraph",
      "title": "FigureYa290BarGraph/FigureYa290BarGraph.html",
      "html": "FigureYa290BarGraph/FigureYa290BarGraph.html",
      "text": "texts/main_FigureYa290BarGraph_FigureYa290BarGraph.txt",
      "folder": "FigureYa290BarGraph",
      "thumb": "gallery_compress/FigureYa290BarGraph.webp"
    },
    "word_count": 786,
    "lines_count": 196,
    "title": "FigureYa290BarGraph",
    "description": "Demand description 想实现这两个柱状图，重点是不知道一个柱子的不同百分比是怎么做的统计检验。 We want to reproduce these bar graphs, particularly focusing on",
    "input_data_types": [
      "临床数据",
      "单细胞"
    ],
    "output_types": [
      "统计表格",
      "PCA图"
    ],
    "technical_methods": [
      "聚类分析",
      "通路分析",
      "标准化"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "colour",
      "values",
      "Sample",
      "acc",
      "header",
      "width",
      "object",
      "nrow"
    ]
  },
  {
    "id": "main_FigureYa173fancybar_FigureYa173fancybar",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa173fancybar_FigureYa173fancybar.txt",
    "content": "FigureYa173fancybar\nFigureYa173fancybar\nAuthor(s)\n: Xiaofan Lu\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\n需求描述\nRequirement\n我想实现这篇文章的Figure\n4i和j，是同一种类型的图。这个图，可以比较组内的情况，然后还可以合并组内的数据，再比组间。还有这种可以直接实现出图的代码。\nI want to draw as Figures 4i and 4j in this article. They are the same\ntype of graph. This graph allows for comparison within groups, merging\ndata within groups, and comparing across groups. Code is also available\nto directly generate the graph.\n出自\nhttps://doi.org/10.1016/j.ebiom.2020.102724\nFrom\nhttps://doi.org/10.1016/j.ebiom.2020.102724\nFig. 4. Practical testing of U-HAPPY CT in three clinical\nscenarios.\n图的解读\nInterpretation of the\nFigure\n图中绿红蓝是三个大组，内部又用同一色系的渐变色画了多个亚组。 The\ngreen, red, and blue colors in the figure represent the three main\ngroups, with multiple subgroups drawn within them using gradients of the\nsame color scheme.\n仔细看，其中红色和蓝色大组分别画了半透明的红色和蓝色误差线。 Look\nclosely, the red and blue groups have semi-transparent red and blue\nerror bars, respectively.\n用base plot，就像画笔一样，一笔一笔画出想要添加的元素。 Using a base\nplot is like painting a brush, adding the elements you want, stroke by\nstroke.\n应用场景\nApplication Scenarios\n多组柱状图(mean ± se; se =\nsd/sqrt(n))，某些组同时存在亚组，并进行组间比较和亚组内比较。 Multiple\ngroup bar charts (mean ± se; se = sd/sqrt(n)), with some groups\ncontaining subgroups and performing both inter-group and intra-subgroup\ncomparisons.\n注意：有些杂志要求，对数据的描述不允许使用se（视觉上感觉离散度更小），要使用sd，请留意。\nNote: Some journals prohibit the use of se in data descriptions\n(visually giving a smaller sense of dispersion). Use sd instead. Please\nnote this.\n该绘图代码在出图前需要不断调整坐标或文字位置，需要在理解的基础上加以使用。\nThis plotting code requires constant adjustment of coordinates or text\npositions before plotting, so it should be used with understanding.\n环境设置\nEnvironment Setup\n自定义函数求解se Custom Function to Solve for se\nse <- function(x) sd(x)/sqrt(length(x))\n输入文件\nInput File\nmulticenter_validation_\n.txt，每个亚组的观测值对应图中的一个bar，放到一个单独的文件里，只需提供diff这一列。\nmulticenter_validation_\n.txt, where each subgroup’s observation\ncorresponds to a bar in the plot. Place these in a separate file. Only\nthe diff column is required.\nprefix <- \"multicenter_validation_\" # 输入文件的文件前缀 # File prefix for the input file\n\n# 加载图中绿色大组对应的数据\n# Load the data corresponding to the green group in the figure\nfull1 <- read.table(paste0(prefix,\"full_NJDTH_UI.txt\"),sep = \"\\t\",check.names = F,stringsAsFactors = F,header = T,row.names = NULL)\n\n# 加载图中红色大组对应的数据\n# Load the data corresponding to the red group in the figure\nsemi1 <- read.table(paste0(prefix,\"semi_NJDTH_UI.txt\"),sep = \"\\t\",check.names = F,stringsAsFactors = F,header = T,row.names = NULL)\nsemi2 <- read.table(paste0(prefix,\"semi_PZTH_UI.txt\"),sep = \"\\t\",check.names = F,stringsAsFactors = F,header = T,row.names = NULL)\nsemi3 <- read.table(paste0(prefix,\"semi_SYCCYHC_UI.txt\"),sep = \"\\t\",check.names = F,stringsAsFactors = F,header = T,row.names = NULL)\n\n# 加载图中蓝色大组对应的数据\n#Load the data corresponding to the blue group in the picture\nmanu1 <- read.table(paste0(prefix,\"manual_NJDTH_UI.txt\"),sep = \"\\t\",check.names = F,stringsAsFactors = F,header = T,row.names = NULL)\nmanu2 <- read.table(paste0(prefix,\"manual_NJDTH_GE.txt\"),sep = \"\\t\",check.names = F,stringsAsFactors = F,header = T,row.names = NULL)\nmanu3 <- read.table(paste0(prefix,\"manual_NJDTH_Philips.txt\"),sep = \"\\t\",check.names = F,stringsAsFactors = F,header = T,row.names = NULL)\nmanu4 <- read.table(paste0(prefix,\"manual_JSPPH_Siemens.txt\"),sep = \"\\t\",check.names = F,stringsAsFactors = F,header = T,row.names = NULL)\nmanu5 <- read.table(paste0(prefix,\"manual_GCPH_Toshiba.txt\"),sep = \"\\t\",check.names = F,stringsAsFactors = F,header = T,row.names = NULL)\n计算画图所需的统计量\nCalculate the statistics needed to draw the graph\n# 1. 计算各亚组均值（注意均值的顺序是后期调整的，根据均值大小[柱子高低]）\n# 1. Calculate the mean for each subgroup (note that the order of the means is adjusted later based on the mean size [bar height])\navg <- c(mean(full1$diff),0, # 这里的0是为了柱状图（full和semi）之间的空隙 # The 0 here is for the gap between the bars (full and semi)\n         mean(semi1$diff),\n         mean(semi2$diff),\n         mean(semi3$diff),0, # 这里的0是为了柱状图（semi和manu）之间的空隙 # The 0 here is for the gap between the bars (semi and manu)\n         mean(manu3$diff),\n         mean(manu2$diff),\n         mean(manu1$diff),\n         mean(manu4$diff),\n         mean(manu5$diff))\n\n# 2. 计算个亚组标准误（注意柱子的顺序要和均值一致，这里的manu组为32145）\n# 2. Calculate the standard error for each subgroup (note that the order of the bars must match the mean; here, the standard error for the manu group is 32145)\nvar <- c(se(full1$diff),0,\n         se(semi1$diff),\n         se(semi2$diff),\n         se(semi3$diff),0,\n         se(manu3$diff),\n         se(manu2$diff),\n         se(manu1$diff),\n         se(manu4$diff),\n         se(manu5$diff))\n\n# 3. 计算有多个亚组的组均值\n# 3. Calculating group means for multiple subgroups\navg_semi <- mean(c(semi1$diff,semi2$diff,semi3$diff))\navg_manu <- mean(c(manu1$diff,manu2$diff,manu3$diff,manu4$diff,manu5$diff))\n\n# 4. 计算有多个亚组的组se\n# 4. Calculating group se values for multiple subgroups\nvar_semi <- se(c(semi1$diff,semi2$diff,semi3$diff))\nvar_manu <- se(c(manu1$diff,manu2$diff,manu3$diff,manu4$diff,manu5$diff))\n\n# 5. semi亚组的方差分析（可换成kruskal）\n# 5. Semi-subgroup ANOVA (can be replaced with Kruskal's method)\ntmp <- data.frame(diff = c(semi1$diff,semi2$diff,semi3$diff),\n                  class = as.factor(rep(c(\"A\",\"B\",\"C\"), c(nrow(semi1),nrow(semi2),nrow(semi3)))))\nsaov <- summary(aov(diff~class,tmp)) # intersemi p=6.04e-09\n\n# 6. manual亚组的方差分析（可换成kruskal）\n# 6. Manual-subgroup ANOVA (can be replaced with Kruskal's method)\ntmp <- data.frame(diff = c(manu1$diff,manu2$diff,manu3$diff,manu4$diff,manu5$diff),\n                  class = as.factor(rep(c(\"A\",\"B\",\"C\",\"D\",\"E\"), c(nrow(manu1),nrow(manu2),nrow(manu3),nrow(manu4),nrow(manu5)))))\nmaov <- summary(aov(diff~class,tmp)) # intermanul p<2e-16\n\n# 6. 组间t检验（可换成wilcox非参检验，未校正）\n# 6. Between-group t-test (can be replaced with Wilcox nonparametric test, uncorrected)\nfvss.t <- t.test(full1$diff,c(semi1$diff,semi2$diff,semi3$diff))$p.value # full vs semi p=2.194e-06\nfvsm.t <- t.test(full1$diff,c(manu1$diff,manu2$diff,manu3$diff,manu4$diff,manu5$diff))$p.value # full vs manul p=1.557547e-18\nsvsm.t <- t.test(c(semi1$diff,semi2$diff,semi3$diff),c(manu1$diff,manu2$diff,manu3$diff,manu4$diff,manu5$diff))$p.value # semi vs manul p=0.1779296\n开始画图\nStart drawing\n代码中常使用到的par(“usr”)参数简单解释如下： The par(“usr”) parameter\ncommonly used in the code is briefly explained as follows:\npar(“usr)后有4个坐标点，[1]代表图像在水平位置的最左侧，[2]为最右侧，[3]为垂直位置的最低点，[4]为最高点，这在绘制图例的时候很方便找到极端角落位置。\nThere are 4 coordinate points after par(”usr”, [1] represents the\nleftmost horizontal position of the image, [2] the rightmost right\nposition, [3] the lowest vertical point, and [4] the highest point. This\nis very convenient for finding the extreme corner position when drawing\nthe legend.\n# 设置颜色 # # Set color #\ndarkblue   <- \"#21498D\"\nseagreen   <- \"#008B8A\"\nsun        <- \"#E53435\"\nred        <- \"red\"\n\n# 编写label，注意和均值的柱子一致\n# Write label, pay attention to the consistency with the mean column\nlab <- c(\"Full-NJDTH-UI\",\"\",\n         \"Semi-NJDTH-UI\",\"Semi-PZTH-UI\",\"Semi-SYCCYHC-UI\",\"\",\n         \"Manual-NJDTH-Philips\",\"Manual-NJDTH-GE\",\"Manual-NJDTH-UI\",\"Manual-JSPPH-Siemens\",\"Manual-GCPH-Toshiba\")\n\n# 绘制基本柱状图\n# Draw a basic bar chart\npdf(\"fancybar.pdf\",width = 6,height = 5)\npar(bty=\"o\", mgp = c(2,0.5,0), mar = c(7.1,4.1,2.1,4.1),tcl = -.25,las = 1) # 基本设置 # Basic settings\npar(xpd = T) # 允许图像超出（一般是为了画图例用） # Allow the plot to extend beyond the bounds (usually for legends)\nbar <- barplot(avg, \n               border = F, # 柱子不显示轮廓 # Do not outline the bars\n               ylab = \"Scanning length error (mm)\", # y轴标签 # y-axis label\n               ylim = c(0,80), # 高度要比最大的均值要大一些，给添加P值预留空间 # The height should be slightly larger than the maximum mean to allow for adding P values\n               yaxt = \"n\", # 不显示y轴 # Hide the y-axis\n               xaxt = \"n\", # 不显示x轴 # Hide the x-axis\n               col = c(seagreen,NA, # 注意颜色的NA是均值为0的部分，为空白柱 # Note that NA in the color represents a blank column with a mean of 0)\n                       sun, ggplot2::alpha(sun,0.6), ggplot2::alpha(sun,0.3), NA, # 注意颜色的渐变透明 # Note the color gradient transparency\n                       darkblue, ggplot2::alpha(darkblue,0.8), ggplot2::alpha(darkblue,0.6), ggplot2::alpha(darkblue,0.4), ggplot2::alpha(darkblue,0.2)))\n\naxis(side = 2,at = seq(0,60,10)) # 手动添加y轴 # Manually add y-axis\n\n# 添加垂直的误差线\n# Add vertical error bars\nsegments(bar, # 由bar对象确定位置，也就是每个柱子的中心点 # The position is determined by the bar object, that is, the center point of each column\n         avg - var, # 下侧最低点，为mean- se # The lowest point on the bottom side is mean-se\n         bar,\n         avg + var, # 顶部最高点，为mean + se # The highest point on the top is mean + se\n         lwd = 1.5)\n\n# 添加水平的误差线\n# Add horizontal error bars\narrows(bar, # 同上位置添加水平线 # Add horizontal line at the same position as above\n       avg - var, \n       bar,\n       avg + var, \n       lwd = 1.5, # 线宽 # Line width\n       angle = 90,\n       code = 3, length = 0.05)\n# 根据bar对象添加x轴标签\n# Add x-axis label based on bar object\ntext(x = bar, \n     y = par(\"usr\")[3] - 1, # 在图像垂直最低点再往下1单位添加x轴标签 # Add x-axis label 1 unit below the lowest vertical point of the image\n     srt = 45,\n     adj = 1, labels =lab, xpd = TRUE, cex = 0.6)\n\n# 添加图例\n# Add legend\npar(xpd = T)\nlegend(par(\"usr\")[2]-0.5, # 水平最右侧向内0.5  # Horizontally rightmost 0.5 inward\n       par(\"usr\")[4],  # 垂直最顶上 # Vertically top\n       legend = c(\"Full\",\"Semi\",\"Manual\"), # 原文中带有渐变的图例是后期AI的，因为考虑到柱子本身存在渐变 # The original legend with gradient is a later AI, because the column itself has a gradient\n       fill = c(seagreen,sun,darkblue),\n       cex=0.8, \n       border=NA, \n       y.intersp=1, \n       x.intersp=0.2,\n       bty = \"n\") # 不要图例边框 # No legend border\n\n# 添加semi亚组的背景透明区块（这里要好好体会坐标）\n# Add background transparent block of semi subgroup (here you need to understand the coordinates well)\npar(new = T,xpd = F) # 新添加图层，允许元素超过边界 # Add a new layer, allowing elements to exceed the boundary\nrect(xleft = bar[3]-0.5,# 红色semi组的左侧外缘在bar对象x轴第三个点-0.5的位置（每个柱子宽1，左右各0.5）# The left outer edge of the red semi group is at the position -0.5 of the third point on the x-axis of the bar object (each column is 1 wide, 0.5 on each side)\n     ybottom = 0, # y轴底为0 # The bottom of the y-axis is 0\n     xright = bar[5]+0.5, # 同理x轴右侧在第五个点向右再+0.5 # Similarly, the right side of the x-axis is +0.5 to the right of the fifth point\n     ytop = avg_semi, # y顶就是组均值 # The top of the y-axis is the group mean\n     col = ggplot2::alpha(sun,0.1), # 透明色 # Transparent color\n     border = NA)\n\n# 同理添加误差线（线稍微粗一些，颜色透明）\n# Similarly, add error bars (the line is slightly thicker and the color is transparent)\nsegments(bar[4], # 在bar的第四个点，也就是红色亚组最中间的点上添加 # Add to the fourth point of the bar, which is the middle point of the red subgroup\n         avg_semi - var_semi,\n         bar[4],\n         avg_semi + var_semi, \n         lwd = 4,\n         col = ggplot2::alpha(red,0.4))\narrows(bar[4], \n       avg_semi - var_semi, \n       bar[4],\n       avg_semi + var_semi, \n       lwd = 4, angle = 90,\n       code = 3, length = 0.05,col = ggplot2::alpha(sun,0.4),lty = 2)\n\n# 同理添加manua亚组的背景透明区块和误差线\n# Similarly, add transparent background blocks and error bars for the manua subgroup\nrect(bar[7]-0.5,\n     0,\n     bar[11]+0.5,\n     avg_manu,\n     col = ggplot2::alpha(darkblue,0.1),border = NA)\nsegments(bar[9], \n         avg_manu - var_manu, \n         bar[9],\n         avg_manu + var_manu,\n         lwd = 4,col = ggplot2::alpha(darkblue,0.4))\narrows(bar[9], \n       avg_manu - var_manu, \n       bar[9],\n       avg_manu + var_manu, lwd = 4, angle = 90,\n       code = 3, length = 0.05,col = ggplot2::alpha(darkblue,0.4),lty = 2)\n\n# 添加P值，觉得坐标调整麻烦的可以直接在AI里画\n# Add P value. If you find it troublesome to adjust the coordinates, you can draw it directly in AI.\n# full vs semi\npar(xpd = F)\nsegments(bar[1],73,bar[4]-0.05,73) # 这里的坐标，主要是高度要耐心调整 # The coordinates here are mainly about the height. Please adjust them patiently.\nsegments(bar[1],73,bar[1],71)\nsegments(bar[4]-0.05,73,bar[4]-0.05,71)\ntext(x = (bar[1]+bar[4])/2,\n     y = 75,\n     ifelse(fvss.t < 0.001,\"P < 0.001\",\n            paste0(\"P = \",round(fvss.t,3))),\n     cex = 0.8)\n\n# semi vs manul\nsegments(bar[4]+0.05,73,bar[9],73)\nsegments(bar[4]+0.05,73,bar[4]+0.05,71)\nsegments(bar[9],73,bar[9],71)\ntext(x = (bar[4]+bar[9])/2,\n     y = 75,\n     ifelse(svsm.t < 0.001,\"P < 0.001\",\n            paste0(\"P = \",round(svsm.t,3))),\n     cex = 0.8)\n\n# full vs manul\nsegments(bar[1],78,bar[9],78)\nsegments(bar[1],78,bar[1],76)\nsegments(bar[9],78,bar[9],76)\npar(xpd = T)\ntext(x = (bar[1]+bar[9])/2,\n     y = 80,\n     ifelse(fvsm.t < 0.001,\"P < 0.001\",\n            paste0(\"P = \",round(fvsm.t,3))),\n     cex = 0.8)\npar(xpd = F)\n\n# intersemi\nsegments(bar[3],67,bar[5],67)\nsegments(bar[3],67,bar[3],65)\nsegments(bar[5],67,bar[5],65)\ntext(x = bar[4],\n     y = 69,\n     ifelse(saov[[1]]$`Pr(>F)`[1] < 0.001,\"P < 0.001\",\n            paste0(\"P = \",round(saov[[1]]$`Pr(>F)`[1],3))),\n     cex = 0.8)\n\n# intermanul\nsegments(bar[7],67,bar[11],67)\nsegments(bar[7],67,bar[7],65)\nsegments(bar[11],67,bar[11],65)\ntext(x = bar[9],\n     y = 69,\n     ifelse(maov[[1]]$`Pr(>F)`[1] < 0.001,\"P < 0.001\",\n            paste0(\"P = \",round(maov[[1]]$`Pr(>F)`[1],3))),\n     cex = 0.8)\n\n# 关闭图像句柄\n# Close image handle\ninvisible(dev.off())\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa173fancybar_FigureYa173fancybar",
      "title": "FigureYa173fancybar/FigureYa173fancybar.html",
      "html": "FigureYa173fancybar/FigureYa173fancybar.html",
      "text": "texts/main_FigureYa173fancybar_FigureYa173fancybar.txt",
      "folder": "FigureYa173fancybar",
      "thumb": "gallery_compress/FigureYa173fancybar.webp"
    },
    "word_count": 1611,
    "lines_count": 312,
    "title": "FigureYa173fancybar",
    "description": "Requirement 我想实现这篇文章的Figure 4i和j，是同一种类型的图。这个图，可以比较组内的情况，然后还可以合并组内的数据，再比组间。还有这种可以直接实现出图的代码。",
    "input_data_types": [],
    "output_types": [
      "统计表格"
    ],
    "technical_methods": [
      "生存分析"
    ],
    "biology_areas": [],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "intersp",
      "header",
      "lwd",
      "width",
      "ylim",
      "new",
      "side",
      "yaxt",
      "labels",
      "legend"
    ]
  },
  {
    "id": "main_FigureYa101PCA_FigureYa101PCA",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa101PCA_FigureYa101PCA.txt",
    "content": "FigureYa101PCA\nFigureYa101PCA\nXiaofan Lu, Taojun Ye\n2025-5-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRNA-seq的PCA图，同一组用相同颜色，多次重复（批次）用不同形状。我的分组很多，3次重复，不需要像FigureYa38PCA那样画圈画箭头。\nRequirement description\nPCA plot of RNA seq, with the same color for the same group and\ndifferent shapes for multiple repetitions (batches). I have many groups\nand repeat them three times, so I don’t need to draw circles or arrows\nlike in FigureYa38PCA.\n出自\nhttp://genesdev.cshlp.org/content/32/2/96\nfrom\nhttp://genesdev.cshlp.org/content/32/2/96\n应用场景\n场景一：每个分组内的样品较多，是不同批次获得的。如果能用各种形状来区分批次的话，就能一眼看出哪个批次远离其他批次，有助于判断批次效应的影响。\n场景二：每个分组内的样品是2到n次生物学重复获得的。如果能用各种形状来区分不同重复的话，就能一眼看出哪次重复远离其他重复，有助于判断去掉哪个离群样品。\n如果想画圈和箭头，或者无法提供重复或批次batch的信息，请使用FigureYa38PCA。\n不仅限于RNA-seq，同样适用于其他类型的数据。\nApplication scenarios\nScenario 1: Each group has a large number of samples obtained from\ndifferent batches. If various shapes can be used to distinguish batches,\nit can be seen at a glance which batch is far away from other batches,\nwhich helps to determine the impact of batch effects.\nScenario 2: The samples within each group are obtained from 2 to n\nbiological replicates. If various shapes can be used to distinguish\ndifferent repetitions, it can be seen at a glance which repetition is\nfar away from other repetitions, which helps to determine which outlier\nsample to remove.\nIf you want to draw circles and arrows, or cannot provide information\non duplicates or batches, please use FigureYa38PCA.\nNot limited to RNA seq, it also applies to other types of data.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\n# 加载stringr包，提供强大的字符串处理功能\n# Load the stringr package, which provides powerful string processing functions\nlibrary(stringr)\n\n# 设置系统环境，使R显示英文错误信息\n# Set the system environment to display English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 全局选项设置：禁止将字符型变量自动转换为因子类型\n# Global option setting: Prevent automatic conversion of character variables to factors\noptions(stringsAsFactors = FALSE)\n自定义函数\n包括PCA分析过程以及出图，参数设置：\nindata 是一个矩阵，列为样本，行为观测\nbatch 是一个数据框，必须提供批次的信息，否则请使用FigureYa38PCA\nbatchvar 是批次的变量名，这里默认batch的列名\nposition 是最后出图时图例的位置，从以下位置中选择：“bottomright”,\n“bottom”, “bottomleft”, “left”, “topleft”, “top”, “topright”, “right”\nand “center”.\npch.original\n是用于映射replicate形状的，默认从pch=16实心原点开始，到pch=25，一共10种实心图案可供映射，也可以自己选择pch形状起始点，参考：\nhttp://www.sthda.com/english/wiki/r-plot-pch-symbols-the-different-point-shapes-available-in-r\nwithoutgrid\n是一个逻辑变量，指示是否要绘制背景网格（例文的图有网格，个人不推荐）\n如果想输出样本ID，可以将showID设为TRUE，但样本量大的时候不推荐，图会看不清楚\n其他参数可保持默认\n函数细节可根据需要自己修改，比如batch的形状（pch参数）\nCustom functions\nIncluding PCA analysis process and plotting, parameter settings:\n-Indata is a matrix with columns as samples and behavioral\nobservations -Batch is a data box, and batch information must be\nprovided. Otherwise, please use FigureYa38PCA -Batchvar is the variable\nname of the batch, which defaults to the column name of the batch\n-Position is the position of the legend when the final image is\ngenerated. Choose from the following positions: “bottomright”, “bottom”,\n“bottomleft”, “left”, “topleft”, “top”, “topright”, “right”, and\n“center” -PCH. Original is used to map replica shapes. By default, it\nstarts from the solid origin at PCH=16 and ends at PCH=25. There are a\ntotal of 10 solid patterns available for mapping, or you can choose your\nown starting point for the PCH shape. Please refer to:\nhttp://www.sthda.com/english/wiki/r-plot-pch-symbols-the-different-point-shapes-available-in-r\n-Withoutgrid is a logical variable that indicates whether to draw a\nbackground grid (the example image has a grid, which I personally do not\nrecommend) -If you want to output the sample ID, you can set showID to\nTRUE, but it is not recommended when the sample size is large, as the\nimage may not be clear -Other parameters can remain default -The details\nof the function can be modified as needed, such as the shape of the\nbatch (pch parameter)\n# 功能：基于主成分分析(PCA)绘制批次效应图\n# Function: Draw batch effect plot based on Principal Component Analysis (PCA)\n# 参数：\n# indata: 输入数据矩阵，行表示特征，列表示样本\n# batch: 批次信息数据框\n# batchvar: 批次变量名称，默认为批次数据框的列名\n# fig.dir: 图片输出目录\n# PCA.fig.title: PCA图的标题\n# pos1: 第一个图例的位置，默认为\"bottomright\"\n# pos2: 第二个图例的位置，默认为\"topright\"\n# xy: 要绘制的主成分，默认为前两个主成分\n# pch.orginal: 原始点的形状，默认为16\n# cols: 自定义颜色，默认为NULL\n# showID: 是否显示样本ID，默认为FALSE\n# cex: 点的大小，默认为1\n# showLegend: 是否显示图例，默认为TRUE\n# batch1move: 第一个批次图例的移动距离，默认为0.3\n# batch2move: 第二个批次图例的移动距离，默认为0.4\n# width: 图片宽度，默认为5\n# height: 图片高度，默认为5\n# withoutgrid: 是否不带网格，默认为TRUE\n# Parameters:\n# indata: Input data matrix with features as rows and samples as columns\n# batch: Data frame containing batch information\n# batchvar: Names of batch variables, default to column names of batch data frame\n# fig.dir: Directory to save figures\n# PCA.fig.title: Title for the PCA plot\n# pos1: Position of the first legend, default is \"bottomright\"\n# pos2: Position of the second legend, default is \"topright\"\n# xy: Principal components to plot, default is the first two components\n# pch.orginal: Original point shape, default is 16\n# cols: Custom colors, default is NULL\n# showID: Whether to show sample IDs, default is FALSE\n# cex: Point size, default is 1\n# showLegend: Whether to show legends, default is TRUE\n# batch1move: Movement distance for the first batch legend, default is 0.3\n# batch2move: Movement distance for the second batch legend, default is 0.4\n# width: Figure width, default is 5\n# height: Figure height, default is 5\n# withoutgrid: Whether to plot without grid, default is TRUE\npca2batch <- function(indata, batch, batchvar = colnames(batch), fig.dir, PCA.fig.title, pos1 = \"bottomright\", pos2 = \"topright\", xy=c(1,2), pch.orginal=16, cols=NULL, showID=FALSE, cex=1, showLegend=T, batch1move=0.3, batch2move=0.4, width=5, height=5, withoutgrid=TRUE) {\n \n  # 加载ClassDiscovery包，用于PCA分析\n  # Load the ClassDiscovery package for PCA analysis\n  library(ClassDiscovery) \n  \n  # 计算第一个批次变量的水平数\n  # Calculate the number of levels for the first batch variable\n  N.batch1 = length(unique(batch[,batchvar[1]]))    \n  # 计算第二个批次变量的水平数\n  # Calculate the number of levels for the second batch variable\n  N.batch2 = length(unique(batch[,batchvar[2]]))    \n  \n  # 检查是否提供了自定义颜色\n  # Check if custom colors are provided\n  if (is.null(cols)) { \n    # 如果没有，使用彩虹色\n    # If not, use rainbow colors\n    cols <- rainbow(N.batch1) \n  }else{\n    # 检查颜色数量是否与批次数量匹配\n    # Check if the number of colors matches the number of batches\n    if (length(cols) != N.batch1) {stop(\"cols length not equal to batch length\")} \n  }           \n  \n  # 移除数据中的缺失值\n  # Remove missing values from the data\n  indata=na.omit(indata)\n  # 执行PCA分析，不进行标准化\n  # Perform PCA analysis without standardization\n  pca <- SamplePCA(indata, usecor=F, center=F) \n  # 计算第一个主成分的方差解释比例\n  # Calculate the variance explained by the first principal component\n  pct1 <- round (pca@variances[xy[1]]/sum(pca@variances), digits=3)*100 \n  # 计算第二个主成分的方差解释比例\n  # Calculate the variance explained by the second principal component\n  pct2 <- round (pca@variances[xy[2]]/sum(pca@variances), digits=3)*100 \n  # 设置X轴标签文本\n  # Set X-axis label text\n  xlab.text = paste(\"PC\", xy[1], \": \", as.character(pct1), \"% variance\", sep=\"\")\n  # 设置Y轴标签文本\n  # Set Y-axis label text\n  ylab.text = paste(\"PC\", xy[2], \": \", as.character(pct2), \"% variance\", sep=\"\")\n  \n  # 根据是否需要网格绘制不同的图形\n  # Draw different plots based on whether grid is needed\n  if(withoutgrid) {\n    # 设置不带网格的输出文件名\n    # Set output file name without grid\n    outfile = file.path(fig.dir, paste(PCA.fig.title, \".withoutgrid.pdf\",sep=\"\")) \n    \n    # 创建PDF设备\n    # Create PDF device\n    pdf(file=outfile, width = width, height = height)\n    # 调整图形边距，为图例留出空间\n    # Adjust plot margins to make space for legends\n    par(mar = par()$mar + c(0,0,0,6)) \n    # 绘制PCA散点图\n    # Plot PCA scatter plot\n    plot(pca@scores[,xy[1]], pca@scores[,xy[2]], \n         cex=cex, xlab=xlab.text, ylab=ylab.text,\n         col=cols[factor(batch[,batchvar[1]])], \n         pch=(pch.orginal:(pch.orginal-1+N.batch2))[factor(batch[,batchvar[2]])])\n    # 添加水平和垂直参考线\n    # Add horizontal and vertical reference lines\n    abline(h=0, v=0, col=\"brown\", lty=2)\n  } else {\n    # 设置带网格的输出文件名\n    # Set output file name with grid\n    outfile = file.path(fig.dir, paste(PCA.fig.title, \".withgrid.pdf\",sep=\"\")) \n    \n    # 保存到PDF文件\n    # Save to PDF file\n    pdf(file=outfile, width = width, height = height)\n    # 调整图形边距，为图例留出空间\n    # Adjust plot margins to make space for legends\n    par(mar = par()$mar + c(0,0,0,6)) \n    # 先绘制一次固定视窗\n    # Plot once to fix the viewport\n    plot(pca@scores[,xy[1]], pca@scores[,xy[2]], \n         cex=cex, xlab=xlab.text, ylab=ylab.text,\n         col=cols[factor(batch[,batchvar[1]])], \n         pch=(pch.orginal:(pch.orginal-1+N.batch2))[factor(batch[,batchvar[2]])])\n    # 添加灰色背景\n    # Add gray background\n    rect(par(\"usr\")[1],par(\"usr\")[3],par(\"usr\")[2],par(\"usr\")[4],col = \"gray80\") \n    \n    # 再画一次覆盖灰色背景\n    # Plot again to cover the gray background\n    par(new=TRUE)\n    plot(pca@scores[,xy[1]], pca@scores[,xy[2]], \n         cex=cex, xlab=xlab.text, ylab=ylab.text,\n         col=cols[factor(batch[,batchvar[1]])], \n         pch=(pch.orginal:(pch.orginal-1+N.batch2))[factor(batch[,batchvar[2]])])\n    # 添加白色网格线\n    # Add white grid lines\n    grid (lty = 1, col = \"white\",lwd=2)\n  }\n  \n  # 如果showID为TRUE，则在图上显示样本ID\n  # If showID is TRUE, display sample IDs on the plot\n  if (showID) { \n    text(pca@scores[,xy[1]], pca@scores[,xy[2]], colnames(indata), lwd=1, cex=cex)\n  }\n  # 如果showLegend为TRUE，则添加图例\n  # If showLegend is TRUE, add legends\n  if(showLegend){ \n    # 允许图形绘制超出边界\n    # Allow plotting outside the plot area\n    par(xpd = TRUE) \n    # 添加第一个图例（批次1）\n    # Add the first legend (batch 1)\n    legend(pos1,fill = cols,\n           legend=names(table(factor(batch[,batchvar[1]]))),\n           inset=c(-batch1move,0), \n           border = NA,bty = \"n\")\n    # 添加第二个图例（批次2）\n    # Add the second legend (batch 2)\n    legend(pos2,legend=names(table(factor(batch[,batchvar[2]]))),\n           border = NA,bty = \"n\",\n           inset=c(-batch2move,0), \n           pch = (pch.orginal:(pch.orginal-1+N.batch2)))\n  }\n  # 关闭图形设备\n  # Close the graphics device\n  invisible(dev.off())\n}\n下面根据场景举两个列子，便于小伙伴儿模仿。\nBelow are two columns based on the scene for easy imitation by\nfriends.\n场景一，多个批次\n输入文件\n需要两个输入文件：\neasy_input_expr.csv，表达矩阵，包含多个基因在多个样本中的表达量。\neasy_input_batch.csv，样品信息，第一列样品名，跟表达矩阵一致；后面两列是分组（batch1）和批次（batch2）。\nScenario 1, Multiple Batches\nInput file\nTwo input files are required:\neasy_input_expr.csv， Expression matrix, containing the\nexpression levels of multiple genes in multiple samples.\neasy_input_batch.csv， Sample information, first column sample\nname, consistent with the expression matrix; The last two columns are\ngrouping (batch1) and batch (batch2).\n# 读取表达矩阵数据\n# Read expression matrix data\ndf <- read.csv(\"easy_input_expr.csv\",header = T,row.names = 1,check.names = F, stringsAsFactors = F)\n# 查看表达矩阵前3行3列的数据\n# View the first 3 rows and 3 columns of the expression matrix\ndf[1:3,1:3]\n# 读取样本批次信息\n# Read sample batch information\nbatch <- read.csv(\"easy_input_batch.csv\",header = T, row.names = 1, check.names = F,stringsAsFactors = F)\n# 查看批次信息前几行\n# View the first few rows of the batch information\nhead(batch)\n# 根据需要决定是否进行标准化处理\n# Decide whether to perform standardization according to your needs\n# 注意：scale函数默认对列进行操作，因此需要两次转置\n# Note: The scale function operates on columns by default, so two transpositions are needed\nindata <- as.data.frame(t(scale(t(df),center = T,scale = T)))\n# 查看标准化后的数据前3行3列\n# View the first 3 rows and 3 columns of the standardized data\nindata[1:3,1:3]\n调用函数画图\nCall function drawing\n# 自定义颜色\n# Define custom colors\n# 定义足够多的颜色，用于展示分组\n# Define enough colors to display different groups\nmycol <- c(\"#223D6C\",\"#D20A13\",\"#088247\",\"#FFD121\",\"#11AA4D\",\"#58CDD9\",\"#7A142C\",\"#5D90BA\",\"#431A3D\",\"#91612D\",\"#6E568C\",\"#E0367A\",\"#D8D155\",\"#64495D\",\"#7CC767\")\n\n# 直接出图 - 带网格背景的PCA图\n# Generate PCA plot directly - with grid background\npca2batch(\n  indata = indata[, rownames(batch)],  # 使用匹配批次信息的表达数据 / Use expression data matching batch info\n  batch = batch,                      # 批次信息数据框 / Batch information data frame\n  fig.dir = \".\",                      # 保存在当前文件夹 / Save in current directory\n  PCA.fig.title = \"PCA.2batches\",     # PCA图标题 / PCA plot title\n  cols = mycol[1:length(unique(batch$batch1))],  # 使用自定义颜色 / Use custom colors\n  showID = F,                         # 不显示样本ID / Do not show sample IDs\n  cex = 0.8,                          # 点的大小 / Point size\n  showLegend = T,                     # 显示图例 / Show legend\n  width = 6, height = 5,              # 图片宽高 / Image dimensions (width, height)\n  pos1 = \"bottomright\", pos2 = \"topright\", # 图例位置 / Legend positions\n  withoutgrid = F                     # 有网格背景（示例） / With grid background (example)\n)\n# 直接出图 - 不带网格背景的PCA图\n# Generate PCA plot directly - without grid background\npca2batch(\n  indata = indata[, rownames(batch)],  # 使用匹配批次信息的表达数据 / Use expression data matching batch info\n  batch = batch,                      # 批次信息数据框 / Batch information data frame\n  fig.dir = \".\",                      # 保存在当前文件夹 / Save in current directory\n  PCA.fig.title = \"PCA.2batches\",     # PCA图标题 / PCA plot title\n  cols = mycol[1:length(unique(batch$batch1))],  # 使用自定义颜色 / Use custom colors\n  showID = F,                         # 不显示样本ID / Do not show sample IDs\n  cex = 0.8,                          # 点的大小 / Point size\n  showLegend = T,                     # 显示图例 / Show legend\n  width = 6, height = 5,              # 图片宽高 / Image dimensions (width, height)\n  pos1 = \"bottomright\", pos2 = \"topright\", # 图例位置 / Legend positions\n  withoutgrid = T                     # 无网格背景（推荐） / No grid background (recommended)\n)\n场景二，多次生物学重复\n输入文件\nGSE125184_CCAB_RPKM_ExpMatrix.csv，基因表达矩阵，行为基因，列为sample。下载自\nhttps://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE125184\n，解压缩，跟FigureYa98STEMheatmap是同一套输入数据。\neasy_input_meta.csv，样品信息，包括分组condition和重复的批次（batch）。\nScenario 2: Multiple biological repetitions\nInput file\nGSE125184_CCAB_RPKM_ExpMatrix.csv， Gene expression matrix,\nbehavioral genes, listed as samples. Download from<\nhttps://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE125184\n>Decompress, it is the same set of input data as\nFigureYa98STEMheatmap.\neasy_input_meta.csv， Sample information, including grouping\nconditions and repeated batches.\n# 默认图例会根据分组名字按字母排序\n# By default, the legend will be sorted alphabetically by group names\n\n# 下面按照自己想要的顺序排序\n# Sort the groups in a custom order as follows\n\n# 将metadata数据框中的condition列转换为因子类型，并指定因子水平的顺序\n# Convert the 'condition' column in the metadata data frame to a factor, \n# and specify the order of the factor levels\nmetadata$condition <- factor(metadata$condition, levels = c(\"VM\", \"H\", \"P1\", \"P2\", \"YFB-S\", \"YFB-C\", \"YFB-L\", \"FB-S\", \"FB-CL\"))\n调用函数画图\nCall function drawing\n# 定义足够多的颜色，用于展示分组\n# Define sufficient colors for displaying different groups\nmycol <- c(\"#223D6C\",\"#D20A13\",\"#088247\",\"#FFD121\",\"#11AA4D\",\"#58CDD9\",\"#7A142C\",\"#5D90BA\",\"#431A3D\",\"#91612D\",\"#6E568C\",\"#E0367A\",\"#D8D155\",\"#64495D\",\"#7CC767\")\n\n# 直接出图\n# Directly generate PCA plot\npca2batch(\n  indata = expr[, rownames(metadata)],  # 表达矩阵，选取与metadata匹配的样本 / Expression matrix, select samples matching metadata\n  batch = metadata,  # 样品信息数据框 / Sample metadata data frame\n  pch.orginal = 15,  # 起始点形状为15（正方形） / Starting point shape (15 = square)\n  fig.dir = \".\",  # 图片保存路径为当前目录 / Save figures to current directory\n  PCA.fig.title = \"PCA.replicates\",  # PCA图标题 / PCA plot title\n  cols = mycol[1:length(unique(metadata$condition))],  # 为不同条件分配颜色 / Assign colors to different conditions\n  showID = F,  # 是否显示样本ID（如需显示则改为T） / Show sample IDs (change to T to display)\n  cex = 0.8,  # 点和文字大小 / Point and text size\n  showLegend = T,  # 是否显示图例 / Show legend\n  width = 6, height = 5,  # 图片宽高（英寸） / Figure dimensions (inches)\n  batch1move = 0.3,  # 微调第一个图例的位置 / Fine-tune position of first legend\n  batch2move = 0.36,  # 微调第二个图例的位置 / Fine-tune position of second legend\n  pos1 = \"topright\", pos2 = \"bottomright\",  # 两个图例的位置 / Positions of two legends\n  withoutgrid = T  # 无网格背景（推荐设置） / No grid background (recommended)\n)\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa101PCA_FigureYa101PCA",
      "title": "FigureYa101PCA/FigureYa101PCA.html",
      "html": "FigureYa101PCA/FigureYa101PCA.html",
      "text": "texts/main_FigureYa101PCA_FigureYa101PCA.txt",
      "folder": "FigureYa101PCA",
      "thumb": "gallery_compress/FigureYa101PCA.webp"
    },
    "word_count": 2004,
    "lines_count": 382,
    "title": "FigureYa101PCA",
    "description": "RNA-seq的PCA图，同一组用相同颜色，多次重复（批次）用不同形状。我的分组很多，3次重复，不需要像FigureYa38PCA那样画圈画箭头。 Requirement description PCA plot of RNA seq, with the same color for the same group and",
    "input_data_types": [
      "临床数据",
      "表达矩阵"
    ],
    "output_types": [
      "散点图",
      "热图",
      "统计表格",
      "PCA图"
    ],
    "technical_methods": [
      "主成分分析",
      "标准化"
    ],
    "biology_areas": [],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "outfile",
      "acc",
      "center",
      "header",
      "lwd",
      "width",
      "new",
      "usecor",
      "batch2"
    ]
  },
  {
    "id": "main_FigureYa147Plus_STRING_FigureYa147Plus_STRING",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa147Plus_STRING_FigureYa147Plus_STRING.txt",
    "content": "FigureYa147Plus_STRING\nFigureYa147Plus_STRING\nAuthor(s)\n: Zongcheng Li, Ying Ge\nDate\n: 2025-10-23\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\nTo cite database ‘STRING’ in publications use:\nSzklarczyk D, Kirsch R, Koutrouli M, Nastou K, Mehryary F, Hachilif\nR, Annika GL, Fang T, Doncheva NT, Pyysalo S, Bork P‡, Jensen LJ‡, von\nMering C‡. The STRING database in 2023: protein–protein association\nnetworks and functional enrichment analyses for any sequenced genome of\ninterest. Nucleic Acids Res. 2023 Jan 6;51(D1):D638-646.\n需求描述\nRequirements description\n用STRING数据库的查询结果作为输入，画出FigureYa147interaction那样的图。\n应用场景\nApplication scenarios\n展示相互作用关系，同时展示相互作用证据的来源和打分。 Show the\ninteraction relationship, and at the same time show the source and score\nof the interaction evidence.\n像例文中的蛋白相互作用，或转录因子-靶基因，或miRNA-靶基因的关系。\nLike the protein interaction in the example text, or the relationship\nbetween transcription factor-target gene, or miRNA-target gene.\n其中转录因子-靶基因的关系可以这样设计：中央画转录因子，周围画靶基因；连线代表各种证据例如有motif、有ATAC-seq的peak、有H3K27ac的peak等等；自己给这些证据权重，计算一个总体的打分作为连线的长度。\nThe relationship between transcription factor-target gene can be\ndesigned as follows: draw the transcription factor in the center and the\ntarget gene around it; the connecting line represents various evidences\nsuch as motif, ATAC-seq peak, H3K27ac peak, etc.; give these evidence\nweights by yourself and calculate an overall score as the length of the\nconnecting line.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nlibrary(tidyr)                # 加载tidyr包｜Load tidyr package\nlibrary(scales)               # 加载scales包｜Load scales package\nlibrary(ggplot2)              # 加载绘图包｜Load plotting package\nlibrary(reshape2)             # 加载数据重塑包｜Load data reshaping package\nlibrary(igraph)               # 加载网络分析包｜Load network analysis package\nlibrary(magrittr)             # 加载管道操作包｜Load pipe operator package\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 #Display English error message\noptions(stringsAsFactors = FALSE) #禁止chr转成factor #Disable chr conversion to factor\n自定义画图函数 Custom drawing function\nmycircle <- function(coords, v=NULL, params) {\n  vertex.color <- params(\"vertex\", \"color\")\n  if (length(vertex.color) != 1 && !is.null(v)) {\n    vertex.color <- vertex.color[v]\n  }\n  vertex.size  <- 1/200 * params(\"vertex\", \"size\")\n  if (length(vertex.size) != 1 && !is.null(v)) {\n    vertex.size <- vertex.size[v]\n  }\n  vertex.frame.color <- params(\"vertex\", \"frame.color\")\n  if (length(vertex.frame.color) != 1 && !is.null(v)) {\n    vertex.frame.color <- vertex.frame.color[v]\n  }\n  vertex.frame.width <- params(\"vertex\", \"frame.width\")\n  if (length(vertex.frame.width) != 1 && !is.null(v)) {\n    vertex.frame.width <- vertex.frame.width[v]\n  }\n  \n  mapply(coords[,1], coords[,2], vertex.color, vertex.frame.color,\n         vertex.size, vertex.frame.width,\n         FUN=function(x, y, bg, fg, size, lwd) {\n           symbols(x=x, y=y, bg=bg, fg=fg, lwd=lwd,\n                   circles=size, lheight = 30, add=TRUE, inches=FALSE)\n         })\n}\n\n# Define new vertex shape \"fcircle\" (filled circle with border)\nadd.vertex.shape(\"fcircle\", clip=igraph.shape.noclip,\n         plot=mycircle, parameters=list(vertex.frame.color=\"white\", # 或 \"black\"｜Or \"black\"\n                                  vertex.frame.width=2)) # 边框宽度为2｜Border width = 2\n参数设置\nParameter settings\n# Give your focus official gene_symbol\nsourceGene <- \"FOXP3\"\n\n# Given name will be shown on the plot instead.\nsourceName <- \"FOXP3\"\n输入文件\nInput file\nSTRING数据库\nhttps://string-db.org\n，点击STRING chat。\n输入：“show me a table of proteins interact with FoxP3 in human, with\nscore > 0.8, including four columns: FoxP3, the other protein,\nlocation, score”\n把表格复制到txt文件，命名为easy_input.txt。\n开始画图\nStart drawing\n用igraph画图 Drawing with igraph\n# 读取相互作用关系和score\n# Read the interaction relationship and score\n\nlinks <- read.table(\"easy_input.txt\", header = TRUE, sep = \"\\t\")\ncolnames(links) <- c(\"source\", \"target\", \"Loc\", \"score\")\n# 把score归一化｜Rescale score\n#links$score <- rescale(links$score, to = c(1, 10))\n\n# 拆分Loc列｜Split Loc column\nlinks <- separate_rows(links, Loc, sep = \", \")\nhead(links)\nnet <- graph_from_data_frame(links, directed = F)\n\nn_loc <- length(unique(links$Loc))\npal_loc <- setNames(RColorBrewer::brewer.pal(n_loc, name = \"Set1\"), sort(unique(links$Loc)))\n\n# see plot.igraph for more settings \nvertexes <- get.vertex.attribute(net, \"name\")\nnet %<>% \n  set.vertex.attribute(\"label\", \n                       value = ifelse(vertexes == sourceGene, \n                                      sourceName, vertexes)) %<>%\n  set.edge.attribute(\"color\", \n                     value = pal_loc[links$Loc]) %<>%\n  set.edge.attribute(\"weight\", \n                     value = links$score)\nset.seed(777)\nlay <- layout_with_dh(net) #weight.node.dist = unique(links[,c(\"target\",\"score\")])$score) # weight here may be invalid!\n\n# plot in SVG device, then you may use Adobe Illustrator \n# to fine tune the network map. \n# Such as adjust the text position to avoid overlapping.\n\npdf(file = \"interaction.pdf\", width = 6, height = 8)\nplot(net, layout = lay, \n     vertex.shape = 'fcircle',\n     vertex.size = ifelse(vertexes == sourceGene, 15, 3),\n     vertex.color = \"hotpink\",\n     vertex.frame.color = ggplot2::alpha(\"white\", alpha = 0.5),\n     vertex.frame.width = ifelse(vertexes == sourceGene, 30, 0.1),\n     vertex.label.color = ifelse(vertexes == sourceGene, \"black\", \"grey30\"),\n     vertex.label.family = \"sans\",\n     vertex.label.cex = ifelse(vertexes == sourceGene, 0.9, 0.6),\n     edge.curved = curve_multiple(net, start = 0.06))\n     # fine tune \"start\" to get better visual effect. To shrink multiple edges using smaller value.\nlegend(-1, -1, legend= names(pal_loc),\n       col= pal_loc, lty=1, cex=0.6,\n       box.lty=1, box.lwd=1, box.col=\"black\")\ndev.off()\n后期处理\nPost-processing\nUse Adobe Illustrator to fine tune the network map. Such as adjust\nthe text position to avoid overlapping.\nWant to learn more about network visualization with R?\nGO to\nhttps://kateto.net/tutorials/\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa147Plus_STRING_FigureYa147Plus_STRING",
      "title": "FigureYa147Plus_STRING/FigureYa147Plus_STRING.html",
      "html": "FigureYa147Plus_STRING/FigureYa147Plus_STRING.html",
      "text": "texts/main_FigureYa147Plus_STRING_FigureYa147Plus_STRING.txt",
      "folder": "FigureYa147Plus_STRING",
      "thumb": "gallery_compress/FigureYa147Plus_STRING.webp"
    },
    "word_count": 708,
    "lines_count": 155,
    "title": "FigureYa147Plus_STRING",
    "description": "Requirements description 用STRING数据库的查询结果作为输入，画出FigureYa147interaction那样的图。 应用场景",
    "input_data_types": [],
    "output_types": [
      "统计表格",
      "网络图"
    ],
    "technical_methods": [
      "网络分析",
      "motif分析"
    ],
    "biology_areas": [],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "add",
      "to",
      "lheight",
      "inches",
      "header",
      "lwd",
      "width",
      "directed",
      "bg"
    ]
  },
  {
    "id": "main_FigureYa309cell2location_04_cell2location_plot",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa309cell2location_04_cell2location_plot.txt",
    "content": "04_cell2location_plot\nIn [1]:\nimport\nscanpy\nas\nsc\nimport\nnumpy\nas\nnp\nimport\npandas\nas\npd\nimport\nmatplotlib.pyplot\nas\nplt\nimport\nmatplotlib\nas\nmpl\nimport\ncell2location\nfrom\nmatplotlib\nimport\nrcParams\nrcParams\n[\n'pdf.fonttype'\n]\n=\n42\n# enables correct plotting of text for PDFs\nIn [2]:\nresults_folder\n=\n'./results/'\n# create paths and names to results folders for reference regression and cell2location models\nrun_name\n=\nf\n'\n{\nresults_folder\n}\n/cell2location_map'\nIn [3]:\nadata_file\n=\nf\n\"\n{\nrun_name\n}\n/sp.h5ad\"\nadata_vis\n=\nsc\n.\nread_h5ad\n(\nadata_file\n)\nIn [4]:\nadata_vis\nOut[4]:\nIn [5]:\n# add 5% quantile, representing confident cell abundance, 'at least this amount is present',\n# to adata.obs with nice names for plotting\nadata_vis\n.\nobs\n[\nadata_vis\n.\nuns\n[\n'mod'\n][\n'factor_names'\n]]\n=\nadata_vis\n.\nobsm\n[\n'q05_cell_abundance_w_sf'\n]\n当前Anndata对象中包括了不止一张切片的数据\nIn [6]:\nadata_vis\n.\nobs\n[[\n\"sample\"\n,\n\"donor_id\"\n]]\n.\nvalue_counts\n()\nOut[6]:\nIn [12]:\nlist\n(\nadata_vis\n.\nobs\n.\ncolumns\n)\nOut[12]:\nFigure 7F\n¶\nIn [13]:\n# select one slide\nfrom\ncell2location.utils\nimport\nselect_slide\nslide\n=\nselect_slide\n(\nadata_vis\n,\n'6800STDY12499411'\n)\n# plot in spatial coordinates\nwith\nmpl\n.\nrc_context\n({\n'axes.facecolor'\n:\n'black'\n,\n'figure.figsize'\n:\n[\n4.5\n,\n5\n]}):\nsc\n.\npl\n.\nspatial\n(\nslide\n,\ncmap\n=\n'magma'\n,\n# show first 8 cell types\ncolor\n=\n[\n'EMT'\n,\n'PT'\n],\nncols\n=\n2\n,\nsize\n=\n1.3\n,\nimg_key\n=\n'hires'\n,\n# limit color scale at 99.2% quantile of cell abundance\nvmin\n=\n0\n,\nvmax\n=\n'p99.2'\n)\nFigure S5D\n¶\nIn [14]:\n# select one slide\nfrom\ncell2location.utils\nimport\nselect_slide\nslide\n=\nselect_slide\n(\nadata_vis\n,\n'6800STDY12499506'\n)\n# plot in spatial coordinates\nwith\nmpl\n.\nrc_context\n({\n'axes.facecolor'\n:\n'black'\n,\n'figure.figsize'\n:\n[\n4.5\n,\n5\n]}):\nsc\n.\npl\n.\nspatial\n(\nslide\n,\ncmap\n=\n'magma'\n,\n# show first 8 cell types\ncolor\n=\n[\n'TR Mac.1'\n,\n'TR Mac.2'\n,\n'TR Mac.3'\n,\n'MHC-II TAM'\n],\nncols\n=\n2\n,\nsize\n=\n1.3\n,\nimg_key\n=\n'hires'\n,\n# limit color scale at 99.2% quantile of cell abundance\nvmin\n=\n0\n,\nvmax\n=\n'p99.2'\n)\nFigure 7B\n¶\nIn [15]:\n# plot in spatial coordinates\nwith\nmpl\n.\nrc_context\n({\n'axes.facecolor'\n:\n'black'\n,\n'figure.figsize'\n:\n[\n4.5\n,\n5\n]}):\nsc\n.\npl\n.\nspatial\n(\nslide\n,\ncmap\n=\n'magma'\n,\n# show first 8 cell types\ncolor\n=\n[\n'EMT'\n,\n'PT'\n,\n'TR Mac.2'\n,\n'LoH ATL'\n],\nncols\n=\n2\n,\nsize\n=\n1.3\n,\nimg_key\n=\n'hires'\n,\n# limit color scale at 99.2% quantile of cell abundance\nvmin\n=\n0\n,\nvmax\n=\n'p99.2'\n)\nIn [28]:\n# Now we use cell2location plotter that allows showing multiple cell types in one panel\nfrom\ncell2location.plt\nimport\nplot_spatial\n# select up to 6 clusters\nclust_labels\n=\n[\n'PT'\n,\n'EMT'\n,\n'LoH ATL'\n,\n'TR Mac.2'\n]\nclust_col\n=\n[\n''\n+\nstr\n(\ni\n)\nfor\ni\nin\nclust_labels\n]\n# in case column names differ from labels\n# slide = select_slide(adata_vis, '6800STDY12499507')\nwith\nmpl\n.\nrc_context\n({\n'figure.figsize'\n:\n(\n15\n,\n15\n)}):\nfig\n=\nplot_spatial\n(\nadata\n=\nslide\n,\n# labels to show on a plot\ncolor\n=\nclust_col\n,\nlabels\n=\nclust_labels\n,\nshow_img\n=\nTrue\n,\n# 'fast' (white background) or 'dark_background'\nstyle\n=\n'fast'\n,\n# limit color scale at 99.2% quantile of cell abundance\nmax_color_quantile\n=\n0.992\n,\n# size of locations (adjust depending on figure size)\ncircle_diameter\n=\n6\n,\ncolorbar_position\n=\n'right'\n)\nfig\n# plt.savefig('figure_cell2location.pdf')\nOut[28]:\nIn [ ]:",
    "chapter_info": {
      "id": "main_FigureYa309cell2location_04_cell2location_plot",
      "title": "FigureYa309cell2location/04_cell2location_plot.html",
      "html": "FigureYa309cell2location/04_cell2location_plot.html",
      "text": "texts/main_FigureYa309cell2location_04_cell2location_plot.txt",
      "folder": "FigureYa309cell2location",
      "thumb": "gallery_compress/FigureYa309cell2location.webp"
    },
    "word_count": 604,
    "lines_count": 421,
    "title": "In [1]:",
    "description": "暂无描述",
    "input_data_types": [],
    "output_types": [],
    "technical_methods": [],
    "biology_areas": [],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "adata_vis",
      "labels",
      "circle_diameter",
      "colorbar_position",
      "vmax",
      "style",
      "show_img",
      "max_color_quantile",
      "run_name",
      "color"
    ]
  },
  {
    "id": "main_FigureYa104GEOmining_GEO_citations",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa104GEOmining_GEO_citations.txt",
    "content": "GEO accession\nPMID\nJournal\n2017/2018 Impact Factor\nYear\nTitle\nAuthors\nGSE94856\n28867486\nDev. Cell\n9.616\n2017\nYAP/TAZ Orchestrate VEGF Signaling during Developmental Angiogenesis.\nWang X, Freire Valls A, Schermann G, Shen Y, Moya IM, Castro L, Urban S, Solecki GM, Winkler F, Riedemann L, Jain RK, Mazzone M, Schmidt T, Fischer T, Halder G and Ruiz de Almodóvar C\nGSE102409\n30224758\nNat. Med.\n32.621\n2018\nTranscriptional addiction in cancer cells is mediated by YAP/TAZ through BRD4.\nZanconato F, Battilana G, Forcato M, Filippi L, Azzolin L, Manfrin A, Quaranta E, Di Biagio D, Sigismondo G, Guzzardo V, Lejeune P, Haendler B, Krijgsveld J, Fassan M, Bicciato S, Cordenonsi M and Piccolo S\nGSE102406\n30224758\nNat. Med.\n32.621\n2018\nTranscriptional addiction in cancer cells is mediated by YAP/TAZ through BRD4.\nZanconato F, Battilana G, Forcato M, Filippi L, Azzolin L, Manfrin A, Quaranta E, Di Biagio D, Sigismondo G, Guzzardo V, Lejeune P, Haendler B, Krijgsveld J, Fassan M, Bicciato S, Cordenonsi M and Piccolo S\nGSE107013\n30082728\nNat Commun\n12.353\n2018\nTRPS1 shapes YAP/TEAD-dependent transcription in breast cancer cells.\nElster D, Tollot M, Schlegelmilch K, Ori A, Rosenwald A, Sahai E and von Eyss B\nGSE102638\n29966764\nBiochim Biophys Acta Gene Regul Mech\n-NA-\n2018\nEnhancer-driven transcriptional regulation is a potential key determinant for human visceral and subcutaneous adipocytes.\nLiefke R, Bokelmann K, Ghadimi BM and Dango S\nGSE99202\n29269485\nGenes Dev.\n-NA-\n2017\nYAP repression of the\nEstarás C, Hsu HT, Huang L and Jones KA\nGSE99202\n30449705\nStem Cell Reports\n-NA-\n2018\nSpecifying the Anterior Primitive Streak by Modulating YAP1 Levels in Human Pluripotent Stem Cells.\nHsu HT, Estarás C, Huang L and Jones KA\nGSE97972\n28673931\nEMBO J.\n10.557\n2017\nMechanical cue-induced YAP instructs Skp2-dependent cell cycle exit and oncogenic signaling.\nJang W, Kim T, Koo JS, Kim SK and Lim DS\nGSE92739\n28671673\nOncogene\n6.854\n2017\nEWS-FLI1 perturbs MRTFB/YAP-1/TEAD target gene regulation inhibiting cytoskeletal autoregulatory feedback in Ewing sarcoma.\nKatschnig AM, Kauer MO, Schwentner R, Tomazou EM, Mutz CN, Linder M, Sibilia M, Alonso J, Aryee DNT and Kovar H\nGSE92738\n28671673\nOncogene\n6.854\n2017\nEWS-FLI1 perturbs MRTFB/YAP-1/TEAD target gene regulation inhibiting cytoskeletal autoregulatory feedback in Ewing sarcoma.\nKatschnig AM, Kauer MO, Schwentner R, Tomazou EM, Mutz CN, Linder M, Sibilia M, Alonso J, Aryee DNT and Kovar H\nGSE92737\n28671673\nOncogene\n6.854\n2017\nEWS-FLI1 perturbs MRTFB/YAP-1/TEAD target gene regulation inhibiting cytoskeletal autoregulatory feedback in Ewing sarcoma.\nKatschnig AM, Kauer MO, Schwentner R, Tomazou EM, Mutz CN, Linder M, Sibilia M, Alonso J, Aryee DNT and Kovar H\nGSE92741\n28671673\nOncogene\n6.854\n2017\nEWS-FLI1 perturbs MRTFB/YAP-1/TEAD target gene regulation inhibiting cytoskeletal autoregulatory feedback in Ewing sarcoma.\nKatschnig AM, Kauer MO, Schwentner R, Tomazou EM, Mutz CN, Linder M, Sibilia M, Alonso J, Aryee DNT and Kovar H\nGSE97661\n29638227\nNat. Methods\n26.919\n2018\nA toolbox of immunoprecipitation-grade monoclonal antibodies to human transcription factors.\nVenkataraman A, Yang K, Irizarry J, Mackiewicz M, Mita P, Kuang Z, Xue L, Ghosh D, Liu S, Ramos P, Hu S, Bayron Kain D, Keegan S, Saul R, Colantonio S, Zhang H, Behn FP, Song G, Albino E, Asencio L, Ramos L, Lugo L, Morell G, Rivera J, Ruiz K, Almodovar R, Nazario L, Murphy K, Vargas I, Rivera-Pacheco ZA, Rosa C, Vargas M, McDade J, Clark BS, Yoo S, Khambadkone SG, de Melo J, Stevanovic M, Jiang L, Li Y, Yap WY, Jones B, Tandon A, Campbell E, Montelione GT, Anderson S, Myers RM, Boeke JD, Fenyö D, Whiteley G, Bader JS, Pino I, Eichinger DJ, Zhu H and Blackshaw S\nGSE90967\n28211448\nNat Commun\n12.353\n2017\nCX-5461 is a DNA G-quadruplex stabilizer with selective lethality in BRCA1/2 deficient tumours.\nXu H, Di Antonio M, McKinney S, Mathew V, Ho B, O'Neil NJ, Santos ND, Silvester J, Wei V, Garcia J, Kabeer F, Lai D, Soriano P, Banáth J, Chiu DS, Yap D, Le DD, Ye FB, Zhang A, Thu K, Soong J, Lin SC, Tsai AH, Osako T, Algara T, Saunders DN, Wong J, Xian J, Bally MB, Brenton JD, Brown GW, Shah SP, Cescon D, Mak TW, Caldas C, Stirling PC, Hieter P, Balasubramanian S and Aparicio S\nGSE88861\n28041841\nCancer Cell\n22.844\n2017\nACTL6A Is Co-Amplified with p63 in Squamous Cell Carcinoma to Drive YAP Activation, Regenerative Proliferation, and Poor Prognosis.\nSaladi SV, Ross K, Karaayvaz M, Tata PR, Mou H, Rajagopal J, Ramaswamy S and Ellisen LW\nGSE88859\n28041841\nCancer Cell\n22.844\n2017\nACTL6A Is Co-Amplified with p63 in Squamous Cell Carcinoma to Drive YAP Activation, Regenerative Proliferation, and Poor Prognosis.\nSaladi SV, Ross K, Karaayvaz M, Tata PR, Mou H, Rajagopal J, Ramaswamy S and Ellisen LW\nGSE78688\n27830782\nNature\n41.577\n2016\nEvolution of Osteocrin as an activity-regulated factor in the primate brain.\nAtaman B, Boulting GL, Harmin DA, Yang MG, Baker-Salisbury M, Yap EL, Malik AN, Mei K, Rubin AA, Spiegel I, Durresi E, Sharma N, Hu LS, Pletikos M, Griffith EC, Partlow JN, Stevens CR, Adli M, Chahrour M, Sestan N, Walsh CA, Berezovskii VK, Livingstone MS and Greenberg ME\nGSE66252\n26678338\nCancer Cell\n22.844\n2015\nA MYC-Driven Change in Mitochondrial Dynamics Limits YAP/TAZ Function in Mammary Epithelial Cells and Breast Cancer.\nvon Eyss B, Jaenicke LA, Kortlever RM, Royla N, Wiese KE, Letschert S, McDuffus LA, Sauer M, Rosenwald A, Evan GI, Kempa S and Eilers M\nGSE68296\n26439301\nMol. Cell\n14.248\n2015\nYAP Drives Growth by Controlling Transcriptional Pause Release from Dynamic Enhancers.\nGalli GG, Carrara M, Yuan WC, Valdes-Quezada C, Gurung B, Pepe-Mooney B, Zhang T, Geeven G, Gray NS, de Laat W, Calogero RA and Camargo FD\nGSE68170\n26439301\nMol. Cell\n14.248\n2015\nYAP Drives Growth by Controlling Transcriptional Pause Release from Dynamic Enhancers.\nGalli GG, Carrara M, Yuan WC, Valdes-Quezada C, Gurung B, Pepe-Mooney B, Zhang T, Geeven G, Gray NS, de Laat W, Calogero RA and Camargo FD\nGSE68388\n26439301\nMol. Cell\n14.248\n2015\nYAP Drives Growth by Controlling Transcriptional Pause Release from Dynamic Enhancers.\nGalli GG, Carrara M, Yuan WC, Valdes-Quezada C, Gurung B, Pepe-Mooney B, Zhang T, Geeven G, Gray NS, de Laat W, Calogero RA and Camargo FD\nGSE62272\n26439301\nMol. Cell\n14.248\n2015\nYAP Drives Growth by Controlling Transcriptional Pause Release from Dynamic Enhancers.\nGalli GG, Carrara M, Yuan WC, Valdes-Quezada C, Gurung B, Pepe-Mooney B, Zhang T, Geeven G, Gray NS, de Laat W, Calogero RA and Camargo FD\nGSE66081\n26258633\nNat. Cell Biol.\n19.064\n2015\nGenome-wide association between YAP/TAZ/TEAD and AP-1 at enhancers drives oncogenic growth.\nZanconato F, Forcato M, Battilana G, Azzolin L, Quaranta E, Bodega B, Rosato A, Bicciato S, Cordenonsi M and Piccolo S\nGSE64758\n25936800\nMol. Cell\n14.248\n2015\nSMADs and YAP compete to control elongation of β-catenin:LEF-1-recruited RNAPII during hESC differentiation.\nEstarás C, Benner C and Jones KA\nGSE55186\n25087979\nCancer Cell\n22.844\n2014\nThe Hippo transducer YAP1 transforms activated satellite cells and is a potent effector of embryonal rhabdomyosarcoma formation.\nTremblay AM, Missiaglia E, Galli GG, Hettmer S, Urcia R, Carrara M, Judson RN, Thway K, Nadal G, Selfe JL, Murray G, Calogero RA, De Bari C, Zammit PS, Delorenzi M, Wagers AJ, Shipley J, Wackerhage H and Camargo FD\nGSE52437\n24332857\nCell Rep\n8.032\n2013\nSwitch enhancers interpret TGF-β and Hippo signaling to control cell fate in human embryonic stem cells.\nBeyer TA, Weiss A, Khomchuk Y, Huang K, Ogunjimi AA, Varelas X and Wrana JL",
    "chapter_info": {
      "id": "main_FigureYa104GEOmining_GEO_citations",
      "title": "FigureYa104GEOmining/GEO_citations.html",
      "html": "FigureYa104GEOmining/GEO_citations.html",
      "text": "texts/main_FigureYa104GEOmining_GEO_citations.txt",
      "folder": "FigureYa104GEOmining",
      "thumb": "gallery_compress/FigureYa104GEOmining.webp"
    },
    "word_count": 1221,
    "lines_count": 189,
    "title": "GEO accession",
    "description": "暂无描述",
    "input_data_types": [],
    "output_types": [],
    "technical_methods": [],
    "biology_areas": [
      "癌症研究",
      "发育生物学",
      "神经科学"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": []
  },
  {
    "id": "main_FigureYa146TMEbox_FigureYa146TMEbox",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa146TMEbox_FigureYa146TMEbox.txt",
    "content": "FigureYa146TMEbox\nFigureYa146TMEbox\nAuthor(s)\n: Dongqiang Zeng\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n计算免疫微环境TMEscore，画出对比的box plot，标出差异显著性。\nCalculate the immune microenvironment TMEscore, draw a comparative box\nplot, and mark the significance of the difference.\n出自\nhttps://cancerimmunolres.aacrjournals.org/content/early/2019/03/06/2326-6066.CIR-18-0436\nFrom\nhttps://cancerimmunolres.aacrjournals.org/content/early/2019/03/06/2326-6066.CIR-18-0436\nFigure 2. Construction of TME signatures and functional annotation.\nE, The fraction of TME cells in three gene clusters. Within each group,\nthe scattered dots represent TME cell expression values. We also plotted\nthe Immunoscore of three gene clusters. The thick line represents the\nmedian value. The bottom and top of the boxes are the 25th and 75th\npercentiles (interquartile range). The whiskers encompass 1.5 times the\ninterquartile range. The statistical difference of three gene clusters\nwas compared through the Kruskal–Wallis test. *, P < 0.05; **, P <\n0.01; ***, P < 0.001; ****, P < 0.0001\n应用场景\nApplication scenarios\n这个流程探索的是不同TMEcluster的微环境相关signature的分布是否有差异，同样可以适用于是否复发，是否转移，癌和癌旁的表型数据。\nThis process explores whether the distribution of\nmicroenvironment-related signatures of different TME clusters is\ndifferent. It can also be applied to recurrence, metastasis, cancer and\nadjacent phenotypic data.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nlibrary(reshape2)\nlibrary(ggplot2)\nlibrary(ggpubr)\nlibrary(tidyverse)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 #Display English error message\noptions(stringsAsFactors = FALSE) #禁止chr转成factor #Display English error message\n输入文件\nInput file\n如果你不想计算TMEscore，只是想画带显著性的box\nplot，可以参考FigureYa12box。或者按照very_easy_input.csv文件准备自己的数据，直接进入“开始画图”。\nIf you don’t want to calculate TMEscore, but just want to draw a\nsignificant box plot, you can refer to FigureYa12box. Or prepare your\nown data according to the very_easy_input.csv file and go directly to\n“Start drawing”.\neasy_input_cluster.txt，样本所在的分类，实际应用时可以替换成是否复发,\n是否转移等表型。原文通过CIBERSORT的细胞聚类和基因聚类获得，这一步不太好实现，流程太长了，如果哪个朋友想要个性化服务再说吧。具体步骤如下：先通过consensuclusterplus2确定细胞的最佳聚类，然后通过kmeans获得cell\ncluster; 接着通过cell\ncluster进行了两两差异分析，再通过随机森林降维获得signature gene,\n然后再用signature gene通过kmeans聚类获得这个数据中的TMEcluster。\neasy_input_cluster.txt, the classification of the sample, can be\nreplaced with phenotypes such as recurrence or metastasis in actual\napplication. The original text is obtained through CIBERSORT cell\nclustering and gene clustering. This step is too long, if any friend\nwants personalized service, please talk to us. The specific steps are as\nfollows: first determine the best clustering of cells through\nconsensusuclusterplus2, and then obtain cell cluster through kmeans;\nthen perform pairwise difference analysis through cell cluster, and then\nobtain signature gene through random forest dimensionality reduction,\nand then use signature gene to obtain TMEcluster in this data through\nkmeans clustering.\nTumor microenvironment characterization in gastric cancer identifies\nprognostic and imunotherapeutically relevant gene signatures. 2019,\nCancer Immunology Research. DOI: 10.1158/2326-6066.CIR-18-0436 PMID:\n30842092\nsignature.RData，signature gene\nset，其中包含代表免疫微环境signature的\nTMEscoreA和TMEscoreB，总结于这篇2018年的Nature: TGFbeta attenuates\ntumour response to PD-L1 blockade by contributing to exclusion of T\ncells. Nature 2018;554:544–8.\nhttps://www.nature.com/articles/nature25501?draft=journal&proof=true1\nsignature.RData, signature gene set, which contains TMEscoreA and\nTMEscoreB representing the immune microenvironment signature, summarized\nin this 2018 Nature: TGFbeta attenuates tumour response to PD-L1\nblockade by contributing to exclusion of T cells. Nature 2018;554:544–8.\nhttps://www.nature.com/articles/nature25501?draft=journal&proof=true1\neset，每个样本的基因表达矩阵。例文整合了多个数据集，数据量庞大。为了尽量减小传输文件的大小，这里的表达矩阵是经过了signature_gene挑选后的矩阵（来自于GSE62254），也因此最后画出的图中pvalue都很小。\neset, gene expression matrix for each sample. The example paper\nintegrates multiple data sets, and the amount of data is huge. In order\nto minimize the size of the transfer file, the expression matrix here is\nthe matrix selected by signature_gene (from GSE62254), so the pvalues in\nthe final figure are very small.\n# phenotype data\npdata <- read.table(\"easy_input_cluster.txt\", header = T, sep = \"\\t\")\nhead(pdata)\n# signature\n(load(\"signature.RData\"))\nhead(signature)\n# expression set\neset <- read.csv(\"easy_input_expr.csv\", row.names = 1)\neset[1:3, 1:3]\n# phenotype data的样本需与expression set的样本一致\n# The samples of phenotype data must be consistent with the samples of expression set\npdata <- pdata[pdata$ID%in%colnames(eset),]\ndim(pdata)\neset <- eset[,colnames(eset)%in%pdata$ID]\ndim(eset)\n# 筛选，每个geneset的基因需要起码有2个以上在expression set中，否则运行后面的代码会报错\n# Screening, each gene set needs to have at least 2 genes in the expression set, otherwise running the following code will result in an error\nmingenecounts <- 2\nprint(lapply(signature,function(x) summary(x%in%rownames(eset))))\nsignature <- signature[lapply(signature,function(x) sum(x%in%rownames(eset)==TRUE)) >= mingenecounts]\nCalculate gene set scores\ngoi <- names(signature)\n\n#相关的signature-gene-set如下：\n#The relevant signature-gene-set is as follows:\nprint(goi)\n# 计算gene set score\n# Calculate gene set score\nfor (sig in goi) {\n  pdata[, sig] <- NA\n  genes <- signature[[sig]]\n  genes <- genes[genes %in% rownames(eset)]\n  tmp <- eset[genes, , drop=FALSE]\n\n  pc <- prcomp(t(tmp),retx=TRUE)\n  pdata[, sig] <- pc$x[,1] * sign(cor(pc$x[,1], colMeans(tmp)))\n}\nhead(pdata)\n# 把其中两列的名字由缩写改为全称\n# 按照这个写法，你还可以修改其他列的名字，它将最后出现在图的横坐标里\n# Change the names of two columns from abbreviations to full names\n# Following this writing method, you can also modify the names of other columns, which will appear in the horizontal axis of the graph\ncolnames(pdata) <- sub(\"APM\",\"Antigen_processing_machinery\",\n                       colnames(pdata))\ncolnames(pdata) <- sub(\"DDR\",\"DNA_damage_response\",\n                       colnames(pdata))\n\n# 用TMEscoreA和TMEscoreB计算TMEscore\n# Calculate TMEscore using TMEscoreA and TMEscoreB\npdata$TMEscore <- pdata$TMEscoreA - pdata$TMEscoreB\n\n# 进行数据标准化\n# 共用一个坐标时可以使数据更加集中\n# Standardize data\n# Sharing a coordinate can make the data more concentrated\npdata[,3:ncol(pdata)] <- scale(pdata[,3:ncol(pdata)],scale = T,center = T)\n\n# 重排列的顺序，非必须\n# Rearrange the order, not necessary\npdata <- pdata[,c(1,2,ncol(pdata),3:c(ncol(pdata)-1))]\nhead(pdata)\n#数据宽转长\n# Convert data from wide to long\npdata_melt <- melt(pdata,\n                 id.vars = c(\"ID\",\"TMEcluster\"),\n                 variable.name =\"Signature\",\n                 value.name = \"Signature_score\")\n\n# 输出到文件\n# Output to file\nwrite.csv(pdata_melt, \"very_easy_input.csv\", row.names = F, quote = F)\n开始画图\nStart drawing\npdata_melt <- read.csv(\"very_easy_input.csv\", header = T)\nhead(pdata_melt)\n# 使用ggplo2画图\n# Use ggplo2 to draw\nc <- ggplot(pdata_melt,\n            aes(x=Signature, y=Signature_score, \n                fill = TMEcluster, #按类填充颜色 # Fill color by class\n                color = TMEcluster)) + #按类给边框着色 # Color the border by class\n  geom_boxplot(notch = F, alpha = 0.95, \n               outlier.shape = 16,\n               outlier.colour = \"black\", #outlier点用黑色 #outlier points in black \n               outlier.size = 0.65) +\n  #自定义配色\n#custom color matching \n  scale_fill_manual(values= c(\"#E31A1C\",\"#E7B800\",\"#2E9FDF\")) +\n  #ggtitle(\"Gene signature score\", \"stratified by TME-cluster\") + \n  theme_classic() +\n  theme(axis.text.x = element_text(angle = 60, hjust = 1,size = 10), \n        axis.text.y = element_text(angle = 90, size = 12),\n        axis.title.y = element_text(angle = 90, size = 15)) +\n  theme(legend.position = \"top\")\n\n# 标注p value\n# Mark p value\nc + stat_compare_means(aes(label = paste0(\"p = \", ..p.format..)))\n# 标注*\n# mark*\n# `****` = 1e-04, `***` = 0.001, `**` = 0.01, `*` = 0.05, ns = 1\np <- c + stat_compare_means(label = \"p.signif\")\np\nggsave(p, filename = \"TME-relevant-sigature-boxplot.pdf\", width = 13, height = 6)\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa146TMEbox_FigureYa146TMEbox",
      "title": "FigureYa146TMEbox/FigureYa146TMEbox.html",
      "html": "FigureYa146TMEbox/FigureYa146TMEbox.html",
      "text": "texts/main_FigureYa146TMEbox_FigureYa146TMEbox.txt",
      "folder": "FigureYa146TMEbox",
      "thumb": "gallery_compress/FigureYa146TMEbox.webp"
    },
    "word_count": 964,
    "lines_count": 199,
    "title": "FigureYa146TMEbox",
    "description": "Requirement description 计算免疫微环境TMEscore，画出对比的box plot，标出差异显著性。 Calculate the immune microenvironment TMEscore, draw a comparative box",
    "input_data_types": [
      "临床数据",
      "表达矩阵"
    ],
    "output_types": [
      "散点图",
      "箱线图",
      "统计表格",
      "PCA图"
    ],
    "technical_methods": [
      "聚类分析",
      "标准化"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "colour",
      "values",
      "header",
      "center",
      "ns",
      "retx",
      "width",
      "pvalue"
    ]
  },
  {
    "id": "main_FigureYa61GSVA_FigureYa61GSVA",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa61GSVA_FigureYa61GSVA.txt",
    "content": "FigureYa61 GSVA\nFigureYa61 GSVA\nYu Sun, Taojun Ye\n2025-5-20\n需求描述\n模仿paper里方法做GSVA，结果保存到文件，能作为FigureYa39bar的输入文件画出bar\nplot。\n##Requirement description\nSimulate the method in the paper to create GSVA, save the results to\na file, and use it as the input file for FigureYa39bar to draw a bar\nplot.\n出自\nhttps://www.nature.com/articles/s41591-018-0096-5/\nfrom\nhttps://www.nature.com/articles/s41591-018-0096-5/\n应用场景\n关于GSVA分析，可以这样理解：如果说表达矩阵反映了样本和基因的关系，则GSVA将一个“样本×基因”的矩阵转化为“样本×通路”的矩阵，直接反映了样本和读者感兴趣的通路之间的联系。因此，如果用limma包做差异表达分析可以寻找样本间差异表达的基因，同样地，使用limma包对GSVA的结果（依然是一个矩阵）做同样的分析，则可以寻找样本间有显著差异的通路。这些“差异表达”的通路，相对于基因而言，更加具有生物学意义，更具有可解释性，是统计学与生物学成功结合后，对GSEA结果的一次升华，可以进一步用于肿瘤subtype的分型等等与生物学意义结合密切的探究。\n示例文件easy_input_expr.csv跟FigureYa59volcano用的是同一套表达数据。\nFigureYa59volcano的输入文件easy_input_limma.csv是用\n全体基因\n做差异分析获得的。\n此处gsva_limma.csv文件是用\n通路\n做差异分析获得的。\n##Application scenarios\nRegarding GSVA analysis, it can be understood as follows: if the\nexpression matrix reflects the relationship between samples and genes,\nthen GSVA transforms a “sample x gene” matrix into a “sample x pathway”\nmatrix, directly reflecting the connection between samples and pathways\nof interest to readers. Therefore, if differential expression analysis\nis performed using the limma package, genes with differential expression\nbetween samples can be identified. Similarly, using the limma package to\nanalyze the results of GSVA (still a matrix) in the same way can\nidentify pathways with significant differences between samples. These\n“differentially expressed” pathways, compared to genes, have more\nbiological significance and interpretability. They are a sublimation of\nGSEA results after the successful combination of statistics and biology,\nand can be further used for the classification of tumor subtypes and\nother closely related explorations with biological significance.\nThe example file easyinput-expr.csv uses the same set of expression\ndata as FigureYa59volcano.\n-The input file easy_input_imma. csv for FigureYa59volcano was\nobtained through differential analysis using * * all genes *\n. -The\ngsva_imma. csv file here was obtained through differential analysis\nusing\n* pathway * *.\n环境设置\n安装包\n##Environment settings\n###Installation package\n#使用国内镜像安装包\noptions(\"repos\"= c(CRAN=\"https://mirrors.tuna.tsinghua.edu.cn/CRAN/\"))\noptions(BioC_mirror=\"http://mirrors.ustc.edu.cn/bioc/\")\ninstall.packages(\"msigdbr\")\n#Use domestic image installation package\noptions(\"repos\"= c(CRAN=\" https://mirrors.tuna.tsinghua.edu.cn/CRAN/ \"))\noptions(BioC_mirror=\" http://mirrors.ustc.edu.cn/bioc/ \")\ninstall.packages(\"msigdbr\")\n加载包\n###Load Package\n# 加载必要的R包 | Load necessary R packages\nlibrary(msigdbr)  # 获取基因集数据库 | For accessing gene set databases\nlibrary(dplyr)    # 数据处理和转换 | Data manipulation and transformation\nlibrary(data.table) # 高效处理大型数据集 | Efficient handling of large datasets\nlibrary(GSVA)     # 基因集变异分析 | Gene Set Variation Analysis\nlibrary(limma)    # 微阵列和RNA-seq数据分析 | Microarray and RNA-seq data analysis\nlibrary(stringr)  # 字符串处理 | String manipulation\nlibrary(ggplot2)  # 数据可视化 | Data visualization\n\n# 设置环境为英文以显示英文报错信息 | Set environment to English for error messages\nSys.setenv(LANGUAGE = \"en\") \n# 禁止自动将字符转换为因子 | Prevent automatic conversion of strings to factors\noptions(stringsAsFactors = FALSE) \n# 可选：设置并行计算核心数 | Optional: Set number of cores for parallel computation\n# options(mc.cores = parallel::detectCores())\n输入文件\nGSVA需要两个输入文件：基因表达矩阵和通路里的基因列表。\nhallmark.gs.RData：“整理通路里的基因列表”这部分生成的，同一物种同一版本注释可重复使用。\neasy_input_expr.csv：基因表达矩阵，每行一个基因，每列一个sample。\n##Input file\nGSVA requires two input files: a gene expression matrix and a list of\ngenes in the pathway.\n-Hallmark.gs.RData: This section generates a list of genes in the\npathway, and annotations for the same species and version can be\nreused.\n-Easyinput-expr.csv: Gene expression matrix, with one gene per row\nand one sample per column.\n整理通路里的基因列表\n下面这部分运行后，要保存好生成的hallmark.gs.RData文件，同一物种同一版本注释可重复使用。以后就可以跳过这步，直接进入“GSVA”。\n每次只需要更换表达矩阵，用同一物种同一版本gmt生成的”hallmark.gs.RData”可以一直用。\n为了减少冗余信息的干扰，paper中要求：\n在每个geneset中，不应该出现重复的基因；\n在两个或更多个pathway中出现的基因应该被彻底剔除。\n在实际分析过程中，笔者留意到在单个的geneset中已经很少出现重复的基因，但在两个或更多个pathway中出现的基因则数目相对较多，读者可\n酌情考虑，调整此处过滤的力度\n。\n##Organize the gene list in the pathway\nAfter running the following section, it is necessary to save the\ngenerated hallmark.gs.RData file. Annotations of the same species and\nversion can be reused. In the future, you can skip this step and\ndirectly enter “GSVA”.\nOnly the expression matrix needs to be changed each time, and\nthe “hallmark. gs. RData” generated using the same species and version\nof gmt can be used continuously.\nIn order to reduce the interference of redundant information, the\npaper requires:\n-In each gene set, there should be no duplicated genes; -Genes that\nappear in two or more pathways should be completely eliminated.\nIn the actual analysis process, the author noticed that duplicate\ngenes rarely appear in a single gene set, but the number of genes\nappearing in two or more pathways is relatively large. Readers can\nconsider adjusting the filtering intensity at their discretion.\n# 查看msigdbr包支持的物种列表 | View available species in msigdbr package\nmsigdbr_species()\n# 从MSigDB数据库获取人类Hallmark基因集 | Retrieve hallmark gene sets for Homo sapiens from MSigDB\nh <- msigdbr(species = \"Homo sapiens\", # 物种拉丁名 | Latin name of species\n             category = \"H\") # 此处以hallmark为例，你也可以选择MSigDB的其他注释 | Using hallmark gene sets here, can choose other categories\n# 示例数据表达矩阵的基因名是gene symbol，这里就选gene_symbol。\n# 如果你的表达矩阵以ENTREZ ID作为基因名，就把下面这段的gene_symbol换成entrez_gene\n# Format gene sets into list structure for GSVA input\nh <- select(h, gs_name, gene_symbol) %>% #或entrez_gene | Or use entrez_gene if applicable\n  as.data.frame %>% \n  split(., .$gs_name) %>% \n  lapply(., function(x)(x$gene_symbol)) #或entrez_gene | Use entrez_gene if working with ENTREZ IDs\n\n# 在每个geneset里面去掉重复的基因 | Remove duplicate genes within each gene set\ngs <- lapply(h, unique)\n\n# 接下来去掉那些在两个或更多个pathways里出现过的genes\n# Remove genes that appear in two or more pathways\ncount <- table(unlist(gs))\nkeep <- names(which(table(unlist(gs)) < 2))\ngs <- lapply(gs, function(x) intersect(keep, x))\n\n# 过滤之后，很多pathway一个gene都不剩了，去掉这些\n# Remove pathways that have no genes left after filtering\ngs <- gs[lapply(gs, length) > 0]\n\n# 预览过滤后的结果 | Preview filtered gene sets\nhead(gs)\n# 保存到文件，方便以后重复使用 | Save for future reuse\nsave(gs, file = \"hallmark.gs.RData\")\nGSVA\n# 读入前面生成的通路中的基因列表 | Load preprocessed gene sets\n(load(\"hallmark.gs.RData\")) #保存在当前文件夹 | Saved in current directory\n# 读入基因表达矩阵 | Load gene expression matrix\ngsym.expr <- read.csv(\"easy_input_expr.csv\", row.names = 1)\nhead(gsym.expr)\n# 这一句就完成了GSVA分析 | Perform GSVA analysis in one line\n# 参数说明 | Arguments:\n# as.matrix(gsym.expr): 表达矩阵，行名为基因，列名为样本 | Expression matrix with genes as rows and samples as columns\n# gs: 基因集列表，由msigdbr生成 | Gene sets generated from msigdbr\nparams <- gsvaParam(exprData = as.matrix(gsym.expr), geneSets = gs)\ngsva_es <- gsva(params)\n# 预览GSVA分析返回的矩阵 | Preview GSVA enrichment scores\nhead(gsva_es)\n# 把通路的表达量保存到文件 | Save pathway enrichment scores to CSV\nwrite.csv(gsva_es, \"gsva_output.csv\", quote = F)\n到这里，GSVA分析就结束了。\n接下来，你可能要对这些通路进行进一步的分析，此处以差异表达分析为例。\nThis concludes the GSVA analysis.\nNext, you may need to further analyze these pathways, using\ndifferential expression analysis as an example.\n通路的差异表达分析\n##Differential expression analysis of pathways\n# 分组 | Define sample groups\ngroup_list <- data.frame(sample = colnames(gsva_es), group = c(rep(\"a\", 3), rep(\"b\", 3)))\nhead(group_list)\n# 设置对比 | Set up design matrix for differential analysis\ndesign <- model.matrix(~ 0 + factor(group_list$group))\ncolnames(design) <- levels(factor(group_list$group))\nrownames(design) <- colnames(gsva_es)\ndesign\n# 构建差异比较矩阵 | Construct contrast matrix for differential testing\ncontrast.matrix <- makeContrasts(b-a, levels = design)\n\n# 差异分析，b vs. a | Differential analysis between group b and a\n# 参数说明 | Arguments:\n# gsva_es: GSVA富集分数矩阵 | GSVA enrichment score matrix\n# design: 实验设计矩阵 | Experimental design matrix\nfit <- lmFit(gsva_es, design)\nfit2 <- contrasts.fit(fit, contrast.matrix)\nfit2 <- eBayes(fit2)\nx <- topTable(fit2, coef = 1, n = Inf, adjust.method = \"BH\", sort.by = \"P\")\nhead(x)\n# 把通路的limma分析结果保存到文件 | Save limma results to CSV\nwrite.csv(x, \"gsva_limma.csv\", quote = F)\n\n# 输出t值，用做FigureYa39bar的输入数据 | Prepare t-values for FigureYa39bar input\npathway <- str_replace(row.names(x), \"HALLMARK_\", \"\")\ndf <- data.frame(ID = pathway, score = x$t)\nwrite.csv(df, \"easy_input2_for39bar.csv\", quote = F, row.names = F)\n开始画图\nt为柱子的长度（图中横轴），行名为图中pathway的名称。\n如果想做更多细节上的调整，可参考FigureYa39bar。\n##Start drawing\nT is the length of the column (horizontal axis in the figure), and\nthe row name is the name of the pathway in the figure.\nIf you want to make more detailed adjustments, you can refer to\nFigureYa39bar.\n# 读取用于柱状图分析的数据 | Read data for bar plot analysis\ndf <- read.csv(\"easy_input2_for39bar.csv\")\nhead(df)\n# 按照score的值分组 | Group data by score values\ncutoff <- 1\ndf$group <- cut(df$score, breaks = c(-Inf, -cutoff, cutoff, Inf), labels = c(1,2,3))\n\n# 按照score排序 | Sort data by score\nsortdf <- df[order(df$score),]\nsortdf$ID <- factor(sortdf$ID, levels = sortdf$ID)\nhead(sortdf)\n# 绘制分组柱状图 | Create grouped bar plot\nggplot(sortdf, aes(ID, score, fill = group)) + geom_bar(stat = 'identity') + \n  coord_flip() + \n  scale_fill_manual(values = c('palegreen3', 'snow3', 'dodgerblue4'), guide = FALSE) + \n\n  # 添加两条虚线作为阈值参考 | Add two dashed lines as threshold references\n  geom_hline(yintercept = c(-cutoff, cutoff), \n             color = \"white\",\n             linetype = 2, # 虚线类型 | Dashed line type\n             size = 0.3) + # 线宽 | Line width\n  \n  # 添加负分组标签 | Add labels for negative group\n  geom_text(data = subset(df, score < 0),\n            aes(x = ID, y = 0, label = paste0(\" \", ID), color = group), \n            size = 3, # 字体大小 | Font size\n            hjust = \"inward\") +  # 水平对齐方式 | Horizontal alignment\n  \n  # 添加正分组标签 | Add labels for positive group\n  geom_text(data = subset(df, score > 0),\n            aes(x = ID, y = -0.1, label = ID, color = group),\n            size = 3, hjust = \"outward\") +  \n  scale_colour_manual(values = c(\"black\", \"snow3\", \"black\"), guide = FALSE) +\n  \n  # 设置坐标轴标签 | Set axis labels\n  xlab(\"\") + ylab(\"t value of GSVA score, tumor \\n versus non-malignant\") +\n  theme_bw() + # 使用黑白主题 | Use black and white theme\n  theme(panel.grid = element_blank()) + # 去除网格线 | Remove grid lines\n  theme(panel.border = element_rect(size = 0.6)) + # 设置边框粗细 | Set border thickness\n  # 去除Y轴元素 | Remove Y-axis elements\n  theme(axis.line.y = element_blank(), axis.ticks.y = element_blank(), axis.text.y = element_blank())\n# 保存图表为PDF | Save plot as PDF\nggsave(\"gsva.pdf\", width = 6, height = 8)\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa61GSVA_FigureYa61GSVA",
      "title": "FigureYa61GSVA/FigureYa61GSVA.html",
      "html": "FigureYa61GSVA/FigureYa61GSVA.html",
      "text": "texts/main_FigureYa61GSVA_FigureYa61GSVA.txt",
      "folder": "FigureYa61GSVA",
      "thumb": "gallery_compress/FigureYa61GSVA.webp"
    },
    "word_count": 1371,
    "lines_count": 245,
    "title": "FigureYa61 GSVA",
    "description": "模仿paper里方法做GSVA，结果保存到文件，能作为FigureYa39bar的输入文件画出bar plot。 Simulate the method in the paper to create GSVA, save the results to",
    "input_data_types": [
      "临床数据",
      "表达矩阵"
    ],
    "output_types": [
      "火山图",
      "统计表格"
    ],
    "technical_methods": [
      "通路分析",
      "差异表达分析"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "score",
      "label",
      "values",
      "guide",
      "coef",
      "width",
      "grid",
      "n",
      "labels"
    ]
  },
  {
    "id": "main_FigureYa270panMeth_FigureYa270panMeth",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa270panMeth_FigureYa270panMeth.txt",
    "content": "FigureYa270panMeth\nFigureYa270panMeth\nXiaofan Lu, Taojun Ye\n2025-09-24\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n想实现这篇铁死亡泛癌的其他图片，主要是Figure\n1。感觉这个套路只要换一个通路就可以测试，我看Xiaofan\nLu写了这篇文章的Figure\n2A（铁死亡基因在泛癌肿瘤与正常的差异箱线图，FigureYa208FPI），Figure\n3B（铁死亡与免疫通路的相关性，FigureYa253panGSEA），可否请Xiaofan\nLu详细写一下文章Figure 1的相关代码？\n1A（铁死亡在泛癌中体细胞拷贝数变异情况，绘制条形图，可参考FigureYa265panCNV）\n1B（铁死亡基因在肿瘤与正常的差异表达，绘制拼接的点图和柱状图，可参考FigureYa263panDiff）\n1C（铁死亡基因体细胞拷贝数与基因表达的相关性点图，可参考FigureYa268panCNVexpr）\n1D（铁死亡基因肿瘤与正常组织甲基化状态点图）\n1E（铁死亡转录组表达与启动子甲基化相关性的点图）\n这些图都是泛癌的，不知道Xiaofan Lu可不可以用例文数据分别实现个教程\n[皱眉] ？（感觉都可以出一期专栏——iSicence复现了哈哈）\n这次实现Figure 1D，铁死亡基因肿瘤与正常组织甲基化状态点图。\nRequirement description\nFor Figure 1. I feel that this routine can be tested by simply\nchanging the pathway. I saw that Professor Dayu wrote Figure 2A (Box\nplot of differences in ferroptosis genes between pan cancer tumors and\nnormal, Figure Ya208FPI) and Figure 3B (Correlation between ferroptosis\nand immune pathways) in this article, FigureYa253panGSEA）， Could you\nplease ask Xiaofan Lu to write the relevant code for Figure 1 in\ndetail?\n-1A (Iron induced cell copy number variation in pan cancer, plot a\nbar chart, refer to FigureYa265panCNV) -1B (Differential expression of\nferroptosis genes between tumors and normal, plot concatenated dot plots\nand bar charts, refer to FigureYa263panDiff) -1C (Correlation plot\nbetween iron death gene somatic copy number and gene expression, refer\nto FigureYa268panCNVexpr) -1D (Methylation Status Point Map of Iron\nDeath Gene Tumors and Normal Tissues) -1E (Point plot of correlation\nbetween iron death transcriptome expression and promoter\nmethylation)\nThese images are all pan cancerous. Can Xiaofan Lu write a tutorial\nusing example text data? (I feel like I could even publish a column -\niSicence has reproduced it haha)\nFigure 1D, a point map of methylation status between iron death gene\ntumors and normal tissues, for this time.\n出自\nhttps://linkinghub.elsevier.com/retrieve/pii/S2589004220304892\nfrom\nhttps://linkinghub.elsevier.com/retrieve/pii/S2589004220304892\n接下来会陆续实现Figure1E，敬请关注。\nFigure 1E to be continue.\nFigure 1. The Dysregulation of Ferroptosis Regulator Genes (FRGs) (D)\nHeatmap shows the differential methylation of FRGs in cancers;\nhypermethylated and hypomethylated genes are marked in red and\nblue\n, respectively (Wilcoxon rank-sum test).\n应用场景\n分析铁死亡基因肿瘤与正常组织甲基化状态并绘制点图\nApplication scenarios\nAnalyze the methylation status of iron death genes in tumors and\nnormal tissues and draw a point map\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\n# 加载ggplot2包，用于创建优雅的统计图形\n# Load the ggplot2 package for creating elegant statistical graphics\nlibrary(ggplot2)\n\n# 加载ChAMP包，用于DNA甲基化数据分析\n# Load the ChAMP package for DNA methylation data analysis\nlibrary(ChAMP)\n\n# 加载data.table包，提供高效处理大型数据集的功能\n# Load the data.table package for efficient processing of large datasets\nlibrary(data.table)\n\n# 加载randomcoloR包，用于生成视觉上愉悦的随机颜色\n# Load the randomcoloR package to generate visually pleasing random colors\nlibrary(randomcoloR)\n\n# 加载ggpubr包，提供ggplot2的增强功能和 publication-ready 图表\n# Load the ggpubr package, which provides enhanced ggplot2 functionality and publication-ready charts\nlibrary(ggpubr)\n\n# 加载GSVA包，用于基因集变异分析\n# Load the GSVA package for gene set variation analysis\nlibrary(GSVA)\n# 加载clusterProfiler包，用于基因富集分析和功能注释\n# Load the clusterProfiler package for gene enrichment analysis and functional annotation\nlibrary(clusterProfiler)\n# 加载impute包，用于处理数据集中的缺失值\n# Load the impute package for handling missing values in datasets\nlibrary(impute)\n\n# 加载ComplexHeatmap包，用于创建复杂的热图可视化\n# Load the ComplexHeatmap package for creating complex heatmap visualizations\nlibrary(ComplexHeatmap)\n# 加载甲基化450k数据的探针注释数据\n# Load probe annotation data for methylation 450k data\ndata(\"probe.features\")\n\n# 设置环境语言为英文，确保报错信息以英文显示\n# Set the environment language to English to ensure error messages are displayed in English\nSys.setenv(LANGUAGE = \"en\")\n\n# 禁止R自动将字符型数据转换为因子类型，避免意外的数据转换\n# Disable R's automatic conversion of character data to factors to avoid unexpected data transformations\noptions(stringsAsFactors = FALSE)\n输入文件\nmerged_sample_quality_annotations.tsv，下载自\nhttps://gdc.cancer.gov/about-data/publications/pancanatlas\n，下载地址\nhttp://api.gdc.cancer.gov/data/1a7d7be8-675d-4e60-a105-19d4121bdebf\n。跟FigureYa263panDiff、FigureYa265panCNV、FigureYa268panCNVexpr使用的是同一套数据，已经下载的小伙伴就不用重复下载了。\ntcga_methy450文件夹里面是甲基化数据，过滤掉了有空值的探针，均已保存为RData文件，微云链接：\nhttps://share.weiyun.com/jRry4rlU\n。下载后把tcga_methy450文件夹放到当前文件夹。\nInput file\nmerged_sample_quality_annotations.tsv， Download from<\nhttps://gdc.cancer.gov/about-data/publications/pancanatlas\n>, download link<\nhttp://api.gdc.cancer.gov/data/1a7d7be8-675d-4e60-a105-19d4121bdebf\n>The same set of data is used for FigureYa263panDiff,\nFigureYa265panCNV, and FigureYa268panCNVexpr, so users who have already\ndownloaded it do not need to download it again.\nThe tcga_sthy450 folder contains methylation data, filtered out\nprobes with null values, and saved them as RData files. Weiyun link:<\nhttps://share.weiyun.com/jRry4rlU\n>After downloading,\nplace the tcga_cethy450 folder into the current folder.\n# 获得同时有肿瘤和正常样本的肿瘤名\n# Obtain the names of tumors that have both tumor and normal samples\ntumors <- c(\"BLCA\",\"BRCA\",\"CESC\",\"CHOL\",\"COAD\",\n            \"ESCA\",\"GBM\",\"HNSC\",\"KICH\",\"KIRC\",\n            \"KIRP\",\"LIHC\",\"LUAD\",\"LUSC\",\"PAAD\",\n            \"PRAD\",\"READ\",\"STAD\",\"THCA\",\"UCEC\")\n\n# 获得感兴趣的基因集(TTC35是EMC2的同名)\n# Obtain the gene set of interest (TTC35 is an alias for EMC2)\nfrg <- c(\"CDKN1A\",\"HSPA5\",\"TTC35\",\"SLC7A11\",\"NFE2L2\",\"MT1G\",\"HSPB1\",\"GPX4\",\"FANCD2\",\"CISD1\",\"FDFT1\",\"SLC1A5\",\"SAT1\",\n         \"TFRC\",\"RPL8\",\"NCOA4\",\"LPCAT3\",\"GLS2\",\"DPP4\",\"CS\",\"CARS\",\"ATP5G3\",\"ALOX15\",\"ACSL4\",\"EMC2\")\n\n# 修正TCGA名称\n# Correct TCGA naming\n# https://gdc.cancer.gov/about-data/publications/pancanatlas\nrawAnno <- read.delim(\"merged_sample_quality_annotations.tsv\",sep = \"\\t\",row.names = NULL,check.names = F,stringsAsFactors = F,header = T) # 数据来自PanCanAtlas\n# Data from PanCanAtlas\nrawAnno$simple_barcode <- substr(rawAnno$aliquot_barcode,1,15)\nsamAnno <- rawAnno[!duplicated(rawAnno$simple_barcode),c(\"cancer type\", \"simple_barcode\")]\nsamAnno <- samAnno[which(samAnno$`cancer type` != \"\"),]\nwrite.table(samAnno,\"simple_sample_annotation.txt\",sep = \"\\t\",row.names = F,col.names = T,quote = F)\n\n# 提取匹配到FRG基因的启动子探针\n# Extract promoter probes that match FRG genes\npromoter <- probe.features[which(probe.features$feature %in% c(\"TSS1500\",\"TSS200\")),] # 根据注释文件筛选启动子探针，也可以分析其他探针比如增强子Enhancer等等\n# Filter promoter probes based on annotation file; other probe types like enhancers can also be analyzed\npromoter <- promoter[which(promoter$gene %in% frg),] # 取出感兴趣基因在感兴趣位点的探针\n# Extract probes of interested genes at interested sites\nwrite.table(promoter, \"promoter_annotation_for_interested_genes.txt\",sep = \"\\t\",row.names = T,col.names = NA,quote = F)\n\n# 获取只有感兴趣探针/基因的甲基化子集\n# Obtain methylation subsets of only the probes/genes of interest\nfor (i in tumors) { # 比较慢请耐心\n  # This loop is slow, please be patient\n  message(\"--\",i,\"...\")\n  load(file.path(\"tcga_methy450\",paste0(\"TCGA-\",i,\"_methy450.RData\"))) # 加载甲基化RData文件\n  # Load methylation RData file\n  methy450 <- as.data.frame(methy450) # 转数据框\n  # Convert to data frame\n  rownames(methy450) <- methy450[,1] # 行名改为第一列\n  # Set row names to the first column\n  methy450 <- methy450[,-1] # 去掉第一列探针名\n  # Remove the first column (probe names)\n  dimname <- dimnames(methy450) # 获取行名和列明\n  # Get row and column names\n  methy450 <- sapply(methy450, as.numeric) # 将数据全部转为数值以防报错\n  # Convert all data to numeric to avoid errors\n  dimnames(methy450) <- dimname # 重新赋值行名和列名\n  # Reassign row and column names\n  methy450 <- as.data.frame(methy450) # 转数据框\n  # Convert back to data frame\n  \n  compb <- intersect(rownames(methy450),rownames(promoter)) # 获取甲基化数据和感兴趣探针的交集\n  # Get the intersection of methylation data and probes of interest\n  methy450 <- methy450[compb,] # 取出子集\n  # Extract subset\n  methy450$gene <- promoter[compb,\"gene\"] # 将探针名和基因名进行映射\n  # Map probe names to gene names\n  \n  # 如果基因匹配多个探针，则取中位数beta值\n  # If a gene matches multiple probes, take the median beta value\n  methy450 <- apply(methy450[,setdiff(colnames(methy450), \"gene\")], 2, function(x) tapply(x, INDEX=factor(methy450$gene), FUN=median, na.rm=TRUE))\n  methy450 <- as.data.frame(methy450)\n  write.table(methy450, paste0(\"TCGA_\",i,\"_methy450_subset.txt\"),sep = \"\\t\",row.names = T,col.names = NA,quote = F)\n  rm(methy450); gc() # 释放内存\n  # Free up memory\n}\ngc()\n提取甲基化数据\nExtract methylation data\n# 初始化存储差异甲基化结果的数据框\n# Initialize data frame to store differential methylation results\ndeltaMeth <- NULL\n\n# 遍历每种肿瘤类型进行差异甲基化分析\n# Iterate through each tumor type for differential methylation analysis\nfor (i in tumors) {\n  message(\"--\",i,\"...\")\n  \n  # 获取只包含感兴趣探针/基因的甲基化数据\n  # Read methylation data subset containing only probes/genes of interest\n  meth_subset <- read.table(paste0(\"TCGA_\",i,\"_methy450_subset.txt\"),sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\n  colnames(meth_subset) <- substr(colnames(meth_subset),1,15)\n  \n  # 根据样本条形码的第14位字符区分肿瘤样本和正常样本\n  # Differentiate tumor and normal samples by the 14th character of the sample barcode\n  tumsam <- colnames(meth_subset)[substr(colnames(meth_subset),14,14) == \"0\"] # 获取肿瘤样本\n  norsam <- colnames(meth_subset)[substr(colnames(meth_subset),14,14) == \"1\"] # 获取正常样本\n  \n  # 初始化存储当前肿瘤类型分析结果的数据框\n  # Initialize data frame to store analysis results for current tumor type\n  outTab <- NULL\n  \n  # 对每个基因进行差异甲基化分析\n  # Perform differential methylation analysis for each gene\n  for (j in rownames(meth_subset)) {\n    # KICH肿瘤类型没有正常甲基化样本，特殊处理\n    # Special handling for KICH tumor type which lacks normal methylation samples\n    if(i == \"KICH\") { \n      delta <- 0 # 如果在分析KICH则delta设置为0\n      wt <- 1 # 如果在分析KICH则设置pvalue为1\n      outTab <- rbind.data.frame(outTab,\n                                 data.frame(gene = j,\n                                            tumor = i,\n                                            Delta = delta,\n                                            Pvalue = wt,\n                                            stringsAsFactors = F),\n                                 stringsAsFactors = F)\n    } else {\n      # 获取当前基因在肿瘤样本和正常样本中的甲基化beta值\n      # Get methylation beta values for current gene in tumor and normal samples\n      tmp1 <- as.numeric(meth_subset[j,tumsam]) # 获取肿瘤样本的beta值\n      tmp2 <- as.numeric(meth_subset[j,norsam]) # 获取正常样本的beta值\n      \n      # 进行Wilcoxon秩和检验评估差异显著性\n      # Perform Wilcoxon rank-sum test to assess significance of differences\n      wt <- wilcox.test(tmp1,tmp2)$p.value # wilcox检验\n      \n      # 计算肿瘤样本和正常样本的平均甲基化水平\n      # Calculate average methylation levels for tumor and normal samples\n      avgt <- mean(tmp1) # 肿瘤样本的平均beta值\n      avgn <- mean(tmp2) # 正常样本的平均beta值\n      \n      # 计算差异甲基化值（肿瘤组-正常组）\n      # Calculate differential methylation value (tumor - normal)\n      delta <- avgt - avgn # delta值由肿瘤样本减去正常样本计算得到\n      \n      # 存储当前基因的分析结果\n      # Store analysis results for current gene\n      outTab <- rbind.data.frame(outTab,\n                                 data.frame(gene = j,\n                                            tumor = i,\n                                            Delta = delta,\n                                            Pvalue = wt,\n                                            stringsAsFactors = F),\n                                 stringsAsFactors = F)\n    }\n  }\n  \n  # 将当前肿瘤类型的分析结果添加到总体结果中\n  # Append analysis results for current tumor type to overall results\n  deltaMeth <- rbind.data.frame(deltaMeth,\n                                outTab,\n                                stringsAsFactors = F)\n}\n# 将所有肿瘤类型的差异甲基化分析结果保存到文件\n# Save differential methylation analysis results for all tumor types to file\nwrite.table(deltaMeth, \"TCGA_pancan_delta_meth_subset.txt\",sep = \"\\t\",row.names = F,col.names = T,quote = F)\n开始画图\nStart plot\n# 设置颜色（用于后续绘图的颜色映射）\n# Set colors (for color mapping in subsequent plotting)\nblue <- \"#4577FF\"       # 蓝色\nred <- \"#C2151A\"        # 红色\norange <- \"#E45737\"     # 橙色\ngreen <- \"#6F8B35\"      # 绿色\ndarkblue <- \"#303B7F\"   # 深蓝色\ndarkred <- \"#D51113\"    # 深红色\nyellow <- \"#EECA1F\"     # 黄色\n\n# 产生泡泡图（可视化肿瘤与正常样本的启动子甲基化差异）\n# Generate bubble plot (visualize promoter methylation differences between tumor and normal samples)\ndeltaMeth$gene <- factor(deltaMeth$gene,\n                         # 将gene列转换为因子并指定显示顺序（逆序排列基因）\n                         # Convert 'gene' column to factor and specify display order (reverse gene order)\n                         levels = rev(c(\"CDKN1A\",\"HSPA5\",\"TTC35\",\"SLC7A11\",\"NFE2L2\",\"MT1G\",\"HSPB1\",\"GPX4\",\"FANCD2\",\"CISD1\",\n                                        \"FDFT1\",\"SLC1A5\",\"SAT1\",\"TFRC\",\"RPL8\",\"NCOA4\",\"LPCAT3\",\"GLS2\",\"DPP4\",\"CS\",\"CARS\",\"ATP5G3\",\"ALOX15\",\"ACSL4\")))\n\n# 定义颜色渐变 palette（从蓝色到白色到橙色，共128种颜色，带透明度）\n# Define color gradient palette (from blue to white to orange, 128 colors with transparency)\nmy_palette <- colorRampPalette(c(blue,\"white\",orange), alpha=TRUE)(n=128)\n\n# 使用ggplot2绘制泡泡图\n# Use ggplot2 to create bubble plot\nggplot(deltaMeth, aes(x=tumor, y=gene)) +\n  # 绘制散点图，点的大小映射为 -log10(Pvalue)，颜色映射为Delta值\n  # Draw scatter plot, point size mapped to -log10(Pvalue), color mapped to Delta value\n  geom_point(aes(size=-log10(Pvalue), color=Delta)) +\n  # 设置颜色渐变刻度，标题为\"Delta(T-N)\"，使用定义的颜色 palette\n  # Set color gradient scale, title \"Delta(T-N)\", use defined color palette\n  scale_color_gradientn('Delta(T-N)', \n                        colors=my_palette) + \n  # 使用黑白主题\n  # Use black and white theme\n  theme_bw() +\n  # 自定义图表主题样式\n  # Customize plot theme style\n  theme(\n        # 坐标轴x轴文本：45度倾斜，大小12，水平对齐0.3，垂直对齐0.5，黑色\n        # X-axis text: 45-degree angle, size 12, hjust 0.3, vjust 0.5, black color\n        axis.text.x = element_text(angle = 45, size = 12, hjust = 0.3, vjust = 0.5, color = \"black\"),\n        # 坐标轴y轴文本：大小12，颜色交替使用红色和蓝色（前14个基因红色，后10个蓝色）\n        # Y-axis text: size 12, colors alternating red and blue (first 14 genes red, next 10 blue)\n        axis.text.y = element_text(size = 12, color = rep(c(red, blue), c(14, 10))),\n        # 隐藏坐标轴标题\n        # Hide axis titles\n        axis.title = element_blank(),\n        # 绘制黑色实线边框，宽度0.7\n        # Draw black solid border, size 0.7\n        panel.border = element_rect(size = 0.7, linetype = \"solid\", colour = \"black\"),\n        # 图例位置设为右侧\n        # Legend position at right\n        legend.position = \"right\",\n        # 图表边距设为1行\n        # Plot margin set to 1 line\n        plot.margin = unit(c(1, 1, 1, 1), \"lines\")\n  )\n# 保存图表为PDF文件，宽度8英寸，高度6英寸\n# Save plot as PDF file, width 8 inches, height 6 inches\nggsave(\"Figure 1D delta between tumor and normal promoter methylation of interested genes in pancancer.pdf\", width = 8, height = 6)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa270panMeth_FigureYa270panMeth",
      "title": "FigureYa270panMeth/FigureYa270panMeth.html",
      "html": "FigureYa270panMeth/FigureYa270panMeth.html",
      "text": "texts/main_FigureYa270panMeth_FigureYa270panMeth.txt",
      "folder": "FigureYa270panMeth",
      "thumb": "gallery_compress/FigureYa270panMeth.webp"
    },
    "word_count": 1609,
    "lines_count": 345,
    "title": "FigureYa270panMeth",
    "description": "想实现这篇铁死亡泛癌的其他图片，主要是Figure 1。感觉这个套路只要换一个通路就可以测试，我看Xiaofan Lu写了这篇文章的Figure",
    "input_data_types": [
      "临床数据",
      "RNA-seq"
    ],
    "output_types": [
      "火山图",
      "热图",
      "统计表格",
      "箱线图",
      "散点图"
    ],
    "technical_methods": [
      "通路分析",
      "生存分析",
      "质量控制",
      "差异表达分析"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学"
    ],
    "complexity_level": "高级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "gene",
      "colour",
      "header",
      "width",
      "n",
      "pvalue",
      "vjust",
      "INDEX",
      "colors"
    ]
  },
  {
    "id": "main_FigureYa48Adonis_FigureYa48Adonis",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa48Adonis_FigureYa48Adonis.txt",
    "content": "FigureYa48 Adonis\nFigureYa48 Adonis\nAuthor(s)\n: yeoli; Ying Ge, Yijing Chen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n进行置换多元方差分析（PERMANOVA，Adonis），画出图b\nPerform permutational multivariate analysis of variance (PERMANOVA,\nAdonis) and draw Figure b.\n图 1：取样区域和肠道微生物群区域差异概览。\nb，条形图说明了与肠道微生物变化显著相关的前 30\n个宿主因素。这些变化来自样本间加权的 UniFrac\n距离。条形图根据元数据类别着色。规模效应和统计显著性由 PERMANOVA\n(Adonis)\n计算。FDR控制在5%。DBP：舒张压；TCHO：总胆固醇；FBG：空腹血糖。\n出自\nhttps://www.nature.com/articles/s41591-018-0164-x\nFig. 1: Overview of sampling regions and of regional variation in gut\nmicrobiota. b, Bar plot illustrating the top 30 host factors found to be\nsignificantly associated with gut microbial variations. The variations\nwere derived from between-sample weighted UniFrac distances. The bars\nare colored according to metadata categories. Size effect and\nstatistical significance were calculated by PERMANOVA (Adonis). FDR was\ncontrolled at 5%. DBP, diastolic blood pressure; TCHO, total\ncholesterol; FBG, fasting blood glucose.\nfrom\nhttps://www.nature.com/articles/s41591-018-0164-x\n应用场景\nApplication scenario\n分析不同分组或环境因子对样品差异的解释度，例如例文中宿主的临床表型对肠道微生物的影响。\nAnalyze the explanatory power of different groups or environmental\nfactors on sample differences, such as the impact of the host’s clinical\nphenotype on gut microbiota in the example text.\n输入数据\nInput data\n三个输入文件：\nThree input files:\nsource(\"install_dependencies.R\")\n#肠道微生物数据，每行为一种肠道微生物，每一列为一个样本\n#gut microbiota data, each row represents a type of gut microbe, and each column represents a sample\nmydata <- read.table(\"easy_input_meta.txt\",head=T,sep = \"\\t\",row.names = 1)\nmydata <- t(mydata) #转置\nmydata[1:3,1:4]\n#理化因子表格，每行为一个样本，每一列为一个因子，例如年龄、疾病、吸烟等\n#physicochemical factor table, one sample per row, one factor per column, e.g., age, disease, smoking, etc.\nmyfactor <- read.table(\"easy_input_factors.txt\",header = T,sep = \"\\t\", row.names = 1)\nhead(myfactor)\n#非必需，理化因子的分组信息，例如某几个因子都属于生活方式\n#non-essential, grouping information of physicochemical factors, for example, certain factors all belong to lifestyle\ngp <- read.table(\"easy_input_factor.group.txt\",head=F,sep = \"\\t\")\ncolnames(gp) <- c(\"factor\",\"group\")\nhead(gp)\n开始计算\nStart calculating\n# 进行adonis分析\n# perform adonis analysis\nlibrary(vegan)\nresult <- adonis2(mydata ~ ., \n                  data = myfactor, \n                  by = \"terms\",        # 按项计算（与原始adonis相同）\n                  permutations = 999,  # 置换次数，默认999\n                  method = \"bray\",     # 距离方法，默认是\"bray\"（Bray-Curtis）\n                  strata = NULL,       # 分层变量，如果需要分层置换检验\n                  parallel = getOption(\"mc.cores\") # 并行计算核心数\n                  )\n\nmytable <- as.data.frame(result)\nmytable <- mytable[1:ncol(myfactor),]\n\n# 是否进行p值校正并根据校正后p值挑选\n# whether or not to perform p-value correction and select based on the corrected p-value\nfdr <- T\n\nif(fdr == T){\n  # p.adjust\n  mytable$fdr <- p.adjust(mytable$`Pr(>F)`, method = \"fdr\")\n  # 根据fdr挑选理化因子\n  # select physicochemical factors based on fdr\n  choose <- mytable[mytable$fdr < 0.05,]\n}else{\n  choose <- mytable[mytable$`Pr(>F)` < 0.05,]\n}\n\n# 把计算结果保存到文件，可以像例文那样，作为文章的补充材料\n# save the calculations to a file that can be used as additional material for the article, as in the example essay\nwrite.csv(choose, \"output_Adonis.csv\", quote = F)\n开始画图\nStart drawing\nlibrary(ggplot2)\n#根据R2排序\n#sort by R2\nchoose <- choose[order(choose$R2),]\nchoose$factor <- factor(row.names(choose),levels=row.names(choose))\n\n#定义足够多的颜色，对应理化因子分组的数量\n#define a sufficient number of colors corresponding to the number of physicochemical factor groupings\nmycol <- c(\"#BD6263\",\"#8EA325\",\"#A9D179\",\"#84CAC0\",\"#F5AE6B\",\"#BCB8D3\",\"#4387B5\")\n\n#理化因子有无分组\n#physical and chemical factors with or without grouping\ngroup <- T #此处有分组信息 grouping information is available here\n\nif (group == T) { \n  choose <- merge(choose,gp,by=\"factor\")\n  ggplot(choose,aes(x=factor, y=R2, fill = group)) + #按分组填充颜色 fill color by group\n    geom_bar(stat = \"identity\",color = \"black\") + #bar有黑色边框 bar has a black border\n    scale_x_discrete(expand = c(0,0)) + #上下不留空 do not leave it blank up and down\n    scale_fill_manual(values = mycol) + #使用自定义的配色 use a custom color scheme\n    \n    labs(x=\"\",y=\"Adnois R2\") +\n    coord_flip() + #坐标轴互换 coordinate-axis interchange\n    \n    theme_bw() + #去除背景色 remove background color\n    theme(panel.grid =element_blank()) + #去除网格线 remove gridlines\n    theme(panel.border = element_blank()) + #去除外层边框 remove outer border\n    theme(axis.line = element_line(colour = \"black\")) +#沿坐标轴显示直线 display lines along the axes\n    \n    guides(fill = guide_legend(title = NULL)) \n\n} else {\n  #不提供分组信息的情况\n  #circumstances in which grouping information is not provided\n  ggplot(choose,aes(x=factor,y=R2),fill = \"black\") + \n    geom_bar(stat = \"identity\",color = \"black\") + \n    scale_x_discrete(expand = c(0,0)) + \n\n    labs(x=\"\", y=\"Adnois R2\") +\n    coord_flip() +\n    theme_bw() +\n    theme(panel.grid =element_blank()) + \n    theme(panel.border = element_blank()) + \n    theme(axis.line = element_line(colour = \"black\")) +\n    \n    guides(fill = guide_legend(title = NULL)) \n}\n#保存到PDF文件\n#save to PDF file\nggsave(\"adonis_barplot.pdf\")\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa48Adonis_FigureYa48Adonis",
      "title": "FigureYa48Adonis/FigureYa48Adonis.html",
      "html": "FigureYa48Adonis/FigureYa48Adonis.html",
      "text": "texts/main_FigureYa48Adonis_FigureYa48Adonis.txt",
      "folder": "FigureYa48Adonis",
      "thumb": "gallery_compress/FigureYa48Adonis.webp"
    },
    "word_count": 620,
    "lines_count": 148,
    "title": "FigureYa48 Adonis",
    "description": "Requirement description 进行置换多元方差分析（PERMANOVA，Adonis），画出图b Perform permutational multivariate analysis of variance (PERMANOVA,",
    "input_data_types": [
      "临床数据",
      "突变数据"
    ],
    "output_types": [
      "统计表格"
    ],
    "technical_methods": [],
    "biology_areas": [],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "colour",
      "values",
      "parallel",
      "header",
      "permutations",
      "grid",
      "method",
      "line",
      "data",
      "x"
    ]
  },
  {
    "id": "main_FigureYa195PanPaire_FigureYa195PanPaire",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa195PanPaire_FigureYa195PanPaire.txt",
    "content": "FigureYa195PanPair\nFigureYa195PanPair\nAuthor(s)\n: Xiaofan Lu; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-05-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirements Description\n直接比较了泛癌里面paired的基因的表达差异。之前的FigureYa55panCancer_violin比较癌和normal，没有paired的数据。\nA direct comparison was made of the gene expression differences in\npaired samples across pan-cancer. The previous\nFigureYa55panCancer_violin compared cancer versus normal tissues but did\nnot use paired data.\n出自：\nhttps://www.nature.com/articles/s41388-019-1026-9\n图1 人类癌症中rRNA代谢相关基因的表达图谱。 a)\nTCGA数据库中按癌症类型分组的所有样本的rRNA代谢评分。Y轴表示基于TCGA基因表达数据通过ssGSEA方法计算的rRNA代谢评分。箱线图展示了中位数、四分位数、最小值和最大值，每个点代表一个独立样本。p值采用Mann-Whitney检验计算。\nb)\n与(a)相似，但分析的是TCGA中按癌症类型分组的配对样本。每个点代表一个样本。p值通过双尾Student\nt检验得出。\nSource:\nhttps://www.nature.com/articles/s41388-019-1026-9\nFig. 1 Expression landscape of rRNA metabolism-related genes in human\ncancer. a) rRNA metabolic score among all samples grouped by cancer from\nthe TCGA. Y-axis representing rRNA metabolic score, which was calculated\nby ssGSEA based on the gene expression in the TCGA. Boxplots show\nmedian, quartiles, min, and max, each point representing one sample.\np-values are based on the Mann–Whitneytest. b) Similar to (a), but\nin paired samples\ngrouped by cancer from the TCGA. Each\npoint representing one sample. p-values are based on two-tailed Student\nt-test.\n应用场景\nApplication Scenario\n提取TCGA泛癌里配对样本的表达量，再从中提取感兴趣的通路里的基因，计算通路富集得分，画出连线图。\n根据barcode提取配对样本的方法同样适用于TCGA的其他类型数据，例如DNA甲基化等。\n配对样本的表达量还可以用来做更能多分析，画更多图。例如用来筛选配对间的差异表达基因，用FigureYa149rankHeatmap来展示。\n还可以把基因集换成你感兴趣的signature、biomarker。你在某个cohort里发现的差异基因，再来TCGA泛癌里看看异同。\nExtract expression data from paired samples in TCGA pan-cancer, then\nselect genes from pathways of interest, calculate pathway enrichment\nscores, and generate a connected-line plot.\nThe same barcode-based method for extracting paired samples can also\nbe applied to other TCGA data types, such as DNA methylation.\nThe paired-sample expression data can be used for additional analyses\nand visualizations. For example, it can be used to identify\ndifferentially expressed genes (DEGs) between paired samples and display\nthem using FigureYa149rankHeatmap.\nYou can also replace the gene sets with your own signatures or\nbiomarkers of interest. For instance, DEGs identified in a specific\ncohort can be further examined in TCGA pan-cancer to compare\nsimilarities and differences.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(data.table)\nlibrary(GSVA)\n\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\")\n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n输入文件的获得\nObtaining Input Files\n如果你已经准备好easy_input_pair.txt、easy_input_expr.RDS和easy_input_gene.txt文件，就可以跳过这步，直接进入“输入文件”。\nIf you already have the files easy_input_pair.txt,\neasy_input_expr.RDS and easy_input_gene.txt prepared, you can skip this\nstep and go directly to “Input Files”.\nTCGA pan-cancer配对样本的表达矩阵提取\nExtracting Paired-Sample Expression Matrix from TCGA Pan-Cancer\n这步运行一次就行，可直接跳到“获取感兴趣的基因集”。\n这步提取出的配对样本及其表达矩阵，已保存到easy_input_pair.txt和easy_input_expr.RDS文件。你可以用这些配对样本的表达量做很多事情，不要局限于例图哦～\nGDC-PANCAN.basic_phenotype.tsv，样本信息，从XENA下载\nhttps://xenabrowser.net/datapages/\nEBPlusPlusAdjustPANCAN_IlluminaHiSeq_RNASeqV2.geneExp.tsv，表达矩阵，从TCGA\nPanCanAtlas下载：\nhttps://gdc.cancer.gov/about-data/publications/pancanatlas\nThis step only needs to be run once. You can go directly to\n“Obtaining Gene Sets of Interest”.\nThe extracted paired samples and their expression matrices have been\nsaved in easy_input_pair.txt and easy_input_expr.RDS. You can use this\npaired-sample expression data for many analyses - don’t limit yourself\nto the example plots.\nGDC-PANCAN.basic_phenotype.tsv: Sample information, downloaded from\nXENA\nhttps://xenabrowser.net/datapages/\nEBPlusPlusAdjustPANCAN_IlluminaHiSeq_RNASeqV2.geneExp.tsv: Expression\nmatrix, downloaded from TCGA PanCanAtlas\nhttps://gdc.cancer.gov/about-data/publications/pancanatlas\n.\n# 载入样本信息\n# Load sample information\npheno <- read.table(\"GDC-PANCAN.basic_phenotype.tsv\",sep = \"\\t\",row.names = 1,header = T,check.names = F,stringsAsFactors = F)\n\n# 加载基因表达矩阵\n# Load gene expression matrix\nexpr <- fread(\"EBPlusPlusAdjustPANCAN_IlluminaHiSeq_RNASeqV2.geneExp.tsv\",sep = \"\\t\",header = T,check.names = F,stringsAsFactors = F)\n\n# 表达矩阵数据处理\n# Process expression matrix data\nexpr <- as.data.frame(expr)\n\n# 取\"|\"左侧的基因名\n# Take gene names before \"|\" \nexpr$gene_id <- sapply(strsplit(expr$gene_id,\"|\",fixed = T), \"[\", 1)\n\n# 去重\n# Remove duplicates\nexpr <- expr[!duplicated(expr$gene_id),] \n\n# 移除带有\"?\"的基因\n# Remove genes with \"?\" and drop first column\nrownames(expr) <- expr$gene_id; expr <- expr[-grep(\"?\",rownames(expr),fixed = T),-1] \n\n# 取前16位barcode\n# Take first 16 characters of barcode \ncolnames(expr) <- substr(colnames(expr), start = 1, stop = 16) \n\nexpr[1:3,1:3]\n\n# 样本信息处理（取TCGA中原位癌和正常样本）\n# Process sample information (Select TCGA primary tumor and normal samples)\npheno <- pheno[which(pheno$program == \"TCGA\" & pheno$sample_type_id %in% c(1,11)),] \n\n# 更新数据\n# Update data\ncom_sam <- intersect(colnames(expr),rownames(pheno))\nexpr <- expr[,com_sam]\npheno <- pheno[com_sam,]\n根据TCGA sample barcode的规则提取配对样本及其对应的表达矩阵，\nhttps://docs.gdc.cancer.gov/Encyclopedia/pages/TCGA_Barcode/\nExtracting paired samples and their corresponding expression matrices\nbased on TCGA sample barcode rules,\nhttps://docs.gdc.cancer.gov/Encyclopedia/pages/TCGA_Barcode/\n# 获取唯一的项目ID\n# Get unique project IDs \nproid <- unique(pheno$project_id)\n\n# 初始化空数据框用于存储配对样本\n# Initialize empty dataframe for paired samples \ntcga.pan.pair <- NULL\n\n# 遍历每个项目\n# Loop through each project\nfor (i in proid) {\n  \n  # 获取当前项目的所有样本\n  # Get all samples for current project \n  sam <- rownames(pheno[which(pheno$project_id == i),])\n  \n  # 识别正常样本(-11A)\n  # Identify normal samples (-11A)\n  n.sam <- sam[grep(\"-11A\",sam)]\n  \n  # 识别肿瘤样本(-01A)\n  # Identify tumor samples (-01A) \n  t.sam <- sam[grep(\"-01A\",sam)]\n  \n  # 如果存在正常样本\n  # If normal samples exist \n  if(length(n.sam) > 0) {\n    \n    # 从正常样本中提取患者代码\n    # Extract patient codes from normal samples \n    toMatch <- substr(n.sam,start = 9, stop = 12)\n    \n    # 寻找匹配的肿瘤样本\n    # Find matching tumor samples \n    matches <- unique(grep(paste(toMatch,collapse = \"|\"), \n                           t.sam, value = TRUE))\n    \n    # 如果找到匹配\n    # If matches found \n    if(length(matches) > 0) {\n      \n      # 提取患者代码\n      # Extract patient codes\n      t.code <- substr(matches, start = 1, stop = 12)\n      n.code <- substr(n.sam, start = 1, stop = 12)\n      \n      # 寻找共有的患者代码\n      # Find common patient codes \n      com_code <- intersect(t.code, n.code)\n      \n      # 创建配对样本ID\n      # Create paired sample IDs\n      pair.t.sam <- paste0(com_code, \"-01A\")\n      pair.n.sam <- paste0(com_code, \"-11A\")\n      \n      # 创建配对样本数据框\n      # Create dataframe for paired samples \n      tmp <- data.frame(samID = c(pair.t.sam,pair.n.sam),\n                        tissue = rep(c(\"paired.tumor\",\"paired.normal\"), each = length(com_code)),\n                        project = i,\n                        row.names = c(pair.t.sam,pair.n.sam),\n                        stringsAsFactors = F)\n      \n      # 合并结果\n      # Combine results \n      tcga.pan.pair <- rbind.data.frame(tcga.pan.pair,tmp,stringsAsFactors = F)\n    } else {cat(\"Fail to find matched tumor samples for \",i,\"\\n\")}\n\n  } else {cat(\"Fail to find normal samples for \",i,\"\\n\")}\n}\n\n# 按项目统计样本数\n# Count samples by project\ntable(tcga.pan.pair$project)\n\n# 保存配对样本信息到文件\n# Save paired sample info to file\nwrite.table(tcga.pan.pair,\"easy_input_pair.txt\",sep = \"\\t\",row.names = F,quote = F)\n\n# 进一步更新数据\n# Further update data\nexpr <- as.data.frame(na.omit(expr[,tcga.pan.pair$samID]))\n\n# 保存配对样本表达矩阵\n# Save expression matrix of paired samples\nsaveRDS(expr, \"easy_input_expr.RDS\")\n获取感兴趣的基因集\nObtaining Gene Sets of Interest\n感兴趣的通路里包含哪些基因？\n可以从领域内的网站或数据库下载，或者通过阅读综述、研究论文，自己总结基因名。\n这里提供一个方法，从GSEA网站下载MSigDB的gmt文件\nhttp://software.broadinstitute.org/gsea/downloads.jsp\n，从gmt文件中获得感兴趣通路里的基因，以\nh: hallmark gene sets\n为例，下载\nh.all.v7.1.symbols.gmt\n文件。\n用到了FigureYa151pathifier里的自定义函数。\nWhich genes are included in your pathways of interest?\nYou can download them from domain-specific websites or databases, or\nmanually compile gene lists by reviewing literature and research\npapers.\nHere we provide one method: Download GMT files from MSigDB on the\nGSEA website\nhttp://software.broadinstitute.org/gsea/downloads.jsp\n,\nthen extract genes from your target pathways in the GMT file. Taking the\nh: hallmark gene sets\nas an example, download the file\nh.all.v7.1.symbols.gmt\n.\nThis process utilizes custom functions from FigureYa151pathifier.\n# 自定义函数，用于读取gmt文件为列表形式\n# Custom function to read GMT file as list\ngmt2list <- function(annofile){\n  \n  # 检查文件是否存在\n  # Check file existence\n  if (!file.exists(annofile)) {\n    stop(\"There is no such gmt file.\")\n  }\n  \n  # 处理压缩文件\n  # Handle compressed files\n  if (tools::file_ext(annofile) == \"xz\") {\n    annofile <- xzfile(annofile)\n    x <- scan(annofile, what=\"\", sep=\"\\n\", quiet=TRUE)\n    close(annofile)\n  } else if (tools::file_ext(annofile) == \"gmt\") {\n    x <- scan(annofile, what=\"\", sep=\"\\n\", quiet=TRUE)\n  } else {\n    stop (\"Only gmt and gmt.xz are accepted for gmt2list\")\n  }\n  \n  # 处理GMT文件内容\n  # Process GMT content\n  y <- strsplit(x, \"\\t\")\n  names(y) <- sapply(y, `[[`, 1)\n  \n  # 返回基因列表\n  # Return gene lists\n  annoList <- lapply(y, `[`, c(-1,-2))\n}\n\n# 读取GMT文件\n# Read GMT file\ngset <- gmt2list(\"h.all.v7.1.symbols.gmt\") \n\n# 提取带有OXIDATIVE字样的通路\n# Extract pathways containing \"OXIDATIVE\"\ngset_meta <- gset[names(gset) %like% \"OXIDATIVE\"]\ngset_meta\nmeta <- gset_meta$HALLMARK_OXIDATIVE_PHOSPHORYLATION\n\n# 或者要多个通路\n# Alternative, combine multiple pathways\n#meta <- c(gset$HALLMARK_DNA_REPAIR, gset$HALLMARK_APOPTOSIS)\n\n# 保存到文件\n# Save to file\n#write.table(meta, \"easy_input_gene.txt\", row.names = F, col.names = F, quote = F)\n输入文件\nInput Files\neasy_input_gene.txt，代谢基因，来自例文补充材料41388_2019_1026_MOESM2_ESM.xlsx中Table\nS1。不局限于通路，还可以是某一群基因，例如前期研究筛选出的signature等。\neasy_input_pair.txt，配对样本信息。\neasy_input_expr.RDS，配对样本的表达矩阵。\neasy_input_gene.txt - Metabolic genes sourced from Supplementary\nTable S1 in the reference publication (41388_2019_1026_MOESM2_ESM.xlsx).\nNot limited to pathway genes, this may also include specific gene sets\nsuch as signatures identified in previous studies.\neasy_input_pair.txt - Paired sample information.\neasy_input_expr.RDS - Expression matrix of paired samples.\n# 加载感兴趣通路里的基因\n# Load genes from pathway of interest\nmeta <- read.table(\"easy_input_gene.txt\")$V1\n\n# 加载配对样本信息\n# Load paired sample information\ntcga.pan.pair <- read.table(\"easy_input_pair.txt\", header = T)\n\n# 加载配对样本的表达矩阵\n# Load expression matrix of paired samples\nexpr <- readRDS(\"easy_input_expr.RDS\")\nexpr[1:3, 1:3]\n单样本富集得分\nSingle-Sample Enrichment Score\n大白话：把每一个样本中多个基因的表达值（多个数值）用ssGSEA换算成一个数值。这样一来，画图时就可以清晰地看到每对配对样本的normal和tumor之间的表达量谁高谁低了。\n用ssGSEA计算通路的富集得分。\nIn simple terms: Convert the expression values of multiple genes\n(multiple numerical values) in each sample into a single numerical value\nusing ssGSEA. This allows clear visualization in plots to compare\nexpression levels between normal and tumor samples in each paired\nset.\nUse ssGSEA to calculate pathway enrichment scores.\n# 准备输入数据\n# Prepare input data \nindata <- expr\n\n# 数据转换：log2(标准化计数+1)\n# Data transformation: log2(normalized counts + 1) \nindata <- round(log2(pmax(indata + abs(min(indata)), 0) + .Machine$double.eps + 1),3) \n\n# 创建GSVA参数对象\n# Create GSVA parameter object\ngsva_params <- ssgseaParam(exprData = as.matrix(indata),\n                          geneSets = list(\"metabolism\" = meta))\n\n# 运行ssGSEA分析\n# Run ssGSEA analysis\nmeta.ssgsea <- gsva(gsva_params)\n# 准备包含得分的元数据\n# Prepare metadata with scores\npan.meta <- tcga.pan.pair\n\n# 对富集分数进行Z-score标准化\n# Z-score normalization of enrichment scores\npan.meta$mscore <- scale(as.numeric(meta.ssgsea[1,pan.meta$samID]))\n配对检验\nPaired Testing\n# 获取所有癌症类型 \n# Get all cancer types\nproid <- unique(pan.meta$project)\n\n# 初始化p值和显著性标记向量 \n# Initialize vectors for p-values and significance markers\nwp <- sig <- c()\n\n# 遍历每种癌症类型 \n# Loop through each cancer type\nfor(i in proid) {\n  \n  # 提取当前癌症类型的样本 \n  # Extract samples for current cancer type\n  tmp <- pan.meta[which(pan.meta$project == i),]\n  \n  # 分离肿瘤和正常样本 \n  # Separate tumor and normal samples\n  t <- tmp[which(tmp$tissue == \"paired.tumor\"),]\n  n <- tmp[which(tmp$tissue == \"paired.normal\"),]\n  \n  # 执行配对Wilcoxon检验 \n  # Perform paired Wilcoxon test\n  wp <- c(wp, wilcox.test(t$mscore,n$mscore,paired = T)$p.value)\n  \n  # 根据p值计算显著性标记 \n  # Calculate significance markers based on p-value\n  sig <- c(sig, as.character(cut(wilcox.test(t$mscore,n$mscore,paired = T)$p.value,\n                                 c(0,0.001,0.005,0.01,0.05,1),c(\"****\",\"***\",\"**\",\"*\",\"\"))))\n}\n\n# 设置名称 \n# Set names\nnames(wp) <- names(sig) <- unique(pan.meta$project)\n\n# 查看结果 \n# View results\nwp\nsig\n开始画图\nPlotting\n# 基础绘图\n# Base R plotting \nylim <- c(floor(range(pan.meta$mscore)[1]), ceiling(range(pan.meta$mscore)[2]))\n\n# 初始化PDF输出\n# Initialize PDF output\npdf(\"Metabolic landscape of tcga paired sample.pdf\",width = 8.5,height = 3.5)\n\n# 默认不显示布局结构\n# Default: don't show layout structure in final PDF\nshowLayout <- F \n\n# 设置复杂布局矩阵\n# Set complex layout matrix \nmat <- c(rep(c(rep(1,2), rep(2,2), rep(3:24,each = 3)),16))\nlayout(matrix(c(mat, rep(25, 4+22*3)),byrow = T,nrow = 17)) \n\n# 可选布局预览\n# Optional layout preview\nif(showLayout) {\n  layout.show(n = 25) \n}\n\n#---------------------------#\n# 画布区域1：绘制最左侧标签 #\n# Canvas Area 1: Left label #\n#---------------------------#\npar(bty = \"n\", mgp = c(2,.6,0), mar = c(0,0,0,0), xpd = T)\nplot(0,0,col = \"white\",\n     xlab = \"\",xaxt = \"n\", \n     ylab = \"\",yaxt = \"n\",\n     xaxs = \"i\", yaxs = \"i\") \ntext(0,0,\"rRNA metabolic score\\n[Z-score (ssGSE)]\", srt = 90, cex = 1, font = 2)\n\n#------------------------------#\n# 画布区域2：绘制最左侧区域y轴 #\n#  Canvas Area 2: Left y-axis  #\n#------------------------------#\npar(bty = \"o\", mgp = c(2,.6,0), mar = c(3,1.5,1,0), las = 2, font.axis = 2, xpd = F) \na <- barplot(c(0,0),\n             border = NA,\n             ylim = ylim,\n             xlab = \"\", xaxt = \"n\", \n             ylab = \"rRNA metabolic score\\n[Z-score (ssGSE)]\", yaxt = \"n\") \naxis(side = 2, at = pretty(ylim), lwd = 2)\nabline(h = par(\"usr\")[3], col = \"black\", lwd = 3)\nabline(h = par(\"usr\")[4], col = \"black\", lwd = 2) \n\n#-------------------------------#\n#  画布区域3-24：绘制22种癌症   #\n# Canvas Areas 3-24: 22 cancers #\n#-------------------------------#\nfor (i in proid) {\n  \n  # 提取肿瘤/正常样本分数\n  # Extract tumor/normal scores\n  t.dat <- pan.meta[which(pan.meta$project == i & pan.meta$tissue == \"paired.tumor\"),]\n  n.dat <- pan.meta[which(pan.meta$project == i & pan.meta$tissue == \"paired.normal\"),]\n  \n  # 设置空柱状图对齐\n  # Setup empty barplot for alignment \n  par(bty = \"n\", mgp = c(2,.6,0), mar = c(3,0,1,0), las = 2, font.axis = 2, xpd = F) \n  a <- barplot(c(0,0), col = \"white\",\n               border = NA,\n               ylim = ylim,\n               xlab = \"\", xaxt = \"n\", \n               ylab = \"\", yaxt = \"n\")\n  \n  # 添加癌症名称标签\n  # Add cancer name label \n  par(xpd = T)\n  text((a[1,] + a[2,])/2 - 0.05, y = par(\"usr\")[3]-0.4, gsub(\"TCGA-\",\"\",i), srt = 35) # 倾斜35度角\n  abline(h = par(\"usr\")[3], col = \"black\", lwd = 2)\n  abline(h = par(\"usr\")[4], col = \"black\", lwd = 2) \n  par(xpd = F)\n  \n  # 右侧边框处理\n  # Right border handling \n  if(i != proid[length(proid)]) {\n    abline(v = par(\"usr\")[2], col = \"#3B50A0\", lwd = 3, lty = 3) \n  } else { # 否则封上蓝色虚线\n    abline(v = par(\"usr\")[2]-0.05, col = \"black\", lwd = 3) \n  }\n  \n  # 绘制连接线\n  # Draw connecting lines \n  segments(a[1,], t.dat$mscore,\n           a[2,], n.dat$mscore,\n           col = \"#6C99CE\", lwd = 1.5)\n  \n  # 添加点\n  # Add points\n  points(rep(a[1,], nrow(t.dat)), t.dat$mscore, pch = 19, col = \"#BB61A1\", cex = 1.2)\n  points(rep(a[2,], nrow(n.dat)), n.dat$mscore, pch = 19, col = \"#7EC09A\", cex = 1.2)\n  \n  # 添加显著性标记\n  # Add significance markers \n  text((a[1,] + a[2,])/2, y = par(\"usr\")[4]-0.3, as.character(sig[i]), cex = 1.2)\n}\n\n#--------------------------#\n# 画布区域25：绘制底部图例 #\n#  Canvas Area 25: Legend  #\n#--------------------------#\npar(bty = \"n\", mgp = c(2,.6,0), mar = c(0,0,0,0), xpd = T)\nplot(0,0,col = \"white\",\n     xlab = \"\",xaxt = \"n\", \n     ylab = \"\",yaxt = \"n\",\n     xaxs = \"i\", yaxs = \"i\") \nlegend((par(\"usr\")[1] + par(\"usr\")[2])/2,par(\"usr\")[4],\n       legend = c(\"Tumor\",\"Normal\"),\n       col = c(\"#BB61A1\",\"#7EC09A\"),\n       pch = c(19,19),\n       border = NA, \n       bty = \"n\", \n       cex = 1.1,\n       x.intersp = 0.5,\n       y.intersp = 1,\n       #yjust = 0.5,\n       horiz = T) \n\n# 关闭图形设备\n# Close graphics device\ninvisible(dev.off())\n\n# 保存工作空间\n# Save workspace \n#save.image(\"PanMeta.RData\")\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa195PanPaire_FigureYa195PanPaire",
      "title": "FigureYa195PanPaire/FigureYa195PanPaire.html",
      "html": "FigureYa195PanPaire/FigureYa195PanPaire.html",
      "text": "texts/main_FigureYa195PanPaire_FigureYa195PanPaire.txt",
      "folder": "FigureYa195PanPaire",
      "thumb": "gallery_compress/FigureYa195PanPaire.webp"
    },
    "word_count": 2008,
    "lines_count": 536,
    "title": "FigureYa195PanPair",
    "description": "Requirements Description 直接比较了泛癌里面paired的基因的表达差异。之前的FigureYa55panCancer_violin比较癌和normal，没有paired的数据。 A direct comparison was made of the gene expression differences in",
    "input_data_types": [
      "临床数据",
      "表达矩阵"
    ],
    "output_types": [
      "火山图",
      "热图",
      "统计表格",
      "箱线图"
    ],
    "technical_methods": [
      "通路分析",
      "生存分析",
      "标准化",
      "差异表达分析"
    ],
    "biology_areas": [
      "癌症研究",
      "代谢疾病"
    ],
    "complexity_level": "高级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "paired",
      "intersp",
      "header",
      "lwd",
      "width",
      "ylim",
      "n",
      "samID",
      "nrow"
    ]
  },
  {
    "id": "main_FigureYa144DiagHeatmap_FigureYa144DiagHeatmap",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa144DiagHeatmap_FigureYa144DiagHeatmap.txt",
    "content": "FigureYa144DiagHeatmap\nFigureYa144DiagHeatmap\nAuthor(s)\n: Xiaofan Lu\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n绘制元素对角化热图。 Draw the element diagonalization heat map.\n出自\nhttps://molecular-cancer.biomedcentral.com/articles/10.1186/s12943-019-1066-3\nFrom\nhttps://molecular-cancer.biomedcentral.com/articles/10.1186/s12943-019-1066-3\nFig. 1 Pan-cancer genetic and expression alterations of m6A\nregulators. d The CNV alteration frequency of m6A regulators across\ncancer types.\nThe upper part of each grid shows the deletion\nfrequency, and the bottom part shows the amplification\nfrequency\n.\n应用场景\nApplication scenarios\n倘若同一对象的某一因素存在对立的两个水平，用经典热图展示这样的结构可能要画两次；那不如试试这幅对角热图，每个元素都分割成上下两块，完美展示对立水平哦～\nIf a factor of the same object has two opposing levels, it may take two\ntimes to display such a structure using a classic heat map; why not try\nthis diagonal heat map, where each element is divided into two pieces,\nperfectly showing the opposing levels~\n例如像例文这种展示某癌症的某基因存在拷贝数扩增和缺失的对立水平； For\nexample, the example shows that a gene in a certain cancer has opposing\nlevels of copy number amplification and deletion;\n或者同时展示基因在多个样品中的表达量（激活）和DNA甲基化水平（抑制）等等。\nOr simultaneously display the expression level (activation) and DNA\nmethylation level (inhibition) of a gene in multiple samples, etc.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nLoad package\nlibrary(reshape2)\nlibrary(RColorBrewer)\n\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息  #Display English error message\noptions(stringsAsFactors = FALSE) #禁止chr转成factor #Disable chr conversion to factor\n输入文件\nInput file\neasy_input_amp.txt和easy_input_del.txt，两个矩阵。分别对应热图中的左上角（amplification）和右下角（deletion）。例文是突变数据，每行一个基因，每列一种癌症类型，两个文件一一对应。还可以是基因表达量等数值。数据来源：例文的Additional\nfile 1\nhttps://static-content.springer.com/esm/art%3A10.1186%2Fs12943-019-1066-3/MediaObjects/12943_2019_1066_MOESM1_ESM.xlsx\neasy_input_amp.txt and easy_input_del.txt, two matrices. They correspond\nto the upper left corner (amplification) and lower right corner\n(deletion) in the heat map respectively. The example text is mutation\ndata, one gene per row, one cancer type per column, and the two files\ncorrespond one to one. It can also be numerical values such as gene\nexpression. Data source: Additional file 1 of the example article\nhttps://static-content.springer.com/esm/art%3A10.1186%2Fs12943-019-1066-3/MediaObjects/12943_2019_1066_MOESM1_ESM.xlsx\n总之，把你自己的数据按照这两个文件的格式替换就好。 In short, just\nreplace your own data according to the format of these two files.\n# 左上角的数据\n# Data in the upper left corner\nup <- read.table(\"easy_input_amp.txt\",sep = \"\\t\",row.names = NULL,check.names = F,stringsAsFactors = F,header = T)\nup[1:3, 1:3]\n# 右下角的数据\n# Data in the lower right corner\ndn <- read.table(\"easy_input_del.txt\",sep = \"\\t\",row.names = NULL,check.names = F,stringsAsFactors = F,header = T)\ndn[1:3, 1:3]\n# 检验两个矩阵是否一致\n# Check if the two matrices are consistent\nidentical(dim(up),dim(dn))\n把数据转换成画图所需的格式\nConvert the data to the format required for drawing\nup.long$Categrory <- \"UP\"\nhead(up.long)\ndn.long <- setNames(melt(dn), c('Gene', 'Cancer', 'Frequency'))\ndn.long$Categrory <- \"DN\"\nhead(dn.long)\n# generate color for up and dn seperately\n# 坐上角颜色\n# Upper left corner color\nup.long$range <- cut(up.long$Frequency, \n                     breaks = seq(floor(min(up.long$Frequency)),\n                                  ceiling(max(up.long$Frequency)),0.01)) # 分割富集得分，步长为0.01（如果希望颜色更加细腻可以步长缩短，但是没有必要）\n# Segment enrichment score, step size is 0.01 (if you want the color to be more delicate, you can shorten the step size, but it is not necessary)\nrangeMat1 <- levels(up.long$range) # 提出分割区间 # Propose segmentation intervals\nrbPal1 <- colorRampPalette(colors = c(nake,red)) # 产生和例文一致的颜色区间函数\n# Generate color interval function consistent with the example text\ncol.vec1 <- rbPal1(length(rangeMat1)); names(col.vec1) <- rangeMat1 # 产生配对的颜色向量\n# Generate paired color vectors\nup.long$color <- col.vec1[as.character(up.long$range)] # 匹配每个区间对应的颜色\n# Match the color corresponding to each interval\nhead(up.long)\n# 右下角颜色\n# Bottom right corner color\ndn.long$range <- cut(dn.long$Frequency, breaks = seq(floor(min(dn.long$Frequency)),ceiling(max(dn.long$Frequency)),0.01)) \nrangeMat2 <- levels(dn.long$range)\nrbPal2 <- colorRampPalette(colors = c(nake,blue))\ncol.vec2 <- rbPal2(length(rangeMat2)); names(col.vec2) <- rangeMat2\ndn.long$color <- col.vec2[as.character(dn.long$range)]\n\n# combine up and dn cells\nheatmat <- rbind.data.frame(up.long,dn.long) # 汇总热图矩阵 # Summarize the heatmap matrix\nhead(heatmat)\ntail(heatmat)\n开始画图\nStart drawing\n用base plot一笔一笔画图 Draw one stroke at a time using base plot\npdf(\"Diagonally cut heat map.pdf\",width = 8,height = 6)\nlayout(matrix(c(rep(rep(c(1,2),c(1,length(cancer.level))),length(gene.level)),\n                rep(3,11),rep(4,6),rep(5,6),rep(6,11),\n                rep(3,11),rep(4,6),rep(5,6),rep(6,11)),\n              byrow = T,nrow = length(gene.level)+2))\n\n#------------------------#\n# 画布区域1：左侧柱状注释#\n#------------------------#\n#------------------------#\n# Canvas area 1: left column annotation#\n#------------------------#\n\n#如果不画左侧分类，就不运行这段，直接跳到“画布区域2：主要热图区域”\n#If you don't draw the left classification, don't run this section, jump directly to \"Canvas area 2: main heat map area\"\npar(bty=\"n\", mgp = c(2,0.5,0),mar = c(4.1,0.1,2.1,0.1),tcl=-.25,xpd = T) # 和热图保持一致，但左右间隔变小\n# Same as the heat map, but with smaller left and right intervals\nb <- barplot(matrix(c(2,7,11)), # 堆叠柱状图，这里对应三种m6A regulator分类，实际应用时根据自己的分类数量决定\n# Stacked bar chart, here corresponds to three m6A regulator classifications, in actual application, it depends on the number of your own classifications\n             col = c(\"#5AC9FA\",\"#FAC67A\",\"#51B743\"), # 柱子颜色  # Column color\n             border = NA, ylim = c(0,length(gene.level)),\n             xaxs=\"i\", yaxs=\"i\", # 取消坐标轴与实际画图区域的间隙\n# Cancel the gap between the coordinate axis and the actual drawing area\n             yaxt = \"n\")\n# 添加块名，实际应用时根据自己的分类数量调整\n# Add block name, in actual application, adjust according to the number of your own classifications\ntext(b,2/2,\"E\",cex = 2) \ntext(b,2+7/2,\"W\",cex = 2)\ntext(b,2+7+11/2,\"R\",cex = 2)\n\n#-------------------------#\n# 画布区域2：主要热图区域 #\n#-------------------------#\n#-------------------------#\n# Canvas area 2: main heat map area #\n#--------------------------#\n\npar(bty=\"n\", mgp = c(2,0.5,0), mar = c(4.1,0.1,2.1,6.1),tcl=-.25,xpd = T)\nx=as.numeric(factor(heatmat$Cancer,levels = cancer.level))\ny=as.numeric(factor(heatmat$Gene,levels = gene.level))\n\n# 创建空白画布\n# Create a blank canvas\nplot(1,\n     xlim=c(1,length(unique(x))+1),\n     ylim=c(1,length(unique(y))+1),\n     xaxs=\"i\", yaxs=\"i\",\n     xaxt=\"n\",yaxt=\"n\",\n     type=\"n\",bty=\"n\",\n     xlab=\"\",ylab=\"\",\n     main = \"Copy number variation across cancer types\")\n# 填充颜色\n# fill color\nfor(i in 1:nrow(heatmat)) {\n  if(heatmat$Categrory[i]==\"UP\") polygon(x[i]+c(0,1,1),y[i]+c(0,0,1),col=heatmat$color[i]) # 填充上三角 # Fill the upper triangle\n  if(heatmat$Categrory[i]==\"DN\") polygon(x[i]+c(0,1,0),y[i]+c(0,1,1),col=heatmat$color[i]) # 填充下三角 # Fill the lower triangle\n}\n# 基因名和癌症名\n# Gene name and cancer name\naxis(1,at = sort(unique(x)) + 0.5,labels = cancer.level,lty = 0,las = 2) # 添加x轴坐标并垂直\n# Add x-axis coordinates and vertical\naxis(4,at = sort(unique(y)) + 0.5,labels = gene.level,lty = 0,las = 1) # 添加y轴坐标并水平\n# Add y-axis coordinates and horizontal\nmtext(\"Cancer types\",side = 1,line = 3) # 在大约第三行的位置补x轴名称\n# Fill in the x-axis name at about the third line\n\n#---------------#\n# 画布区域3：空 #\n#---------------#\n#---------------#\n# Canvas area 3: empty #\n#---------------#\n\npar(mar=c(0,0,0,0),xpd = T)\nplot(0,0,\n     col = \"white\", # 点设置为白色 # Set the point to white\n     xlab = \"\",xaxt = \"n\", # 不显示x坐标轴 # Do not display the x-axis\n     ylab = \"\",yaxt = \"n\") # 不显示y坐标轴 # Do not display the y-axis\n\n#---------------------#\n# 画布区域4：Gain图例 #\n#---------------------#\n#---------------------#\n# Canvas area 4: Gain legend #\n#---------------------#\n\n#当样品数量增加或减少时，需要自己尝试调整图例的位置\n# When the number of samples increases or decreases, you need to try to adjust the position of the legend yourself\npar(mar=c(3.1,0,0,0),xpd = T) #图例的位置，四个数字分别对应bottom, left, top, right\n# The position of the legend, the four numbers correspond to bottom, left, top, right\nbarplot(rep(1,length(col.vec1)),border = \"NA\", space = 0, # 生成条形图图例 \n# Generate a bar chart legend\n        ylab=\"\",\n        xlab=\"\",\n        xlim=c(1,length(col.vec1)),\n        axes = F, col=col.vec1) # 颜色区间 # Color range\ntext(par(\"usr\")[1]+10,par(\"usr\")[3]-0.5,\"0\", adj=0.55,cex = 1.2) # 富集得分-0.5 \n# Enrichment score -0.5\ntext(length(col.vec1)/2,par(\"usr\")[3]-0.5,\"Gain\", adj=0.55,cex = 1.2) # 富集得分0\n# Enrichment score 0\ntext(par(\"usr\")[2]-10,par(\"usr\")[3]-0.5,\"0.9\", adj=0.55,cex = 1.2) # 富集得分0.5\n# Enrichment score 0.5\n\n#---------------------#\n# 画布区域5：Loss图例 #\n#---------------------#\n\npar(mar=c(3.1,0,0,0),xpd = T)\nbarplot(rep(1,length(col.vec2)),border = \"NA\", space = 0, # 生成条形图图例\n# Generate a bar chart legend\n        ylab=\"\",\n        xlab=\"\",\n        xlim=c(1,length(col.vec2)),\n        axes = F, col=col.vec2) # 颜色区间 # Color range\ntext(par(\"usr\")[1]+10,par(\"usr\")[3]-0.5,\"0\", adj=0.55,cex = 1.2) # 富集得分-0.5\n# Enrichment score -0.5\ntext(length(col.vec2)/2,par(\"usr\")[3]-0.5,\"Loss\", adj=0.55,cex = 1.2) # 富集得分0\n# Enrichment score 0\ntext(par(\"usr\")[2]-10,par(\"usr\")[3]-0.5,\"0.9\", adj=0.55,cex = 1.2) # 富集得分0.5\n# Enrichment score 0.5\n\n#---------------#\n# 画布区域6：空 #\n#---------------#\n#---------------#\n# Canvas area 6: empty #\n#---------------#\n\npar(mar=c(0,0,0,0),xpd = T)\nplot(0,0,\n     col = \"white\", # 点设置为白色 # Set the point to white\n     xlab = \"\",xaxt = \"n\", # 不显示x坐标轴 # Do not display the x-axis\n     ylab = \"\",yaxt = \"n\") # 不显示y坐标轴 # Do not display the y-axis\n\n# 关闭图像句柄\n# Close the image handle\ninvisible(dev.off())\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa144DiagHeatmap_FigureYa144DiagHeatmap",
      "title": "FigureYa144DiagHeatmap/FigureYa144DiagHeatmap.html",
      "html": "FigureYa144DiagHeatmap/FigureYa144DiagHeatmap.html",
      "text": "texts/main_FigureYa144DiagHeatmap_FigureYa144DiagHeatmap.txt",
      "folder": "FigureYa144DiagHeatmap",
      "thumb": "gallery_compress/FigureYa144DiagHeatmap.webp"
    },
    "word_count": 1171,
    "lines_count": 251,
    "title": "FigureYa144DiagHeatmap",
    "description": "Requirement description 绘制元素对角化热图。 Draw the element diagonalization heat map. 出自",
    "input_data_types": [
      "突变数据"
    ],
    "output_types": [
      "热图",
      "统计表格"
    ],
    "technical_methods": [
      "通路分析"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "header",
      "width",
      "ylim",
      "xlim",
      "side",
      "nrow",
      "yaxt",
      "yaxs",
      "labels"
    ]
  },
  {
    "id": "main_FigureYa198SignatureCombinationV2_FigureYa198SignatureCombinationV2",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa198SignatureCombinationV2_FigureYa198SignatureCombinationV2.txt",
    "content": "FigureYa198SignatureCombinationV2\nFigureYa198SignatureCombinationV2\nAuthor(s)\n: Xiaofan Lu\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n我想实现下文章figure 1c的计算方法，FigureYa182RFSurv挑出了importance\n比较大的基因，后续常规用muticox等方法再缩减基因。这篇文章写的是用1023中组合按KM的\nlogRank pvalue和基因数目挑选模型，不一样的风格。\nRequirement Description\nI would like to crowdsource the calculation method for Figure 1c in\nthe article. FigureYa182RFSurv selected genes with relatively high\nimportance, followed by conventional methods like multicox to further\nreduce the number of genes. However, this paper describes a different\napproach—selecting the model from 1,023 combinations based on the\nlog-rank p-value of the Kaplan-Meier (KM) analysis and the number of\ngenes, which is a distinct style.\n出自\nhttps://onlinelibrary.wiley.com/doi/abs/10.1002/jcp.28600\nfrom\nhttps://onlinelibrary.wiley.com/doi/abs/10.1002/jcp.28600\nFIGURE 1 Identification of candidate genes and development of an\nintegrated PCG‐lncRNA signature. (a) Volcano plot displayed the lncRNAs\nand PCGs of the univariate Cox regression analysis. (b) Random survival\nforest analysis screened 10 genes. (c) After Kaplan–Meier analysis of 2\n‒1 = 1,023 combinations, the top 20 signatures were sorted according to\nthe p value of KM. And the signature included five genes that were\nscreened out, for it had a relative big −log10 p value and a small\nnumber of genes. KM: Kaplan–Meier; lncRNA: long noncoding RNA; PCG:\nprotein‐coding gene\n应用场景\nApplication scenarios\n核心就是排列组合。\n根据随机生存森林分析筛选变量，通过基因组合后利用log-rank检验取p值显著且基因个数较少的组合，定义为预后签名。\nThe core idea is permutation and combination.\nBased on the variables screened by random survival forest analysis,\ngene combinations are evaluated using the log-rank test, and the\ncombination with a significant p-value and a smaller number of genes is\nselected as the prognostic signature.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nlibrary(survival)\nlibrary(randomForestSRC)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # error messages are displayed in English\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # It is forbidden to convert chr into factor\n自定义函数 Custom functions\n# 显示进程\n# Displays the process\ndisplay.progress = function (index, totalN, breakN=20) {\n  if ( index %% ceiling(totalN/breakN) == 0  ) {\n    cat(paste(round(index*100/totalN), \"% \", sep=\"\"))\n  }\n}\n输入文件\nEnter the file\nbrca.mRNA.expr.txt和brca.lncRNA.expr.txt，基因表达矩阵。\nbrca.surv.txt，临床信息。\n原文只有99个样本。我们这里有180个样本。\nbrca.mRNA.expr.txt and brca.lncRNA.expr.txt, gene expression\nmatrix.\nbrca.surv.txt. Clinical information.\nThe original text had only 99 samples. We have 180 samples here.\n# 加载表达数据 \n# Load the expression data\nmexp <- read.table(\"brca.mRNA.expr.txt\",sep = \"\\t\",header = T,row.names = 1,check.names = F,stringsAsFactors = F)\nlexp <- read.table(\"brca.lncRNA.expr.txt\",sep = \"\\t\",header = T,row.names = 1,check.names = F,stringsAsFactors = F)\nsurv <- read.table(\"brca.surv.txt\",sep = \"\\t\",header = T,row.names = 1,check.names = F,stringsAsFactors = F)\n\n# 提取既有表达数据又有临床数据的样本\n# Samples with both expression and clinical data were extracted\ncom_sam <- intersect(intersect(colnames(mexp),rownames(surv)),colnames(lexp))\nmexp <- mexp[,com_sam]\nlexp <- lexp[,com_sam]\nsurv <- surv[com_sam,]\n\n# 合并表达谱\n# Merge expression matrix\nexpr <- rbind.data.frame(mexp,lexp)\n\n# 去除无表达的基因，log变换，z-score\n# Removal of non-expressed genes, log transformation, z-score\nexpr <- expr[rowSums(expr) > 0,]\nexpr <- as.data.frame(round(t(scale(t(log2(expr + 1)))),3))\n过滤出与OS有关的基因\nFilter out genes associated with OS\ncox.pcutoff <- 0.05 # cox的p阈值 # p-threshold for cox\nCoxoutput.OS <- NULL\nfor (i in 1:nrow(expr)) {\n  display.progress(index = i,totalN = nrow(expr)) # 显示进度 # Shows progress\n  \n  # 产生临时变量存储生存以及变量表达值\n  # Generate temporary variables to store survival and variable expression values\n  tmp <- data.frame(gene = as.numeric(expr[i,]),\n                    OS.time = surv[,\"OS.time\"],\n                    OS = surv[,\"OS\"],\n                    stringsAsFactors = F)\n  \n  # 单变量cox比例风险模型\n  # Univariate COX proportional hazards model\n  cox <- coxph(Surv(OS.time, OS) ~ gene, data = tmp)\n  coxSummary = summary(cox)\n  \n  # 生成cox结果数据框，包括基因名，风险比，z值，waldtest p值，以及HR置信区间\n  # Generate a cox result data frame including gene name, hazard ratio, z-value, Waldtest p-value, and HR confidence intervals\n  Coxoutput.OS=rbind.data.frame(Coxoutput.OS,data.frame(gene=rownames(expr)[i],\n                                                        HR=as.numeric(coxSummary$coefficients[,\"exp(coef)\"]),\n                                                        z=as.numeric(coxSummary$coefficients[,\"z\"]),\n                                                        pvalue=as.numeric(coxSummary$coefficients[,\"Pr(>|z|)\"]),\n                                                        lower=as.numeric(coxSummary$conf.int[,3]),\n                                                        upper=as.numeric(coxSummary$conf.int[,4]),\n                                                        stringsAsFactors = F),\n                                stringsAsFactors = F)\n}\nhead(Coxoutput.OS)\nwrite.csv(Coxoutput.OS,\"univariate cox regression for gene filtering.csv\",row.names = F,quote = F)\n随机森林进一步降维\nRandom forests are further dimensionally reduced\ngene.sel <- Coxoutput.OS[which(Coxoutput.OS$pvalue < cox.pcutoff),\"gene\"]\ntmp <- expr[gene.sel,]\n\nrownames(tmp) <- gsub(\"-\",\"_\",rownames(tmp)) # 防止出现“-”导致程序报错 # Prevent the occurrence of \"-\" from causing errors in the program\ndt.rf <- cbind.data.frame(surv[,c(\"OS\",\"OS.time\")],t(tmp))\n\nntree <- 1000\nsurv.rf <- rfsrc(Surv(OS.time, OS) ~ ., \n                 data = dt.rf, \n                 ntree = ntree,\n                 importance = TRUE,\n                 seed = 12345678)\n排列组合确定最优签名\nPermutations and combinations determine the optimal signature\nnum.imp <- 10\nrel.imp <- sort(surv.rf$importance, decreasing = T)\nrel.imp.sel <- rel.imp[1:num.imp] # 取出一定数量的基因 # Remove a certain number of genes\nnames(rel.imp.sel) <- gsub(\"_\",\"-\",names(rel.imp.sel)) # 还原基因名 # Restore the gene name\n\noutTab <- NULL\nn.sum <- 0\nfor (i in 1:num.imp) {\n  cat(paste0(\"combination using \",i,\" genes...\\n\"))\n  tmp <- utils::combn(names(rel.imp.sel), m=i) # 获取当前基因个数下的排列组合 # Get the permutations and combinations under the current number of genes\n  n <- ncol(tmp)\n  for (j in 1:n) {\n    combgene <- tmp[,j] # 取出每一次组合的基因名 #Take out the gene name for each combination\n    combexpr <- cbind.data.frame(t(expr[combgene,]), # 构建数据库做多变量cox # Build a database to do multivariate cox\n                                 OS.time = surv[,\"OS.time\"],\n                                 OS = surv[,\"OS\"],\n                                 stringsAsFactors = F)\n    cox <- coxph(Surv(OS.time, OS) ~ ., data = combexpr)\n    coxSummary <- summary(cox)\n    coeff <- coxSummary$coefficients[,1] # 取出系数 # Take out the coefficient\n    riskscore <- as.matrix(combexpr[,combgene]) %*% coeff # 计算riskscore # Calculate riskscore\n    riskscore <- data.frame(riskscore = as.numeric(riskscore[,1]),\n                            group = ifelse(riskscore[,1] > median(riskscore[,1]),\"HRisk\",\"LRisk\"), # 根据中位数分组 # Grouped according to median\n                            row.names = rownames(riskscore),\n                            OS.time = combexpr$OS.time,\n                            OS = combexpr$OS,\n                            stringsAsFactors = F)\n    fitd <- survdiff(Surv(OS.time, OS) ~ group,\n                     data = riskscore,\n                     na.action = na.exclude)\n    p.val <- 1-pchisq(fitd$chisq, length(fitd$n) - 1) # log-rank检验 #log-rank test\n    \n    outTab <- rbind.data.frame(outTab,\n                               data.frame(num.gene = ifelse(i == 1, paste0(i,\" gene\"), paste0(i,\" genes\")), # 当前基因数目 # Current number of genes\n                                          km.pvalue = p.val, # KM曲线p值 # KM curve p value\n                                          core.gene = paste(combgene,collapse = \" | \"), # 该组合下的基因 # Genes under the combination\n                                          stringsAsFactors = F),\n                               stringsAsFactors = F)\n  }\n  n.sum <- n + n.sum # 校验排列组合的总数 # Check the total number of permutations\n}\nif(n.sum == 2^num.imp-1) { # 如果总和不等则报错 # If the sum is not equal, an error is reported\n  write.csv(outTab,\"combination of important genes with KM pvalues.csv\",row.names = F,quote = F)\n} else (message(\"Wrong combination!!!\"))\n开始画图\n绘制火山图\nStart drawing\nDraw a volcano map\nsigpoints <- Coxoutput.OS[which(Coxoutput.OS$pvalue < cox.pcutoff),]\nunsigpoints <- Coxoutput.OS[which(Coxoutput.OS$pvalue >= cox.pcutoff),]\n\npdf(\"volcano.pdf\",width = 5,height = 5)\npar(bty = \"o\", mgp = c(2,.6,0), mar = c(3,3,1,1), las = 1, font.axis = 1) # 基础参数\nplot(log(Coxoutput.OS$HR),\n     -log10(Coxoutput.OS$pvalue),\n     xlab = \"Univariate Cox coefficient\",\n     ylab = bquote(\"-log\"[10]~\"(P value)\"),\n     xlim = c(-2,2))\npoints(log(sigpoints$HR),\n       -log10(sigpoints$pvalue),\n       col = ggplot2::alpha(\"#E53435\",0.8),\n       pch = 19)\npoints(log(unsigpoints$HR),\n       -log10(unsigpoints$pvalue),\n       col = ggplot2::alpha(\"#21498D\",0.8),\n       pch = 19)\nabline(h = -log10(cox.pcutoff), lty = 2, col = \"grey60\")\ninvisible(dev.off())\n重要性图\nImportance map\nxrange <- range(pretty(range(rel.imp.sel))) # 根据重要性区间确定x轴范围 # The x-axis range is determined according to the importance interval\nyrange <- c(1,length(rel.imp.sel))  # 根据重要变量个数确定y轴范围 # The y-axis range is determined based on the number of important variables\n\npdf(\"variable importance.pdf\",width = 5,height = 5)\npar(bty = \"o\", mgp = c(1.5,.33,0), mar = c(3,7,1,2),las = 1, tcl = -.25)\nplot(NULL,NULL,\n     xlim = xrange,\n     ylim = yrange,\n     xlab = \"Variable Importance\",\n     ylab = \"\",\n     yaxt = \"n\",\n     las = 1)\naxis(side = 2,at = 1:length(rel.imp.sel),rev(names(rel.imp.sel))) # 补齐y轴\nfor (i in 1:length(rel.imp.sel)) { # 循环添加线 # Cycle through the addition of lines\n  lines(c(xrange[1],rev(rel.imp.sel)[i]),\n        c(i,i),\n        lwd = 2.5,\n        col = \"steelblue\")\n}\ninvisible(dev.off())\n绘制排列组合p值\nPlot permutations and combinations of p-values\nnum.comb <- 20\noutTab2 <- outTab[order(outTab$km.pvalue),][1:num.comb,]\n\npdf(\"combination barplot.pdf\",width = 5,height = 5)\npar(bty = \"o\", mgp = c(1.5,.33,0), mar = c(1,4,3,1),las = 1, tcl = -.25)\nbarplot(rev(-log10(outTab2$km.pvalue)),\n        horiz = T, # 柱状图横向 #Histogram landscape\n        names.arg = rev(outTab2$num.gene), # 添加y轴名称 # Add a y-axis name\n        xaxt = \"n\", # 取消下方x轴 # Cancel the lower x-axis\n        col = \"#E53435\")\naxis(side = 3) # 在上方添加x轴 # Add the x-axis above\nmtext(side = 3, bquote(\"-log\"[10]~\"(P value)\"), line = 1) # 添加x轴名称 # Add a name for the x-axis\ninvisible(dev.off())\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa198SignatureCombinationV2_FigureYa198SignatureCombinationV2",
      "title": "FigureYa198SignatureCombinationV2/FigureYa198SignatureCombinationV2.html",
      "html": "FigureYa198SignatureCombinationV2/FigureYa198SignatureCombinationV2.html",
      "text": "texts/main_FigureYa198SignatureCombinationV2_FigureYa198SignatureCombinationV2.txt",
      "folder": "FigureYa198SignatureCombinationV2",
      "thumb": "gallery_compress/FigureYa198SignatureCombinationV2.webp"
    },
    "word_count": 1217,
    "lines_count": 247,
    "title": "FigureYa198SignatureCombinationV2",
    "description": "我想实现下文章figure 1c的计算方法，FigureYa182RFSurv挑出了importance 比较大的基因，后续常规用muticox等方法再缩减基因。这篇文章写的是用1023中组合按KM的 logRank pvalue和基因数目挑选模型，不一样的风格。",
    "input_data_types": [
      "表达矩阵",
      "突变数据",
      "生存数据",
      "临床数据",
      "DNA-seq"
    ],
    "output_types": [
      "火山图",
      "统计表格",
      "PCA图",
      "生存曲线"
    ],
    "technical_methods": [
      "生存分析"
    ],
    "biology_areas": [],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "gene",
      "seed",
      "header",
      "lwd",
      "width",
      "importance",
      "ylim",
      "ntree",
      "1"
    ]
  },
  {
    "id": "main_FigureYa125FishertestV2_FigureYa125FishertestV2",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa125FishertestV2_FigureYa125FishertestV2.txt",
    "content": "FigureYa125FishertestV2\nFigureYa125FishertestV2\nAuthor(s)\n: Xiaofan Lu, Enyu Lin, Taojun Ye\nReviewer(s)\n: Ying Ge\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n两个指标（miRNA和FAP蛋白）按照高低分为四组，计算两个指标的相关性和p\nvalue，用热图展示。\nRequirement description\nDivide the two indicators (miRNA and FAP protein) into four groups\naccording to their levels, calculate the correlation and p-value between\nthe two indicators, and display them using a heatmap.\n出自\nhttp://cancerres.aacrjournals.org/content/78/7/1751\nfrom\nhttp://cancerres.aacrjournals.org/content/78/7/1751\nFigure 4. E–F, Comparison of the miR-508 ISH scores and the CALD1 and\nFAP IHC scores in colorectal cancer tissues. The correlations are shown\nin European cohort (n ¼ 128; E) and Renji cohort 2 (n ¼ 100; Fisher\nexact test; F).\n应用场景\n本质上就是把连续型因素分类后，研究两种因素间的相关性，用列联表热图展示，同时做Fisher’s\nexact test。\n可用于计算和展示miRNA跟靶基因，或转录因子跟靶基因之间的相关关系。\nApplication scenarios\nEssentially, it is to classify continuous factors, study the\ncorrelation between two factors, display it using a contingency table\nheatmap, and conduct Fisher’s exact test.\nCan be used to calculate and display the correlation between miRNA\nand target genes, or transcription factors and target genes.\n环境设置\nEnvironment settings\n# 设置系统环境变量，使R显示英文报错信息 (Set system environment variable to display error messages in English)\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止R在读取数据时自动将字符串转换为因子 (Prevent R from automatically converting strings to factors when reading data)\noptions(stringsAsFactors = FALSE)\n输入文件\neasy_input.txt，两个连续型变量在每个样本里的观测值。每行一个样本，两列分别是两个观测值，此处是miRNA\nISH scores和FAP IHC scores。\nInput file\neasy_input.txt， The observed values of two continuous variables in\neach sample. Each row contains one sample, and the two columns represent\ntwo observations, namely miRNA ISH scores and FAP IHC scores.\n# 从easy_input.txt文件读取数据，假设首行为列名 (Read data from easy_input.txt, assuming the first row contains column names)\nsimdata <- read.table(\"easy_input.txt\",header = T)\n# 查看数据前几行，了解数据结构 (View the first few rows of the data to understand its structure)\nhead(simdata)\n# 计算两个连续变量之间的相关系数 (Calculate the correlation coefficient between two continuous variables)\n# 此结果将在后续作为图表标题的一部分 (This result will be used as part of the chart title later)\nr.cor <- cor(simdata$miR.508, simdata$FAP)\n# 打印相关系数结果 (Print the correlation coefficient)\nr.cor\n# 计算相关系数的p值，用于检验相关性的显著性 (Calculate the p-value for the correlation coefficient to test its significance)\n# 结果同样会用于图表标题 (This result will also be used in the chart title)\np.cor <- cor.test(simdata$miR.508, simdata$FAP)$p.value\n# 打印p值结果 (Print the p-value)\np.cor\n附：这里的输入数据是模拟出来的，生成方法如下：\nAttachment: The input data here is simulated, and the generation\nmethod is as follows:\n连续变量分类\n例文把两个因素都分为四组：Positive，Moderate，Weak，Negative。\n因此，我们根据四分位数将数据分割为四种类型：\nContinuous variable classification\nThe example text divides both factors into four groups: positive,\nmoderate, weak, and negative.\nTherefore, we divide the data into four types based on quartiles:\n# 根据miR.508表达量的四分位数将数据分为四类 (Classify data into four categories based on quartiles of miR.508 expression)\n# 分类标签参考示例设置 (Classification labels follow the example provided)\n# 因子水平按降序排列，便于后续可视化 (Factor levels sorted in descending order for visualization)\nsimdata$miR.508_classify <- factor(cut(simdata$miR.508, quantile(simdata$miR.508), \n                                       labels = c(\"Negative\", \"Weak\", \"Moderate\", \"Positive\")),\n                                   levels = c(\"Positive\", \"Moderate\", \"Weak\", \"Negative\")) \n\n# 可选方案：根据中位数将数据分为高低两类 (Alternative: classify data into two categories based on median)\n# 此代码行被注释，保留作为参考 (This line is commented out for reference)\n#simdata$miR.508_classify <- factor(cut(simdata$miR.508, c(0, median(simdata$miR.508),max(simdata$miR.508)), \n#                                       labels = c(\"Negative\", \"Positive\")), \n#                                   levels = c(\"Positive\", \"Negative\"))\n\n# 根据FAP表达量的四分位数将数据分为四类 (Classify data into four categories based on quartiles of FAP expression)\n# 分类标签与示例一致 (Classification labels consistent with the example)\n# 因子水平按升序排列 (Factor levels sorted in ascending order)\nsimdata$FAP2_classify <- factor(cut(simdata$FAP, quantile(simdata$FAP), \n                             labels = c(\"Negative\", \"Weak\", \"Moderate\", \"Positive\")), \n                         levels = c(\"Negative\", \"Weak\", \"Moderate\", \"Positive\")) \n\n# 创建miR.508和FAP2分类的列联表 (Create contingency table for miR.508 and FAP2 classifications)\n# 将列联表转换为数据框格式 (Convert contingency table to data frame format)\ntab_classify <- as.data.frame.array(table(simdata$miR.508_classify,simdata$FAP2_classify)) \n# 打印列联表查看结果 (Print contingency table to inspect results)\ntab_classify\n# 对分类变量执行Fisher精确检验 (Perform Fisher's exact test on the contingency table)\n# 当分类较多时需要增加workspace参数以避免内存不足错误 (Increase workspace for large contingency tables)\n# 通常设置为1e9可满足大多数情况需求 (Typical value of 1e9 suffices for most cases)\np.fisher <- fisher.test(tab_classify, workspace = 1e9)$p.value \n# 打印Fisher检验的p值 (Print p-value from Fisher's exact test)\np.fisher\n注意：\n由于不同字符串的排序不同，或者是最终列联表的横纵坐标编号不同，请一定在绘制完成后仔细核对原始数据和计数矩阵，谨防映射关系出错。\n**Attention: * * Due to different sorting of strings or different\nhorizontal and vertical coordinate numbers in the final contingency\ntable, please carefully check the original data and count matrix after\ndrawing to avoid mapping errors.\n开始画图\n下面用base plot一笔一笔画图：\nStart drawing\nBelow is a stroke by stroke plot using the base plot:\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa125FishertestV2_FigureYa125FishertestV2",
      "title": "FigureYa125FishertestV2/FigureYa125FishertestV2.html",
      "html": "FigureYa125FishertestV2/FigureYa125FishertestV2.html",
      "text": "texts/main_FigureYa125FishertestV2_FigureYa125FishertestV2.txt",
      "folder": "FigureYa125FishertestV2",
      "thumb": "gallery_compress/FigureYa125FishertestV2.webp"
    },
    "word_count": 670,
    "lines_count": 121,
    "title": "FigureYa125FishertestV2",
    "description": "两个指标（miRNA和FAP蛋白）按照高低分为四组，计算两个指标的相关性和p value，用热图展示。 Requirement description",
    "input_data_types": [
      "临床数据"
    ],
    "output_types": [
      "散点图",
      "热图",
      "统计表格"
    ],
    "technical_methods": [
      "motif分析"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "LANGUAGE",
      "stringsAsFactors",
      "levels",
      "header",
      "workspace",
      "labels"
    ]
  },
  {
    "id": "main_FigureYa205immunophenoscore_update_FigureYa205immunophenoscore_update",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa205immunophenoscore_update_FigureYa205immunophenoscore_update.txt",
    "content": "FigureYa205immunophenoscore_update\nFigureYa205immunophenoscore_update\nAuthor(s)\n: Xiaofan Lu\nReviewer(s)\n: Ying Ge, Hui Huang\nDate\n: 2025-10-06\nAcademic Citation\nIf you use this code in your work or research, we kindly request that you cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization Framework for Enhancing Biomedical Data Interpretation and Research Efficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\nTo cite ‘Immunophenoscore’ in publications use:\nCharoentong P, Finotello F, Angelova M, Mayer C, Efremova M, Rieder D, et al. Pan-cancer immunogenomic analyses reveal genotype-immunophenotype relationships and predictors of response to checkpoint blockade. Cell Rep. (2017) 18:248–62. doi: 10.1016/j.celrep.2016.12.019\n需求描述\nRequirement Description\n想实现下这个 Immunophenoscore的算法，免疫相关的指标有TMB，TILs和免疫细胞浸润等，这个相当于是综合评分，可以丰富下免疫分析的内容。IPS每个基因z score后的值，输出到文件。\nIf you want to try this Immunophenoscore algorithm, immune-related indicators include TMB, TILs and immune cell infiltration, etc., which is equivalent to a comprehensive score, which can enrich the content of immune analysis. The value of the z-score of each gene of IPS is output to a file.\n出自\nhttps://www.frontiersin.org/articles/10.3389/fimmu.2020.01678/full\nFrom\nhttps://www.frontiersin.org/articles/10.3389/fimmu.2020.01678/full\n应用场景\nApplication Scenario\n计算Immunophenoscore（IPS），并绘制immunophenogram。\n免疫表型评分（immunophenoscore，缩写为IPS），算法来自例文的参考文献28，也就是这篇Cell Rep文章：Charoentong P, Finotello F, Angelova M, Mayer C, Efremova M, Rieder D, Hackl H, Trajanoski Z. Pan-cancer Immunogenomic Analyses Reveal Genotype-Immunophenotype Relationships and Predictors of Response to Checkpoint Blockade. Cell Rep. 2017 Jan 3;18(1):248-262. doi: 10.1016/j.celrep.2016.12.019. PMID: 28052254.\n免疫表型图（immunophenogram），这种图可单独使用或多组排成矩阵使用，也可以结合散点图展示想要说明的特征。具体用法可参考上述[Cell Reports文章] (\nhttps://www.cell.com/cell-reports/comments/S2211-1247(16)31709-0)的Figure\n5和6，大量用到这种immunophenogram。\n输出IPS每个基因z score后的值到文件，便于DIY画出自己喜欢的图。例如多组对比进行统计分析，画box/bar/violin，或者所有sample一起画热图。\n代码及IPS基因权重文件\n公开于github，\nhttps://github.com/icbi-lab/Immunophenogram\n。这里稍微改写，并翻译，使用时请\n引用上述文章\n。\nCalculate the Immunohenoscore (IPS) and plot the immunophenogram.\nImmunophenoscore (IPS): The algorithm is derived from Reference 28 in the example paper, which is this Cell Reports article: Charoentong P, Finotello F, Angelova M, Mayer C, Efremova M, Rieder D, Hackl H, Trajanoski Z. Pan-cancer Immunogenomic Analyses Reveal Genotype-Immunophenotype Relationships and Predictors of Response to Checkpoint Blockade. Cell Rep. 2017 Jan 3;18(1):248-262. doi: 10.1016/j.celrep.2016.12.019. PMID: 28052254.\nImmunophenogram: This type of plot can be used individually, arranged in a matrix for multiple groups, or combined with scatter plots to highlight specific features. For specific usage, refer to Figures 5 and 6 in the above Cell Reports article, where immunophenograms are extensively employed.\nOutput the z-score-normalized values of each IPS gene to a file, enabling users to create customized visualizations. For\nexample:box/bar/violin,or\nGenerate a heatmap for all samples .\nCode and IPS gene weight files\nare publicly available on GitHub:\nhttps://github.com/icbi-lab/Immunophenogram\nThe code has been slightly modified and translated here.\nPlease cite the original paper\nwhen using this method.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nlibrary(ggplot2)       # 数据可视化包，用于绘制图形 # Data visualization package for creating plots\nlibrary(grid)          # 网格图形系统，用于布局和图形排列 # Grid graphics system for layout and graphical arrangement\nlibrary(gridExtra)     # 提供额外的网格布局功能，用于组合多个图形 # Provides additional grid layout functionality for combining multiple plots\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # error messages are displayed in English\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # It is forbidden to convert chr into factor\n自定义函数，用于计算 Immunophenoscore(IPS) Custom functions to calculate Immunophenoscore(IPS)\nipsmap <- function (x) {\n  if (x<=0) {\n    ips<-0\n  } else {\n    if (x>=3) {\n      ips<-10\n    } else {\n      ips<-round(x*10/3, digits=0)\n    }\n  }\n  return(ips)\n}\n分配颜色 Assign colors\nmy_palette <- colorRampPalette(c(\"blue\", \"white\", \"red\"))(n = 1000)\nmapcolors<-function (x) {\n  za<-NULL\n  if (x>=3) {\n    za=1000\n  } else {\n    if (x<=-3) {\n      za=1\n    } else {\n      za=round(166.5*x+500.5,digits=0)\n    }\n  }\n  return(my_palette[za])\n}\nmy_palette2 <- colorRampPalette(c(\"black\", \"white\"))(n = 1000)\nmapbw<-function (x) {\n  za2<-NULL\n  if (x>=2) {\n    za2=1000\n  } else {\n    if (x<=-2) {\n      za2=1\n    } else {\n      za2=round(249.75*x+500.5,digits=0)\n    }\n  }\n  return(my_palette2[za2])\n}\n输入文件\nInput files\neasy_input_expr.csv，表达矩阵。例如log2(TPM+1)，每行一个基因，每列一个样本。\neasy_input_IPS_genes.txt，IPS基因权重文件。IPS相关基因、分类及其权重。\neasy_input_expr.csv, the expression matrix. For example, log2 (TPM 1), one gene per row, one sample per column.\neasy_input_IPS_genes.txt, IPS gene weight file. IPS-related genes, taxonomy and their weights.\nunique_ips_genes <- as.vector(unique(IPSG$NAME))\n\n## 初始化数据\n## Initialize the data\nIPS <- MHC <- CP <- EC <- SC <- AZ <- NULL\n\n# 获取表达谱里的基因名\n# Get the gene name in the expression spectrum\nGVEC <- row.names(gene_expression)\n\n# 获取IPS基因文件里的基因名\n# Obtain the gene name in the IPS gene file\nVEC <- as.vector(IPSG$GENE)\n\n# 匹配基因并找到缺失基因\n# Match genes and find the missing genes\nind <- which(is.na(match(VEC,GVEC)))\nMISSING_GENES <- VEC[ind]\n\ndat <- IPSG[ind,]\nif (length(MISSING_GENES) > 0) { # 若存在缺失基因报出（如果上面两个基因不修改，这里是要报缺失的，会导致最终结果错误）\n  # If there is a deletion gene reported (if the above two genes are not modified, the deletion will be reported here, which will lead to an error in the final result.)\n  message(paste0(\"--differently named or missing genes: \",paste(MISSING_GENES,collapse = \", \")))\n  print(IPSG[ind,])\n  message(\"please check data and make sure all genes matches!\")\n} else {\n  message(\"--all genes matched!\") # 请确保所有基因都匹配!!! # Please make sure all genes match!!\n}\n计算并画图\nCalculate and draw\n# 构建结果，包括各项得分以及IPS\n# Build the results, including the scores and IPS\nDF <- data.frame(SAMPLE=sample_names,\n                 MHC=MHC,\n                 EC=EC,\n                 SC=SC,\n                 CP=CP,\n                 AZ=AZ,\n                 IPS=IPS,\n                 stringsAsFactors = F)\n\n# 输出z-score值到文件\n# Output the z-score value to a file\nwrite.table(outTab, file = \"output_zscore.txt\", row.names = TRUE, col.names = NA, quote=FALSE, sep=\"\\t\") \n\n# 输出IPS到文件\n# Export IPS to a file\nwrite.table(DF,file = \"output_IPS.txt\", row.names = FALSE, col.names = TRUE, quote=FALSE, sep=\"\\t\")\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa205immunophenoscore_update_FigureYa205immunophenoscore_update",
      "title": "FigureYa205immunophenoscore_update/FigureYa205immunophenoscore_update.html",
      "html": "FigureYa205immunophenoscore_update/FigureYa205immunophenoscore_update.html",
      "text": "texts/main_FigureYa205immunophenoscore_update_FigureYa205immunophenoscore_update.txt",
      "folder": "FigureYa205immunophenoscore_update",
      "thumb": "gallery_compress/FigureYa205immunophenoscore_update.webp"
    },
    "word_count": 779,
    "lines_count": 154,
    "title": "FigureYa205immunophenoscore_update",
    "description": "Requirement Description 想实现下这个 Immunophenoscore的算法，免疫相关的指标有TMB，TILs和免疫细胞浸润等，这个相当于是综合评分，可以丰富下免疫分析的内容。IPS每个基因z score后的值，输出到文件。 If you want to try this Immunophenoscore algorithm, immune-related indicators include TMB, TILs and immune cell infiltration, etc., which is equivalent to a comprehensive score, which can enrich the content of immune analysis. The value of the z-score of each gene of IPS is output to a file.",
    "input_data_types": [
      "临床数据",
      "表达矩阵"
    ],
    "output_types": [
      "散点图",
      "热图",
      "统计表格",
      "箱线图"
    ],
    "technical_methods": [],
    "biology_areas": [
      "癌症研究",
      "免疫学"
    ],
    "complexity_level": "高级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "LANGUAGE",
      "quote",
      "stringsAsFactors",
      "AZ",
      "za",
      "EC",
      "digits",
      "n",
      "SC"
    ]
  },
  {
    "id": "main_FigureYa39bar_FigureYa39bar",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa39bar_FigureYa39bar.txt",
    "content": "FigureYa39bar\nFigureYa39bar\nAuthor(s)\n: Ying Ge; Yijing Chen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n图一：不同的癌症用不同的颜色展示\nFigure 1: Different cancers shown in different colors\n出自\nhttps://www.nejm.org/doi/full/10.1056/NEJMoa1714448\nfrom\nhttps://www.nejm.org/doi/full/10.1056/NEJMoa1714448\n图二：做类似的图用于GO、KEGG富集分析结果展示，不显著的显示灰色，左右分开的名称，正负富集分开，左右分开画在一张图上。\nFigure 2: Do similar diagrams for GO, KEGG enrichment analysis\nresults show. Display non-significant results in gray, separate names on\nthe left and right, with positive and negative enrichment separated,\nleft and right separate drawn on a graph.\n出自\nhttps://www.nature.com/articles/s41591-018-0096-5\n原文的输入数据是GSVA score，本代码只模仿形式，不包括GSVA分析。\nfrom\nhttps://www.nature.com/articles/s41591-018-0096-5\nThe input data for the original article is the GSVA score; this code\nonly mimics the form and does not include GSVA analysis.\n应用场景\nApplication scenario\n场景一：各肿瘤某一指标的比较，例如图一的肿瘤缓解率。\n场景二：GSVA结果展示，类似于图二。\nScenario 1: Comparison of a certain index across tumors, such as\ntumor remission rate in Figure 1.\nScenario 2: GSVA results are presented, similar to Figure 2.\n场景一\nScenario 1\n每个ID显示为一种颜色\nEach ID is shown as a color\n输入数据\nInput data\nsource(\"install_dependencies.R\")\ndf<-read.csv(\"easy_input1.csv\")\nhead(df)\n#按照score排序\n#sort by score\ndf<-df[order(df$score,decreasing = T),]\ndf$index<-seq(1,nrow(df))\nhead(df)\n开始画图\nStart drawing\nlibrary(ggplot2)\np<-ggplot(df,aes(x=index,y=score,fill=ID)) + \n  geom_bar(stat = 'identity',width = 0.8) + \n  scale_fill_brewer(type = \"Qualitative\", palette = \"Paired\") + #bar的颜色 color of bar\n  \n  scale_y_continuous(breaks=seq(-100, 100, 10), #y轴刻度 y-axis scale\n                     expand = c(0,0)) + #上下都不留空 there's no space between the top and the bottom\n  scale_x_discrete(expand = expand_scale(mult = c(0.01,0))) + #左边留空，右边到头 leave the left side blank, the right side goes to the end\n\n  #画3条横线\n  #draw 3 horizontal lines\n  geom_hline(yintercept = c(-30,0,20), \n             linetype = 5, #画虚线 draw a dotted line\n             size = 0.3) + #线的粗细 thickness of line\n  \n  #其他主题\n  #other themes\n  labs(x = \"\", y = \"Maximum Change in Tumor Size (%)\", \n       title = \"A Maximum Change in Tumor Size, According to Tumor Type\") +\n  theme_bw() + #去除背景色 remove background color\n  theme(panel.grid =element_blank()) + #去除网格线 remove gridlines\n  theme(panel.border = element_blank()) + #去除外层边框 remove outer border\n  theme(axis.line = element_line(colour = \"black\")) + #沿坐标轴显示直线 display lines along the axes\n  theme(axis.line.x = element_blank(), axis.ticks.x = element_blank(), axis.text.x = element_blank()) + #去除x轴 remove x-axis\n  \n  #图例\n  #legend\n  guides(fill = guide_legend(ncol = 5,title = NULL)) + #图例分5列 legend divided into 5 columns\n  scale_size(range=c(5,20)) +\n  theme(legend.background = element_blank(), #移除整体边框 remove overall border\n        #图例的左下角置于绘图区域的左下角\n        #the lower left corner of the legend is placed in the lower left corner of the drawing area\n        legend.position=c(0,0),legend.justification = c(0,0))\n#改用下面这行，图例就会位于顶部 change to the following line and the legend will be at the top\n        #legend.position=\"top\")\np\n#保存到PDF文件\n#save to PDF file\nggsave(\"CancerBar.pdf\",width = 8,height = 5)\n极大值的处理\nHandling of maximum value\n有一个值远高于其他值，右侧会很空。\n因此，原图作者让y轴适合大部分数据，然后在最高的那个bar上标出实际数据\nHaving one value much higher than the others would be very empty on\nthe right side.\nSo the author of the original graph made the y-axis fit most of the\ndata, and then labeled the highest one bar with the actual data\n#设置坐标轴范围，最大值设为50，以适应大多数数据\n#set the axis range to a maximum of 50 to accommodate most data.\np<-p + coord_cartesian(ylim = c(-90,50)) + #y轴范围，根据实际情况调整 y-axis range, adjust according to actual condition\n  #添加数据标签 \n  #add data labels \n  geom_text(data = subset(df, score > 50),\n            aes(index, 48,label=round(score))) + #在超过50的bar上标出实际数据 labeling of actual data on bar over 50\n  geom_text(data = subset(df, index == 3),\n            aes(index, score + 1,label = \"*\")) + #作者的特殊标记 author's special marks\n  geom_text(data = subset(df, index == nrow(df)),\n            aes(index, score - 3, label = \"T\"))  #作者的特殊标记 author's special marks\np\n#保存到PDF文件\n#save to PDF file\nggsave(\"CancerBar_label.pdf\",width = 8,height = 5)\n场景二·原文\nScenario 2·Original\nscore绝对值小于阈值的bar显示为灰色\nBars with score absolute values less than the threshold are displayed\nin gray.\n输入数据\nInput data\n包含两列：ID和score\nIt contains two columns: ID and score\ndf<-read.csv(\"easy_input2.csv\")\nhead(df)\n#按照score的值分组\n#grouped by score value\ndf$group<-cut(df$score, breaks = c(-Inf,-4,4,Inf),labels = c(1,2,3))\nhead(df)\n#按照score排序\n#sort by score\ndf<-df[order(df$score,decreasing = F),]\ndf$index<-seq(1,nrow(df))\nhead(df)\n开始画图\nStart drawing\nlibrary(ggplot2)\nggplot(df,aes(x=index,y=score,fill=group)) + \n  geom_bar(stat = 'identity',width = 0.8) + \n  scale_fill_manual(values = c(\"palegreen3\",\"snow3\",\"dodgerblue4\")) + #bar的颜色 color of bar\n  scale_x_discrete(expand = expand_scale(add = .6)) + \n  scale_y_continuous(breaks=seq(-30, 20, 5)) +\n  coord_flip() + #坐标轴互换 coordinate axis interchange\n  \n  #画2条横线\n  #draw 2 horizontal lines\n  geom_hline(yintercept = c(-4,4), \n             color=\"white\",\n             linetype = 2,#画虚线 draw a dotted line\n             size = 0.3) + #线的粗细 thickness of line\n\n  #写label\n  #write label\n  geom_text(data = subset(df, score > 0),\n            aes(x=index, y=-0.3, label=ID, color = group),#bar跟坐标轴间留出间隙 leave a gap between the bar and the axes\n            size = 3, #字的大小 font size\n            hjust = \"inward\" ) +  #字的对齐方式  the alignment of character\n  geom_text(data = subset(df, score < 0),\n            aes(x=index, y=0.3, label=ID, color = group),\n            size = 3, hjust = \"outward\") +  \n  scale_colour_manual(values = c(\"snow3\",\"black\",\"black\")) +\n\n  #其他主题\n  #other themes\n  labs(x = \"\", y = \"t value of GSVA score, tumor \\n versus non-malignant\", \n       title = \"Endothelial cells, tumour versus non-malignant\") +\n  theme_bw() + #去除背景色 remove background color\n  theme(panel.grid =element_blank()) + #去除网格线 remove gridlines\n  theme(panel.border = element_rect(size = 0.6)) + #边框粗细 border thickness\n  theme(axis.line.y = element_blank(), axis.ticks.y = element_blank(), axis.text.y = element_blank()) + #去除y轴 remove y-axis\n\n  guides(fill=FALSE,color=FALSE) #不显示图例 legend not displayed\n#保存到PDF文件\n#save to PDF file\nggsave(\"GObar.pdf\",width = 5,height = 8)\n场景二·不显著的显示为灰色\nScenario 2·Display non-significant results in gray\npvalue>0.05的bar显示为灰色\nBar with pvalue > 0.05 is shown in gray\n输入数据\nInput data\n包含三列，ID、score和pvalue\nIt contains three columns, ID, score and pvalue\ndf<-read.csv(\"easy_input3.csv\")\nhead(df)\n#按照pvalue分组\n#grouped by pvalue\ndf$p.group<-cut(df$pval, breaks = c(-Inf,0.05,Inf),labels = c(1,0))\n#按照score分组\n#grouped by score\ndf$s.group<-cut(df$score, breaks = c(-Inf,0,Inf),labels = c(0,1))\n#合并\n#merge\ndf$ps.group <- paste0(df$p.group,df$s.group)\n\n#根据pvalue和score分为3组\n#divided into 3 groups based on pvalue and score\ndf$group <- ifelse(df$ps.group=='10','1',ifelse(df$ps.group=='11','2','3'))\nhead(df)\n#按照score排序\n#sort by score\ndf<-df[order(df$score,decreasing = F),]\ndf$index<-seq(1,nrow(df))\nhead(df)\n开始画图\nStart drawing\n只调整了颜色顺序，其余跟“场景二·原文”的画图代码是一样的\nOnly adjust the color order, the rest of the drawing code is the same\nas “Scenario 2·Original”.\nlibrary(ggplot2)\nggplot(df,aes(x=index,y=score,fill=group)) + \n  geom_bar(stat = 'identity',width = 0.8) + \n  scale_fill_manual(values = c(\"palegreen3\",\"dodgerblue4\",\"snow3\")) + #颜色 color\n  scale_x_discrete(expand = expand_scale(add = .6)) + \n  scale_y_continuous(breaks=seq(-30, 20, 5)) +\n  coord_flip() + \n  \n  geom_hline(yintercept = c(-4,4), \n             color=\"white\",\n             linetype = 2,\n             size = 0.3) + \n\n  geom_text(data = subset(df, score > 0),\n            aes(x=index, y=-0.3, label=ID, color = p.group),\n            size=3,\n            hjust = \"inward\") + \n  geom_text(data = subset(df, score < 0),\n            aes(x=index, y=0.3, label=ID, color = p.group),\n            size=3,hjust = \"outward\") +  \n  scale_colour_manual(values = c(\"black\",\"snow3\")) +\n\n  labs(x = \"\", y = \"t value of GSVA score, tumor \\n versus non-malignant\", \n       title = \"Endothelial cells, tumour versus non-malignant\") +\n  theme_bw() + \n  theme(panel.grid =element_blank()) + \n  theme(panel.border = element_rect(size = 0.6)) + \n  theme(axis.line.y = element_blank(), axis.ticks.y = element_blank(), axis.text.y = element_blank()) + \n  guides(fill=FALSE,color=FALSE)\n#保存到PDF文件\n#save to PDF file\nggsave(\"GObar_pval.pdf\",width = 5,height = 8)\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa39bar_FigureYa39bar",
      "title": "FigureYa39bar/FigureYa39bar.html",
      "html": "FigureYa39bar/FigureYa39bar.html",
      "text": "texts/main_FigureYa39bar_FigureYa39bar.txt",
      "folder": "FigureYa39bar",
      "thumb": "gallery_compress/FigureYa39bar.webp"
    },
    "word_count": 1046,
    "lines_count": 246,
    "title": "FigureYa39bar",
    "description": "Requirement description 图一：不同的癌症用不同的颜色展示 Figure 1: Different cancers shown in different colors",
    "input_data_types": [],
    "output_types": [],
    "technical_methods": [
      "通路分析"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "colour",
      "values",
      "width",
      "grid",
      "ylim",
      "pvalue",
      "labels",
      "decreasing"
    ]
  },
  {
    "id": "main_FigureYa256panelLink_FigureYa256panelLink_ori",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa256panelLink_FigureYa256panelLink_ori.txt",
    "content": "FigureYa256panelLink\nFigureYa256panelLink\n小丫画图出品\n2021-12-17\n欢迎关注“小丫画图”公众号，回复“小白”，看小视频，实现点鼠标跑代码。\n小丫微信: epigenomics E-mail:\nfigureya@126.com\n作者：Hazard，他的更多作品看这里\nhttps://k.koudai.com/zuloxG1Y\n小丫编辑校验\n需求描述\n这个图有机会能众筹一下吗？感觉很强大\n出自\nhttps://doi.org/10.1038/s42255-019-0045-8\nFig. 7 |. Hypoxia-associated molecular signatures in clinically\nactionable genes and effects on the response to individual drugs. (a)\nAssociation between FDA-approved drugs and their linked clinically\nactionable genes (right) and alterations of these genes at mRNA,\nprotein, DNA methylation, mutation and SCNA levels based on hypoxia\nscore-high (red) or hypoxia score-low (blue) samples across 21 cancer\ntypes (left). Different symbol shapes represent different types of\nmolecular signatures. Filled cells indicate that the gene is a\ntherapeutic target of clinical practice in the corresponding cancer\ntype. Bar plots in right panel indicate the number of cancer types with\npositive correlation (drug-sensitive, magenta) and negative correlation\n(drug-resistant, green) between hypoxia score and drug response\n(Spearman’s correlation).\n应用场景\n跟FigureYa174squareCross和FigureYa199crosslink出自同一篇文章，这篇文章以连线著称。后面我们还会众筹Figure\n3c。\n该图的优势是将左右两个panel连起来，同时展示多种特征，具体让哪个形状、颜色代表哪些特征，自己可灵活运用。\n为了画这个图，完善了crosslink包，该R包会继续添加更多有趣的连线功能，感兴趣可前往\nhttps://github.com/zzwch/crosslink\n查看最新版本及功能，在github上还能提交issue跟作者直接交流。\n环境设置\n使用国内镜像安装包\noptions(\"repos\"= c(CRAN=\"https://mirrors.tuna.tsinghua.edu.cn/CRAN/\"))\noptions(BioC_mirror=\"http://mirrors.tuna.tsinghua.edu.cn/bioconductor/\")\ninstall.packages(\"remotes\")\n加载包\nlibrary(magrittr)\nlibrary(tidyverse)\nlibrary(ggplot2)\nlibrary(crosslink) \nsource(\"crosslink.R\") # From R package crosslink, https://github.com/zzwch/crosslink\n\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息\noptions(stringsAsFactors = FALSE) #禁止chr转成factor\n自定义函数\nrevLevels <- function(x, levels = NULL){\n  if(is.null(levels)) levels <- rev(sort(unique(x)))\n  return(factor(x, levels = levels))\n}\n输入文件\n# 加载左侧散点图的数据\nhypoxia <- read.csv(\"easy_input_hypoxia.csv\") # \n# 按自己的想法排序\nhypoxia$direction <- factor(hypoxia$direction, levels = c(\"high\", \"low\"))\nhypoxia$omics <- factor(hypoxia$omics, levels = c(\"mRNA\", \"Protein\", \"Methylation\", \"Mutation\", \"CNV\"))\n# 背景填充颜色的格子\npractice <- read.csv(\"easy_input_practice.csv\") \n\n# 加载右侧柱状图的数据\ndrugAnn <- read.csv(\"easy_input_drugAnn.csv\") #\ndrugs <- drugAnn$drug\ndrug_levels <- drugAnn$drug %>% revLevels()\n\n# 加载左侧和右侧之间的连线数据\ngeneAnn <- read.csv(\"easy_input_geneAnn.csv\") #\ngenes <- unique(geneAnn$gene)\n\n# 设置右侧区域背景/文字/方括号的颜色\ncolor_num <- length(unique(drugAnn$therapy))\n# 这里提供了充足的备选颜色\nmycolor <- c(\"red\", \"dodgerblue3\", \"darkorchid1\", \"darkorange\",\n             \"#223D6C\",\"#D20A13\",\"#088247\",\"#FFD121\",\"#11AA4D\",\"#58CDD9\",\"#7A142C\",\"#5D90BA\",\"#431A3D\",\"#91612D\",\"#6E568C\",\"#E0367A\",\"#D8D155\",\"#64495D\",\"#7CC767\")[1:color_num]\n开始画图\n1. prepare left panel\n原文：alterations of these genes at mRNA, protein, DNA methylation,\nmutation and SCNA levels based on hypoxia score-high\n(\nred\n) or hypoxia score-low (\nblue\n)\nsamples across 21 cancer types (left).\nDifferent symbol shapes\nrepresent different types of\nmolecular signatures.\nFilled cells\nindicate that the gene is a therapeutic\ntarget of clinical practice in the corresponding cancer type.\nggplot() +\n  # grid tile \n  geom_tile(\n    mapping = aes(cancer, gene %>% revLevels()),\n    data = expand_grid(cancer = hypoxia$cancer %>% unique(), \n                       gene = hypoxia$gene %>% unique()),\n    fill = NA, color = \"grey\" # 画灰色格子\n    ) +\n  # fill tile \n  geom_tile(\n    mapping = aes(cancer, gene, fill = direction),\n    data = hypoxia %>% filter(paste0(gene, \"-\", cancer) %in% practice$x),\n    alpha = 0.3 # 个别格子填充半透明的背景\n    ) + \n  geom_point(\n    mapping = aes(cancer, gene, color = direction, shape = omics),\n    data = hypoxia,\n    size = 3) + # 形状的大小\n  scale_shape_manual(values = c(15:19)) + # 根据自己的喜好选择形状，这里用实心形状\n  scale_color_manual(values = c(low = \"blue\", high = \"red\")) +\n  scale_fill_manual(values = c(low = \"blue\", high = \"red\")) +\n  theme_void() +\n  theme(axis.text.x = element_text(angle = 90),\n        axis.text.y = element_text()) -> p_left\np_left\n2. prepare right panel\nbracketData <- drugAnn %>%\n  select(drug, therapy, signaling) %>%\n  unique() %>%\n  arrange(desc(drug), signaling) %$%\n  data.frame(min = duplicated(signaling) %>% not %>% which,\n             max = c((duplicated(signaling) %>% not %>% which)[-1] -1, length(signaling)),\n             signaling = signaling[duplicated(signaling) %>% not],\n             therapy = therapy[duplicated(signaling) %>% not]\n             )\nrectData <- drugAnn %>%\n  select(drug, therapy) %>%\n  unique() %>%\n  arrange(desc(drug)) %$%\n  data.frame(min = duplicated(therapy) %>% not %>% which,\n             max = c((duplicated(therapy) %>% not %>% which)[-1] -1, length(therapy)),\n             therapy = therapy[duplicated(therapy) %>% not]\n             )\n\nggplot(\n  mapping = aes(value, factor(drug, levels = drug_levels)),\n    data = drugAnn %>%\n     select(drug, n_sensitive, n_resistant) %>%\n     mutate(drug = factor(drug, levels = drug_levels)) %>%\n     gather(key = \"cat\", value = \"value\", -drug)\n) +\n  ggnewscale::new_scale_fill() +\n  geom_rect(\n    mapping = aes(xmin = -2, xmax = 12, ymin = min-0.5, ymax= max+0.5, fill = therapy),\n    data = rectData,\n    alpha = 0.2, inherit.aes = F\n  ) +\n  scale_color_manual(values = mycolor) +\n  scale_fill_manual(values = mycolor) +\n  \n  ggnewscale::new_scale_fill() +\n  geom_bar(\n    mapping = aes(fill = cat),\n    stat = \"identity\"\n  ) +\n  scale_fill_manual(values = c(\"magenta\", \"green\")) + # bar的颜色\n  \n  # 画方括号\n  geom_segment(\n    mapping = aes(x = 9, xend = 9, y = min, yend = max, color = therapy),\n    data = bracketData, inherit.aes = F\n  ) +\n  geom_segment(\n    mapping = aes(x = 9-0.1, xend = 9, y = min, yend = min, color = therapy),\n    data = bracketData, inherit.aes = F\n  ) +\n  geom_segment(\n    mapping = aes(x = 9-0.1, xend = 9, y = max, yend = max, color = therapy),\n    data = bracketData, inherit.aes = F\n  ) +\n  \n  # 写右侧文字\n  geom_text(\n    mapping = aes(x = 9, y = (max+min)/2, label = signaling\n                  #, color = therapy # pathway的文字颜色\n                  ),\n    data = bracketData,\n    hjust = -0.1, inherit.aes = F\n  ) +\n  \n  # 写左侧文字\n  geom_text(\n    mapping = aes(x = -1, drug %>% revLevels(), label = drug, color = therapy),\n    data = drugAnn, inherit.aes = F\n  ) +\n  \n  #xlim(-2, 12) + \n  theme_void() + \n  theme(axis.text.x = element_text(),\n        axis.ticks.x = element_line(), \n        axis.title.x = element_text(),\n        axis.line.x = element_line()) +\n  labs(x = \"# Cancers\") -> p_right\np_right\n3. crosslink combining left and right panels\ncl_plot(\n    crosslink(\n    data.frame(\n      key = c(genes, drugAnn$drug),\n      therapy = c(rep(NA, length(genes)), drugAnn$therapy),\n      by = c(rep(\"Gene\", length(genes)), rep(\"Drug\", length(drugAnn$drug)))\n    ), \n    geneAnn %>% mutate(\n      therapy = drugAnn$therapy[match(drug ,drugAnn$drug)],\n      drug = factor(drug, levels = drug_levels)   # 关键：强制顺序\n    ), \n    cross.by = \"by\",\n    key.by = \"key\",\n    src.by = \"gene\",\n    tar.by = \"drug\"\n  ) %>% tf_flip(\"y\"), \n  link = list(mapping = aes(color = therapy),\n              scale = list(color = scale_color_manual(values = mycolor))),\n  cross = NA,\n  label = NA,\n  add = theme_void(),\n  annotation = cl_annotation(\n    left = p_left, left.by = \"Gene\", left.width = 2,\n    right = p_right, right.by = \"Drug\", right.width = 4\n  ))\nggsave(\"panelLink.pdf\", width = 10, height = 10)\n附：示例数据生成过程\n# Drug1-Drug20\n# Gene1-Gene30\n# Cancer1-Cancer10\n\ndrugs <- paste0(\"Drug\", 1:20 %>% format)\ngenes <- paste0(\"Gene\", 1:30 %>% format)\ncancers <- paste0(\"Cancer\", 1:10 %>% format)\n\nset.seed(666)\n\ndrugAnn <- data.frame(\n  drug = drugs,\n  therapy = rep(c(\"Immunotherapy\", \"Chemotherapy\", \"Hormone therapy\", \"Targeted therapy\"), each = 5),\n  n_sensitive = sample(c(NA, 1:4), 20, replace = T),\n  n_resistant = sample(c(NA, 1:4), 20, replace = T),\n  signaling = paste0(\"Signaling\", c(1, 2, 3, 3, 4, 5, 5, 6, 6,6, 7, 7, 7, 7, 7, 8, 9,9, 10, 10) %>% format))\nwrite.csv(drugAnn, \"easy_input_drugAnn.csv\", quote = F, row.names = F)\n\ngeneAnn <- data.frame(\n  gene = c(genes, sample(genes, 10, replace = T)) %>% sort(),\n  drug = c(drugs, sample(drugs, 20, replace = T)) %>% sort()\n) %>% unique()\nwrite.csv(geneAnn, \"easy_input_geneAnn.csv\", quote = F, row.names = F)\n\nn_pairs <- 200\nhypoxia <- data.frame(\n  cancer = sample(cancers, n_pairs, replace = T),\n  gene = sample(genes, n_pairs, replace = T)\n) %>% unique()\n\nhypoxia %<>% \n  mutate(\n    direction = sample(c(\"high\", \"low\"), nrow(hypoxia), replace = T),\n    omics = sample(c(\"mRNA\", \"Protein\", \"Methylation\", \"Mutation\", \"CNV\"), nrow(hypoxia), replace = T)\n    )\nwrite.csv(hypoxia, \"easy_input_hypoxia.csv\", quote = F, row.names = F)\n\npractice <- sample(paste0(hypoxia$gene, \"-\", hypoxia$cancer), 10, replace = T) %>% unique()\nwrite.csv(practice, \"easy_input_practice.csv\", quote = F, row.names = F)\nSession Info\nsessionInfo()",
    "chapter_info": {},
    "word_count": 1068,
    "lines_count": 265,
    "title": "FigureYa256panelLink",
    "description": "这个图有机会能众筹一下吗？感觉很强大 出自 https://doi.org/10.1038/s42255-019-0045-8",
    "input_data_types": [
      "突变数据"
    ],
    "output_types": [
      "散点图"
    ],
    "technical_methods": [
      "通路分析"
    ],
    "biology_areas": [
      "癌症研究",
      "药物研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "add",
      "gene",
      "drug",
      "values",
      "min",
      "key",
      "n_resistant",
      "signaling"
    ]
  },
  {
    "id": "main_FigureYa109SubtypeGSEA_update_FigureYa109SubtypeGSEA_update",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa109SubtypeGSEA_update_FigureYa109SubtypeGSEA_update.txt",
    "content": "FigureYa109subtypeGSEA_update\nFigureYa109subtypeGSEA_update\nAuthor(s)\n: Xiaofan Lu, Taojun Ye\nReviewer(s)\n: Ying Ge\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n多组的富集分析及结果展示，用clusterProfiler做GSEA，挑选各组特异性top通路，画出paper里这样的对角热图。图中横坐标的6列对应6个亚型（分组），右侧文字的背景色对应6个亚组（分组）富集的通路。\nRequirement description\nPerform enrichment analysis and result display for multiple groups,\nuse clusterProfiler for GSEA, select specific top pathways for each\ngroup, and draw a diagonal heatmap as shown in the paper. The 6 columns\non the horizontal axis in the figure correspond to 6 subtypes (groups),\nand the background color of the text on the right corresponds to the\nenriched pathways of the 6 subtypes (groups).\n出自\nhttps://bmccancer.biomedcentral.com/articles/10.1186/s12885-018-4546-8\nfrom\nhttps://bmccancer.biomedcentral.com/articles/10.1186/s12885-018-4546-8\nFig. 3c GSEA analysis reveals distinct enriched gene sets between\nsubtypes. In the heatmap, rows are defined by the selected 60 gene sets,\nand columns by consensus scores for each subtype. Subtype enriched gene\nsets are highlighted by different color, L1 (light red), L2 (light\nbrown), L3 (light blue), L4 (light orange), L5 (light purple) and L6\n(light green).\n应用场景\n多组富集分析结果，画在一起对比展示，就能同时看到同一通路在其他分组里的富集状态。\nApplication scenarios\nMultiple sets of enrichment analysis results can be compared and\ndisplayed together to simultaneously see the enrichment status of the\nsame pathway in other groups.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\n# 加载clusterProfiler包：用于基因富集分析和可视化（Load the clusterProfiler package: for gene enrichment analysis and visualization）\nlibrary(clusterProfiler)\n# 加载GSVA包：用于基因集变异分析（Load the GSVA package: for gene set variation analysis）\nlibrary(GSVA)\n\n# 加载pheatmap包：用于绘制精美热图（Load the pheatmap package: for creating beautiful heatmaps）\nlibrary(pheatmap)\n\n# 加载gplots包：提供各种绘图函数（Load the gplots package: provides various plotting functions）\nlibrary(gplots)\n# 设置系统环境语言为英文，使报错信息显示英文（Set system environment language to English to display error messages in English）\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止字符串自动转换为因子类型，避免数据处理意外（Disable automatic conversion of strings to factors to avoid unexpected data processing issues）\noptions(stringsAsFactors = FALSE)\n输入文件\n以TCGA皮肤黑色素瘤为例，输入数据包括cBioPortal下载的标准化表达谱以及TCGA定义的3种亚型（keratin,\nimmune，MITF-low），这里按亚型分为3组，将对比展示这三种亚型的富集分析。\neasy_input_expr.csv，表达矩阵\neasy_input_subtype.txt，分组信息，此处是3种亚型\nInput file\nTaking TCGA skin melanoma as an example, the input data includes\nstandardized expression profiles downloaded from cBioPortal and three\nsubtypes defined by TCGA (keratin, immune, MITF low), which are divided\ninto three groups according to subtypes. The enrichment analysis of\nthese three subtypes will be compared and displayed.\neasy_input_expr.csv， Expression matrix\neasy_input_subtype.txt， Grouping information, here are 3\nsubtypes\n# 读取表达矩阵数据，设置check.names=F避免列名被自动修改，设置row.names=1使用第一列作为行名（Read expression matrix data, set check.names=F to prevent column names from being automatically modified, set row.names=1 to use the first column as row names）\nexpr <- read.csv(\"easy_input_expr.csv\", check.names = F, row.names = 1)\n\n# 查看表达矩阵前3行和前3列的数据，用于数据质量检查（View the first 3 rows and 3 columns of the expression matrix for data quality check）\nexpr[1:3,1:3]\n# 查看表达矩阵的维度（行数和列数）（Check the dimensions (number of rows and columns) of the expression matrix）\ndim(expr)\n# 读取样本亚型信息，使用制表符分隔，设置check.names=F避免列名被自动修改，stringsAsFactors=F禁止字符串转成因子，header=T表示第一行是列名，row.names=1使用第一列作为行名（Read sample subtype information, use tab as separator, set check.names=F to prevent column names from being automatically modified, stringsAsFactors=F to disable automatic conversion of strings to factors, header=T indicates the first row contains column names, row.names=1 uses the first column as row names）\nsubt <- read.table(\"easy_input_subtype.txt\", sep = \"\\t\", check.names = F, stringsAsFactors = F, header = T, row.names = 1)\n\n# 查看样本亚型数据的前几行（View the first few rows of the sample subtype data）\nhead(subt)\n# 统计每种亚型的样本数量（Count the number of samples in each subtype）\ntable(subt$TCGA_Subtype)\n多组差异表达：One vs. Others\n做GSEA需要样本中所有基因的排序，这里用的是\n每一组\nvs. 所有其他组\n获得的log2FoldChange。下面将用表达矩阵获得每组基因的log2FoldChange排序。\n示例数据样本较多，你的样本可能只有1-3个/组，速度会快很多。\nMultiple differential expressions: One vs. Others\nTo do GSEA, it is necessary to sort all genes in the sample, using\nthe log2FoldChange obtained from * * each group vs. all other groups *\n*. Below, the expression matrix will be used to obtain the\nlog2FoldChange ranking for each group of genes.\nThere are many sample sizes for example data, and your sample size\nmay only be 1-3 per group, which will result in a much faster speed.\n自定义分析函数\n先自定义一个函数，便于分别计算显著上调的和显著下调的分组的特异性通路。\n重要参数说明：\nmsigdb为加载的MSigDB数据库，可从GSEA官网下载gmt格式的文件：\nhttp://software.broadinstitute.org/gsea/downloads.jsp\n，此处以c5.all.v6.2.symbols.gmt为例，下载链接：\nhttp://software.broadinstitute.org/gsea/msigdb/download_file.jsp?filePath=/resources/msigdb/6.2/c5.all.v6.2.symbols.gmt\nn.top是选取的\ntop通路集的个数\n，默认是10\nmode为寻找模式，up代表上调，dn代表下调，推荐寻找亚型特异性上调通路\ndegs.list为配对差异表达基因列表\nsubtype.label为亚型名称，顺序及名称必须匹配degs.list\n其余参数为GSEA参数\nCustom analysis function\nFirst, customize a function to calculate the specific pathways for\nsignificantly upregulated and significantly downregulated groups\nseparately.\nImportant parameter description:\n-MSIGDB is the loaded MSigDB database, which can be downloaded in GMT\nformat from the GSEA official website<\nhttp://software.broadinstitute.org/gsea/downloads.jsp\n>Here, taking c5.all.v6.2.symbols.gmt as an example, download\nlink:<\nhttp://software.broadinstitute.org/gsea/msigdb/download_file.jsp?filePath=/resources/msigdb/6.2/c5.all.v6.2.symbols.gmt\n>\n-N.top is the number of selected * * top path sets * *, default is\n10\n-Mode is to search for patterns, up represents upregulation, dn\nrepresents downregulation, and it is recommended to search for subtype\nspecific upregulation pathways\n-Degs.list is a list of paired differentially expressed genes\n-Subtype.label is the subtype name, and the order and name must match\ndegs.list\n-The remaining parameters are GSEA parameters\n寻找显著上调的亚型特异性通路(推荐)\n运行上面的函数来寻找显著上调的亚型特异性通路。\nSearch for significantly upregulated subtype specific pathways\n(recommended)\nRun the above function to find subtype specific pathways that are\nsignificantly upregulated.\n# 定义MSigDB基因集文件路径（Define the path to the MSigDB gene set file）\nmsigdfFile = \"c5.all.v6.2.symbols.gmt\"\n\n# 设置富集分析后每个亚型保留的顶级通路数量（Set the number of top pathways to retain for each subtype after enrichment analysis）\nn.top = 10\n\n# 设置富集分析模式，可选\"up\"（上调通路）或\"dn\"（下调通路）（Set the enrichment analysis mode, options are \"up\" (upregulated pathways) or \"dn\" (downregulated pathways)）\nmode = \"up\" #\"up\"和\"dn\"二选一\n\n# 执行亚型特异性GSEA分析，获取上调通路相关结果（Perform subtype-specific GSEA analysis to obtain results related to upregulated pathways）\ngs.up <- subtype_specific_gsea(msigdb = msigdfFile,\n                               n.top = n.top,\n                               degs.list = degs.list,\n                               subtype.label = n.sub.label,\n                               mode = mode)\n# 计算GSVA得分：基于基因表达矩阵和GSEA分析得到的基因集，使用GSVA方法计算通路富集得分（Calculate GSVA scores: Based on the gene expression matrix and gene sets obtained from GSEA analysis, use the GSVA method to calculate pathway enrichment scores）\ngsva_params <- gsvaParam(exprData = as.matrix(expr),\n                     geneSets = gs.up$gs)\ngsva_gs.up <- gsva(gsva_params)\n# 查看GSVA得分矩阵的维度，确认结果（Check the dimensions of the GSVA score matrix to confirm the results）\ndim(gsva_gs.up)\n# 这里是30条通路，说明top通路无重叠（Here there are 30 pathways, indicating no overlap among the top pathways）\n\n# 初始化数据框，用于存储每个亚型的通路平均GSVA得分（Initialize a data frame to store the average GSVA scores of pathways for each subtype）\ngsva_gs.up_mean <- data.frame(row.names = rownames(gsva_gs.up)) \n\n# 计算每个亚型内样本的通路GSVA得分均值（也可以换用其他统计量，比如中位数等等）（Calculate the mean of pathway GSVA scores for samples within each subtype (other statistics such as median can also be used)）\nfor (i in n.sub.label) {\n  gsva_gs.up_mean <- cbind.data.frame(gsva_gs.up_mean,\n                                   data.frame(rowMeans(gsva_gs.up[,rownames(subt)[which(subt$TCGA_Subtype == i)]])))\n}\n\n# 设置结果数据框的列名为各亚型名称（Set the column names of the result data frame to the names of each subtype）\ncolnames(gsva_gs.up_mean) <- n.sub.label\n绘制热图（无聚类）\nDraw a heatmap (without clustering)\n# 自定义分组的颜色（Define custom colors for subgroups）\njco <- c(\"#F2CCCC\",\"#E6D8CF\",\"#D5E3F0\",\"#FDE7DA\",\"#E2D6EC\", \"#CCEFDB\")\n\n# 创建行注释数据框，包含通路所属亚型和通路名称（Create row annotation dataframe containing pathway subtype and name）\nannRows <- data.frame(subtype=rep(n.sub.label,each=n.top), \n                      names = unlist(gs.up$top.gs), \n                      stringsAsFactors = F)\n# 去除重复通路（如果有通路在多个亚型中均为上调）（Remove duplicate pathways if any appear in multiple subtypes）\nannRows <- annRows[!duplicated(annRows$names),]; rownames(annRows) <- annRows$names \n\n# 定义亚型分组的颜色映射（Define color mapping for subtype groups）\n# 示例数据是3个分组，有更多组就继续往后添加（Example for 3 subgroups, add more colors for additional subgroups）\nannColors <- list(subtype=c(\"keratin\"=jco[1],\"immune\"=jco[2],\"MITF-low\"=jco[3]))\n\n# 设置输出文件名（Set output file name）\nfilename <- paste0(\"subtype_specific_top_\",mode,\"_gsea.pdf\")\n\n# 绘制热图展示亚型特异性通路富集结果（Plot heatmap to visualize subtype-specific pathway enrichment results）\npheatmap(gsva_gs.up_mean[rownames(annRows),],\n         cellwidth = 10, cellheight = 10,         # 设置单元格尺寸（Set cell dimensions）\n         #color = bluered(64),                    # 自定义颜色方案（Custom color scheme）\n         cluster_rows = F,                       # 不聚类行（Disable row clustering）\n         cluster_cols = F,                       # 不聚类列（Disable column clustering）\n         border_color = NA,                      # 不显示边框（Remove cell borders）\n         annotation_row = annRows[,\"subtype\",drop = F],  # 添加行注释（Add row annotations）\n         annotation_colors = annColors,          # 设置注释颜色（Set annotation colors）\n         filename = filename)                    # 保存为PDF文件（Save as PDF file）\n寻找显著下调的亚型特异性通路\nSearch for subtype specific pathways that are significantly\ndownregulated\n# 设置富集分析模式为\"dn\"，分析下调通路（Set the enrichment analysis mode to \"dn\" for analyzing downregulated pathways）\nmode = \"dn\"\n\n# 执行亚型特异性GSEA分析，获取下调通路相关结果（Perform subtype-specific GSEA analysis to obtain results related to downregulated pathways）\ngs.dn <- subtype_specific_gsea(msigdb = msigdfFile,\n                               n.top = n.top,\n                               degs.list = degs.list,\n                               subtype.label = n.sub.label,\n                               mode = mode)\n# 计算GSVA得分：基于基因表达矩阵和GSEA分析得到的下调基因集（Calculate GSVA scores: Based on the gene expression matrix and downregulated gene sets from GSEA analysis）\ngsva_params <- gsvaParam(exprData = as.matrix(expr),\n                     geneSets = gs.dn$gs)\ngsva_gs.dn <- gsva(gsva_params)\n# 注意这里只有27条通路了，说明top通路有重叠（Note that there are only 27 pathways here, indicating overlap among the top pathways）\n\n# 初始化数据框，用于存储每个亚型的下调通路平均GSVA得分（Initialize a data frame to store the average GSVA scores of downregulated pathways for each subtype）\ngsva_gs.dn_mean <- data.frame(row.names = rownames(gsva_gs.dn)) \n\n# 计算每个亚型内样本的下调通路GSVA得分均值（也可以换用其他统计量，比如中位数等等）（Calculate the mean of downregulated pathway GSVA scores for samples within each subtype (other statistics such as median can also be used)）\nfor (i in n.sub.label) {\n  gsva_gs.dn_mean <- cbind.data.frame(gsva_gs.dn_mean,\n                                      data.frame(rowMeans(gsva_gs.dn[,rownames(subt)[which(subt$TCGA_Subtype == i)]])))\n}\n\n# 设置结果数据框的列名为各亚型名称（Set the column names of the result data frame to the names of each subtype）\ncolnames(gsva_gs.dn_mean) <- n.sub.label\n绘制热图（无聚类）\nDraw a heatmap (without clustering)\n# 创建行注释数据框，包含通路所属亚型和通路名称（Create row annotation dataframe containing pathway subtype and name）\nannRows <- data.frame(subtype=rep(n.sub.label,each=n.top), \n                      names = unlist(gs.dn$top.gs), \n                      stringsAsFactors = F)\n# 去除重复通路（如果有通路在多个亚型中均为下调）（Remove duplicate pathways if any appear in multiple subtypes）\nannRows <- annRows[!duplicated(annRows$names),]; rownames(annRows) <- annRows$names \n\n# 定义亚型分组的颜色映射（Define color mapping for subtype groups）\n# 示例数据是3个分组，有更多组就继续往后添加（Example for 3 subgroups, add more colors for additional subgroups）\nannColors <- list(subtype=c(\"keratin\"=jco[1],\"immune\"=jco[2],\"MITF-low\"=jco[3]))\n\n# 设置输出文件名（Set output file name）\nfilename <- paste0(\"subtype_specific_top_\",mode,\"_gsea.pdf\")\n\n# 绘制热图展示亚型特异性下调通路富集结果（Plot heatmap to visualize subtype-specific downregulated pathway enrichment results）\npheatmap(gsva_gs.dn_mean[rownames(annRows),],\n         cellwidth = 10, cellheight = 10,         # 设置单元格尺寸（Set cell dimensions）\n         #color = bluered(64),                    # 自定义颜色方案（Custom color scheme）\n         border_color = NA,                      # 不显示边框（Remove cell borders）\n         cluster_rows = F,                       # 不聚类行（Disable row clustering）\n         cluster_cols = F,                       # 不聚类列（Disable column clustering）\n         annotation_row = annRows[,\"subtype\",drop = F],  # 添加行注释（Add row annotations）\n         annotation_colors = annColors,          # 设置注释颜色（Set annotation colors）\n         filename = filename)                    # 保存为PDF文件（Save as PDF file）\n后期处理\n例文行名的颜色应该是后期加上的。\n生成的pdf文件是矢量图，可以用Illustrator等软件打开编辑，例如把左侧annotation拉到右侧作为行名的背景色。\nPost processing\nThe color of the example text name should be added later.\nThe generated PDF file is a vector image that can be opened and\nedited using software such as Illustrator, such as pulling the left\nannotation to the right as the background color for row names.\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa109SubtypeGSEA_update_FigureYa109SubtypeGSEA_update",
      "title": "FigureYa109SubtypeGSEA_update/FigureYa109SubtypeGSEA_update.html",
      "html": "FigureYa109SubtypeGSEA_update/FigureYa109SubtypeGSEA_update.html",
      "text": "texts/main_FigureYa109SubtypeGSEA_update_FigureYa109SubtypeGSEA_update.txt",
      "folder": "FigureYa109SubtypeGSEA_update",
      "thumb": "gallery_compress/FigureYa109SubtypeGSEA_update.webp"
    },
    "word_count": 1492,
    "lines_count": 268,
    "title": "FigureYa109subtypeGSEA_update",
    "description": "多组的富集分析及结果展示，用clusterProfiler做GSEA，挑选各组特异性top通路，画出paper里这样的对角热图。图中横坐标的6列对应6个亚型（分组），右侧文字的背景色对应6个亚组（分组）富集的通路。 Requirement description Perform enrichment analysis and result display for multiple groups,",
    "input_data_types": [
      "临床数据",
      "表达矩阵"
    ],
    "output_types": [
      "火山图",
      "热图",
      "统计表格"
    ],
    "technical_methods": [
      "聚类分析",
      "通路分析",
      "标准化",
      "差异表达分析",
      "质量控制"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "header",
      "cluster_cols",
      "cellwidth",
      "subtype",
      "drop",
      "geneSets",
      "annotation_row",
      "LANGUAGE"
    ]
  },
  {
    "id": "main_FigureYa142circosBar_FigureYa142circosBar",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa142circosBar_FigureYa142circosBar.txt",
    "content": "FigureYa142circosBar\nFigureYa142circosBar\nAuthor(s)\n: Hao Wu\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\n需求描述\nRequirements\n用circos画出B图。 Use circos to draw Figure B.\n出自\nhttps://doi.org/10.1186/s40168-019-0629-2\nFrom\nhttps://doi.org/10.1186/s40168-019-0629-2\nFig. 4 Significantly (P < 0.05) different a, b KO functional\ncategories and c pathways between GSH and GSL. All KO functional\ncategories are depicted in (a), and the differential KO functional\ncategories were evaluated using the two-tailed Wilcoxon test.\nThe abundant differential KO functional categories (relative\nabundance > 0.03%) are described in the heatmap\n(b), and\nthe involved pathways are counted in the histogram and are\nlinked by lines\n. KO functional categories that were\nsignificantly enriched in GSH or GSL were separately analyzed for KEGG\npathway enrichment; those pathways that did not belong to microorganisms\nwere removed; all significantly enriched pathways are described in (c).\nKO functional categories and pathways that were significantly enriched\nin GSH are shown in red; those significantly enriched in GSL are shown\nin green\n应用场景\nApplication scenarios\n例文中的KO可以替换为基因，可推广于基因与所在通路的关系、细胞与所属分群的关系、物种和菌群的关系等。以基因和所在通路为例，说明各部分可用于展示的信息：\nKO in the example can be replaced by genes, which can be extended to the\nrelationship between genes and their pathways, the relationship between\ncells and their clusters, the relationship between species and bacterial\ncommunities, etc. Taking genes and their pathways as an example, the\ninformation that can be displayed in each part is explained:\n横坐标是富集的基因名，纵坐标是分组；\n连线表示基因和其所属的KEGG通路的关系；\n柱状图表示每个KEGG通路中包含的基因数；\nThe horizontal axis is the name of the enriched gene, and the\nvertical axis is the grouping;\nThe line represents the relationship between the gene and the KEGG\npathway to which it belongs;\nThe bar graph represents the number of genes contained in each KEGG\npathway;\n用circos画图，最重要的是设计，想好要展示的内容是什么（本图要展示热图、连线、柱状图），然后就可以准备输入数据和配置文件了。\nWhen drawing with circos, the most important thing is design. Think\nabout what you want to show (this figure will show heat maps, lines, and\nbar graphs), and then you can prepare to input data and configuration\nfiles.\n环境设置\nEnvironment settings\n安装circos，推荐用conda，最后一些配置文件会在anaconda/etc目录下，需要的时候更改即可。也可以参考FigureYa14Circos里的方法一步步安装。\nInstall circos, it is recommended to use conda, and finally some\nconfiguration files will be in the anaconda/etc directory, which can be\nchanged when needed. You can also refer to the method in\nFigureYa14Circos for step-by-step installation.\nLinux或Mac系统在终端运行circos，Windows 10需要安装WSL\nhttps://docs.microsoft.com/en-us/windows/wsl/install-win10\nRun circos in the terminal on Linux or Mac systems, and install\nWSL on Windows 10\nhttps://docs.microsoft.com/en-us/windows/wsl/install-win10\n输入文件的获得\nObtaining input files\n例文的方法仅供参考，实际应用中，只需搞清楚Ya_circos/data/文件夹里各个文件的意义，把自己的数据按照相应的文件的格式替换即可，可直接进入“输入文件”。\nThe example method is for reference only. In actual applications, you\nonly need to understand the meaning of each file in the Ya_circos/data/\nfolder, replace your own data according to the format of the\ncorresponding file, and directly enter the “input file”.\n文章补充材料提供了csv文件（位于“oriData”文件夹），通过以下方法调整成输入文件的格式。\nThe article’s supplementary materials provide a csv file (located in the\n“oriData” folder), which is adjusted to the input file format using the\nfollowing method.\n热图：文章在对不同土壤中土豆感染疮痂病的严重程度最终分析得到大气土壤（GS）的变化最为明显，并对GSH（大气土壤土豆感染严重）和GSL（大气土壤土豆轻微感染）做出分析。GSH和GSL分别重复5组，GS1~GS5为GSH，GS6~GS10为GSL。统计得到每个样本和每个KO（KO\northology/K numbers）间的相对丰度（原补充材料表8，即1.GSH and\nGSL.xls），并通过秩和检验得到GSH和GSL的差异KO分别为240和561（p<0.05）（2.GSH-vs-GSL.wilcox.all.xls，3.GSH-vs-GSL.wilcox.filter.xls），想了解哪些KO是最显著差异的，作者对秩和检验后得到的KOs按照样本相对丰度的均值=(mean(GSH)+mean(GSL))/2\n排序，并将均值大于0.03%的作为最显著差异的KOs，最终得到98个差异KOs（4.Deal_KOs.xlsx）。\nHeat map: The article finally analyzed the severity of potato scab\ninfection in different soils and found that the change in atmospheric\nsoil (GS) was the most obvious, and analyzed GSH (severe atmospheric\nsoil potato infection) and GSL (slight atmospheric soil potato\ninfection). GSH and GSL were repeated 5 groups respectively, GS1~GS5 for\nGSH, and GS6~GS10 for GSL. The relative abundance between each sample\nand each KO (KO orthology/K numbers) was obtained (Table 8 in the\noriginal supplementary material, i.e. 1.GSH and GSL.xls), and the\ndifference KOs of GSH and GSL were 240 and 561 (p<0.05)\n(2.GSH-vs-GSL.wilcox.all.xls, 3.GSH-vs-GSL.wilcox.filter.xls) through\nthe rank sum test. To find out which KOs are the most significantly\ndifferent, the author sorted the KOs obtained after the rank sum test\naccording to the mean of the relative abundance of the samples =\n(mean(GSH)+mean(GSL))/2, and took the KOs with a mean greater than 0.03%\nas the most significantly different KOs, and finally obtained 98\ndifferent KOs (4.Deal_KOs.xlsx).\na <- read.csv(\"./oriData/1heatmap/1.GSH and GSL.csv\",header=T,sep=\",\")  ## 1.GSH and GSL.csv是原文的补充材料8 ## 1.GSH and GSL.csv is the supplementary material 8 of the original paper\nhead(a)\n连线：连线两端是要表达有联系的内容。本图中是想要展示每个KO与相应的KEGG\nB级目录的所属关系。这个关系在准备文件的时候有些麻烦。在得到98个显著差异KOs后（4.Deal_KOs.xlsx），将KO名称按照要求带入网址\nhttps://www.kegg.jp/kegg/tool/map_pathway.html\n，最终得到KO\n-> k number -> C分类 -> B分类 ->\nA分类结果。得到结果后需要将文件整理到excel中（5.table2.Knumber_Bclass.xlsx），最终其实只需要这个文件的第一列和第五列。\nConnection: The two ends of the connection are to express the\nrelated content. In this figure, we want to show the relationship\nbetween each KO and the corresponding KEGG B-level directory. This\nrelationship is a bit troublesome when preparing the file. After\nobtaining 98 significantly different KOs (4.Deal_KOs.xlsx), the KO name\nis brought into the URL\nhttps://www.kegg.jp/kegg/tool/map_pathway.html\nas\nrequired, and finally the result of KO -> k number -> C\nclassification -> B classification -> A classification is\nobtained. After getting the results, you need to organize the file into\nexcel (5.table2.Knumber_Bclass.xlsx). In the end, only the first and\nfifth columns of this file are needed.\n柱状图：这部分主要展示GSH和GSL在每个KEGG\nB分类中统计到的KO的数目，并绘制成柱状图（6.hist_GSH.xlsx，7.hist_GSL.xlsx）。由于我在统计KEGG分类的时候是手动的，所以柱状图统计的时候和文章结果存在略微出入，但是方法是正确的。大家在应用自己的数据的时候，改变数据即可。\nBar graph: This part mainly shows the number of KOs counted by GSH\nand GSL in each KEGG B classification, and draws a bar graph\n(6.hist_GSH.xlsx, 7.hist_GSL.xlsx). Since I counted the KEGG\nclassification manually, there was a slight discrepancy between the bar\ngraph and the results of the article, but the method was correct. When\nyou apply your own data, just change the data.\n输入文件\nInput file\n位于Ya_circos文件夹，包含两类文件，输入数据（位于data文件夹）和配置文件（位于etc文件夹）。\n图长什么样，全靠配置文件*.conf\n。\nLocated in the Ya_circos folder, it contains two types of files, input\ndata (located in the data folder) and configuration files (located in\nthe etc folder).\nWhat the graph looks like depends on the\nconfiguration file*.conf\n.\n每个\n.conf文件里都写了文字说明，用文本编辑器打开查看 There are\ntext descriptions in each\n.conf file. Use a text editor to open and\nview it.\n重要提示：\n如果需要修改circos.conf文件，务必在修改前做好备份，感谢！\nImportant Tips:\nIf you need to modify the circos.conf\nfile, be sure to back it up before modifying it. Thank you!\ncircos.conf，共由7个部分组成，分别是：\nPart1. 最开始的基本设置；\nPart2. 染色体标签绘制；\nPart3. 热图绘制；\nPart4. 柱状图绘制\nPart5. 背景色绘制；\nPart6. 连接线绘制；\nPart7. 最后的导入模块设置。每部分的内容在配置文件中有相应备注。\ncircos.conf, consists of 7 parts, namely:\nPart1. The initial basic settings;\nPart2. Chromosome label drawing;\nPart3. Heat map drawing;\nPart4. Bar chart drawing\nPart5. Background color drawing;\nPart6. Connecting line drawing;\nPart7. The final import module settings. Each part has corresponding\nnotes in the configuration file.\n例图热图的图例和数值区间不是线性的，这里用到了一个技巧，设置规则对每个数值区间设置不同颜色梯度。另外，由于文章中的颜色偏向荧光色，circos本身不存在这种颜色。所以我用取色器取色在颜色梯度中自己设置这种荧光色。\nThe legend and value interval of the heat map in the example figure are\nnot linear. Here is a trick to set a rule to set a different color\ngradient for each value interval. In addition, since the colors in the\narticle tend to be fluorescent colors, circos itself does not have such\ncolors. So I use the color picker to pick colors and set this\nfluorescent color in the color gradient myself.\n热图中的每个GS都要单独做一个文件用于绘制的原因：在实际应用时，可以把数据整合到一个矩阵中绘制热图，但是这样不利于修改每个样本的特征。配置文件中每个样本单独一个\n模块，且\n内容相同，就是为了在具体问题中可以单独修改，彼此不影响。当想要修改某一部分的时候，可以利用ctrl+F搜索到相应位置修改，例如我要修改links，就搜索“Part6”，然后对Part6的内容进行修改。\nThe reason why each GS in the heat map must be made into a separate file\nfor drawing: In actual application, the data can be integrated into a\nmatrix to draw a heat map, but this is not conducive to modifying the\ncharacteristics of each sample. Each sample in the configuration file\nhas a separate\nmodule, and the\ncontent is the same, so\nthat they can be modified separately in specific problems without\naffecting each other. When you want to modify a part, you can use ctrl+F\nto search for the corresponding position to modify. For example, if I\nwant to modify links, I search for “Part6” and then modify the content\nof Part6.\ndata/karyotype.txt，染色体，可以替换成想展示的其他类型信息，例如，第一、二列基本不变，第三列表示在输入文件中表示哪条染色体（即染色体号），第四列是在circos图中染色体的名称，第五列到第六列表示该条染色体起始终止位置（即染色体长度），最后一列表示染色体颜色。circos一般是用于表现单条或者多条染色体上得特征。当然也可以用于表现其他内容，只要符合数据格式都可以展示。比如本图，先确定要在染色体上展示什么，本图两条染色体（hs1和hs2），一条表示KO名称，一条表示KEGG分类。所以我是按照KO数量平均标注在hs1号染色体上（已知KO数目是98，所以设置hs1长度为98×2-2=194，2表示每个名称间距），hs2同理按照KEGG\nB级分类通路数目平均画在hs2上（已知B分类数目24个，设置hs2长度为24×3-3=69，3表示每个名称间距）。要设置文件成data/karyotype.txt的格式，并在circos.conf开头指定。设置染色体的一些参数和刻度的代码是etc/ideogram.conf和etc/ticks.conf\n这两个配置文件不需要输入数据。最后要旋转一下两条染色体，通过设置etc/circos.conf末尾的参数angle_offset*改变旋转角度，这一步可以不用管也行，最后设置。\netc/ideogram.conf，设置染色体展示在circos上的设置。刻度的相关设置，设置etc/ticks.conf文件（部分内容借鉴FigureYa14circos）。\ndata/GS1.txt，热图数据文件。第一列表示要展示的染色体号，第二第三列为KO起始终止位置，第四列为该KO的数值（相对丰度），GS2~GS10同理。只要是能用热图展示的数据，都可以绘制，比如转录组表达矩阵到组间差异基因的热图展示，宏基因组中群落OTU等热图展示。\ndata/KO_orthology_text.txt，在hs1染色体上要展示的KO的名称。第一列是要展示的染色体号，第二第三列是起始终止位置，第四列是该位置区间的KO名称，第四列设置该KO的颜色，其中red为红，lred=light\nred，dred=dark red，vlred=very light red，vdred=very dark red。\ndata/class_text.txt，hs2号染色体上展示KEGG\nB级分类名称。跟data/KO_orthology_text.txt类似。\ndata/links.txt，连线文件。因为link连线展示的是两个有关联的数据，所以这个文件格式含有两条染色体。一般就是不同染色体上有联系的内容的设置，可扩展于差异基因于相应富集通路所属关系，细胞于所属分群的关系，甚至是DNA和TF相互作用的关系或者基因和转录调控元件等等。如该文件第一行表示hs1染色体上的0到1位置的KO与hs2号染色体上18到19位置上的通路是所属关系，往下以此类推。这个文件的准备一般都要自主手动制作，或其他程序产生这种具有相应联系的文件。\n设置hs2号染色体上的黑色边框和刻度，首先黑色框通过etc/circos.conf中的part4中的\n设置，其次0\n8，0\n20的刻度横线设置通过data/light_border.txt文件设置。另外，还有一个弧形刻度线在hs2（0.86r-1.00r）上展示，对应文件是data/hist_3.txt。（原谅我这个小白实在不知道这里的刻度和弧线刻度怎么弄，我只想到了这种办法）\ndata/hist_GSH.txt和hist_GSL.txt，柱状图文件。本图中柱状图文件表示的是KEGG\nB级分类在连线中有多少个KO属于这个通路，红色表示该通路在GSH有多少个KOs，绿色表示在GSL有多少个KOs。\ndata/highlight.txt，设置染色体hs2上的背景色，这个背景色是按照将KEGG\n的A级分类分配背景色的。第一列是染色体号，二三列是背景色起始终止位置，第四列是背景色颜色和半径。\ndata/karyotype.txt, chromosomes, can be replaced with other types of\ninformation you want to display. For example, the first and second\ncolumns remain basically unchanged, the third column indicates which\nchromosome is represented in the input file (i.e., the chromosome\nnumber), the fourth column is the name of the chromosome in the circos\ndiagram, the fifth to sixth columns indicate the starting and ending\npositions of the chromosome (i.e., the chromosome length), and the last\ncolumn indicates the chromosome color. Circos is generally used to\ndisplay features on a single or multiple chromosomes. Of course, it can\nalso be used to display other content, as long as it conforms to the\ndata format. For example, in this figure, first determine what to\ndisplay on the chromosome. This figure has two chromosomes (hs1 and\nhs2), one for KO name and one for KEGG classification. So I marked the\nKOs on chromosome hs1 according to the average number of KOs (the number\nof KOs is known to be 98, so the length of hs1 is set to 98×2-2=194, 2\nrepresents the spacing between each name), and hs2 is similarly drawn on\nhs2 according to the average number of KEGG B-level classification\npathways (the number of B classifications is known to be 24, so the\nlength of hs2 is set to 24×3-3=69, 3 represents the spacing between each\nname). The file should be set in the format of data/karyotype.txt and\nspecified at the beginning of circos.conf. The codes for setting some\nparameters and scales of chromosomes are etc/ideogram.conf and\netc/ticks.conf. These two configuration files do not require data input.\nFinally, the two chromosomes need to be rotated. The rotation angle can\nbe changed by setting the parameter angle_offset* at the end of\netc/circos.conf. This step can be ignored and set at the end.\netc/ideogram.conf, set the settings for chromosome display on\ncircos. For the related settings of the scale, set the etc/ticks.conf\nfile (part of the content is referenced from FigureYa14circos).\ndata/GS1.txt, heat map data file. The first column indicates the\nchromosome number to be displayed, the second and third columns are the\nstart and end positions of the KO, and the fourth column is the value\n(relative abundance) of the KO. The same is true for GS2~GS10. As long\nas the data can be displayed with a heat map, it can be drawn, such as\nthe heat map display of transcriptome expression matrix to differential\ngenes between groups, and the heat map display of community OTU in the\nmetagenome.\ndata/KO_orthology_text.txt, the name of the KO to be displayed on\nthe hs1 chromosome. The first column is the chromosome number to be\ndisplayed, the second and third columns are the start and end positions,\nand the fourth column is the KO name in the position interval. The\nfourth column sets the color of the KO, where red is red, lred=light\nred, dred=dark red, vlred=very light red, vdred=very dark red.\ndata/class_text.txt, KEGG B-level classification name is displayed\non chromosome hs2. Similar to data/KO_orthology_text.txt.\ndata/links.txt, link file. Because the link shows two related data,\nthis file format contains two chromosomes. Generally, it is the setting\nof related content on different chromosomes, which can be extended to\nthe relationship between differentially expressed genes and\ncorresponding enriched pathways, the relationship between cells and\ntheir respective clusters, and even the relationship between DNA and TF\ninteractions or genes and transcriptional regulatory elements, etc. For\nexample, the first line of this file indicates that the KO at positions\n0 to 1 on chromosome hs1 is related to the pathway at positions 18 to 19\non chromosome hs2, and so on. The preparation of this file is generally\ndone manually, or other programs generate such files with corresponding\nconnections.\nSet the black border and scale on chromosome hs2. First, the black\nframe is set through the\nin part4 of etc/circos.conf, and then\nthe horizontal scale lines of 0~8 and 0~20 are set through the\ndata/light_border.txt file. In addition, there is an arc scale line\ndisplayed on hs2 (0.86r-1.00r), and the corresponding file is\ndata/hist_3.txt. (Forgive me for not knowing how to make the scale and\narc scale here. I just thought of this method)\ndata/hist_GSH.txt and hist_GSL.txt, histogram files. The histogram\nfiles in this figure show how many KOs belong to this pathway in the\nKEGG B-level classification. Red indicates how many KOs there are in\nGSH, and green indicates how many KOs there are in GSL.\ndata/highlight.txt, set the background color on chromosome hs2. This\nbackground color is assigned according to the background color of KEGG\nA-level classification. The first column is the chromosome number, the\nsecond and third columns are the starting and ending positions of the\nbackground color, and the fourth column is the background color and\nradius.\n开始画图\nStart drawing\n以上设置好染色体和准备好输入文件，就可以在终端（MAC或Linux系统的terminal，Windows10用WSL）运行命令完成绘图：\nAfter setting up the chromosomes and preparing the input files, you can\nrun the command in the terminal (terminal of MAC or Linux system, WSL\nfor Windows 10) to complete the drawing:\ncircos –conf path/to/etc/circos.conf\n第一次运行可能会出现一些问题，详情细节设置请看etc/circos.conf文件。对应内容修改到配置文件相应位置修改参数即可，一些参数可能没有很细节的解释，可能是因为其很好理解，我就没有加以注释。\nThere may be some problems when running for the first time. For detailed\nsettings, please refer to the etc/circos.conf file. Just modify the\ncorresponding content to the corresponding position of the configuration\nfile to modify the parameters. Some parameters may not have a very\ndetailed explanation. Maybe because they are easy to understand, I did\nnot comment them.\n后期处理\nPost-processing\n有些文字要用ps或者AI加上去： Some text needs to be added with PS or\nAI:\n刻度上的数字和GS1~GS10的标签，因为circos无法在染色体之间的区域进行绘制。\n对KEGG的B分类内容，删掉“_”符号。\n最外圈的弧线和KEGG的A分类名称。\nThe numbers on the scale and the labels of GS1~GS10, because circos\ncannot draw in the area between chromosomes.\nFor the B classification content of KEGG, delete the “_”\nsymbol.\nThe arc of the outermost circle and the name of the A classification\nof KEGG.\n如果有问题，欢迎大家踊跃提问，我会尽力帮助大家解决！ If you have any\nquestions, please feel free to ask. I will do my best to help you solve\nthem!",
    "chapter_info": {
      "id": "main_FigureYa142circosBar_FigureYa142circosBar",
      "title": "FigureYa142circosBar/FigureYa142circosBar.html",
      "html": "FigureYa142circosBar/FigureYa142circosBar.html",
      "text": "texts/main_FigureYa142circosBar_FigureYa142circosBar.txt",
      "folder": "FigureYa142circosBar",
      "thumb": "gallery_compress/FigureYa142circosBar.webp"
    },
    "word_count": 2144,
    "lines_count": 308,
    "title": "FigureYa142circosBar",
    "description": "Requirements 用circos画出B图。 Use circos to draw Figure B. 出自",
    "input_data_types": [
      "表达矩阵",
      "临床数据",
      "DNA-seq",
      "RNA-seq"
    ],
    "output_types": [
      "热图",
      "统计表格",
      "网络图"
    ],
    "technical_methods": [
      "通路分析",
      "生存分析"
    ],
    "biology_areas": [
      "感染性疾病"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "vdred",
      "2",
      "lred",
      "header",
      "3",
      "vlred",
      "dred"
    ]
  },
  {
    "id": "main_FigureYa120MulticlassedgeR_FigureYa120MulticlassedgeR",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa120MulticlassedgeR_FigureYa120MulticlassedgeR.txt",
    "content": "FigureYa120MulticlassedgeR\nFigureYa120MulticlassedgeR\nAuthor(s)\n: Xiaofan Lu, Taojun Ye\nReviewer(s)\n: Ying Ge\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n用edgeR实现多组差异分析。能用来替换FigureYa109SubtypeGSEA中的配对差异表达过程（亚型数目>=3），并跟它无缝对接。\nRequirement description\nImplement multi group difference analysis using EdgeR. Can be used to\nreplace the paired differential expression process (subtype\nnumber>=3) in FigureYa109SubtypeGSEA and seamlessly integrate with\nit.\n应用场景\n结合FigureYa109subtypeGSEA，分析每一组与其他样品的差异基因，进而找出亚型特异富集的通路；\n结合FigureYa116supervisedCluster，分析每一组与其他样品的差异基因，进而找出亚型特异的marker基因。\n注意：\n本次不涉及批次效应消除，若样本间含有批次效应，请阅读edgeR的document，在设计矩阵中纳入batch\neffect。\nhttps://bioconductor.org/packages/release/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf\n，有个完整的例子：4.2\nRNA-Seq of pathogen inoculated arabidopsis with batch effects\n这里针对read\ncount表达矩阵作为输入的情况，还可以用FigureYa118MulticlassDESeq2。如果你的数据是FPKM/RPKM或芯片数据，请参考FigureYa119Multiclasslimma。\nApplication scenarios\nBased on Figure Ya109 subtype GSEA, analyze the differentially\nexpressed genes between each group and other samples, and identify\nsubtype specific enriched pathways;\nUsing FigureYa116supervisedCluster, analyze the differentially\nexpressed genes between each group and other samples, and identify\nsubtype specific marker genes.\n**Note: * * This time does not involve batch effect elimination. If\nthere are batch effects between samples, please read the edgeR document\nand include batch effects in the design matrix<\nhttps://bioconductor.org/packages/release/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf\n>Here is a complete example: 4.2 RNA Seq of pathogenic uncoordinated\narabidopsis with batch effects\nFor the case where the read count expression matrix is used as input,\nFigureYa118MulticlassDESeq2 can also be used. If your data is FPKM/RPKM\nor chip data, please refer to FigureYa119 Multiclasslimma.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nlibrary(edgeR)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息\noptions(stringsAsFactors = FALSE) #禁止chr转成factor\n自定义函数，分别比较每一组跟其他样品之间的差异，如果有更多组，按规律补充进去即可。\nCustomize the function to compare the differences between each group\nand other samples separately. If there are more groups, simply add them\naccording to the pattern.\n# 创建需要配对比较的列表 [Create a list for pairwise comparisons]\n# 参数：group - 样本分组信息，命名向量，格式为样本名=分组名 [Parameter: group - Sample grouping information, named vector with format sample_name=group_name]\ncreateList <- function(group=NULL) {\n  \n  tumorsam <- names(group)  # 获取所有肿瘤样本名称 [Get names of all tumor samples]\n  sampleList = list()       # 存储所有比较的样本集合 [Store sample sets for all comparisons]\n  treatsamList =list()      # 存储处理组样本集合 [Store treatment group sample sets]\n  treatnameList <- c()      # 存储处理组名称 [Store treatment group names]\n  ctrlnameList <- c()       # 存储对照组名称 [Store control group names]\n  \n  #A-1: 类1 vs 其他 [Class 1 vs Others]\n  sampleList[[1]] = tumorsam  # 所有样本参与比较 [All samples included in comparison]\n  treatsamList[[1]] = intersect(tumorsam, names(group[group==\"immune\"])) # 亚型名称需要根据情况修改 [Subtype name needs to be modified according to actual situation]\n  treatnameList[1] <- \"immune\" # 该亚型的命名 [Name of this subtype]\n  ctrlnameList[1] <- \"Others\"  # 其他亚型的命名 [Name of other subtypes]\n  \n  #A-2: 类2 vs 其他 [Class 2 vs Others]\n  sampleList[[2]] = tumorsam\n  treatsamList[[2]] = intersect(tumorsam, names(group[group==\"keratin\"]))\n  treatnameList[2] <- \"keratin\"\n  ctrlnameList[2] <- \"Others\"\n  \n  #A-3: 类3 vs 其他 [Class 3 vs Others]\n  sampleList[[3]] = tumorsam\n  treatsamList[[3]] = intersect(tumorsam, names(group[group==\"MITF-low\"]))\n  treatnameList[3] <- \"MITF-low\"\n  ctrlnameList[3] <- \"Others\"\n  \n  # 返回：包含四个元素的列表 [Returns: A list containing four elements]\n  # 1. 所有比较的样本集合 [Sample sets for all comparisons]\n  # 2. 处理组样本集合 [Treatment group sample sets]\n  # 3. 处理组名称 [Treatment group names]\n  # 4. 对照组名称 [Control group names]\n  return(list(sampleList, treatsamList, treatnameList, ctrlnameList))\n  \n}\n\n# 配对edgeR差异表达分析 [Paired edgeR differential expression analysis]\n# 参数：res.path - 结果保存路径 [Parameter: res.path - Path to save results]\n# 参数：countsTable - 表达量计数矩阵，行名为基因，列名为样本 [Parameter: countsTable - Expression count matrix, row names are genes, column names are samples]\n# 参数：prefix - 结果文件前缀 [Parameter: prefix - Prefix for result files]\n# 参数：complist - 比较列表，由createList函数生成 [Parameter: complist - Comparison list generated by createList function]\n# 参数：overwt - 是否覆盖已存在的结果文件 [Parameter: overwt - Whether to overwrite existing result files]\ntwoclassedgeR <- function(res.path=NULL, countsTable=NULL, prefix=NULL, complist=NULL, overwt=FALSE) {\n  \n  #Groupinfo could contain \"batch\", which will be considered by edgeR design matrix\n  sampleList <- complist[[1]]      # 所有比较的样本集合 [Sample sets for all comparisons]\n  treatsamList <- complist[[2]]    # 处理组样本集合 [Treatment group sample sets]\n  treatnameList <- complist[[3]]   # 处理组名称 [Treatment group names]\n  ctrlnameList <- complist[[4]]    # 对照组名称 [Control group names]\n  allsamples <- colnames(countsTable)  # 获取所有样本名称 [Get names of all samples]\n  \n  options(warn=1)  # 设置警告级别 [Set warning level]\n  for (k in 1:length(sampleList)) { # 循环读取每一次比较的内容 [Loop through each comparison]\n    samples <- sampleList[[k]]      # 当前比较的样本集合 [Sample set for current comparison]\n    treatsam <- treatsamList[[k]]   # 当前比较的处理组样本 [Treatment samples for current comparison]\n    treatname <- treatnameList[k]   # 当前处理组名称 [Name of current treatment group]\n    ctrlname <- ctrlnameList[k]     # 当前对照组名称 [Name of current control group]\n    \n    compname <- paste(treatname, \"_vs_\", ctrlname, sep=\"\") # 生成最终文件名 [Generate final file name]\n    tmp = rep(\"others\", times=length(allsamples))  # 初始化样本类型 [Initialize sample types]\n    names(tmp) <- allsamples\n    tmp[samples]=\"control\"          # 设置当前比较的样本为control [Set samples in current comparison as control]\n    tmp[treatsam]=\"treatment\"       # 设置当前处理组样本为treatment [Set treatment samples as treatment]\n    outfile <- file.path( res.path, paste(prefix, \"_edgeR_test_result.\", compname, \".txt\", sep=\"\") )  # 结果文件路径 [Path of result file]\n    \n    # 因此差异表达分析较慢，因此如果文件存在，在不覆盖的情况下（overwt=F）不再次计算差异表达\n    # Since differential expression analysis is time-consuming, skip if file exists and overwt is FALSE\n    if (file.exists(outfile) & (overwt==FALSE)) { \n      cat(k, \":\", compname, \"exists and skipped;\\n\")\n      next\n    }\n  \n    # 创建样本信息数据框 [Create sample information data frame]\n    saminfo <- data.frame(\"Type\"=tmp[samples],\"SampleID\"=samples,stringsAsFactors = F)\n    \n    # 将样本类型转换为因子，指定水平顺序 [Convert sample type to factor with specified level order]\n    group=factor(saminfo$Type,levels = c(\"control\",\"treatment\"))    \n    \n    # 设计矩阵仅包含亚型信息，若有批次效应请修改，例如design <- model.matrix(~group+treat)\n    # Design matrix only includes subtype information. Modify if batch effect exists, e.g., design <- model.matrix(~group+treat)\n    design <- model.matrix(~group)\n    rownames(design) <- samples\n    \n    # 差异表达过程，具体参数细节及输出结果解释，请参阅相关document\n    # Differential expression analysis process. Refer to documentation for parameter details and result interpretation\n    y <- DGEList(counts=countsTable[,samples],group=saminfo$Type)  # 创建DGEList对象 [Create DGEList object]\n    y <- calcNormFactors(y)         # 计算标准化因子 [Calculate normalization factors]\n    y <- estimateDisp(y, design, robust=TRUE)  # 估计离散度 [Estimate dispersion]\n    fit <- glmFit(y, design)        # 拟合广义线性模型 [Fit generalized linear model]\n    lrt <- glmLRT(fit)              # 进行似然比检验 [Perform likelihood ratio test]\n    ordered_tags <- topTags(lrt, n=100000)  # 获取差异表达基因 [Get differentially expressed genes]\n    allDiff=ordered_tags$table      # 提取差异表达结果表 [Extract differential expression results table]\n    allDiff=allDiff[is.na(allDiff$FDR)==FALSE,]  # 过滤掉FDR为NA的行 [Filter out rows with NA FDR]\n    diff=allDiff                    # 简化变量名 [Simplify variable name]\n    \n    # 整理结果表格 [Format result table]\n    diff$id <- rownames(diff)\n    res <- diff[,c(\"id\",\"logFC\",\"logCPM\",\"LR\",\"PValue\",\"FDR\")]\n    colnames(res) <- c(\"id\",\"log2FC\",\"logCPM\",\"LR\",\"PValue\",\"FDR\")\n    \n    # 保存结果到文件 [Save results to file]\n    write.table(res, file=outfile, row.names=F, col.names=T, sep=\"\\t\", quote=F)\n    cat(k, \",\")  # 输出进度 [Output progress]\n  }\n  options(warn=0)  # 恢复默认警告级别 [Restore default warning level]\n}\n输入文件\nInput file\n# 读取read count表达矩阵 [Read read count expression matrix]\n# 参数说明：\n# \"easy_input_counts.txt\" - 输入文件路径 [Input file path]\n# sep = \"\\t\" - 字段分隔符为制表符 [Field separator is tab]\n# header = T - 文件包含表头 [File contains header]\n# check.names = F - 不检查列名有效性 [Do not check column name validity]\n# stringsAsFactors = F - 不将字符串转换为因子 [Do not convert strings to factors]\n# row.names = 1 - 使用第一列作为行名 [Use first column as row names]\nexpr <- read.table(\"easy_input_counts.txt\",sep = \"\\t\",header = T,check.names = F,stringsAsFactors = F,row.names = 1)\nexpr[1:3, 1:3]  # 显示前3行3列数据 [Display first 3 rows and 3 columns of data]\n# 读取亚型信息 [Read subtype information]\n# 参数说明与上面类似 [Parameter explanations similar to above]\nsubt <- read.table(\"easy_input_subtype.txt\", sep = \"\\t\", check.names = F, stringsAsFactors = F, header = T, row.names = 1)\nhead(subt)  # 显示数据前几行 [Display first few rows of data]\n# 获取唯一的亚型名称 [Get unique subtype names]\nn.sub.label <- unique(subt$TCGA_Subtype)\nn.sub.label  # 打印亚型名称 [Print subtype names]\n# 计算亚型个数 [Calculate number of subtypes]\nn.sub <- length(table(subt$TCGA_Subtype))\nn.sub  # 打印亚型个数 [Print number of subtypes]\n开始分析\nStart analyzing\n在当前文件夹会生成3个文件，可以作为FigureYa116supervisedCluster的输入：\nSKCM_edgeR_test_result.immune_vs_Others.txt\nSKCM_edgeR_test_result.keratin_vs_Others.txt\nSKCM_edgeR_test_result.MITF-low_vs_Others.txt\n如果想跟FigureYa109SubtypeGSEA无缝对接，就继续运行下面这段，生成degs.list，然后从FigureYa109SubtypeGSEA里的“自定义分析函数”开始运行，手动把“自定义分析函数”里第160行的\ngeneList <- degs$log2FoldChange\n改为\ngeneList <- degs$log2FC\n：\nThree files will be generated in the current folder, which can be\nused as input for FigureYa116supervisedCluster:\nSKCM_edgeR_test_result.immune_vs_Others.txt\nSKCM_edgeR_test_result.keratin_vs_Others.txt\nSKCM_edgeR_test_result.MITF-low_vs_Others.txt\nIf you want to seamlessly integrate with FigureYa109SubtypeGSEA,\ncontinue running the following paragraph to generate degs.list, and then\nstart running from “Custom Analysis Functions” in\nFigureYa109SubtypeGSEA. Manually change the “geneList<- degs\n$log2FoldChange” in line 160 of “Custom Analysis Functions” to\n“geneList<- degs $log2FC”:\n# 定义差异表达结果文件列表 [Define list of differential expression result files]\nDEfiles <- c(\"SKCM_edgeR_test_result.immune_vs_Others.txt\",\n             \"SKCM_edgeR_test_result.keratin_vs_Others.txt\",\n             \"SKCM_edgeR_test_result.MITF-low_vs_Others.txt\")\n\n# 初始化差异表达基因数据框列表 [Initialize list to store differential expression gene data frames]\ndegs.list <- list()\n\n# 循环读取每个差异表达分析结果文件 [Loop through each differential expression analysis result file]\nfor (i in 1:n.sub) {  # n.sub是之前计算的亚型数量 [n.sub is the number of subtypes calculated earlier]\n  \n  # 读取差异表达分析结果文件 [Read differential expression analysis result file]\n  # 参数说明：\n  # DEfiles[i] - 当前循环的文件名 [Name of current file in loop]\n  # sep = \"\\t\" - 使用制表符分隔 [Use tab as field separator]\n  # header = T - 文件包含表头 [File contains header]\n  # check.names = F - 不检查列名有效性 [Do not check column name validity]\n  # stringsAsFactors = F - 不将字符串转换为因子 [Do not convert strings to factors]\n  # row.names = 1 - 使用第一列作为行名 [Use first column as row names]\n  degs <- read.table(DEfiles[i],sep = \"\\t\",header = T,check.names = F,stringsAsFactors = F,row.names = 1)\n  \n  # 显示数据前几行 [Display first few rows of data]\n  head(degs)\n  \n  # 将结果存入列表，使用亚型名称作为键，同时去除含有NA值的行 [Store results in list with subtype name as key, removing rows with NA values]\n  degs.list[[n.sub.label[i]]] <- as.data.frame(na.omit(degs))  # n.sub.label是之前获取的亚型名称向量 [n.sub.label is the subtype name vector obtained earlier]\n}\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa120MulticlassedgeR_FigureYa120MulticlassedgeR",
      "title": "FigureYa120MulticlassedgeR/FigureYa120MulticlassedgeR.html",
      "html": "FigureYa120MulticlassedgeR/FigureYa120MulticlassedgeR.html",
      "text": "texts/main_FigureYa120MulticlassedgeR_FigureYa120MulticlassedgeR.txt",
      "folder": "FigureYa120MulticlassedgeR",
      "thumb": "gallery_compress/FigureYa120MulticlassedgeR.webp"
    },
    "word_count": 1376,
    "lines_count": 238,
    "title": "FigureYa120MulticlassedgeR",
    "description": "用edgeR实现多组差异分析。能用来替换FigureYa109SubtypeGSEA中的配对差异表达过程（亚型数目>=3），并跟它无缝对接。 Requirement description Implement multi group difference analysis using EdgeR. Can be used to",
    "input_data_types": [
      "临床数据",
      "表达矩阵"
    ],
    "output_types": [
      "火山图",
      "统计表格"
    ],
    "technical_methods": [
      "通路分析",
      "标准化",
      "差异表达分析"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学",
      "药物研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "times",
      "header",
      "complist",
      "n",
      "sample_name",
      "pvalue",
      "prefix",
      "allDiff",
      "group"
    ]
  },
  {
    "id": "main_FigureYa242corMethExpr_FigureYa242corMethExpr",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa242corMethExpr_FigureYa242corMethExpr.txt",
    "content": "FigureYa242corMethExpr\nFigureYa242corMethExpr\nXiaofan Lu\n2025-5-20\n需求描述 / Requirement Description\nFPKM跟启动子区甲基化的相关性。输入数据是TCGA的FPKM和DNA甲基化数据。 / Correlation between FPKM and promoter methylation. Input data is FPKM and DNA methylation data from TCGA.\n希望能学习到怎么获取基因启动子区的甲基化探针，自己跑代码时就能灵活自定义将启动子区调整TSS1500，TSS200，甚至分析gene body区域甲基化与基因表达的关系。 / Hope to learn how to obtain methylation probes in gene promoter regions, and be able to flexibly customize the promoter region to TSS1500, TSS200, or even analyze the relationship between gene body methylation and gene expression when running code.\n出自 / From\nhttps://academic.oup.com/nar/article/48/D1/D856/5584613\n应用场景 / Application Scenario\n计算特定基因启动子DNA甲基化与对应表达谱的相关性并绘图。 / Calculate and plot the correlation between specific gene promoter DNA methylation and corresponding expression profiles.\n环境设置 / Environment Setup\n使用国内镜像安装包 / Use domestic mirrors to install packages\noptions(\"repos\"= c(CRAN=\"https://mirrors.tuna.tsinghua.edu.cn/CRAN/\"))\noptions(BioC_mirror=\"http://mirrors.tuna.tsinghua.edu.cn/bioconductor/\")\n加载包 Loading Package\nlibrary(TCGAbiolinks)\nlibrary(ChAMPdata)\nlibrary(data.table)\ndata(probe.features) # 加载450甲基化探针注释文件 Load the 450 methylation probe annotation file\n\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 Display English error messages\noptions(stringsAsFactors = FALSE) #禁止chr转成factor Disable conversion of chr values ​​to factors\n输入文件 / Input Files\nTCGA-UCEC.methylation450.tsv.gz，UCEC的DNA甲基化数据，下载自XENA / UCEC DNA methylation data, downloaded from XENA\nhttps://xenabrowser.net/datapages/?dataset=TCGA-UCEC.methylation450.tsv&host=https%3A%2F%2Fgdc.xenahubs.net&removeHub=https%3A%2F%2Fxena.treehouse.gi.ucsc.edu%3A443\n。已上传至微云 / Has been uploaded to Weiyun\nhttps://share.weiyun.com/Qn0X57I0\n# 加载基因表达注释文件 / Load gene expression annotation file\nGinfo <- read.table(\"overlapTable27.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\n下载UCSC的FPKM数据 / Download FPKM data from UCSC\ntumor <- \"UCEC\"\nexpquery <- GDCquery(project = paste0(\"TCGA-\", tumor),\ndata.category = \"Transcriptome Profiling\",\ndata.type = \"Gene Expression Quantification\",\nworkflow.type = \"HTSeq - FPKM\" # 下载FPKM数据 / Download FPKM data\n)\nGDCdownload(expquery,directory = \"GDCdata\")\nexpquery2 <- GDCprepare(expquery,directory = \"GDCdata\",summarizedExperiment = T)\nfpkm <- TCGAanalyze_Preprocessing(expquery2) # 获取表达谱（FPKM值）Obtain expression profile (FPKM value)\n\n# 取出FPKM中的gene Remove the gene in FPKM\ncomgene <- intersect(rownames(fpkm),rownames(Ginfo)) # 取出共有基因 Remove common genes\nGinfo <- Ginfo[comgene,]\nfpkm <- as.data.frame(fpkm[comgene,]) # 取出mRNA的FPKM值 / Extract mRNA FPKM values\ncolnames(fpkm) <- substr(colnames(fpkm),1,16) # 取TCGA样本名的前16位 / Take the first 16 characters of TCGA sample names\nfpkm <- fpkm[,which(substr(colnames(fpkm), 14, 15) == \"01\")] # 保留肿瘤样本 / Keep tumor samples\n\n将FPKM的ENSEMBL ID转为Gene Symbol并去重 / Convert FPKM's ENSEMBL ID to Gene Symbol and remove duplicates\nfpkm$Gene <- as.character(Ginfo$genename)\nfpkm <- fpkm[!duplicated(fpkm$Gene),] # 重复基因去重 / Remove duplicate genes\nrownames(fpkm) <- fpkm$Gene; fpkm <- fpkm[,-ncol(fpkm)]\nfpkm <- as.data.frame(round(fpkm,3)) # 取表达的小数点后3位数 / Take 3 decimal places of expression values\nfwrite(fpkm,\"UCEC_FPKM.txt\",sep = \"\\t\",row.names = T,quote = F)\n\n读取UCEC的DNA甲基化数据 / Read UCEC DNA methylation data\n这里为了加快速度，已经对甲基化数据做过处理，只读取符合要求的启动子探针数据，不过代码所做的筛选过程依然有效 / To speed up, the methylation data has been pre-processed to only read promoter probe data that meets requirements, but the code filtering process is still valid\nmeth <- fread(\"TCGA-UCEC.methylation450.tsv.gz\",sep = \"\\t\",check.names = F,stringsAsFactors = F,header = T,data.table = F)\nmeth <- as.data.frame(meth); rownames(meth) <- meth[,1]; meth <- as.data.frame(na.omit(meth[,-1])) # 去除空值 / Remove empty values\ncolnames(meth) <- substr(colnames(meth), start = 1,stop = 16) # 取样本名的前16位 / Take first 16 characters of sample names\nmeth <- meth[,which(substr(colnames(meth), 14, 15) == \"01\")] # 保留肿瘤样本 / Keep tumor samples\n计算特点基因启动子表观遗传甲基化与对应表达谱的相关性 / Calculate correlation between specific gene promoter epigenetic methylation and corresponding expression profiles\n# 根据需要确定启动子探针 / Determine promoter probes as needed\ntable(probe.features$feature) # 查看背景集里有多少探针feature / Check how many probe features are in the background set\ntable(probe.features$cgi) # 查看背景集里有多少探针region / Check how many probe regions are in the background set\ntable(probe.features$feat.cgi) # 查看背景集里有多少探针feature和region的组合 / Check how many probe feature and region combinations are in the background set\n# 可自定义启动子区长度Custom promoter region length can be defined\npb <- rownames(probe.features[which(#probe.features$cgi == \"island\" & # CpG岛 # CpG island\n                                            probe.features$feature %in% c(\"TSS1500\", # from -200 to -1500 bp upstream of TSS\n                                                                          \"TSS200\", # from -200 bp upstream of TSS\n                                                                          \"1stExone\", # the first exon\n                                                                          \"5'UTR\" \n                                                                          ) &\n                                              !probe.features$CHR %in% c(\"X\",\"Y\") # 不在性染色体 # Not on sex chromosomes\n                                            ),])\nsubmeth <- round(meth[intersect(pb,rownames(meth)),],3)\nfwrite(submeth,\"UCEC_PromMeth_ProbeLevel.tsv\",sep = \"\\t\",row.names = T,quote = F)\n\n# 对重复基因的探针取中位数（比较慢请耐心等待） # Calculate median for probes of duplicate genes (please be patient as this will take a while)\nsubmeth$gene <- as.character(probe.features[rownames(submeth),\"gene\"])\nGmeth <- apply(submeth[,setdiff(colnames(submeth), \"gene\")], 2, function(x) tapply(x, INDEX=factor(submeth$gene), FUN=median, na.rm=TRUE)) # be patient because this will take a while\nGmeth <- as.data.frame(round(Gmeth,3)) # 取甲基化的小数点后3位数 # Round methylation values to 3 decimal places\nfwrite(Gmeth,\"UCEC_PromMeth_GeneLevel.tsv\",sep = \"\\t\",row.names = T,quote = F)\n\n# 取出共有样本 # Extract common samples\ncomsam <- intersect(colnames(fpkm),colnames(Gmeth))\n\n# 取出感兴趣基因的表达和启动子甲基化 # Extract expression and promoter methylation of genes of interest\ngene <- \"SFN\"\ncorTab <- data.frame(expr = log2(as.numeric(fpkm[gene,comsam]) + 1),\n                     meth = as.numeric(Gmeth[gene,comsam]),\n                     stringsAsFactors = F)\n\nct <- cor.test(corTab$expr,corTab$meth)\nreg <- lm(expr~meth, data=corTab) # 计算回归线 # Calculate regression line\n开始画图Start plotting\npdf(file = paste0(\"correlation between expression and methylation of \",gene,\".pdf\"), width = 4.5,height = 4.5)\npar(bty=\"l\", mgp = c(1.5,.33,0), mar=c(3,3,2,2), las=1, tcl=-.25, xpd = F)\nplot(corTab$meth,\n     corTab$expr,\n     xlab = bquote(italic(.(gene))~\" (median \"~beta~\" value of promoter)\"), # 添加基因斜体以及希腊字母beta # Add gene name in italics and Greek letter beta\n     ylab = bquote(italic(.(gene))~\" (FPKM)\"), # 添加基因斜体 # Add gene name in italics\n     main = bquote(.(tumor)~\" - \"~italic(.(gene))), # 添加基因斜体 # Add gene name in italics\n     pch = 19,\n     cex = 0.9,\n     xaxt = \"n\", # 不绘制x坐标轴刻度 # Do not draw x-axis ticks\n     xlim = c(0,1),\n     col = ggplot2::alpha(\"#73C485\", 0.8))\naxis(side = 1, at = seq(0,1,0.2), labels = seq(0,1,0.2)) # 修改x坐标轴 # Modify x-axis\nabline(reg, lwd = 2, col = \"red\", lty = 2) # 添加回归线 # Add regression line\nlegend(\"topright\", # 图例放在右上角 # Place legend in top right corner\n       legend = bquote(\"Pearson \"~rho~\"=\"~.(round(ct$estimate,2))~\"; \"~italic(P)~\"-value=\"~.(formatC(ct$p.value,3))), # 添加希腊字母rho，p值斜体以及科学计数法 # Add Greek letter rho, italic P-value and scientific notation\n       bty = \"n\") # 去掉图例边框线 # Remove legend border\ninvisible(dev.off())\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa242corMethExpr_FigureYa242corMethExpr",
      "title": "FigureYa242corMethExpr/FigureYa242corMethExpr.html",
      "html": "FigureYa242corMethExpr/FigureYa242corMethExpr.html",
      "text": "texts/main_FigureYa242corMethExpr_FigureYa242corMethExpr.txt",
      "folder": "FigureYa242corMethExpr",
      "thumb": "gallery_compress/FigureYa242corMethExpr.webp"
    },
    "word_count": 858,
    "lines_count": 116,
    "title": "FigureYa242corMethExpr",
    "description": "FPKM跟启动子区甲基化的相关性。输入数据是TCGA的FPKM和DNA甲基化数据。 / Correlation between FPKM and promoter methylation. Input data is FPKM and DNA methylation data from TCGA. 希望能学习到怎么获取基因启动子区的甲基化探针，自己跑代码时就能灵活自定义将启动子区调整TSS1500，TSS200，甚至分析gene body区域甲基化与基因表达的关系。 / Hope to learn how to obtain methylation probes in gene promoter regions, and be able to flexibly customize the promoter region to TSS1500, TSS200, or even analyze the relationship between gene body methylation and gene expression when running code. 出自 / From",
    "input_data_types": [
      "临床数据"
    ],
    "output_types": [
      "散点图",
      "统计表格"
    ],
    "technical_methods": [],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "header",
      "lwd",
      "width",
      "summarizedExperiment",
      "xlim",
      "side",
      "labels",
      "legend",
      "col"
    ]
  },
  {
    "id": "main_FigureYa171subgroupSurv_FigureYa171subgroupSurv",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa171subgroupSurv_FigureYa171subgroupSurv.txt",
    "content": "FigureYa171subgroupSurv\nFigureYa171subgroupSurv\nAuthor(s)\n: Shipeng Guo\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement\n我们对亚组进行分析（比如说，risk\nsignature在不同的年龄、性别、gleason评分等）的时候，区分高危和低危之后，画图把高危和低危的预测放到不同的年龄或肿瘤级别中，看看是否仍然有效。\n目前只能通过手动来做，是否可以帮忙做一个续惯的流程。\n输入survival信息，和不同的临床亚组。 When performing subgroup analysis\n(for example, risk signatures for different age groups, genders, Gleason\nscores, etc.), after distinguishing high-risk from low-risk, we plot\nthese predictions across different age groups or tumor grades to see if\nthey still hold true. Currently, this can only be done manually. Could\nyou help me create a custom workflow?\n出自\nhttps://www.onlinelibrary.wiley.com/doi/full/10.1002/cam4.1498\nFrom\nhttps://www.onlinelibrary.wiley.com/doi/full/10.1002/cam4.1498\nFigure 7. Subgroup analyses revealed by Kaplan-Meier survival curve.\n(A) Stratified survival analyses based on the clinicopathological\nfeatures age, clinical stage, histological stage, and neoplasm\nhistological grade for the 7-miRNA-based OS classifier.\n应用场景\nApplication Scenario\n本质上就是每次按条件筛选数据，然后做生存分析。 Essentially, we filter\nthe data by condition each time and then perform a survival\nanalysis.\n你可能还想看这篇： 8秒完成2万个基因的生存分析，人人都可以！\nhttps://mp.weixin.qq.com/s/o4e1HzG4zPIQoGT6-7D0ug\nYou\nmay also want to read this article: Complete survival analysis of 20,000\ngenes in 8 seconds, everyone can do it!\nhttps://mp.weixin.qq.com/s/o4e1HzG4zPIQoGT6-7D0ug\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nLoad the package\nlibrary(survival)\nlibrary(survminer)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # Display English error messages\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # Disable conversion of chr to factor\n输入文件\nInput file\neasy_input.csv，包含生存数据和临床亚组信息。 easy_input.csv, contains\nsurvival data and clinical subgroup information.\ndd <- data.table::fread(\"easy_input.csv\",data.table = F)\ndd[1:3,]\n以一个亚组为例\nTake a subgroup as an example\n以age>=60为例，提取数据、绘制生存曲线。 Take age>=60 as an\nexample, extract data, and plot the survival curve.\n批量操作\nBatch operation\n本质上就是每次按条件筛选数据，然后做生存分析，重点是在筛选数据\nEssentially, this involves filtering data by condition each time and\nthen performing a survival analysis. The key is in filtering the\ndata.\n自定义函数\nCustom function\n给一个筛选标准，直接画图。 Give a filtering criterion and plot\ndirectly.\n支持单次操作 Supports single operations\nmysurvplot <- function(cols=cols,filter=filter){\n  ## 过滤条件 ## Filter condition\n  index = dd[,cols]==filter\n  ## 按行过滤数据 ## Filter data by row\n  rt = dd[index,]\n  ## 生存分析 ## Survival analysis\n  fit = survfit(Surv(futime, fustat) ~ Risk, data = rt)\n  ## 计算p值 ## Calculate p-value\n  x = survdiff(Surv(futime, fustat) ~ Risk, data = rt)\n  pValue=1-pchisq(x$chisq,df=1)\n  pValue= round(pValue,3)\n  ## 作图 ## Plot\n  p=ggsurvplot(fit,\n             pval = pValue,\n             palette = c(orange, blue),\n             title=paste0(cols,filter),\n             xlab=\"Time in days\")\n  return(p)\n}\n函数用法 ## Function Usage\nTest the function with three examples\n# 举三个例子测试函数\n## Run in batches, saving the plot results as a list\nmysurvplot(\"age\",\"<60\")\nmysurvplot(\"gleason\",\">7\")\nmysurvplot(\"stage\",\"T1+T2\")\n批量运行，把画图结果存为list\n# 为了方便批量操作，把筛选条件写成向量形式\n# For ease of batch operation, write the filter criteria as a vector\ncols <- c(\"age\",\"age\",\"gleason\",\"gleason\",\"psa\",\"psa\",\"stage\",\"stage\")\nfilter <- c(\">=60\",\"<60\",\"<=7\",\">7\",\"<=10\",\">10\",\"T1+T2\",\"T3+T4\")\n\np <- list()\nfor ( i in 1:length(cols)) {\n  p[[i]] = mysurvplot(cols[i],filter[i])\n}\n拼图 Merge Graph\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa171subgroupSurv_FigureYa171subgroupSurv",
      "title": "FigureYa171subgroupSurv/FigureYa171subgroupSurv.html",
      "html": "FigureYa171subgroupSurv/FigureYa171subgroupSurv.html",
      "text": "texts/main_FigureYa171subgroupSurv_FigureYa171subgroupSurv.txt",
      "folder": "FigureYa171subgroupSurv",
      "thumb": "gallery_compress/FigureYa171subgroupSurv.webp"
    },
    "word_count": 440,
    "lines_count": 113,
    "title": "FigureYa171subgroupSurv",
    "description": "Requirement 我们对亚组进行分析（比如说，risk signature在不同的年龄、性别、gleason评分等）的时候，区分高危和低危之后，画图把高危和低危的预测放到不同的年龄或肿瘤级别中，看看是否仍然有效。",
    "input_data_types": [
      "临床数据",
      "生存数据"
    ],
    "output_types": [
      "统计表格",
      "生存曲线"
    ],
    "technical_methods": [
      "生存分析"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "df",
      "pvalue",
      "fit",
      "pval",
      "rt",
      "filter",
      "p",
      "pValue",
      "xlab"
    ]
  },
  {
    "id": "main_FigureYa23count2TPM_FigureYa23count2TPMv2",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa23count2TPM_FigureYa23count2TPMv2.txt",
    "content": "FigureYa23count2TPMv2\nFigureYa23count2TPMv2\nAuthor(s)\n: Zhougeng Xu; Ying Ge, Yijing Chen\nDate\n: 2025-09-22\n需求描述\nRequirement description\nRNA-seq read count转换成TPM。\nConvert RNA-seq read count to TPM.\n应用场景\nApplication scenario\n只能拿到RNA-seq数据的read count，想转换成TPM。\n注：TPM的计算方式最好是直接从原始的FASTQ文件进行获取，例如Samlon,\nSailfish 或 kallisto, 或者先用FASTQ比对得到BAM，然后用RESM估计TPM.\nIf you only have access to RNA-seq read counts and want to convert\nthem to TPM.\nNote: The best way to calculate TPM is directly from the original\nFASTQ files using tools like Salmon, Sailfish, or kallisto, or by first\naligning the FASTQ to obtain BAM files and then using RESM to estimate\nTPM.\n计算基因长度\nCalculate gene length\n这步比较耗时。建议：\n使用TCGA数据的小伙伴可以直接使用压缩包里的\neff_length.csv\n文件，就可以跳过这步，直接从“输入数据”开始运行。\n每个物种每个基因组注释版本的基因长度是相同的，下面这部分代码你只需要运行一次，保存好生成的\neff_length.csv\n文件，标注好基因组版本。当你需要做count到FPKM或TPM的转换时，就可以跳过“计算基因长度”这步，直接从“read\ncount转TPM”开始运行。\n这一步有两种思路:\n方法1：简单粗暴的计算基因在染色体的起始和结束之差\n方法2：比较麻烦的计算每个基因的最长转录本(外显子之和)或所有外显子之和\n推荐方法2\nThis step is more time consuming. It is recommended:\nIf you use TCGA data, you can directly use the\neff_length.csv\nfile in the zip package, then you can skip\nthis step and run directly from “Input data”.\nThe gene length is the same for each genome annotation version of\neach species, you only need to run this part of the code once, save the\ngenerated\neff_length.csv\nfile, and label the genome\nversion. When you need to do the conversion from count to FPKM or TPM,\nyou can skip the step of “calculate gene length”, and directly start\nfrom “read count to TPM”.\nThere are two ways of thinking in this step:\nMethod 1: Simply calculate the difference between the start and\nend of the gene on the chromosome.\nMethod 2: Calculate the longest transcript (sum of exons) of each\ngene or the sum of all exons, which is more troublesome.\nRecommended method 2\n方法1\nMethod 1\n如果只是想粗略了解一下表达情况，可以简单把基因在染色体上的起始位置和结束位置之差用作标准化的长度。\nIf you just want to get a rough idea of the expression, you can\nsimply use the difference between the start and end positions of the\ngene on the chromosome as a normalized length.\nlibrary(biomaRt)\n\n#查看基因组参数\n#view genomic parameter\nmart = useMart('ensembl')\nlistDatasets(mart)\n\n#你需要哪个基因组，就复制它在dataset列里的词，放在下面这行的`dataset = `参数里\n#此处以人类为例，植物参考注一\n#Which genome you need, copy its word in the dataset column and put it in the `dataset = ` parameter on the following line\n#Here is an example for humans, for plants refer to note 1\nbmart <- biomaRt::useMart(biomart = \"ENSEMBL_MART_ENSEMBL\", \n                          dataset = \"hsapiens_gene_ensembl\",\n                          host = \"www.ensembl.org\")\n\n# 从输入数据里提取基因名\n# extract gene names from input data\nfeature_ids <- rownames(expMatrix)\n\nattributes = c(\n        \"ensembl_gene_id\",\n        #\"hgnc_symbol\",\n        \"chromosome_name\",\n        \"start_position\",\n        \"end_position\"\n    )\nfilters = \"ensembl_gene_id\"\n\nfeature_info <- biomaRt::getBM(attributes = attributes, \n                               filters = filters, \n                               values = feature_ids, mart = bmart)\nmm <- match(feature_ids, feature_info[[filters]])\nfeature_info_full <- feature_info[mm, ]\nrownames(feature_info_full) <- feature_ids\n\n# 计算基因的有效长度\n# calculate the effective length of the gene\neff_length <- abs(feature_info_full$end_position - feature_info_full$start_position)\nnames(eff_length) <- feature_info_full$ensembl_gene_id\n这里的\neff_length\n就是每个基因的有效长度\nHere\neff_length\nis the effective length of each gene\n方法2\nMethod 2\n这一步原本打算用Bioconductor的\nord.Hs.eg.db\n,但是实际发现里面的ENSEMBL\nID明显比输入的TCGA数据集里的ID少。所以决定从GTF文件提取：\n先写一个函数，实现从下载GTF文件到计算基因长度.\n分为两个模式，用模式2算出的length去做count转FPKM，跟TCGA的FPKM最为接近，详情请看FigureYa34count2FPKM。自己斟酌选用：\n模式1. transcript，计算最长的转录本长度\n模式2. gene，计算所有转录本的所有外显子的总长度\nThis step was initially intended to use Bioconductor’s\norg.Hs.eg.db\n, but it was actually found that the ENSEMBL\nIDs in it were significantly less than those in the input TCGA dataset.\nTherefore, it was decided to extract them from the GTF file:\nFirst write a function to realize from download GTF file to calculate\ngene length.\nThere are two modes, use the length calculated in mode 2 to do the\ncount to FPKM, which is the closest to the FPKM of TCGA, please see\nFigureYa34count2FPKM for details. choose at your own discretion:\nModel 1. transcript, calculate the length of the longest\ntranscripts.\nModel 2. gene, calculate the total length of all exons of all\ntranscripts.\n目前只测试了拟南芥和人类。\n注，函数不支持需要登陆才能下载的GTF的URL\n下面调用函数下载GTF文件，提取存放有效转录本长度的向量\n把你想要的gtf文件的地址写在下面\nurl <-\n的后面\n案例一：\n此处以TCGA的read\ncount作为输入，用跟TCGA一致的注释文件提取外显子长度。\n到这里查询TCGA用的是哪个版本的注释文件：\nhttps://gdc.cancer.gov/about-data/data-harmonization-and-generation/gdc-reference-files\n用的是这个版本：\nGDC.h38 GENCODE v22 GTF (used in RNA-Seq alignment and by HTSeq)\n去\nhttps://www.gencodegenes.org/releases/22.html\n下载相应版本的gtf文件\nCurrently only Arabidopsis thaliana and human are tested. Note, the\nfunction does not support the URL of GTF which requires login to\ndownload.\nCall the function below to download the GTF file and extract the\nvector containing the lengths of valid transcripts.\nWrite the address of the GTF file you want in the following\nurl <-\nfollowed by\nCase 1:\nHere, the read count of TCGA is used as input, and the exon lengths\nare extracted using an annotation file consistent with TCGA.\nGo here to query which version of the annotation file is used by\nTCGA:\nhttps://gdc.cancer.gov/about-data/data-harmonization-and-generation/gdc-reference-files\nThis version is used:\nGDC.h38 GENCODE v22 GTF (used in RNA-Seq alignment and by HTSeq)\nGo to\nhttps://www.gencodegenes.org/releases/22.html\nto\ndownload the corresponding version of the gtf file\n#url <- \"ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_22/gencode.v22.annotation.gtf.gz\"\n\nfile<- \"gencode.v22.annotation.gtf\"\neff_length <- get_eff_len(file = file,\n                          #采用模式2，计算所有转录本的所有外显子的总长度\n                          #Use model 2 to calculate the total length of all exons of all transcripts\n                          mode='gene',\n                          #采用模式1，计算最长的转录本长度\n                          #Use model 1 to calculate the longest transcript length\n                          #mode=='transcript',\n                          feature = \"exon\",\n                          gene_id = 'gene_id',\n                          transcript_id = \"transcript_id\")\n\neff_length1 <- data.frame(eff_length)\nwrite.csv(eff_length1, \"eff_length.csv\", row.names = TRUE)\n注意，用CDS时不会统计非编码RNA\n案例二：拟南芥的GTF文件(推荐Araport)，统计每个基因最长的转录本的CDS序列长度\nNote that non-coding RNA is not counted when using CDS\nCase 2: GTF file for Arabidopsis thaliana (Araport recommended),\ncalculate the CDS sequence length of the longest transcript for each\ngene.\nfile <- \"Araport11_GFF3_genes_transposons.201606.gtf\"\neff_length <- get_eff_len(file = file,\n                          feature = \"CDS\",\n                          gene_id = 'gene_id',\n                          transcript_id = \"transcript_id\")\n下载TCGA RNA-seq的read count数据\nDownload TCGA RNA-seq read count data\n如果你自己的RNA-seq数据已经保存成\neasy_input.txt\n的格式，就跳过这步，直接进入“输入数据”\nIf your own RNA-seq data has been saved in\neasy_input.txt\nformat, skip this step and go directly to\n“Input data”.\n#source(\"https://bioconductor.org/biocLite.R\")\n#biocLite(\"TCGAbiolinks\")\nlibrary(TCGAbiolinks)\nexpquery <- GDCquery(project = \"TCGA-LIHC\", \n                data.category = \"Transcriptome Profiling\",\n                data.type = \"Gene Expression Quantification\",\n                workflow.type = \"HTSeq - Counts\"\n                )\nGDCdownload(expquery)\nexpquery2 <- GDCprepare(expquery)\nexpMatrix <- TCGAanalyze_Preprocessing(expquery2)\n\n#运行下面这行，会把read count保存到文件里，用来做更多其他的分析。\n#Running the following line will save the read count to a file that can be used for more other analysis.\n#write.table(expMatrix, \"easy_input.txt\", sep=\"\\t\", quote=F, row.names=T)\n#此处保存前4个sample\n#Save the first 4 samples here\nwrite.table(expMatrix[,1:4], \"easy_input.txt\", sep=\"\\t\", quote=F, row.names=T)\n输入数据\nInput data\n第一列是基因ID，第一行是sample ID。\n一个单元格内是一个基因在一个sample中的read count。\nThe first column is the gene ID and the first row is the sample\nID.\nInside a cell is the read count of a gene in a sample.\nexpMatrix <- read.table(\"easy_input.txt\",\n                        row.names = 1, header = TRUE, sep=\"\\t\")\n#查看前三个基因的read count\n#view the read count for the first three genes\nexpMatrix[1:3,]\nread count转TPM\nRead count to TPM\n首先要保证表达矩阵的行名和存放基因长度向量的名字一致,\n这一步非常重要\nIt is important to make sure that the row names of the expression\nmatrix match the names of the gene length vectors.\neff_length2 <-read.csv(\"eff_length.csv\", row.names = 1, header = T)\neff_length2$gene_id <- rownames(eff_length2)\nrownames(eff_length2) <- do.call(rbind,strsplit(eff_length2$gene_id,'\\\\.'))[,1]\n\nfeature_ids <- rownames(expMatrix)\n\nif (! all(feature_ids %in% rownames(eff_length2))){\n  tbl <- table(feature_ids %in% rownames(eff_length2))\n  msg1 <- sprintf(\"%i gene is shared, %i gene is specified\", tbl[[2]],tbl[[1]])\n  warning(msg1)\n  \n} \n\nif (! identical(feature_ids, rownames(eff_length2))){\n  msg2 <- sprintf(\"Given GTF file only contain %i gene, but experssion matrix has %i gene\", nrow(eff_length2), nrow(expMatrix))\n  warning(msg2)\n}\n# 修剪表达矩阵和有效基因长度\n# trim the expression matrix and effetive gene length\nexpMatrix <- expMatrix[feature_ids %in% rownames(eff_length2),]\nmm <- match(rownames(expMatrix), rownames(eff_length2))\neff_length2 <- eff_length2[mm, ]\n\nif (identical(rownames(eff_length2), rownames(expMatrix))){\n  print(\"GTF and expression matix now have the same gene and gene in same order\")\n}\n如果上面代码运行时有警告，主要是GTF里面的基因数低于表达矩阵时，请换一个更新版本的GTF文件.\n最后结果时删减表达矩阵的行数，也就是基因数，保证表达矩阵的基因数目和GTF文件解析得到的基因数相同，并且顺序一致。\n最后执行下面的代码\nIf there is a warning when running the above code, mainly because the\nnumber of genes in the GTF is lower than the expression matrix, please\nchange to a newer version of GTF file. In the final result, delete the\nnumber of rows of the expression matrix, that is, the number of genes,\nto ensure that the number of genes in the expression matrix is the same\nas the number of genes in the parsed GTF file, and the order is\nconsistent.\nFinally, execute the following code\nx <- expMatrix / eff_length2$eff_length\nexpMatrix_tpm <- t( t(x) / colSums(x) ) * 1e6\n把算好的TPM保存到本地\nSave the calculated TPM locally\nwrite.table(expMatrix_tpm, \"output_count2tpm.txt\", sep=\"\\t\", quote=F, row.names=T)\n参考资料\nReference\nhttps://biology.stackexchange.com/questions/64860/what-is-the-length-of-gene-when-calculating-tpm-transcripts-per-million\nSeurat::getBMFeatureAnnos\n注1: 直接比较FPKM转成的TPM和count转换而成的TPM，完全一致。\nNote 1: Direct comparison of FPKM converted TPM and count converted\nTPM is identical.\nrawcount <- read.table(\"easy_input.txt\",\n                        row.names = 1, header = TRUE, sep=\"\\t\")\ncount2tpm.mt <- read.table(\"output_count2tpm.txt\", sep = \"\\t\", \n                         row.names = 1)\ncount2tpm.mt[1:3,]\nfpkm2tpm.mt <-  read.table(\"TCGA_FPKM2TPM.genes.txt\", sep = \" \",\n                           row.names = 1)\nfpkm2tpm.mt[1:3,]\n# 比较原始计数和 count2tpm\n# compare raw count and count2tpm\ncor(x=rawcount$TCGA.DD.A11D.01A.11R.A131.07, y=count2tpm.mt$TCGA.DD.A11D.01A.11R.A131.07)\n# 比较原始计数和 fpkm2tpm\n# compare raw count with fpkm2tpm\ncor(x=rawcount$TCGA.DD.A11D.01A.11R.A131.07,\n    y=fpkm2tpm.mt$TCGA.DD.A11D.01A.11R.A131.07)\n# 比较 count2tpm 和 fpkm2tpm\n# compare  count2tpm and fpkm2tpm\ncor(x=count2tpm.mt$TCGA.DD.A11D.01A.11R.A131.07,\n    y=fpkm2tpm.mt$TCGA.DD.A11D.01A.11R.A131.07)\n以第一列为例，raw count 和 count2tpm的相关系数是0.898，raw count\n和fpkm2tpm的相关系数也是 0.898。而count2tpm和fpkm2tpm的相关系数是1,\n证明了count2tpm的代码是有效的。\n注2: biomaRt支持多物种, 通过更改参数biomart 和 host\n来获取，植物的host跟动物的不同\nTake the first column as an example, the correlation coefficient\nbetween raw count and count2tpm is 0.898, and the correlation\ncoefficient between raw count and fpkm2tpm is also 0.898. The\ncorrelation coefficient between count2tpm and fpkm2tpm is 1, which\nproves that the code of count2tpm is valid.\nNote 2: biomaRt supports multi-species, by changing the parameters\nbiomart and host, the host of plants is different from that of\nanimals.\nbiomaRt::listMarts(host=\"plants.ensembl.org\")\nmart <- biomaRt::useMart(biomart = 'plants_mart',\n                         host = \"plants.ensembl.org\")\ngenome <- biomaRt::listDatasets(mart)\n注3:\nbiomaRt::getBM\n由于要从国外服务器下载数据所以比较慢，可能还会断线,\n当你遇到”The query to the BioMart webservice returned an invalid result:\nbiomaRt expected a character string of length 1. Please report this to\nthe mailing list.”时不要慌张，反复重新运行这行命令就行\n注4：如果无法通过\nsource(\"https://bioconductor.org/biocLite.R\")\n安装biocLite,那么就需要手动安装\n把\nhttps://bioconductor.org/biocLite.R\n下载到本地并打开，在文件开头加入如下两行命令并保存。\nNote 3:\nbiomaRt::getBM\nis slower and may be disconnected\nbecause it has to download data from foreign server, when you encounter\n“The query to the BioMart webservice returned an invalid result: biomaRt\nexpected a character string of length 1. Please report this to the\nmailing list.”, don’t panic, just re-run the command repeatedly.\nNote 4: If you can’t install biocLite via\nsource(\"https://bioconductor.org/biocLite.R\")\n, then you\nneed to install it manually.\nDownload\nhttps://bioconductor.org/biocLite.R\nlocally and open it,\nadd the following two lines at the beginning of the file and save\nit.\n#bioconductor\n\n    CRANextra = \"http://www.stats.ox.ac.uk/pub/RWin\"))\n#cran\n然后使用\nsource调用本地biocLite.R文件安装bioclnstaller，再进行安装\nThen use source to call the local biocLite.R file to install\nbioclnstaller, then install it.\nsource('/path/to/biocLite.R')\nBiocInstaller::biocLite()\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa23count2TPM_FigureYa23count2TPMv2",
      "title": "FigureYa23count2TPM/FigureYa23count2TPMv2.html",
      "html": "FigureYa23count2TPM/FigureYa23count2TPMv2.html",
      "text": "texts/main_FigureYa23count2TPM_FigureYa23count2TPMv2.txt",
      "folder": "FigureYa23count2TPM",
      "thumb": "gallery_compress/FigureYa23count2TPM.webp"
    },
    "word_count": 1556,
    "lines_count": 361,
    "title": "FigureYa23count2TPMv2",
    "description": "Requirement description RNA-seq read count转换成TPM。 Convert RNA-seq read count to TPM.",
    "input_data_types": [
      "表达矩阵",
      "DNA-seq"
    ],
    "output_types": [
      "散点图",
      "统计表格"
    ],
    "technical_methods": [
      "标准化"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "attributes",
      "values",
      "CRANextra",
      "header",
      "biomart",
      "filters",
      "type",
      "project",
      "x",
      "transcript_id"
    ]
  },
  {
    "id": "main_FigureYa296VIPER_FigureYa296VIPER",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa296VIPER_FigureYa296VIPER.txt",
    "content": "FigureYa296VIPER\nFigureYa296VIPER\nAuthor(s)\n: Xiaofan Lu; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-09-30\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nDemand description\n转录因子活性计算方法。\n转录因子活性推断\n每个样本的转录因子活性通过VIPER软件包（Alvarez et al.,\n2016）基于z-score标准化的RNA数据进行计算。转录因子的靶基因来源于DoRothEA数据库（Garcia-Alonso\net al.,\n2019），分析时采用中等置信度的靶基因集合。肿瘤样本与正常样本的活性评分通过Student\nt检验进行比较，并使用Benjamini-Hochberg方法校正p值。校正后p值 <\n0.05的转录因子被视为具有显著差异。\n我们还利用VIPER中的ARACNe算法（Lachmann et al.,\n2016）构建基因调控网络，并根据转录因子蛋白丰度的相关性推断其靶基因，从而解析癌症特异的转录因子调控机制。此外，我们将标准化富集的蛋白活性评分与免疫评分进行了相关性分析。\n出自：\nhttps://linkinghub.elsevier.com/retrieve/pii/S1535610820306553\nCalculation methods for transcription factor activity.\nTranscription factor activity inference\nTranscription factor activity for each sample was inferred using the\nVIPER package (Alvarez et al., 2016) on z-score transformed RNA data.\nThe transcription factor targets were collected from DoRothEA\n(Garcia-Alonso et al., 2019) and the medium confidence targets were used\nfor analysis. Activity scores for tumor and normal samples were compared\nusing Student’s t-test and the p values were adjusted using the\nBenjamini-Hochberg method. Transcription factors with an adjusted p\nvalue < 0.05 were considered significant.\nWe also used the ARACNe algorithm (Lachmann et al., 2016) in VIPER to\nconstruct gene regulatory networks and infer transcription factor\ntargets based on correlation to the transcription factor protein\nabundance. This allows for cancer-specific transcription factor gene\nregulation. We correlated the normalized enrichment protein activity\nscores with immune scores.\nSource:\nhttps://linkinghub.elsevier.com/retrieve/pii/S1535610820306553\n应用场景\nApplication scenarios\n将转录组表达矩阵转换为调控因子活性矩阵，并画图。\n这里用VIPER包计算转录因子活性（Protein-activity by Enriched Regulon\nanalysis）。另外，如果要分析\n转录调控网络regulon的活性\n（注意：并非转录因子活性），可参考FigureYa249Regulon。\n例文METHOD DETAILS的Integrated\nanalysis部分描述了挖掘生物学意义时用到的整合分析方法，我们曾实现过其中一些算法：\nESTIMATE：可参考FigureYa211multiCohortImmSubtype\nssGSEA：可参考FigureYa71ssGSEA\nNMF：可参考FigureYa110mutationSignature，FigureYa158MutationPattern，FigureYa169sigHeatmap。\nConvert the transcriptomic expression matrix into a regulator\nactivity matrix and visualize the results.\nHere, the VIPER package is used to calculate transcription factor\nactivity (Protein-activity by Enriched Regulon analysis). Alternatively,\nif\nanalyzing regulon activity\n(note: not transcription\nfactor activity), refer to FigureYa249Regulon.\nThe METHOD DETAILS section under Integrated analysis describes the\ncomputational methods used for biological interpretation, some of which\nwere previously crowdsourced in our studies:\nESTIMATE: Refer to FigureYa211multiCohortImmSubtype\nssGSEA: Refer to FigureYa71ssGSEA\nNMF: Refer to FigureYa110mutationSignature,\nFigureYa158MutationPattern, and FigureYa169sigHeatmap\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(mixtools)\nlibrary(dorothea)\nlibrary(viper)\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n输入文件\nInput Files\nviper/ARACNe需要TXT格式的转录因子列表和表达矩阵作为输入数据，输入文件保存在”InputData”文件夹中。\ntfs.txt，转录因子列表，这里是从dorothea包中提取的。\nHS_CPTAC_HNSCC_RNAseq_RSEM_UQ_log2_Normal.cct，HS_CPTAC_HNSCC_RNAseq_RSEM_UQ_log2_Tumor.cct，表达矩阵，下载自\nhttp://linkedomics.org/data_download/CPTAC-HNSCC\n。整理成easy_input_matrix.txt。\nVIPER/ARACNe requires input data in TXT format, including a\ntranscription factor list and an expression matrix, stored in the\n“InputData” folder.\ntfs.txt: Transcription factor list, extracted from the DoRothEA\npackage.\nHS_CPTAC_HNSCC_RNAseq_RSEM_UQ_log2_Normal.cct，HS_CPTAC_HNSCC_RNAseq_RSEM_UQ_log2_Tumor.cct:\nExpression matrices downloaded from\nhttp://linkedomics.org/data_download/CPTAC-HNSCC\nand\nreformatted into easy_input_matrix.txt.\nwork.path <- \".\"\ndata.path <- file.path(work.path, \"InputData\")\nres.path <- file.path(work.path, \"Results\")\ncode.path <- file.path(work.path, \"Codes\")\nfig.path <- file.path(work.path, \"Figures\")\n\nif (!dir.exists(data.path)) dir.create(data.path)\nif (!dir.exists(res.path)) dir.create(res.path)\nif (!dir.exists(code.path)) dir.create(code.path)\nif (!dir.exists(fig.path)) dir.create(fig.path)\n\n# 从dorothea包中提取转录因子列表\n# Extract transcription factor list from dorothea package\nnet <- dorothea::dorothea_hs\ntfs <- unique(net$tf)\nwrite.table(tfs, file.path(data.path, \"easy_input_tfs.txt\"), row.names = F, col.names = F, quote = F)\n\n# 读取原文提供的转录组数据，并保存到InputData/matrix.txt中\n# Read original transcriptomic data and save to InputData/matrix.txt\ntmp1 <- read.table(file.path(data.path, \"HS_CPTAC_HNSCC_RNAseq_RSEM_UQ_log2_Normal.cct\"), \n                   header = T, row.names = 1, check.names = F)\ncolnames(tmp1) <- paste0(\"Normal\", \"_\", colnames(tmp1))\n\ntmp2 <- read.table(file.path(data.path, \"HS_CPTAC_HNSCC_RNAseq_RSEM_UQ_log2_Tumor.cct\"), \n                   header = T, row.names = 1, check.names = F)\ncolnames(tmp2) <- paste0(\"Tumor\", \"_\", colnames(tmp2))\nexpr <- cbind(tmp1, tmp2)\n\n## 去除在过多样本(>10%)中表达值为0的基因，以避免在bootstrap过程中出现报错\n## Remove genes with zero expression in >10% samples to avoid bootstrap errors\nexpr <- expr[rowSums(expr>0) >= 0.1*ncol(expr), ]\n\n## 整理样本分组信息\n## Prepare sample grouping information\nclin <- data.frame(\n  row.names = colnames(expr),\n  \"IsTumor\" = c(rep(\"Normal\", ncol(tmp1)), rep(\"Tumor\", ncol(tmp2))),\n  \"Patient\" = gsub(\"Tumor_|Normal_\", \"\", colnames(expr))\n)\n# 也可以直接读取样本分组信息文件：\n# Alternatively read sample grouping info directly from file:\n# clin <- read.delim(file.path(data.path, \"HS_CPTAC_HNSCC_CLI.tsi\"))\n# clin <- clin[-1, ]; rownames(clin) <- clin$case_id\n# expr <- expr[, c(\"Idx\", clin$case_id)]\n\nwrite.table(data.frame(\"gene\" = rownames(expr), expr), file.path(data.path, \"easy_input_matrix.txt\"), \n            row.names = F, col.names = T, quote = F, sep = \"\\t\")\n重建基因调控网络 - ARACNe-AP\nReconstructing Gene Regulatory Networks - ARACNe-AP\nARACNe-AP是基于java的程序，需要安装1.8以上的java。java下载地址\nhttps://www.java.com/\nARACNe-AP可以从GitHub上下载后自行编译，存放在\nCode/ARACNe-AP\n文件夹里。具体过程参考GitHub指南。git\nclone\nhttps://github.com/califano-lab/ARACNe-AP.git\n，或者使用已经编译好的可执行文件：dist/aracne.jar。\nARACNe-AP is a Java-based program that requires Java 1.8 or higher to\nbe installed. Java can be downloaded from:\nhttps://www.java.com/\nARACNe-AP can be downloaded from GitHub and compiled locally, then\nstored in the\nCode/ARACNe-AP\ndirectory. For detailed\ninstructions, please refer to the GitHub guide: git clone\nhttps://github.com/califano-lab/ARACNe-AP.git\n.\nAlternatively, you may directly use the pre-compiled executable located\nat: dist/aracne.jar.\n计算转录因子活性 - VIPER\nCalculating Transcription Factor Activity - VIPER\n输入转录因子列表和表达矩阵，推断主要调控因子，获得各转录因子的主要调控靶标，寻找调控网络间的阴影对，预测调控子间的协同作用。\n参考VIPER的文档\nhttps://www.bioconductor.org/packages/release/bioc/vignettes/viper/inst/doc/viper.pdf\nInput a list of transcription factors and an expression matrix to\ninfer key regulatory factors, identify the main regulatory targets of\neach transcription factor, detect shadow pairs within regulatory\nnetworks, and predict synergistic interactions among regulators.\nRefer to the VIPER documentation\nhttps://www.bioconductor.org/packages/release/bioc/vignettes/viper/inst/doc/viper.pdf\nregulon\nsummary(mrs)\n# VIPER图展示每个转录因子的正负调控靶标\n# VIPER plot showing the projection of the negative and positive targets for each TF.\npdf(file.path(fig.path, \"Target for each TF.pdf\"))\nplot(mrs, cex = .7)\ninvisible(dev.off())\n\n\n## Leading-edge分析\n## Leading-edge analysis\n\n### 获得各转录因子的主要调控靶标\n### Obtain leading regulatory targets for each transcription factor\nmrs <- ledge(mrs)\nsummary(mrs)\nmrs.tab <- as.data.frame(mrs$es[c(\"nes\", \"size\", \"p.value\")])\nmrs.tab <- mrs.tab[order(mrs.tab$p.value), ]\nmrs.tab$p.adj <- p.adjust(mrs.tab$p.value, method = \"BH\")\n\n# mrs.tab$leadingEdge <- mrs$ledge \n# 主要调控靶标无法写入txt中，可选择xlsx或rds格式\n# Leading targets cannot be written to txt, can choose xlsx or rds format\nwrite.table(mrs.tab, file = file.path(res.path, \"ouput_mrs.txt\"), quote = F)\n\n\n## msVIPER扩展分析 \n## Beyond msVIPER  \n## ------------------------------------------------------------------\n\n### msVIPER自举分析\n### Bootstrap msVIPER\nsignature <- bootstrapTtest(eset, \"IsTumor\", c(\"Tumor\"), \"Normal\", verbose = TRUE)\nmrs.boot <- msviper(signature, regulon, nullmodel, verbose = TRUE)\nmrs.boot <- bootstrapmsviper(mrs.boot, \"mode\")\n\n# msVIPER图展示使用100次自举迭代的生发中心反应基因表达特征中转录因子regulons的富集情况\n# msVIPER plot showing the enrichment of transcription factor regulons on the germinal center reaction gene expression signature using 100 bootstrap iterations.\npdf(file.path(fig.path, \"Target for each TF (bootstap).pdf\"))\nplot(mrs.boot, cex = .7)\ninvisible(dev.off())\n\n\n### Shadow analysis\n### 寻找调控网络间的阴影对\n### 阴影对MR1−>MR2，表示计算的MR2转录因子活性部分由于MR1的共调控作用\n### Shadow分析\n### Identify shadow pairs in regulatory network\n### Shadow pair MR1−>MR2 indicates MR2's calculated activity is partly due to MR1's co-regulation\n\n# 选取最显著的25个转录因子\n# Select top 25 significant transcription factors\nmrs.shadow <- shadow(mrs, regulators = 25, verbose = TRUE)\nsummary(mrs.shadow)\nmrs.shadow$shadow\nmrs.synergy <- msviperSynergy(mrs.synergy, verbose = TRUE)\nsummary(mrs.synergy)\nmrs.synergy$es$synergy\n# msVIPER图展示共调控regulon在生发中心反应基因表达特征中的富集结果\n# msVIPER plot showing the results for the enrichment of co-regulons on the germinal center reaction gene expression signature\npdf(file.path(fig.path, \"Target for each TF(Co-regulon).pdf\"))\nplot(mrs.synergy, mrs = 25, cex = .7)\ninvisible(dev.off())\n\n\n## 活性分数分析\n## Activity Score \n## ------------------------------------------------------------------\n\n### 将转录组表达矩阵转换为调控因子活性矩阵\n### Convert transcriptome expression matrix to regulator activity matrix\nvpsig <- viperSignature(eset, \"IsTumor\", \"Normal\", verbose = TRUE)\nvpres <- viper(vpsig, regulon, verbose = TRUE)\nreg.score <- exprs(vpres)\n#saveRDS(reg.score, file.path(res.path, \"reg.score.rds\"))\nwrite.table(reg.score, file = file.path(res.path,\"ouput_reg.score.txt\"),sep = \"\\t\",row.names = T,col.names = NA,quote = F)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa296VIPER_FigureYa296VIPER",
      "title": "FigureYa296VIPER/FigureYa296VIPER.html",
      "html": "FigureYa296VIPER/FigureYa296VIPER.html",
      "text": "texts/main_FigureYa296VIPER_FigureYa296VIPER.txt",
      "folder": "FigureYa296VIPER",
      "thumb": "gallery_compress/FigureYa296VIPER.webp"
    },
    "word_count": 1027,
    "lines_count": 262,
    "title": "FigureYa296VIPER",
    "description": "Demand description 转录因子活性计算方法。 转录因子活性推断",
    "input_data_types": [
      "突变数据",
      "临床数据",
      "表达矩阵",
      "RNA-seq"
    ],
    "output_types": [
      "散点图",
      "热图",
      "统计表格",
      "网络图"
    ],
    "technical_methods": [
      "网络分析",
      "通路分析",
      "标准化",
      "motif分析"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "LANGUAGE",
      "quote",
      "stringsAsFactors",
      "method",
      "verbose",
      "header",
      "regulators",
      "names",
      "mrs"
    ]
  },
  {
    "id": "main_FigureYa133m6Apeak_update_FigureYa133m6Apeak_update",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa133m6Apeak_update_FigureYa133m6Apeak_update.txt",
    "content": "FigureYa133m6Apeak_update\nFigureYa133m6Apeak_update\n小丫画图出品\n2020-6-27\n需求描述\n何川组发在nature上的m6a相关的工作，求call差异peak的数据分析部分。\nRequirement Description\nHe Chuan's group published work related to m6a in Nature, and is looking for data analysis of the peak difference in call activity.\n出自\nhttps://www.nature.com/articles/nature21355\n根据文献method总结起来需要以下几步：\n前期：数据及reference下载\nalignment\nextend reads\nselect longest transcript and slide widows 4.calculate count and exclude low count reads(less than 1/20 top window)\ncalculate fisher P value and FDR adjust\nmerge windows with significant FDR.\n应用场景\nm6A-seq分析流程，从序列比对到call peak.\nFrom\nhttps://www.nature.com/articles/nature21355\nBased on the literature, the following steps are required:\nPreliminary: Download data and references\nAlignment\nExtend reads\nSelect the longest transcript and slide widows 4. Calculate counts and exclude low-count reads (less than 1/20 top window)\nCalculate Fisher P value and FDR adjustment\nMerge windows with significant FDR.\n环境设置 >Environment Setup\n本文档中所有代码都要在终端（Terminal）里运行。All code in this document must be run in Terminal.\n建议使用Linux或MAC系统。Windows 10需要安装WSL\nhttps://docs.microsoft.com/en-us/windows/wsl/install-win10\nLinux or Mac OS is recommended. Windows 10 requires installing WSL\nhttps://docs.microsoft.com/en-us/windows/wsl/install-win10\n安装以下软件：SRATools，hisat2，bedtools、samtools。方法如下：\nInstall the following software: SRATools, hisat2, bedtools, and samtools. The method is as follows:\n下载安装SRATools，用于下载SRA数据和转成fastq格式，下载和安装方法看这篇：\nhttps://trace.ncbi.nlm.nih.gov/Traces/sra/sra.cgi?view=toolkit_doc&f=std\n。掌握了这个方法，就可以肆意下载已发表文章里的高通量测序的原始数据了。\nDownload and install SRATools, which is used to download SRA data and convert it to fastq format. For download and installation instructions, see this article:\nhttps://trace.ncbi.nlm.nih.gov/Traces/sra/sra.cgi?view=toolkit_doc&f=std\n. Once you master this method, you can freely download raw data from high-throughput sequencing published articles.\n# 先安装wget用于下载，可断点续传 First install wget for downloading, which allows for resumable downloads.\nconda install -c anaconda wget \n\n# 下载SRATools，用于下载测序数据\nwget https://ftp-trace.ncbi.nlm.nih.gov/sra/sdk/2.9.6-1/sratoolkit.2.9.6-1-mac64.tar.gz\n# 解压缩，设置环境变量或者直接把prefetch和fastq-dump文件复制到当前文件夹就可以用了。\n\n# 或者用conda安装\nconda install -c daler sratoolkit\n\n# Download SRATools for downloading sequencing data.\nwget https://ftp-trace.ncbi.nlm.nih.gov/sra/sdk/2.9.6-1/sratoolkit.2.9.6-1-mac64.tar.gz\n# Unzip and set environment variables or simply copy the prefetch and fastq-dump files to the current folder.\n\n# Alternatively, install using conda:\nconda install -c daler sratoolkit\n安装hisat2，用于把测序数据回帖到基因组：Install hisat2 to post sequencing data back to the genome:\nconda install -c bioconda hisat2\n安装bedtools、samtools，用于sam、bed文件处理Install bedtools and samtools for sam and bed file processing\nconda install -c bioconda samtools \nconda install -c bioconda bedtools\n输入文件Input File\n需要下载测序结果、参考基因组序列和注释。You need to download the sequencing results, reference genome sequence, and annotations.\n测序数据，储存在SRA数据库中。从文章中找到线索，一般搜GSE或SRA就能从正文找到数据ID。示例文章的数据ID是GSE79213，进入GEO数据库，找到这套数据：\nhttps://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE79213\n，能下载到peak.bed和FPKM文件。我们需要从头开始跑，要下载原始的fastq文件，因此，需要到SRA数据库中去下载。在“SRA”这三个字母右侧看到SRP071818，点击链接进入。我们以GSM2088162 input-0 和GSM2088167 m6A-IP-0为例来建立pipeline，分别对应SRR3228697和SRR3228702\n参考基因组序列，下载自ensembl\nhttp://asia.ensembl.org/info/data/ftp/index.html\n，zebrafish version11（原文用的是10）。 序列：\nftp://ftp.ensembl.org/pub/release-97/fasta/danio_rerio/dna/Danio_rerio.GRCz11.dna.primary_assembly.fa.gz\n， 注释：\nftp://ftp.ensembl.org/pub/release-97/gff3/danio_rerio/Danio_rerio.GRCz11.97.chr.gff3.gz\nSequencing data are stored in the SRA database. To find clues in the article, search for \"GSE\" or \"SRA\" to find the data ID within the text. The data ID for this example article is GSE79213. Go to the GEO database and find this data set:\nhttps://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE79213\n. You can download the peak.bed and FPKM files. Since we need to run the sequence from scratch and download the original fastq file, we need to download it from the SRA database. To the right of \"SRA,\" you'll see SRP071818. Click the link to access it. We use GSM2088162 input-0 and GSM2088167 m6A-IP-0 as examples to establish the pipeline, corresponding to SRR3228697 and SRR3228702, respectively.\nThe reference genome sequence was downloaded from ensembl\nhttp://asia.ensembl.org/info/data/ftp/index.html\n, Zebrafish version 11 (the original article used version 10). Sequence:\nftp://ftp.ensembl.org/pub/release-97/fasta/danio_rerio/dna/Danio_rerio.GRCz11.dna.primary_assembly.fa.gz\n, Comment:\nftp://ftp.ensembl.org/pub/release-97/gff3/danio_rerio/Danio_rerio.GRCz11.97.chr.gff3.gz\n在终端输入命令下载：\nEnter the command in the terminal to download:\n1. alignment\n原文用的是tophat，我这里用的hisat2（因为hisat2实在是比tophat好用很多，以至于tophat作者都已经开始推荐了）The original paper used Tophat, but I'm using Hisat2 here (because Hisat2 is so much easier to use than Tophat that the author has already recommended it).\nhisat2 -x genome -p 4 -U SRR3228697.fastq -S SRR3228697.sam 2> SRR3228697.hisat2.log\nhisat2 -x genome -p 4 -U SRR3228702.fastq -S SRR3228702.sam 2> SRR3228702.hisat2.log\n\nsamtools view -bS -q 15 SRR3228697.sam | samtools sort - | samtools rmdup -s - SRR3228697.bam\nsamtools view -bS -q 15 SRR3228702.sam | samtools sort - | samtools rmdup -s - SRR3228702.bam\n2. extend reads\n原文说把reads extend到150，及fragment size。所以只需要把reads的位置前面减去50，后面加上50即可（因为文章中的reads是SE 50bp，即单端测序，读长50bp）The original article said to extend reads to 150 and fragment size. Therefore, simply subtract 50 from the beginning of the read position and add 50 to the end (since the reads in the article are SE 50bp, i.e., single-end sequencing with a read length of 50bp).\n转换bam文件为bed文件，用到bedtools Convert the bam file to a bed file using bedtools.\nbamToBed -i SRR3228697.bam > SRR3228697.bed\nbamToBed -i SRR3228702.bam > SRR3228702.bed\nextend 50，因为有的位置可能小于起始位点小于50，所以加一个条件判断：Extend 50. Because some positions may be less than 50 from the start site, add a conditional:\nawk '{if ($2 > 50) print $1,$2-50,$3+50;else print $1,$2,$3+50}' OFS=\"\\t\" SRR3228697.bed > SRR3228697.ext.bed\nawk '{if ($2 > 50) print $1,$2-50,$3+50;else print $1,$2,$3+50}' OFS=\"\\t\" SRR3228702.bed> SRR3228702.ext.bed\n3. select longest transcript and slide widows\n处理基因组注释文件，主要用到的R + bash + bedtools Processing genome annotation files, mainly using R, bash, and bedtools\n首先把所有的转录本抓出来 First, extract all transcripts\ngrep mRNA Danio_rerio.GRCz11.97.chr.gff3 | awk '{print $1,$4,$5,$7,$9}' OFS=\"\\t\"| awk -F \";\" '{print $1,$2}' OFS=\"\\t\" | sed 's/ID=transcript://g' | sed 's/Parent=gene://g'| awk '{print $1,$2,$3,$4,$5,$6,$3-$2}' OFS=\"\\t\" > mrna.bed\n之后把最长的转录本抓出来Then extract the longest transcript.\n在终端运行R脚本longest.trans.R：Run the R script longest.trans.R in the terminal:\nRscript longest.trans.R mrna.bed longess_trans.bed\n滑窗(bedtools)\nbedtools makewindows -b longess_trans.bed -w 100 -s 10 -i srcwinnum > longess_trans.windows.bed\n4.calculate count and exclude low count reads(less than 1/20 top window)\n计算window中reads数量。有很多种方法，Calculate the number of reads in the window. There are many ways,\n（1）做成gtf文件htseq计算\n（2）featurecount\n（3）bedtools的intersect。\n(1) Create a gtf file and perform htseq calculations\n(2) Feature count\n(3) Use intersect in bedtools.\n这里选用第三种，并且只有reads大于50%的部分在这个window中才会计数，这样避免一个reads被算两次或多次。\nThe third option is used here, and only reads greater than 50% are counted in this window to prevent a read from being counted twice or more.\nbedtools intersect -F 0.5 -a longess_trans.windows.bed -b SRR3228697.ext.bed -c |  awk  '{print $1,$2,$3,$5,$4}' OFS=\"\\t\" | awk -F \"_\" '{print $1,$2}' OFS=\"\\t\"| awk '{print $1,$2,$3,$4,$5,$5\"_\"$6}' OFS=\"\\t\" > SRR3228697.txt\nbedtools intersect -F 0.5 -a longess_trans.windows.bed -b SRR3228702.ext.bed -c |  awk  '{print $4,$5}' OFS=\"\\t\" > SRR3228702.txt\n这里两个文件的输出格式不太一样，我主要是为了节省空间，也可以输出一样的。\n计算window中reads的中位数和总和(bash 中的AWK)：\nThe output formats of the two files are slightly different. I did this to save space, but they can still be output the same.\nCalculate the median and sum of reads in a window (AWK in bash):\nawk 'BEGIN {max = 0} {if ($4+0 > max+0) max=$1} END {print \"Max=\", max}' SRR3228697.txt\nMax= 156\n\nawk 'BEGIN {max = 0} {if ($2+0 > max+0) max=$2} END {print \"Max=\", max}' SRR3228702.txt\nMax= 182\n\nawk '{sum+=$4} END {print \"Sum= \", sum}' SRR3228697.txt\nSum=  9419939\n\nawk '{sum+=$2} END {print \"Sum= \", sum}' SRR3228702.txt\nSum=  8961275\n排除reads少的window，原文说排除reas数量小both IP and input，所以就是排除reads数量小于1/20 156 & 182\nExclude windows with low reads. The original text says to exclude both IP and input with small read counts, so this means excluding read counts less than 1/20 (156 & 182).\nawk '$4 > 7 {print}' SRR3228697.txt > SRR3228697.filter.txt\nawk '$2 > 9 {print}' SRR3228702.txt > SRR3228702.filter.txt\n5. calculate fisher P value and FDR adjust\n在终端运行R脚本callPeak.R，自定义输入和输出文件即可。各个参数的说明：\nRun the R script callPeak.R in the terminal and customize the input and output files. Parameter descriptions:\nSRR3228697.filter.txt: input\nSRR3228702.filter.txt: IP\n9419939：input reads总数\n8961275：IP reads总数\nall.txt：全部数据\npeak.bed: peak数据\n中间有一个warning。不同理会，是all[is.na(all)] <- 0 产生的\n写的比较粗糙，日后改进一下，把该封装的封装成function，提升一下运算速度。\nSRR3228697.filter.txt: input\nSRR3228702.filter.txt: IP\n9419939: Total input reads\n8961275: Total IP reads\nall.txt: All data\npeak.bed: Peak data\nThere is a warning in the middle. Ignore it; it's caused by all[is.na(all)] <- 0\nThis is a bit crude. I'll try to improve it later by encapsulating this function to increase the computation speed.\nRscript callPeak.R SRR3228697.filter.txt SRR3228702.filter.txt 9419939 8961275 peak.bed all.txt\n6. merge windows with significant FDR.\nbash merge peak\nbedtools merge -i peak.bed -c 4 -o collapse | awk -F \",\" '{print $1}' > peak.merge.bed\nComment\n原文说用每个基因的中位数去normalize 每个window的reads数量，我觉得是不合理的，因为fisher算的就是一个富集程度，无论是除法normalize，做减法normalize，还是取log都不太合理(或者我没正确领会作者意思)。同时，统计学上来讲没有重复的P值都是耍流氓，如果有重复可以试试其他的检验方法去call P value。\nThe original article said to use the median of each gene to normalize I think the number of reads per window is unreasonable, because Fisher calculates enrichment, so normalizing by division, subtraction, or logarithm is not reasonable (or perhaps I didn't understand the author's intention correctly). Also, statistically speaking, P values ​​without replication are inaccurate. If replication is present, try other methods to call P values.\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa133m6Apeak_update_FigureYa133m6Apeak_update",
      "title": "FigureYa133m6Apeak_update/FigureYa133m6Apeak_update.html",
      "html": "FigureYa133m6Apeak_update/FigureYa133m6Apeak_update.html",
      "text": "texts/main_FigureYa133m6Apeak_update_FigureYa133m6Apeak_update.txt",
      "folder": "FigureYa133m6Apeak_update",
      "thumb": "gallery_compress/FigureYa133m6Apeak_update.webp"
    },
    "word_count": 1231,
    "lines_count": 167,
    "title": "FigureYa133m6Apeak_update",
    "description": "何川组发在nature上的m6a相关的工作，求call差异peak的数据分析部分。 Requirement Description He Chuan's group published work related to m6a in Nature, and is looking for data analysis of the peak difference in call activity.",
    "input_data_types": [
      "DNA-seq"
    ],
    "output_types": [
      "统计表格"
    ],
    "technical_methods": [
      "通路分析"
    ],
    "biology_areas": [],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "acc",
      "Sum",
      "Max",
      "Parent",
      "ID",
      "max",
      "f",
      "view"
    ]
  },
  {
    "id": "main_FigureYa50ChinaMap_FigureYa50ChinaMap",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa50ChinaMap_FigureYa50ChinaMap.txt",
    "content": "FigureYa50ChinaMap\nFigureYa50ChinaMap\nJie Zhang; Ying Ge, Yijing Chen\n2025-5-20\n需求描述\nrequirement description\n世界地图上的中国标准地图，省份内填充的颜色展示该省数据。\nA standard map of China on the world map, with colors filled within\neach province to represent the data of that province.\n出自\nhttp://dx.plos.org/10.1371/journal.pntd.0005930\nfrom\nhttp://dx.plos.org/10.1371/journal.pntd.0005930\n应用场景\napplication scenario\n展示某一特征值在各省的分布情况。例如：人口、发病率、GDP等。\nDisplay the distribution of a specific characteristic across\nprovinces. For example: population, incidence rate, GDP, etc.\n环境设置\nenvironment setting\n用国内清华的镜像安装包，更快\nUse the domestic Tsinghua’s mirror installation package, faster\noptions(\"repos\"= c(CRAN=\"https://mirrors.tuna.tsinghua.edu.cn/CRAN/\"))\ninstall.packages(\"Cairo\")\ninstall.packages('pinyin')\n加载R包\nload R package\nlibrary(pinyin) #汉字转拼音 convert Chinese characters to pinyin\nlibrary(maps)\nlibrary(ggplot2)\nlibrary(scales)\nlibrary(plyr)\nlibrary(Cairo)\nlibrary(maptools)\nlibrary(sf)\nlibrary(dplyr)\nlibrary(stringr)\n\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 display English error messages\noptions(stringsAsFactors = FALSE) #禁止chr转成factor prohibit the conversion of chr to factor\n输入数据\nInput data\neasy_input.csv，要画的各省数据。包含两列：省的名字和数值\neasy_input.csv, data of each province to be plotted. It contains two\ncolumns: the name and value of the province\nmydata <- read.csv(\"easy_input.csv\")\nhead(mydata)\n导入地图数据，并编辑\nImport map data and edit\nbou2_4m文件夹，中国省级地图文件，比例尺为400万分之一。来源于国家基础地理信息中心的网站\nhttp://nfgis.nsdi.gov.cn\n，里面的省名是GBK编码的汉字。\n字母p结尾的表示多边形数据，用来绘制区域；字母l结尾的文件是线形数据，用来绘制边界。\nbou2_4m folder, Chinese provincial map files with scale of\n1:4,000,000. Sourced from the website of the National Geomatics Center\nof China\nhttp://nfgis.nsdi.gov.cn\n, the province names in it are\nGBK-encoded Chinese characters.\nFiles ending with the letter p represent polygonal data, which are\nused to draw areas; files ending with the letter l are linear data,\nwhich are used to draw boundaries.\nworld_map <- map_data(\"world\")\n\n#边界线\n#boundary line\nchina_map <- st_read(\"bou2_4m/bou2_4l.shp\")\nxs <- china_map %>% \n  as.data.frame() %>% \n  mutate(id = row.names(.))\nchina_line_data <- china_map %>% \n  st_as_sf() %>% \n  mutate(id = row.names(.)) %>% \n  left_join(xs, by = \"id\")\n\n#省级区域地图\n#map of provincial areas\nchina_map <- st_read(\"bou2_4m/bou2_4p.shp\")\nxs <- china_map %>% \n  st_drop_geometry() %>%  \n  mutate(id = row.names(.))\n\n#把省名从GBK转成UTF-8\n#convert province name from GBK to UTF-8\nxs$NAME <- iconv(xs$NAME, from = \"GBK\", to = \"UTF-8\")\n#把省名从汉字转成拼音\n#convert province name from Chinese characters to pinyin\npinyinProv <- data.frame(NAME = unique(xs$NAME), \n                         province = apply(data.frame(unique(xs$NAME), stringsAsFactors = F),1,\n                                        function(x)(py(x, sep = \"\", dic = pydic(method = \"toneless\", dic = \"pinyin2\")))))\n#删掉sheng、zizhiqu、huizuzizhiqu、weiwuerzizhiqu、zhuangzuzizhiqu、tebiehangzhengqu字样\n#delete the words sheng, zizhiqu, huizuzizhiqu, weiwuerzizhiqu, zhuangzuzizhiqu, tebiehangzhengqu\npinyinProv$province <- str_replace_all(pinyinProv$province, \"sheng\",\"\")\npinyinProv$province <- str_replace_all(pinyinProv$province, \"shi\",\"\")\npinyinProv$province <- str_replace_all(pinyinProv$province, \"huizuzizhiqu\",\"\")\npinyinProv$province <- str_replace_all(pinyinProv$province, \"weiwuerzizhiqu\",\"\")\npinyinProv$province <- str_replace_all(pinyinProv$province, \"zhuangzuzizhiqu\",\"\")\npinyinProv$province <- str_replace_all(pinyinProv$province, \"tebiehangzhengqu\",\"\")\npinyinProv$province <- str_replace_all(pinyinProv$province, \"zizhiqu\",\"\")\n#把陕西跟山西的拼音区分开，陕西的拼音是shannxi\n#differentiate the pinyin of Shaanxi and Shanxi, the pinyin for Shaanxi is shannxi.\npinyinProv[11,]$province <- \"shannxi\" \n\n#把拼音合并进地图文件\n#merge pinyin into a map file\nxss <- left_join(xs, pinyinProv, by = \"NAME\")\n\n#提取经纬度\n#extract latitude and longitude\nchina_map_data <- china_map %>% \n  mutate(id = row.names(.)) %>% \n  left_join(xss, by = \"id\")\n南海方框内地图的计算\nCalculation of the map within the South China Sea box\n#参数设置\n#parameter setting\nWidth<-8\nHeight<-9\n\n#方框的位置\n#position of the box\nlong_Start<-128 \nlat_Start<-18\n\n#南海方框内要画的经纬度范围\n#the latitude and longitude ranges to be drawn in the South China Sea box\nchina_line_data <- st_make_valid(china_line_data)\nchina_map_data <- st_make_valid(china_map_data)\n\nsuppressWarnings({\n  bbox <- st_bbox(c(xmin = 106.55, xmax = 123.58, ymin = 4.61, ymax = 25.45), \n                 crs = st_crs(china_line_data))\n  china_map1 <- st_crop(china_line_data, bbox)\n  china_map2 <- st_crop(china_map_data, bbox)\n})\n\n#缩小后的经纬度\n#reduced latitude and longitude\nscale_geometry <- function(geom) {\n  if (is.na(st_dimension(geom))) return(geom)\n  \n  coords <- st_coordinates(geom)\n  scaled_coords <- coords\n  scaled_coords[, \"X\"] <- (coords[, \"X\"] - bbox_origin[\"xmin\"]) / x_range * Width + long_Start\n  scaled_coords[, \"Y\"] <- (coords[, \"Y\"] - bbox_origin[\"ymin\"]) / y_range * Height + lat_Start\n  \n  geom_type <- st_geometry_type(geom)\n  \n  if (geom_type %in% c(\"LINESTRING\", \"MULTILINESTRING\")) {\n    if (\"L1\" %in% colnames(coords)) {  \n      parts <- split(as.data.frame(scaled_coords), list(coords[, \"L1\"]))\n      lines <- lapply(parts, function(p) as.matrix(p[, c(\"X\", \"Y\")]))\n      if (length(lines) > 1) st_multilinestring(lines) else st_linestring(lines[[1]])\n    } else {\n      st_linestring(scaled_coords[, c(\"X\", \"Y\")])\n    }\n  } else if (geom_type %in% c(\"POLYGON\", \"MULTIPOLYGON\")) {\n    if (\"L1\" %in% colnames(coords)) {  \n      close_ring <- function(m) {\n        if (!all(m[1, ] == m[nrow(m), ])) rbind(m, m[1, , drop = FALSE]) else m\n      }\n      \n      parts <- split(as.data.frame(scaled_coords), list(coords[, \"L2\"], coords[, \"L1\"]))\n      polygons <- lapply(parts, function(p) close_ring(as.matrix(p[, c(\"X\", \"Y\")])))\n      \n      if (length(polygons) > 1) {\n        st_multipolygon(list(polygons))\n      } else {\n        st_polygon(list(polygons[[1]]))\n      }\n    } else {\n      closed <- if (!all(scaled_coords[1, 1:2] == scaled_coords[nrow(scaled_coords), 1:2])) {\n        rbind(scaled_coords[, 1:2], scaled_coords[1, 1:2])\n      } else {\n        scaled_coords[, 1:2]\n      }\n      st_polygon(list(closed))\n    }\n  } else {\n    warning(\"未处理的几何类型: \", geom_type)\n    geom\n  }\n}\n\nbbox_origin <- st_bbox(china_map2)\nx_range <- bbox_origin[\"xmax\"] - bbox_origin[\"xmin\"]\ny_range <- bbox_origin[\"ymax\"] - bbox_origin[\"ymin\"]\n\nchina_map3 <- china_map1\nst_geometry(china_map3) <- st_sfc(lapply(st_geometry(china_map1), scale_geometry), \n                                 crs = st_crs(china_map1))\n\nchina_map4 <- china_map2\nst_geometry(china_map4) <- st_sfc(lapply(st_geometry(china_map2), scale_geometry), \n                                 crs = st_crs(china_map2))\n开始画图\nStart drawing\n#地图跟各省数据value合并\n#merge the map with the value data of each province\nchina_data <- merge(china_map_data, mydata, all = TRUE)\nchina_map4 <- merge(china_map4, mydata, all = TRUE)\n\n#保存到pdf文件\n#save to PDF file\nCairoPDF(file=\"China_map\",width=6.14*2,height=3.22*2)\np <- ggplot() +\n  #先画世界地图作为背景，后面画的就是往它上面叠加\n  #first, draw the world map as the background, and then overlay the subsequent drawings on top of it\n  geom_polygon(data=world_map,\n               aes(x=long,y=lat,group=group),\n               colour=\"grey20\", #边界线深灰色 boundary line dark gray\n               fill=\"#EAEAEA\", #浅灰色填充 light gray filling\n               size=.1)+\n  \n  #边界线黑色\n  #boundary line black\n  geom_sf(data = china_line_data, \n          color = \"black\", linewidth = 0.15) +\n  \n  #自定义填充色\n  #custom fill colors\n  scale_fill_gradient(low = \"white\", high = \"#92150C\", #渐变色 gradient color\n                      na.value = \"#FEFFE8\") + #没有值的省用黄色填充 provisions with no value are filled in yellow\n  \n  #省份区域颜色填充\n  #province area color fill\n  geom_sf(data = china_data, \n          aes(fill = Value),  #或as.factor(Value)设置单个的颜色 or set a single color using as.factor(Value)\n          color = \"grey10\", linewidth = 0.1) +\n  \n  #南海边框\n  #South China Sea border\n  geom_rect(aes(xmin = long_Start, xmax = long_Start + Width, \n                ymin = lat_Start, ymax = lat_Start + Height),\n            fill = NA, color = \"black\", linewidth = 0.15) +\n  \n  #南海方框内的省份颜色填充\n  #color fill of provinces in the South China Sea box\n  geom_sf(data = china_map4, \n          aes(fill = Value), \n          color = \"grey10\", linewidth = 0.05) +\n  \n  #南海方框内的边界线\n  #boundary lines in the South China Sea box\n  geom_sf(data = china_map3, \n          color = \"black\", linewidth = 0.05) +\n  \n  coord_sf() + \n  theme_void() + #不画坐标系 do not draw coordinate system\n  theme(plot.background = element_rect(fill = \"lightskyblue\")) #海水蓝色 seawater blue\np\ndev.off()\n后期处理\nPost-processing\n输出的pdf文件是矢量图，可以在Illustrator等软件里打开，截取想要的区域即可。例如：\nThe output pdf file is a vector map, you can open in Illustrator and\nother software, intercept the desired area. For example:\nsessionInfo()",
    "chapter_info": {},
    "word_count": 932,
    "lines_count": 258,
    "title": "FigureYa50ChinaMap",
    "description": "requirement description 世界地图上的中国标准地图，省份内填充的颜色展示该省数据。 A standard map of China on the world map, with colors filled within",
    "input_data_types": [],
    "output_types": [],
    "technical_methods": [],
    "biology_areas": [],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "to",
      "NAME",
      "dic",
      "colour",
      "id",
      "province",
      "width",
      "xmin",
      "ymin"
    ]
  },
  {
    "id": "main_FigureYa140mosaicpie_FigureYa140mosaicpie",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa140mosaicpie_FigureYa140mosaicpie.txt",
    "content": "FigureYa140mosaicPie\nFigureYa140mosaicPie\nAuthor(s)\n: Zongcheng Li\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n输入TCGA数据，画出这种图。 Input TCGA data and draw this kind of\ngraph.\n出自\nhttps://www.cell.com/cancer-cell/pdfExtended/S1535-6108(18)30110-7\nFrom\nhttps://www.cell.com/cancer-cell/pdfExtended/S1535-6108(18)30110-7\nFigure 2. Epigenetic Landscape of lncRNAs in Cancer(A) Percentages of\nsignificant EA (top panel) or ES (bottom panel) lncRNAs in 20 cancer\ntypes. Each pie chart indicates the percentage of each lncRNA epigenetic\nalteration in each cancer type. Purple indicates EA lncRNAs; green\nindicates ES lncRNAs\nExpression of the top 20 EA (top panel) and ES (bottom panel)\nlncRNAs in cancer cell lines from the CCLE database. Each pie chart\nindicates the percentage ofcell lines with the lncRNA expressed (purple,\nabsolute read count > 0) or not expressed (green, absolute read count\n= 0) in each cancer type\nSee also Figure S2 and Table S2.\n图的解析\nAnalysis of the graph\n粉紫色是表观激活EA的lncRNA，绿色是表观抑制ES的lncRNA。\n纵坐标是表观状态变化频率最高的20个lncRNA，横坐标是癌症组织（A）和Cell\nline（D）。\n饼图展示每个lncRNA在每种癌症/cell\nline里发生表观状态变化的比例。\nPink and purple are lncRNAs that apparently activate EA, and green\nare lncRNAs that apparently inhibit ES.\nThe vertical axis is the 20 lncRNAs with the highest frequency of\nepigenetic changes, and the horizontal axis is cancer tissue (A) and\nCell line (D).\nThe pie chart shows the proportion of epigenetic changes of each\nlncRNA in each cancer/cell line.\n其中A图还分成了High reliability和Intermediate\nreliability，文章提供了EA和ES信息，但没有提供High\nreliability和Intermediate\nreliability的分类信息。这里以文章提供的EA和ES信息作为输入数据，展示画法。\nThe A graph is also divided into High reliability and Intermediate\nreliability. The article provides EA and ES information, but does not\nprovide classification information for High reliability and Intermediate\nreliability. Here, the EA and ES information provided by the article is\nused as input data to show the drawing method.\n另外，还将展示从下载TCGA的DNA甲基化数据（用于定义激活/抑制）到画图。\nIn addition, it will also show the process from downloading TCGA DNA\nmethylation data (used to define activation/inhibition) to drawing.\n应用场景\nApplication scenario\n用饼图展示百分比，再把饼图排成矩阵，就可以对应多组数据。 Use pie\ncharts to show percentages, and then arrange the pie charts into a\nmatrix to correspond to multiple sets of data.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nsource(\"cgdsr.R\") # from cgdsr package\nsetRepositories(ind=1:6)\nlibrary(readxl)\nlibrary(ggplot2)\nlibrary(reshape2)\n\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 #Display English error message\noptions(stringsAsFactors = FALSE) #禁止chr转成factor #Disable conversion of chr to factor\n自定义画图函数 Custom drawing function\n# 自定义颜色\n# Custom colors\npink <- \"#F814A7\"\ngreen <- \"#177835\"\nmosaicplot <- function(ggData){\n  ggplot(ggData) +\n  geom_bar(mapping = aes(x = 1, y = value, fill = type), \n           stat = \"identity\") +\n  scale_fill_manual(values = c(pink, green), guide = guide_legend(title = NULL)) + #如果你有更多分组，就继续添加颜色 # If you have more groups, keep adding colors\n  scale_y_continuous(breaks = seq(0, 1, length.out = 9), limits = c(0,1)) +\n  scale_x_continuous(breaks = c(0,0.5,1)) +\n  facet_grid(gene ~ cancer) +\n  coord_polar(theta = 'y') +\n  labs(x = NULL, y = NULL) +\n  theme(strip.background = element_blank(),\n        strip.text.x = element_text(angle = 90, size = 16, hjust = 0),\n        strip.text.y = element_text(angle = 0, size = 16, hjust = 0.5),\n        panel.grid.minor = element_blank(), \n        panel.grid.major.x = element_line(linewidth = 1),\n        panel.grid.major.y = element_line(linewidth = 1.5),\n        axis.text = element_blank(),\n        axis.ticks = element_blank(),\n        legend.position = \"top\")\n}\n第一部分：用例文提供的数据画图\nPart 1: Draw a graph using the data provided in the example\ntext\n输入文件的准备\nPreparation of input file\n如果你的数据已经整理成easy_input.csv的格式，就可以跳过这步，直接进入“开始画图”。\nIf your data has been organized into the format of easy_input.csv, you\ncan skip this step and go directly to “Start drawing”.\n输入文件1-s2.0-S1535610818301107-mmc3.xlsx，下载自：\nhttps://www.sciencedirect.com/science/article/pii/S1535610818301107#mmc3\nInput file 1-s2.0-S1535610818301107-mmc3.xlsx, downloaded from:\nhttps://www.sciencedirect.com/science/article/pii/S1535610818301107#mmc3\n第2列是Gene Name，第4列以后是每种癌症类型里的比例。第1、3列非必须。\nThe second column is the Gene Name, and the fourth and subsequent\ncolumns are the proportions of each cancer type. The first and third\ncolumns are optional.\n把这两个文件整理成画图需要的格式ggData。 Arrange these two files into\nthe format ggData required for drawing.\n# 表观激活EA的lncRNA\n# lncRNA that apparently activates EA\nalteration_ea <- as.data.frame(readxl::read_excel(path = \"1-s2.0-S1535610818301107-mmc3.xlsx\", sheet = 1, skip = 3))\nhead(alteration_ea)\n# 表观抑制ES的lncRNA\n# lncRNA that apparently inhibits ES\nalteration_es <- as.data.frame(readxl::read_excel(path = \"1-s2.0-S1535610818301107-mmc3.xlsx\", sheet = 2, skip = 3))\nhead(alteration_es)\n#这里分两组EA和ES，如果有更多分组，就继续按这个格式往下继续添加\n#Here are two groups of EA and ES. If there are more groups, continue to add them in this format\n\n# EA\nlnc_ea <- unique(alteration_ea$`Gene Name`)\nea <- alteration_ea[match(lnc_ea, alteration_ea$`Gene Name`),c(4:23)]\nrownames(ea) <- lnc_ea\nlnc_ea_used <- lnc_ea[order(rowSums(ea), decreasing = T)[1:20]]\n\n# ES\nlnc_es <- unique(alteration_es$`Gene Name`)\nes <- alteration_es[match(lnc_es, alteration_es$`Gene Name`),c(4:23)]\nrownames(es) <- lnc_es\nlnc_es_used <- lnc_es[order(rowSums(es), decreasing = T)[1:20]]\n\nlnc_used <- c(lnc_ea_used, lnc_es_used)\n\nggData_ea <- melt(as.matrix(ea[lnc_used,]), varnames = c(\"gene\", \"cancer\"))\nggData_es <- melt(as.matrix(es[lnc_used,]), varnames = c(\"gene\", \"cancer\"))\nggData_ea$type <- \"EA\"\nggData_es$type <- \"ES\"\n\nggData <- na.omit(rbind(ggData_ea, ggData_es)) # 合并EA和ES到ggData\n\n# 保存到文件，你可以直接把自己的数据按照这个格式整理好，就可以直接画图了\n# Save to file, you can directly organize your data according to this format, and then you can draw the graph directly\nwrite.csv(ggData, \"easy_input.csv\", row.names = F)\n开始画图\nStart drawing\neasy_input.csv，第一列基因名对应图中一行，第二列疾病名对应图中1列，第三列value对应pie的比例，第四列type对应图中分组。\neasy_input.csv, the first column of gene name corresponds to a row in\nthe graph, the second column of disease name corresponds to 1 column in\nthe graph, the third column of value corresponds to the proportion of\npie, and the fourth column of type corresponds to the grouping in the\ngraph.\nggData <- read.csv(\"easy_input.csv\")\nhead(ggData)\nggData$gene <- factor(ggData$gene, unique(ggData$gene)) #按输入文件中的基因顺序排序\n# Sort by gene order in input file\nstr(ggData)\nmosaicplot(ggData)\nggsave(\"mosaicPie.pdf\", width = 12, height = 12)\n第二部分：用TCGA数据画图\nPart 2: Drawing with TCGA data\n下载输入数据\nDownload input data\ncancergenes_list.txt，感兴趣的癌症基因列表。下载自：\nhttp://ncg.kcl.ac.uk/cancer_genes.php#known\ncancergenes_list.txt, a list of cancer genes of interest.\nDownload from:\nhttp://ncg.kcl.ac.uk/cancer_genes.php#known\nTCGA数据用CGDS-R下载，CGDS-R的用法可参考这篇：\nhttps://mp.weixin.qq.com/s/pqck8jMk-WIZ6EgkBIWQHA\n，以methylation和mRNA\nexpression为例\nTCGA data are downloaded using CGDS-R. For the usage of CGDS-R,\nplease refer to this article:\nhttps://mp.weixin.qq.com/s/pqck8jMk-WIZ6EgkBIWQHA\n,\ntaking methylation and mRNA expression as examples\n# genes of interest\ngenes <- setdiff(read.table(file = \"cancergenes_list.txt\", header = T, sep = \"\\t\")[,1], \"\")\n\n# Create CGDS object\nmycgds = CGDS(\"https://www.cbioportal.org/\")\ntest(mycgds)\n\n# Get list of cancer studies at server\nlcs <- getCancerStudies(mycgds)\n# Get available case lists (collection of samples) for a given cancer study\ncancers <- strsplit(\"BLCA PAAD SKCM PRAD LIHC BRCA LUSC LGG LUAD KICH UCEC KIRC GBM CESC STAD THCA HNSC KIRP\", split = \" \")[[1]]\n\nhypoMat <- list()\nhyperMat <- list()\nexprMat <- list()\n\nfor(mycancer in tolower(cancers)){ #超级慢，可以换成cancers[1:2]先跑前两种癌症 #Super slow, you can change to cancers[1:2] to run the first two cancers first\n  mycancerstudy = paste0(mycancer, '_tcga')\n  #cl = getCaseLists(mycgds,mycancerstudy)\n  # case_list_id: gbm_tcga_cnaseq. Samples with mutation and CNA data (273 samples)\n  mycaselist1 <- paste0(mycancer, \"_tcga_methylation_hm450\")\n  # Get available genetic profiles\n  #gp = getGeneticProfiles(mycgds, mycancerstudy)\n  \n  # DNA methylation data\n  mygeneticprofile1 <- paste0(mycancer, \"_tcga_methylation_hm450\")\n  # Get data slices for a specified list of genes, genetic profile and case list\n  hm450 <- getProfileData(mycgds, genes, mygeneticprofile1, mycaselist1)\n  hm450_hypo <- hm450 < 0.2 #定义hypo #define hypo \n  hm450_hyper <- hm450 > 0.7 #定义pyper #define pyper \n  hypoMat[[mycancer]] <- colSums(hm450_hypo)/nrow(hm450)\n  hyperMat[[mycancer]] <- colSums(hm450_hyper)/nrow(hm450)\n  \n  # mRNA expression data\n  mycaselist2 <- paste0(mycancer, \"_tcga_rna_seq_v2_mrna\")\n  mygeneticprofile2 <- paste0(mycancer, \"_tcga_rna_seq_v2_mrna\")\n  expr <- getProfileData(mycgds, genes, mygeneticprofile2, mycaselist2)\n  expr_binary <- expr > 1\n  exprMat[[mycancer]] <- colSums(expr_binary)/nrow(expr)\n}\n\nhypoMat <- as.data.frame(hypoMat)\nhyperMat <- as.data.frame(hyperMat)\nexprMat <- as.data.frame(exprMat)\nhead(hypoMat)\n# return a combined methylation matrix\n整理成画图所需的格式\nOrganize into the format required for drawing\ngetData_methylation <- function(hypoMat, hyperMat, exprMat, top_n = 20){\n  gene_ea_used <- rownames(hypoMat)[order(rowSums(hypoMat, na.rm = T), decreasing = T)[1:top_n]]\n  gene_es_used <- rownames(hyperMat)[order(rowSums(hyperMat, na.rm = T), decreasing = T)[1:top_n]]\n  genes_used <- unique(c(gene_ea_used, gene_es_used))\n\n  ggData_ea <- melt(as.matrix(hypoMat[genes_used,]), varnames = c(\"gene\", \"cancer\"))\n  ggData_es <- melt(as.matrix(hyperMat[genes_used,]), varnames = c(\"gene\", \"cancer\"))\n  ggData_ea$type <- \"EA\"\n  ggData_es$type <- \"ES\"\n  \n  ggData_methylation <- na.omit(rbind(ggData_ea, ggData_es))\n  ggData_expr <- melt(as.matrix(exprMat[genes_used,]), varnames = c(\"gene\", \"cancer\"))\n  ggData_expr$type <- ifelse(ggData_expr$gene %in% gene_ea_used, \"EA\", \"ES\")\n  \n  ggData_methylation$cancer <- toupper(ggData_methylation$cancer)\n  ggData_expr$cancer <- toupper(ggData_expr$cancer)\n  return(list(MH450 = ggData_methylation, Expr= ggData_expr))\n}\n\nggData <- getData_methylation(hypoMat, hyperMat, exprMat, top_n = 20)\n开始画图\nStart drawing\n# DNA甲基化\n# DNA methylation\nmosaicplot(ggData$MH450)\n\n# mRNA expression\n# mRNA expression\nmosaicplot(ggData$Expr)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa140mosaicpie_FigureYa140mosaicpie",
      "title": "FigureYa140mosaicpie/FigureYa140mosaicpie.html",
      "html": "FigureYa140mosaicpie/FigureYa140mosaicpie.html",
      "text": "texts/main_FigureYa140mosaicpie_FigureYa140mosaicpie.txt",
      "folder": "FigureYa140mosaicpie",
      "thumb": "gallery_compress/FigureYa140mosaicpie.webp"
    },
    "word_count": 1237,
    "lines_count": 266,
    "title": "FigureYa140mosaicPie",
    "description": "Requirement description 输入TCGA数据，画出这种图。 Input TCGA data and draw this kind of graph.",
    "input_data_types": [
      "突变数据"
    ],
    "output_types": [
      "统计表格"
    ],
    "technical_methods": [],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "ticks",
      "values",
      "header",
      "count",
      "guide",
      "width",
      "mycgds",
      "limits",
      "minor"
    ]
  },
  {
    "id": "main_docs_index",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_docs_index.txt",
    "content": "Contents Directory\nContents Directory (main & master)\nSearch\nClear\nmain/FigureYa1survivalCurve_update\nFigureYa1survivalCurve_update.html\nmain/FigureYa2ggtree+pheatmap+msa\nFigureYa2ggtree+pheatmap+msa.html\nggtree_pheatmap_msa_cowplot.html\nmain/FigureYa3genomeView\nFigureYa3genomeView.html\nmain/FigureYa4bestSeparation\nFigureYa4bestSeparation.html\nmain/FigureYa5bubbles\nFigureYa5bubbles.html\nmain/FigureYa6rHRs\nFigureYa6rHRs.html\nmain/FigureYa7PSM\nFigureYa7PSM.html\nmain/FigureYa8radar\nFigureYa8radarChart.html\nmain/FigureYa9heatmap\nFigureYa9heatmap.html\nmain/FigureYa10chromosomeV2_update\nFigureYa10chromosomeV2_update.html\nmain/FigureYa11bubble\nFigureYa11bubbles.html\nmain/FigureYa12box\nFigureYa12box.html\nmain/FigureYa13GSEA_Java_update\nFigureYa13GSEA_Java_update.html\nmain/FigureYa14circos\nFigureYa14circos.html\nmain/FigureYa15WGCNA\nFigureYa15WGCNA.html\nmain/FigureYa16fitting\nFigureYa16WGCNA_fitting.html\nmain/FigureYa17WGCNA_heatmap\nFigureYa17WGCNA_heatmap.html\nmain/FigureYa18oncoplot_update\nFigureYa18oncoplot_update.html\nmain/FigureYa19Lollipop\nFigureYa19Lollipop.html\nmain/FigureYa20mortality\nFigureYa20mortalityV2.html\nmain/FigureYa21TCGA2table\nFigureYa21TCGA2table.html\nmain/FigureYa22FPKM2TPM\nFigureYa22FPKM2TPM.html\nmain/FigureYa23count2TPM\nFigureYa23count2TPMv2.html\nmain/FigureYa24ROC\nFigureYa24ROC.html\nmain/FigureYa25Sankey_update\nFigureYa25Sankey_update.html\nmain/FigureYa26circos_R\nFigureYa26circos_R.html\nmain/FigureYa27tSNE_update\nFIgureYa27tSNE_update.html\nmain/FigureYa28color\nFigureYa28color.html\nmain/FigureYa29map\nFigureYa29map.html\nmain/FigureYa30nomogram_update\nFigureYa30nomogram_update.html\nmain/FigureYa31lasso_update\nFigureYa31lasso_update.html\nmain/FigureYa32ID_table\nFigureYa32ID_table.html\nmain/FigureYa33DCA_update\nFigureYa33DCA_update.html\nmain/FigureYa34count2FPKMv2\nFigureYa34count2FPKMv2.html\nmain/FigureYa35batch_bestSeparationV3_update\nFigureYa35batch_bestSeparationV3_update.html\nmain/FigureYa36nSurvV3\nFigureYa36nSurvV3.html\nmain/FigureYa37correlationV2_update\nFigureYa37correlationV2_update.html\nmain/FigureYa38PCA\nFigureYa38PCA.html\nmain/FigureYa39bar\nFigureYa39bar.html\nmain/FigureYa41GEO2lncRNA_update\nFigureYa41GEO2lncRNA_update.html\nmain/FigureYa42oncoprintV2_update\nFigureYa42oncoprintV2_update.html\nmain/FigureYa43ManhattanV2\nFigureYa43ManhattanV2.html\nmain/FigureYa44profile\nFigureYa44profile.html\nmain/FigureYa45V1\nFigureYa45iClusterV2.html\nmain/FigureYa45V2\nFigureYa45iClusterV2.html\nmain/FigureYa47HRtable\nFigureYa47HRtable.html\nmain/FigureYa48Adonis\nFigureYa48Adonis.html\nmain/FigureYa49AS_3rd\nFigureYa49AS_3rd.html\nmain/FigureYa50ChinaMap\nFigureYa50ChinaMap.html\nmain/FigureYa51TMB_update\nFigureYa51TMB_update.html\nmain/FigureYa52GOplot\nFigureYa52GOplot.html\nmain/FigureYa53PPImodule\nFigureYa53PPImodule-0527更新.html\nmain/FigureYa55panCancer_violinV2\nFigureYa55panCancer_violinV2.html\nmain/FigureYa55plus_pancancer_boxplot\nFigureYa55plus_pancancer_boxplot.html\nmain/FigureYa56immune_inflitrationV3\nFigureYa56immune_inflitrationV3.html\nmain/FigureYa57profile_1bw\nFigureYa57profile_1bw.html\nmain/FigureYa58lncRNAreannotation\nFigureYa58lncRNAreannotation.html\nmain/FigureYa59volcanoV2\nFigureYa59volcanoV2.html\nmain/FigureYa59Plus_GEO2DEG\nFigureYa59Plus_GEO2DEG.html\nmain/FigureYa60GSEA_clusterProfilerV2\nFigureYa60GSEA_clusterProfilerV2.html\nmain/FigureYa60GSEA_clusterProfilerV3\nFigureYa60GSEA_clusterProfilerV2.html\nmain/FigureYa61GSVA\nFigureYa61GSVA.html\nmain/FigureYa62twoAxis\nFigureYa62twoAxis.html\nmain/FigureYa63pubmedMiningV2\nFigureYa63pubmedMiningV2.html\noutput_friends.html\noutput_paper.html\nmain/FigureYa64triangle\nFigureYa64triangle.html\nmain/FigureYa65SVM\nFigureYa65SVM.html\nmain/FigureYa66单因素cox\nFigureYa66单因素cox.html\nmain/FigureYa67phastCons\nFigureYa67phastCons.html\nmain/FigureYa68friendsV2\nFigureYa68friendsV2.html\nmain/FigureYa69cancerSubtype\nFigureYa69cancerSubtype.html\nmain/FigureYa70mutationEvents\nFigureYa70mutationEvents.html\nmain/FigureYa71ssGSEA_update\nFigureYa71ssGSEA_update.html\nmain/FigureYa72biomarker\nFigureYa72biomarker.html\nmain/FigureYa73batchCorrelation\nFigureYa73batchCorrelation.html\nmain/FigureYa74OmicCircos\nFigureYa74OmicCircos.html\nmain/FigureYa75bubble_volcano\nFigureYa75bubble_volcano.html\nmain/FigureYa76corrgram\nFigureYa76corrgram.html\nmain/FigureYa77baseZoom\nFigureYa77baseZoom.html\nmain/FigureYa78gganatogram\nFigureYa78gganatogram.html\nmain/FigureYa79CNV\nFigureYa79CNV.html\nmain/FigureYa80GOclustering\nFigureYa80GOclustering.html\nmain/FigureYa81immune_network\nFigureYa81immune_network.html\nmain/FigureYa82IGVzoom\nFigureYa82IGVzoom.html\nmain/FigureYa83enrichment\nFigureYa83enrichment.html\nmain/FigureYa84roast\nFigureYa84roast.html\nmain/FigureYa85timeROC\nFigureYa85timeROC.html\nmain/FigureYa86SNPmotif\nFigureYa86SNPmotif.html\nmain/FigureYa87fish\nFigureYa87fish.html\nmain/FigureYa88DAVIDkappa\nFigureYa88DAVIDkappa.html\nmain/FigureYa89ggplotCirco\nFigureYa89ggplotCirco.html\nmain/FigureYa91cluster_heatmap\nFigureYa91cluster_heatmap.html\nmain/FigureYa92immune_gene_update\nFigureYa92immune_gene_update.html\nmain/FigureYa94STEMbox_update\nFigureYa94STEMbox_update.html\nmain/FigureYa95pairwise\nFigureYa95pairwise.html\nmain/FigureYa96R2\nFigureYa96R2.html\nmain/FigureYa97correlationV3\nFigureYa97correlationV3.html\nmain/FigureYa98STEMheatmapV2\nFigureYa98STEMheatmapV2.html\nmain/FigureYa99smoothHRv2\nFigureYa99smoothHRv2.html\nmain/FigureYa101PCA\nFigureYa101PCA.html\nmain/FigureYa102multipanelROC\nFigureYa102multipanelROC.html\nmain/FigureYa103coAbundant\nFigureYa103coAbundant.html\nmain/FigureYa104GEOmining\nFigureYa104GEOmining.html\nGEO_citations.html\nmain/FigureYa105GDSC\nFigureYa105GDSC.html\nmain/FigureYa106immunotherapy\nFigureYa106immunotherapy.html\nmain/FigureYa107ChIPheatmap\nFigureYa107ChIPheatmap.html\nmain/FigureYa108RNAseqChIP\nFigureYa108RNAseqChIP.html\nmain/FigureYa109SubtypeGSEA_update\nFigureYa109SubtypeGSEA_update.html\nmain/FigureYa110mutationSignature\nFigureYa110mutationSignature.html\nmain/FigureYa111markerGene\nFigureYa111markerGene_step2_linuxMAC.html\nFigureYa111markerGene_step1.html\nFigureYa111markerGene_step2_win10.html\nmain/FigureYa112venn\nFigureYa112venn.html\nmain/FigureYa112Plus_venn\nFigureYa112venn.html\nmain/FigureYa113MutSigCV\nFigureYa113MutSigCV.html\nmain/FigureYa114ternaryCluster\nFigureYa114ternaryCluster.html\nmain/FigureYa115cofactor\nFigureYa115cofactor.html\nmain/FigureYa116supervisedCluster\nFigureYa116supervisedCluster.html\nmain/FigureYa117multilinearDE\nFigureYa117multilinearDE.html\nmain/FigureYa118MulticlassDESeq2\nFigureYa118MulticlassDESeq2.html\nmain/FigureYa119Multiclasslimma\nFigureYa119Multiclasslimma.html\nmain/FigureYa120MulticlassedgeR\nFigureYa120MulticlassedgeR.html\nmain/FigureYa121MethCGIcluster\nFigureYa121MethCGIcluster.html\nmain/FigureYa122mut2expr_20230822_223122\nFigureYa122mut2expr.html\nmain/FigureYa123mutVSexpr\nFigureYa123mutVSexpr.html\nmain/FigureYa124AssociationHeatmap\nFigureYa125FishertestV2.html\nmain/FigureYa125FishertestV2\nFigureYa125FishertestV2.html\nmain/FigureYa126CorrelationHeatmap\nFigureYa126CorrelationHeatmap.html\nmain/FigureYa127HeatmapPie\nFigureYa127HeatmapPie.html\nmain/FigureYa128Prognostic\nFigureYa128Prognostic.html\nmain/FigureYa129TCGAbox\nFigureYa129TCGAbox.html\nmain/FigureYa130coxSVM\nFigureYa130coxSVM_step12.html\nFigureYa130coxSVM_step34.html\nmain/FigureYa131CMap_update\nFigureYa131CMap_update.html\nmain/FigureYa132alteration\nFigureYa132alteration.html\nmain/FigureYa133m6Apeak_update\nFigureYa133m6Apeak_update.html\nmain/FigureYa135multiVolcano\nFigureYa135multiVolcano.html\nmain/FigureYa136fgsea\nFigureYa136fgsea.html\nmain/FigureYa138NiceCalibration\nFigureYa138NiceCalibration.html\nmain/FigureYa139TMB_titv\nFigureYa139TMB_titv.html\nmain/FigureYa140mosaicpie\nFigureYa140mosaicpie.html\nmain/FigureYa141risk\nFigureYa141risk.html\nmain/FigureYa142circosBar\nFigureYa142circosBar.html\nmain/FigureYa143survCor\nFigureYa143survCor.html\nmain/FigureYa144DiagHeatmap\nFigureYa144DiagHeatmap.html\nmain/FigureYa145target\nFigureYa145target.html\nmain/FigureYa146TMEbox\nFigureYa146TMEbox.html\nmain/FigureYa147interaction\nFigureYa147interaction.html\nmain/FigureYa148SimpleDendrogram\nFigureYa148SimpleDendrogram.html\nmain/FigureYa149rankHeatmap\nFigureYa149rankHeatmap.html\nmain/FigureYa150diversityScore\nFigureYa150diversityScore.html\nmain/FigureYa151pathifier\nFigureYa151pathifier.html\nmain/FigureYa152DouleCorPlot\nFigureYa152DouleCorPlot.html\nmain/FigureYa153ccgraph\nFigureYa153ccgraph.html\nmain/FigureYa154immuneSubtypes\nFigureYa154immuneSubtypes.html\nmain/FigureYa155ATAC\nFigureYa155ATAC.html\nmain/FigureYa156enrichSimulation\nFigureYa156enrichSimulation.html\nmain/FigureYa157ChIPpvalue\nFigureYa157ChIPpvalue.html\nmain/FigureYa158MutationPattern\nFigureYa158MutationPattern.html\nmain/FigureYa159LR_RF_V2\nFigureYa159LR_RF_V2.html\nmain/FigureYa160scGSVA\nFigureYa160scGSVA.html\nmain/FigureYa161stemness\nFigureYa161stemness.html\nmain/FigureYa162boxViolin\nFigureYa162boxViolin.html\nmain/FigureYa163twoVarCor_update\nFigureYa163twoVarCor_update.html\nmain/FigureYa164PCA3D\nFigureYa164PCA3D.html\nmain/FigureYa165heatmapPvalue\nFigureYa165heatmapPvalue.html\nmain/FigureYa166scCNV\nFigureYa166scCNV.html\nmain/FigureYa167TumorIndex\nFigureYa167TumorIndex.html\nmain/FigureYa168legoplot\nFigureYa168legoplot.html\nmain/FigureYa169sigHeatmap\nFigureYa169sigHeatmap.html\nmain/FigureYa170ImmuLncRNA\nFigureYa170ImmuLncRNA.html\nmain/FigureYa171subgroupSurv\nFigureYa171subgroupSurv.html\nmain/FigureYa172ggplot2Gviz\nFigureYa172ggplot2Gviz.html\nmain/FigureYa173fancybar\nFigureYa173fancybar.html\nmain/FigureYa174squareCross\nFigureYa174squareCross.html\nmain/FigureYa175quadrant\nFigureYa175quadrant.html\nmain/FigureYa176BlandAltman\nFigureYa176BlandAltman.html\nmain/FigureYa177RNAvelocity\nFigureYa177RNAvelocity.html\nmain/FigureYa178receptorLigand\nFigureYa178receptorLigand.html\nmain/FigureYa179AMDAplot\nFigureYa179AMDAplot.html\nmain/FigureYa180FGAplotV2\nFigureYa180FGAplotV2.html\nmain/FigureYa181multiCorrelation\nFigureYa181multiCorrelation.html\nmain/FigureYa182RFSurvV2\nFigureYa182RFSurvV2.html\nmain/FigureYa183condSurv\nFigureYa183condSurv.html\nmain/FigureYa184ranger\nFigureYa184ranger.html\nmain/FigureYa185sciATAC\nFigureYa185sciATAC.html\nmain/FigureYa186swimmerplot\nFigureYa186swimmerplot.html\nmain/FigureYa187RMS\nFigureYa187RMS.html\nmain/FigureYa188CNVload\nFigureYa188CNVload.html\nmain/FigureYa189timeCindex\nFigureYa189timeCindex.html\nmain/FigureYa190batchLogistic\nFigureYa190batchLogistic.html\nmain/FigureYa191bestLogistic\nFigureYa191bestLogistic.html\nmain/FigureYa192breakpoint\nFigureYa192breakpoint.html\nmain/FigureYa193RiskTable\nFigureYa193RiskTable.html\nmain/FigureYa194pySCENIC\nFigureYa194pySCENIC.html\nmain/FigureYa195PanPaire\nFigureYa195PanPaire.html\nmain/FigureYa196PanPie\nFigureYa196PanPie.html\nmain/FigureYa197SmoothHaz\nFigureYa197SmoothHaz.html\nmain/FigureYa198SignatureCombinationV2\nFigureYa198SignatureCombinationV2.html\nmain/FigureYa199crosslink\nFigureYa199crosslink.html\nmain/FigureYa200pairwiseAUC\nFigureYa200pairwiseAUC.html\nmain/FigureYa201ClusterCorrelation\nFigureYa201ClusterCorrelation.html\nmain/FigureYa202consensusGene\nFigureYa202consensusGene.html\nmain/FigureYa203ComBat\nFigureYa203ComBat.html\nmain/FigureYa204PCAscore\nFigureYa204PCAscore.html\nmain/FigureYa205immunophenoscore_update\nFigureYa205immunophenoscore_update.html\nmain/FigureYa206scHeatmap\nFigureYa206scHeatmap.html\nmain/FigureYa207Randomization\nFigureYa207Randomization.html\nmain/FigureYa208FPI\nFigureYa208FPI.html\nmain/FigureYa209batchEnrich\nFigureYa209batchEnrich.html\nmain/FigureYa210survivalScape\nFigureYa210survivalScape.html\nmain/FigureYa211multiCohortImmSubtype\nFigureYa211multiCohortImmSubtype.html\nmain/FigureYa212drugTargetV2\nFigureYa212drugTargetV2.html\nmain/FigureYa213customizeHeatmap\nFigureYa213customizeHeatmap.html\nmain/FigureYa214KEGG_hierarchyV2\nFigureYa214KEGG_hierarchyV2.html\nmain/FigureYa215DNAage\nFigureYa215DNAage.html\nmain/FigureYa216MetaREM\nFigureYa216MetaREM.html\nmain/FigureYa217RMR\nFigureYa217RMR.html\nmain/FigureYa218Elasticnet\nFigureYa218Elasticnet.html\nmain/FigureYa219GMM\nFigureYa219GMM.html\nmain/FigureYa220repeatedLasso\nFigureYa220repeatedLasso.html\nmain/docs\nindex.html\nmaster/FigureYa221tenFoldRF\nFigureYa221tenFoldRF.html\nmaster/FigureYa222PCAgene\nFigureYa222PCAgene.html\nmaster/FigureYa223scNMF\nFigureYa223scNMF.html\nmaster/FigureYa224scMarker\nFigureYa224scMarker.html\nmaster/FigureYa225GiViTl\nFigureYa225GiViTl.html\nmaster/FigureYa227boxdensity\nFigureYa227boxdensity.html\nmaster/FigureYa228linkCor\nFigureYa228linkCor.html\nmaster/FigureYa229PCOA\nFigureYa229PCOA.html\nmaster/FigureYa230immunelandscape\nFigureYa230immunelandscape.html\nmaster/FigureYa231scScore\nFigureYa231scScore.html\nmaster/FigureYa232scRankHeatmap\nFigureYa232scRankHeatmap.html\nmaster/FigureYa233genepair\nFigureYa233genepair.html\nmaster/FigureYa234panImmune\nFigureYa234panImmune.html\nmaster/FigureYa235scDEG\nFigureYa235scDEG.html\nmaster/FigureYa236circGroup\nFigureYa236circGroup.html\nmaster/FigureYa237circVenn\nFigureYa237circVenn.html\nmaster/FigureYa238corRiskMut\nFigureYa238corRiskMut.html\nmaster/FigureYa239ST_PDAC\nFigureYa239ST_PDAC.html\nmaster/FigureYa240CRISPR\nFigureYa240CRISPR.html\nmaster/FigureYa241scRNA_NMI\nFigureYa241scRNA_NMI.html\nmaster/FigureYa242corMethExpr\nFigureYa242corMethExpr.html\nmaster/FigureYa243scMarkerGroupHeatmap\nFigureYa243scMarkerGroupHeatmap.html\nmaster/FigureYa244PCAPlot\nFigureYa244PCAPlot.html\nmaster/FigureYa245VarDecompose\nFigureYa245VarDecompose.html\nmaster/FigureYa246supervisedGDSC\nFigureYa246supervisedGDSC.html\nmaster/FigureYa247oncoPredict\nFigureYa247oncoPredict.html\nmaster/FigureYa248MutLandscape\nFigureYa248MutLandscape.html\nmaster/FigureYa249Regulon\nFigureYa249Regulon.html\nmaster/FigureYa250ImmGenePair\nFigureYa250ImmGenePair.html\nmaster/FigureYa251NPHSurv\nFigureYa251NPHSurv.html\nmaster/FigureYa252mclust\nFigureYa252mclust.html\nmaster/FigureYa253panGSEA\nFigureYa253panGSEA.html\nmaster/FigureYa254scViolin\nFigureYa254scViolin.html\nmaster/FigureYa255TIME\nFigureYa255TIME.html\nmaster/FigureYa256panelLink\nFigureYa256panelLink.html\nmaster/FigureYa257armCNV\nFigureYa257armCNV.html\nmaster/FigureYa258SNF\nFigureYa258SNF.html\nmaster/FigureYa259circLink\nFigureYa259circLink.html\nmaster/FigureYa260CNV\nFigureYa260CNV.html\nmaster/FigureYa261circGene\nFigureYa261circGene.html\nmaster/FigureYa262GDC\nFigureYa262GDC.html\nmaster/FigureYa263panDiff\nFigureYa263panDiff.html\nmaster/FigureYa264epiImmune\nFigureYa264epiImmune.html\nmaster/FigureYa265panCNV\nFigureYa265panCNV.html\nmaster/FigureYa266panHeatmap\nFigureYa266panHeatmap.html\nmaster/FigureYa267scCellChat\nFigureYa267scCellChat.html\nmaster/FigureYa268panCNVexpr\nFigureYa268panCNVexpr.html\nmaster/FigureYa269scMetabolism\nFigureYa269scMetabolism.html\nmaster/FigureYa270panMeth\nFigureYa270panMeth.html\nmaster/FigureYa271panMethExpr\nFigureYa271panMethExpr.html\nmaster/FigureYa272scBulkCCCI\nFigureYa272scBulkCCCI.html\nnetwork.html\nmaster/FigureYa273BAPC\nFigureYa273BAPC.html\nmaster/FigureYa274MuSiCbulkProop\nFigureYa274MuSiCbulkProop.html\nmaster/FigureYa275scAUCell\nFigureYa275scAUCell.html\nmaster/FigureYa276panSNV\nFigureYa276panSNV.html\nmaster/FigureYa277Immunomodulator\nFigureYa277Immunomodulator.html\nmaster/FigureYa278heatmapPoints\nFigureYa278heatmapPoints.html\nmaster/FigureYa279panGeneGSEA\nFigureYa279panGeneGSEA.html\nmaster/FigureYa280TMEofSTS\nFigureYa280TMEofSTS.html\nmaster/FigureYa281wheel\nFigureYa281wheel.html\nmaster/FigureYa282CMAP_XSum\nFigureYa282CMAP_XSum.html\nmaster/FigureYa283vennyPvalue\nFigureYa283vennyPvalue.html\nmaster/FigureYa284pairwiseLogrank\nFigureYa284pairwiseLogrank.html\nmaster/FigureYa285scRNA_monocle\nFigureYa285scRNA_monocle.html\nmaster/FigureYa286ExprCorORR\nFigureYa286ExprCorORR.html\nmaster/FigureYa287L2logV2\nFigureYa287L2log.html\nmaster/FigureYa288MutualExclusivity\nFigureYa288MutualExclusivity.html\nmaster/FigureYa289TILSig\nFigureYa289TILSig.html\nmaster/FigureYa290BarGraph\nFigureYa290BarGraph.html\nmaster/FigureYa291PancanProgSigatureV2\nFigureYa291PancanProgSigatureV2.html\nmaster/FigureYa292HCCsubtype\nFigureYa292HCCsubtype.html\nmaster/FigureYa293machineLearning\nFigureYa293machineLearning.html\nmaster/FigureYa294HCCdrug\nFigureYa294HCCdrug.html\nmaster/FigureYa295ClassDiscovery\nFigureYa295ClassDiscovery.html\nmaster/FigureYa296VIPER\nFigureYa296VIPER.html\nmaster/FigureYa297Rbar\nFigureYa297Rbar.html\nmaster/FigureYa298ecdfPvalue\nFigureYa298ecdfPvalue.html\nmaster/FigureYa299pancanSurv\nFigureYa299pancanSurv.html\nmaster/FigureYa300pancanCor\nFigureYa300pancanCor.html\nmaster/FigureYa301scCoExpr\nFigureYa301scCoExpr.html\nmaster/FigureYa302NTPPAM\nFigureYa302NTPPAM.html\nmaster/FigureYa303panCircos\nFigureYa303panCircos.html\nmaster/FigureYa305PMAPscore\nFigureYa305PMAPscore.html\nmaster/FigureYa306slingshot\nFigureYa306slingshot.html\nmaster/FigureYa307CNVHeatmap\nFigureYa307CNVHeatmap.html\nmaster/FigureYa308IHS\nFigureYa308IHS.html\nmaster/FigureYa309cell2location\n01_explore_space_transcriptome.html\n02_cell2location_signature.html\n03_cell2location_mapping.html\n04_cell2location_plot.html\nFigureYa309cell2location.html\nmaster/FigureYa310CPDBChordGramV2\nFigureYa310CPDBChordGramV2.html\nmaster/FigureYa311PAM50Heatmap\nFigureYa311PAM50Heatmap.html\nmaster/FigureYa312CellPreference\nFigureYa312CellPreference.html\nmaster/FigureYa313CircularPlot\nFigureYa313CircularPlot.html\nmaster/FigureYa314SingleRScore\nFigureYa314SingleRScore.html\nmaster/FigureYa315SingleRFraction\nFigureYa315SingleRFraction.html\nmaster/FigureYa316RF_XGBoost_Boruta\nFigureYa316RF_XGBoost_Boruta.html\nmaster/FigureYa317RoeDot\nFigureYa317RoeDot.html\nmaster/FigureYa318GenesetDEDotplot\nFigureYa318GenesetDEDotplot.html\nmaster/FigureYa319ContribScore\nFigureYa319ContribScore.html\nmaster/FigureYa320ClontypeHeatmap\nFigureYa320ClontypeHeatmap.html\nmaster/FigureYa321volcanoSE\nFigureYa321volcanoSE.html\nmaster/FigureYa322SSEA\nFigureYa322SSEA.html\nmaster/FigureYa323STpathseq\nFigureYa323STpathseq.html",
    "chapter_info": {},
    "word_count": 659,
    "lines_count": 654,
    "title": "Contents Directory",
    "description": "暂无描述",
    "input_data_types": [
      "突变数据",
      "生存数据"
    ],
    "output_types": [
      "火山图",
      "热图",
      "箱线图",
      "统计表格",
      "散点图",
      "网络图",
      "生存曲线"
    ],
    "technical_methods": [
      "motif分析",
      "聚类分析",
      "网络分析",
      "生存分析",
      "差异表达分析"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学",
      "药物研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "pvalue"
    ]
  },
  {
    "id": "main_FigureYa2ggtree+pheatmap+msa_ggtree_pheatmap_msa_cowplot",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa2ggtree+pheatmap+msa_ggtree_pheatmap_msa_cowplot.txt",
    "content": "ggtree+pheatmap+msa+cowplot\nggtree+pheatmap+msa+cowplot\nGuangchuang Yu\n4/26/2018\n小丫在《\n我要用1h完成所有发表级Figure的排版 | 悬赏100元，招募latex高手\n》一文里谈到要画以下的图：\n拼图本身并不困难，在文中也讲到了，用\ncowplot\n包就可以，但问题就在于其中要用到的\nmsa\n包，出的是\n\\(\\LaTeX\\)\n代码，找\n\\(\\LaTeX\\)\n高手也是没用的，因为你不可能把\n\\(\\LaTeX\\)\n代码转成R图。要在R里面搞，唯一可以实现的是把\n\\(\\LaTeX\\)\n编译成PDF（msa包本身就支持直接出PDF），然后当成图片来继续搞，这个在小丫的文章中也有提及，所以这似乎没什么问题。\n问题就在于那段\n\\(\\LaTeX\\)\n代码出来的PDF，就像下面这样：\nlibrary(cowplot)\nggdraw() + draw_image(\"myFirstAlignment.pdf\")\n问题1：有太多的空白！\n你总不能就这样直接拿来拼了，当然你可以设置\npaperWidth\n和\npaperHeight\n来调整，但这不是一次两次就能调到刚刚好的，或者你直接默认，出来有很多空白，然后你自己再去把你要的部分给切分出来。\n这个问题等同于说，无法自动化，\n你必须要人工去干预！\n问题2：读图出来的分辨率太低！\ndraw_image\n这个函数不支持指定分辨率！\n简直惨不忍睹！\n根本就没法借到出版的需求！\n解决方案\n所以我主要就是来解决这两个重要的问题。于是我在\nggimage\n中加入了一个\nimage_read2\n的函数，这个函数读PDF这种矢量图默认以300dpi读入，而且能够把上下左右空白的区域自动切除。\n那么这一问题就完美解决了。\n这里又产生一个新的问题，读图出来，要怎么才能被\ncowplot\n认，于是我在\nggplotify\n包中又扩展它支持。\n你可以用\nas.ggplot\n去转换成\nggplot\n对象，然后直接可以应用于\ncowplot\n中。\n这里涉及到\nmsa\n出文件，\nggimage\n读文件，\nggplotify\n转对象，三步，我们还能更进一步，变成一条指令直接出\nggplot\n图，而且中间不产生文件（其实产生了，但以系统临时文件的形式出现），那么我在\nyyplot\n中写了一个函数，\nmsaPrettyPlot\n，它的用法完全就是\nmsaPrettyPrint\n一模一样，但不出\n\\(LaTeX\\)\n或PDF了，直接出\nggplot\n。\n实例演示\n有了我在\nggimage\n,\nggplotify\n中实现的几个函数，用户直接用\nyyplot\n就可以直接出msa的图，然后这一切就可以完全自动化生成最终的图：\nrequire(msa)\nrequire(seqinr)\nrequire(yyplot)\nrequire(pheatmap)\nrequire(cowplot)\n\n## fasta序列\nmySequenceFile <- system.file(\"examples\", \"exampleAA.fasta\", package=\"msa\")\nmySequences <- readAAStringSet(mySequenceFile)\n\n## 比对\nmyFirstAlignment <- msa(mySequences)\n为了解决\nmsa\n包的问题，更新了3个软件包（\nggimage\n,\nggplotify\n,\nyyplot\n），最终以非常简单易用的形式呈现给大家，虽然实例看似简单，但背后3个包的更新，难度和工作量还是挺大的。",
    "chapter_info": {
      "id": "main_FigureYa2ggtree+pheatmap+msa_ggtree_pheatmap_msa_cowplot",
      "title": "FigureYa2ggtree+pheatmap+msa/ggtree_pheatmap_msa_cowplot.html",
      "html": "FigureYa2ggtree+pheatmap+msa/ggtree_pheatmap_msa_cowplot.html",
      "text": "texts/main_FigureYa2ggtree+pheatmap+msa_ggtree_pheatmap_msa_cowplot.txt",
      "folder": "FigureYa2ggtree+pheatmap+msa",
      "thumb": "gallery_compress/FigureYa2ggtree+pheatmap+msa.webp"
    },
    "word_count": 118,
    "lines_count": 105,
    "title": "Guangchuang Yu",
    "description": "暂无描述",
    "input_data_types": [],
    "output_types": [
      "热图"
    ],
    "technical_methods": [],
    "biology_areas": [],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "package"
    ]
  },
  {
    "id": "main_FigureYa306slingshot_FigureYa306slingshot",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa306slingshot_FigureYa306slingshot.txt",
    "content": "FigureYa306slingshot\nFigureYa306slingshot\nAuthor(s)\n: Xiaofan Lu; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-10-04\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\nIf you use circlize in published research, please cite:\nGu, Z. circlize implements and enhances circular visualization in R.\nBioinformatics 2014.\n需求描述\nDemand description\n我想利用slingshot实现拟时序分析并绘制出特定基因随着时序变化的表达图。FigureYa285scRNA_monocle用monocle画过左边这样的图，但是我更想试一下这个slingshot。\nI want to use slingshot to perform pseudotime analysis and plot the\nexpression patterns of specific genes along the inferred trajectory.\nFigureYa285scRNA_monocle has previously used Monocle to generate the\nplot on the left, but I’d like to try Slingshot this time.\n出自：\nhttps://www.nature.com/articles/s41591-021-01323-8\n图3：CD8+ TEX 和 CD4+ TH1 轨迹中的差异表达基因\nSource:\nhttps://www.nature.com/articles/s41591-021-01323-8\nFig. 3: Differentially expressed genes in CD8+ TEX and CD4+ TH1\ntrajectories.\n应用场景\nApplication scenarios\n利用slingshot实现拟时序分析，并绘制出特定基因随着时序变化的表达图。\n个人审美认为用monocle画出的特定基因随着时序变化的热图更好看，可参考FigureYa285scRNA_monocle\nPerform pseudotime analysis using Slingshot and generate expression\nplots of specific genes along the inferred trajectory.\nPersonally, I find the heatmaps of gene expression dynamics over\npseudotime generated by Monocle more visually appealing. For reference,\nsee FigureYa285scRNA_monocle\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(slingshot)\nlibrary(mclust)\nlibrary(RColorBrewer)\nlibrary(tradeSeq)\nlibrary(ComplexHeatmap)\nlibrary(circlize)\nlibrary(reshape2)\nlibrary(ggplot2)\nlibrary(ggridges)\n\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n自定义函数\nCustom function\n# 数据标准化\n# Data standardization function\nstandarize.fun <- function(indata=NULL, halfwidth=NULL, centerFlag=T, scaleFlag=T) {  \n  outdata=t(scale(t(indata), center=centerFlag, scale=scaleFlag))\n  if (!is.null(halfwidth)) {\n    outdata[outdata>halfwidth]=halfwidth\n    outdata[outdata<(-halfwidth)]= -halfwidth\n  }\n  return(outdata)\n}\n\n# 分位数归一化\n# Quantile normalization\nFQnorm <- function(counts){\n  rk <- apply(counts,2,rank,ties.method='min')\n  counts.sort <- apply(counts,2,sort)\n  refdist <- apply(counts.sort,1,median)\n  norm <- apply(rk,2,function(r){ refdist[r] })\n  rownames(norm) <- rownames(counts)\n  return(norm)\n}\n输入文件\nInput Files\n读取sce对象（SingleCellExperiment对象，会用到里面的counts）。\nRead the SingleCellExperiment (sce) object (the counts data within it\nwill be used).\nsce <- readRDS(\"sce.rds\")\n\n## 数据预处理\n## Data preprocessing\n\n# 过滤低表达基因\n# Filter low-expressed genes \ngeneFilter <- apply(assays(sce)$counts,1,function(x){\n  sum(x >= 3) >= 10 \n})\nsce <- sce[geneFilter, ]\n\n# 对计数数据进行分位数归一化处理\n# Perform quantile normalization on count data\nassays(sce)$norm <- FQnorm(assays(sce)$counts)\n计算pca，聚类，拟时序分析\nPerform PCA, clustering, and pseudotime analysis\n# 对标准化数据进行主成分分析(PCA)\n# Principal Component Analysis (PCA)\npca <- prcomp(t(log1p(assays(sce)$norm)), scale. = FALSE) \nrd1 <- pca$x[,1:2]\nreducedDims(sce) <- SimpleList(PCA = rd1)\n\n# 高斯混合模型聚类\n# Gaussian Mixture Model clustering\ncolData(sce)$GMM <- Mclust(rd1)$classification \n\n# 使用GMM聚类结果进行Slingshot拟时序分析\n# Run Slingshot pseudotime analysis using GMM clusters\nsce <- slingshot(sce, clusterLabels = 'GMM', reducedDim = 'PCA') \n\ncolors <- colorRampPalette(brewer.pal(11,'Spectral')[-6])(100) \n\nplotcol <- colors[cut(sce$slingPseudotime_1, breaks=100)]\n\n# 将结果保存为PDF\n# Save plot to PDF\npdf(\"data distribution.pdf\", width = 5,height = 5)\npar(bty=\"o\", mgp = c(1.5,.33,0), mar=c(3.1,3.1,2.1,2.1), las=1, tcl=-.25,las = 1, xpd = T)\nplot(reducedDims(sce)$PCA, col = plotcol, pch=16, asp = 1)\nlines(SlingshotDataSet(sce), lwd=2, col='black')\ninvisible(dev.off())\n\n# 差异分析\n# Differential expression analysis\nsce <- fitGAM(sce)\n\n# 进行关联性检验\n# Perform association testing\nATres <- associationTest(sce)\n\n# 提取显著性最高的250个基因\n# Extract top 250 significant genes\ntopgenes <- rownames(ATres[order(ATres$pvalue), ])[1:250]\n\n# 按拟时序对细胞排序\n# Order cells by pseudotime\npst.ord <- order(sce$slingPseudotime_1, na.last = NA)\n开始画图\nPlotting\n# 1. 绘制特定基因随着时序变化的热图\n# 1. Heatmap of gene expression along pseudotime\nplot.data <- assays(sce)$counts[topgenes, pst.ord]\nplot.data <- standarize.fun(plot.data, halfwidth = 2)\n\n## 可视化颜色设置\n## Color settings for visualization\nhm.col <- colorRampPalette(brewer.pal(11,'Spectral'))(100)\ncell.col <- setNames(brewer.pal(6, \"Set1\"), 1:6)\ntime.col <- colorRamp2(breaks = seq(min(sce$slingPseudotime_1, na.rm = T),\n                                    max(sce$slingPseudotime_1, na.rm = T),\n                                    length.out = 8), \n                       colors = brewer.pal(8, \"PuBu\"))\n\n# 随机选择5个基因进行标注（也可手动指定基因）\n# Randomly select 5 genes to label (or manually specify genes)\nplot.gene <- sample(rownames(plot.data), 5)\n#plot.gene <- c(\"G548\", \"G578\", \"G704\") \n\n## 行列注释\n## Column and row annotations\ncol_ha <- columnAnnotation(\"clust\" = as.character(sce$GMM)[!is.na(sce$slingPseudotime_1)],\n                           \"pseudotime\" = sce$slingPseudotime_1[!is.na(sce$slingPseudotime_1)],\n                           col = list(\"clust\" = cell.col,\n                                      \"pseudotime\" = time.col))\nrow_ha <- rowAnnotation(gene = anno_mark(at = match(plot.gene, rownames(plot.data)),\n                                         labels = plot.gene, side = \"left\")) \n\n#pdf(\"pseudotimeHeatmap.pdf\")\nHeatmap(matrix = plot.data, col = rev(hm.col),\n        cluster_rows = T, cluster_columns = F, \n        row_km = 5, show_row_dend = T, row_title=NULL,\n        show_row_names = F, show_column_names = F,\n        bottom_annotation = col_ha, left_annotation = row_ha,\n        name = \"z-score\")\n#dev.off()\n\n# 2. 基因表达的密度分布图\n# 2. Density-like visualization of gene expression\nplot.gene <- topgenes[seq(1, length(topgenes), length.out = 5)]\nplot.data <- assays(sce)$counts[plot.gene, ]\nplot.data <- melt(plot.data) \ncolnames(plot.data) <- c(\"Gene\", \"Cell\", \"Expression\") \nplot.data$Pseudotime <- sce$slingPseudotime_1[match(plot.data$Cell, colnames(sce))]\nplot.data$Expression <- log(1 + plot.data$Expression)\nplot.data <- lapply(1:nrow(plot.data), function(i){ \n  data.frame(\"Pseudotime\" = rep(plot.data$Pseudotime[i], plot.data$Expression[i]),\n             \"Gene\" = rep(plot.data$Gene[i], plot.data$Expression[i]))\n})\nplot.data <- do.call(rbind, plot.data)\nggplot(plot.data, aes(x = Pseudotime, y = Gene, fill = Gene)) +\n  geom_density_ridges() +\n  theme_classic() +\n  scale_fill_viridis_d()\nggsave(\"density.pdf\", width = 4, height = 6)\n# 3. 基因表达趋势的平滑曲线图\n# 3. Smooth curve plot of expression trends\nplot.gene <- topgenes[seq(1, length(topgenes), length.out = 5)]\nplot.data <- assays(sce)$counts[plot.gene, ]\nplot.data <- melt(plot.data) \ncolnames(plot.data) <- c(\"Gene\", \"Cell\", \"Expression\")\nplot.data$Pseudotime <- sce$slingPseudotime_1[match(plot.data$Cell, colnames(sce))]\n\nggplot(plot.data, aes(x = Pseudotime, y = Expression)) +\n  geom_smooth() +\n  facet_wrap(~Gene, ncol = 1) +\n  theme_classic()\nggsave(\"curve.pdf\", width = 2, height = 8)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa306slingshot_FigureYa306slingshot",
      "title": "FigureYa306slingshot/FigureYa306slingshot.html",
      "html": "FigureYa306slingshot/FigureYa306slingshot.html",
      "text": "texts/main_FigureYa306slingshot_FigureYa306slingshot.txt",
      "folder": "FigureYa306slingshot",
      "thumb": "gallery_compress/FigureYa306slingshot.webp"
    },
    "word_count": 763,
    "lines_count": 219,
    "title": "FigureYa306slingshot",
    "description": "Demand description 我想利用slingshot实现拟时序分析并绘制出特定基因随着时序变化的表达图。FigureYa285scRNA_monocle用monocle画过左边这样的图，但是我更想试一下这个slingshot。 I want to use slingshot to perform pseudotime analysis and plot the",
    "input_data_types": [],
    "output_types": [
      "火山图",
      "热图",
      "PCA图"
    ],
    "technical_methods": [
      "主成分分析",
      "聚类分析",
      "标准化",
      "差异表达分析"
    ],
    "biology_areas": [],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "gene",
      "bottom_annotation",
      "center",
      "show_row_dend",
      "lwd",
      "show_row_names",
      "width",
      "cluster_columns",
      "side"
    ]
  },
  {
    "id": "main_FigureYa266panHeatmap_FigureYa266panHeatmap",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa266panHeatmap_FigureYa266panHeatmap.txt",
    "content": "FigureYa266panHeatmap\nFigureYa266panHeatmap\nAuthor(s)\n: Xiaofan Lu; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-05-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nDemand description\n复现Figure1的EF，希望能用原始数据。\nReplicate Figure 1E-F using raw data where possible.\n出自：\nhttps://molecular-cancer.biomedcentral.com/articles/10.1186/s12943-019-1066-3\n图1 m6A调控因子的泛癌遗传学及表达改变 e\n17种癌症类型中m6A调控因子的基因表达改变。热图显示倍数变化，红色代表上调基因，蓝色代表下调基因。\nf 箱线图展示IGF2BP3在15种癌症类型的肿瘤和正常样本中的表达分布。\nSource:\nhttps://molecular-cancer.biomedcentral.com/articles/10.1186/s12943-019-1066-3\nFig. 1 Pan-cancer genetic and expression alterations of m6A\nregulators. e The gene expression alterations of m6A regulators in 17\ncancer types. The heat map shows the fold changes, with red representing\nup-regulated genes, and blue representing down-regulated genes. f Box\nplots showing the expression distribution of IGF2BP3 across tumor and\nnormal samples in 15 cancer types.\n应用场景\nApplication scenarios\n对泛癌中肿瘤与正常样本做多个基因（m6A为例）的差异表达分析，并根据log2FoldChange值绘制泛癌热图，同时对感兴趣基因绘制泛癌箱型图。\n如果想换成泡泡图结合柱形图，可参考FigureYa263panDiff\n如果想用GSEA计算并展示多个\n基因集\n的差异表达，可参考FigureYa253panGSEA\n如果只对单个基因感兴趣，可参考FigureYa55panCancer_violin，画成小提琴图或box\nplot，FigureYa55plus_pancancer_boxplot。\n另外，我们还实现过这篇文章的其他几个有意思的图：\nFig.1D对角热图，可参考FigureYa144DiagHeatmap\nFig.2A靶向关系连线图，可参考FigureYa199crosslink，带你实现连线自由\nFig.3A基因集的survival\nlandscape，可参考FigureYa210survivalScape\nPerform differential expression analysis of multiple genes (using m6A\nas an example) between tumor and normal samples across pan-cancer\ndatasets, and generate pan-cancer heatmaps based on log2FoldChange\nvalues, along with pan-cancer box plots for genes of interest.\nTo switch to bubble charts combined with bar plots, refer to\nFigureYa263panDiff\nTo use GSEA for calculating and displaying differential expression of\nmultiple gene sets\n, refer to FigureYa253panGSEA\nIf only interested in a single gene, refer to\nFigureYa55panCancer_violin to create violin plots or box plots\nFigureYa55plus_pancancer_boxplot.\nAdditionally, we have crowdsourced several other interesting figures\nfrom this article:\nFig.1D diagonal heatmap, refer to FigureYa144DiagHeatmap\nFig.2A target relationship connection diagram, refer to\nFigureYa199crosslink, achieving connection freedom\nFig.3A survival landscape of gene sets, refer to\nFigureYa210survivalScape\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(data.table)\nlibrary(impute)\nlibrary(ClassDiscovery)\nlibrary(ComplexHeatmap)\nsource(\"twoclasslimma.R\")\n\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n输入文件\nInput Files\n跟FigureYa253panGSEA、FigureYa263panDiff、FigureYa265panCNV使用的是同一套输入数据，已经下载的小伙伴就不用重复下载了。\nmerged_sample_quality_annotations.tsv: 下载自\nhttps://gdc.cancer.gov/about-data/publications/pancanatlas\n，下载地址\nhttp://api.gdc.cancer.gov/data/1a7d7be8-675d-4e60-a105-19d4121bdebf\nEBPlusPlusAdjustPANCAN_IlluminaHiSeq_RNASeqV2.geneExp.tsv:\n表达矩阵，第一列是基因，之后是其在每个样本中的表达量。下载自\nhttp://api.gdc.cancer.gov/data/3586c0da-64d0-4b74-a449-5ff4d9136611\nThese files use the same input data as FigureYa253panGSEA,\nFigureYa263panDiff, and FigureYa265panCNV - if you’ve already downloaded\nthem, no need to download again.\nmerged_sample_quality_annotations.tsv: Downloaded from\nhttps://gdc.cancer.gov/about-data/publications/pancanatlas\n.\nDirect download link:\nhttp://api.gdc.cancer.gov/data/1a7d7be8-675d-4e60-a105-19d4121bdebf\n.\nEBPlusPlusAdjustPANCAN_IlluminaHiSeq_RNASeqV2.geneExp.tsv: Expression\nmatrix where the first column contains gene names, followed by\nexpression values for each sample. Downloaded from\nhttp://api.gdc.cancer.gov/data/3586c0da-64d0-4b74-a449-5ff4d9136611\n# 定义感兴趣的M6A基因集(VIRMA和KIAA1429同名，https://www.genecards.org/cgi-bin/carddisp.pl?gene=VIRMA)\n# Define the M6A gene set of interest (VIRMA and KIAA1429 are the same gene, see: https://www.genecards.org/cgi-bin/carddisp.pl?gene=VIRMA)\nm6a <- c(\"YTHDC1\",\"IGF2BP1\",\"IGF2BP2\",\"IGF2BP3\",\n         \"YTHDF1\",\"YTHDF3\",\"YTHDC2\",\"HNRNPA2B1\",\n         \"YTHDF2\",\"HNRNPC\",\"RBMX\",\"METTL3\",\n         \"METTL14\",\"WTAP\",\"KIAA1429\",\"RBM15\",\n         \"RBM15B\",\"ZC3H13\",\"FTO\",\"ALKBH5\")\n\n# 获得同时有肿瘤和正常样本的肿瘤名\n# Get tumor names that have both tumor and normal samples\ntumors <- c(\"BLCA\",\"BRCA\",\"CESC\",\"CHOL\",\"COAD\",\n            \"ESCA\",\"GBM\",\"HNSC\",\"KICH\",\"KIRC\",\n            \"KIRP\",\"LIHC\",\"LUAD\",\"LUSC\",\"PAAD\",\n            \"PRAD\",\"READ\",\"STAD\",\"THCA\",\"UCEC\")\n\n# 修正TCGA名称：https://gdc.cancer.gov/about-data/publications/pancanatlas\n# Correct TCGA names: https://gdc.cancer.gov/about-data/publications/pancanatlas\nrawAnno <- read.delim(\"merged_sample_quality_annotations.tsv\",sep = \"\\t\",row.names = NULL,check.names = F,stringsAsFactors = F,header = T) \n# 简化样本ID（取前15位TCGA条码）\n# Simplify sample IDs (first 15 characters of TCGA barcode)\nrawAnno$simple_barcode <- substr(rawAnno$aliquot_barcode,1,15)\n\n# 创建精简注释表（去重+关键列）\n# Create concise annotation table (deduplicated + key columns)\nsamAnno <- rawAnno[!duplicated(rawAnno$simple_barcode),c(\"cancer type\", \"simple_barcode\")]\n\n# 过滤无效记录（癌症类型为空）\n# Filter invalid records (empty cancer type)\nsamAnno <- samAnno[which(samAnno$`cancer type` != \"\"),]\n\n# 保存简化版注释文件（供后续分析使用）\n# Save simplified annotation (for downstream analysis)\nwrite.table(samAnno,\"simple_sample_annotation.txt\",sep = \"\\t\",row.names = F,col.names = T,quote = F)\n\n# 快速读取表达谱: https://gdc.cancer.gov/about-data/publications/pancanatlas\n# Quickly read expression profiles: https://gdc.cancer.gov/about-data/publications/pancanatlas\nexpr <- fread(\"EBPlusPlusAdjustPANCAN_IlluminaHiSeq_RNASeqV2.geneExp.tsv\",sep = \"\\t\",stringsAsFactors = F,check.names = F,header = T)\n\n# 转换为数据框并设置行名\n# Convert to dataframe and set row names\nexpr <- as.data.frame(expr); rownames(expr) <- expr[,1]; expr <- expr[,-1]\n\n# 调整行名\n# Adjust row names\ngene <- sapply(strsplit(rownames(expr),\"|\",fixed = T), \"[\",1) \n\nexpr$gene <- gene\n\n# 移除重复样本\n# Remove duplicate samples\nexpr <- expr[!duplicated(expr$gene),] \nrownames(expr) <- expr$gene; expr <- expr[,-ncol(expr)]\n\n# 取部分表达谱，全部匹配\n# Extract partial expression profiles, all matched\ncomgene <- intersect(rownames(expr),m6a) \n\n# 提取m6A基因表达子集\n# Extract m6A gene expression subset\nexpr_sub <- expr[comgene,]\n\n# 简化样本ID（取前15位）\n# Simplify sample IDs (first 15 characters)\ncolnames(expr_sub) <- substr(colnames(expr_sub),1,15)\n\n# 去除重复样本（基于简化后的ID）\n# Remove duplicate samples (based on simplified IDs)\nexpr_sub <- expr_sub[,!duplicated(colnames(expr_sub))]\n\n# 内存清理\n# Memory Cleanup\nrm(expr); gc()\n差异表达分析\nDifferential Expression Analysis\n# 初始化差异表达矩阵以存储每个基因在每个癌种种类里的log2FoldChange值\n# Initialize a differential expression matrix to store log2FoldChange values for each gene in each cancer type\ndegRes <- as.data.frame(matrix(NA,nrow = length(comgene),ncol = length(tumors),\n                 dimnames = list(comgene,tumors)))\n\n# 跨癌种差异表达分析\n# Pan-Cancer Differential Expression Analys\nfor (i in tumors) {\n  message(\"--\",i,\"...\")\n  \n  # 获取当前癌症类型的样本ID\n  # Get sample IDs for current cancer type\n  sam <- samAnno[which(samAnno$`cancer type` == i),\"simple_barcode\"]\n  \n  # 获取表达矩阵和样本注释的交集\n  # Get intersection between expression matrix and sample annotation\n  comsam <- intersect(colnames(expr_sub), sam)\n  \n  # 获得肿瘤样本\n  # Extract tumor samples  \n  tumsam <- comsam[substr(comsam,14,14) == \"0\"] \n  \n  # 获得正常样本\n  # Extract normal samples\n  norsam <- comsam[substr(comsam,14,14) == \"1\"] \n  \n  # 提取目标基因的表达子集\n  # Extract expression subset for target genes\n  expr_subset <- expr_sub[,c(tumsam,norsam)]\n  \n  # 这份数据里存在负值，即便负值比较小，但也要矫正，如果使用其他泛癌表达谱根据情况而定\n  # This dataset contains negative values (though small), so correction is needed. Adjust if using other pan-cancer expression data\n  expr_subset[expr_subset < 0] <- 0 \n  \n  # 这份泛癌数据存在空值，所以做缺失值填补\n  # Missing value imputation (this pan-cancer dataset contains NAs)\n  expr_subset <- as.data.frame(impute.knn(as.matrix(expr_subset))$data) \n  \n  # 输出子表达谱\n  # Output the subset expression profile \n  write.table(expr_subset, paste0(\"TCGA_\",i,\"_expr_subset.txt\"),sep = \"\\t\",row.names = T,col.names = NA,quote = F)\n  \n  # 利用limma脚本做差异表达分析（脚本会识别数据的量级来确定是否进行对数化）\n  # Perform differential expression analysis using the limma script (automatically checks data scale to determine if log transformation is needed)\n  subt <- data.frame(condition = rep(c(\"tumor\",\"normal\"),c(length(tumsam),length(norsam))),\n                     row.names = colnames(expr_subset),\n                     stringsAsFactors = F)\n  \n  # 执行limma差异表达分析\n  # Perform limma differential expression analysis\n  twoclasslimma(subtype  = subt, \n                featmat  = expr_subset, \n                treatVar = \"tumor\", \n                ctrlVar  = \"normal\", \n                prefix   = paste0(\"TCGA_\",i), \n                overwt   = T, \n                sort.p   = F, \n                verbose  = TRUE, \n                res.path = \".\") \n  \n  # 加载差异表达文件\n  # Load the differential expression results \n  res <- read.table(paste0(\"TCGA_\",i,\"_limma_test_result.tumor_vs_normal.txt\"),sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\n  \n  # 将log2FC值存入结果矩阵\n  # Store log2FC values in result matrix\n  degRes[,i] <- res[rownames(degRes),\"log2fc\"]\n}\n# 保存差异表达结果矩阵\n# Save differential expression matrix\nwrite.table(degRes,file = \"log2fc of m6a genes between tumor and normal samples in pancancer.txt\",sep = \"\\t\",row.names = T,col.names = NA,quote = F)\n上面“差异表达分析”输出的TCGA_*_limma_test_result.tumor_vs_normal.txt文件可无缝对接FigureYa59volcano，绘制美丽火山图。\nThe output file TCGA_*_limma_test_result.tumor_vs_normal.txt from the\n“Differential Expression Analysis” section can be directly used with\nFigureYa59volcano to create high-quality volcano plots.\n开始画图\nPlotting\n绘制log2FoldChange的热图\nGenerate a Heatmap of log2FoldChange Values\n# 使用差异表达结果数据\n# Using differential expression results\nindata <- degRes\n\n# 对log2FC做聚类\n# Cluster log2FC values\nhcs <- hclust(distanceMatrix(as.matrix(indata), \"euclidean\"), \"ward.D\") \n\n## 创建行注释\n## Create row annotations\nannRow <- data.frame(row.names = m6a,\n                     class = rep(c(\"Readers\",\"Writers\",\"Erasers\"),c(11,7,2)))\n\n# 设置因子水平（控制显示顺序）\n# Set factor levels (controls display order)\nannRow$class <- factor(annRow$class, levels = c(\"Readers\",\"Writers\",\"Erasers\"))\n\n# 定义注释颜色方案\n# Define annotation color scheme\nannColors <- list(class = c(\"Readers\" = \"#51B743\",\n                            \"Writers\" = \"#FAC67A\",\n                            \"Erasers\" = \"#5AC9FA\"))\n\n# 设置热图的颜色板\n# Set heatmap color gradient\ncolPattern <- c(\"#183869\",\"#4195C1\",\"white\",\"#CB5746\",\"#62011D\") \n\n# 热图绘制\n# Heatmap Visualization\nhm <- pheatmap(as.matrix(indata[rownames(annRow),]),\n         border_color = \"black\", \n         cluster_rows = FALSE,\n         cluster_cols = hcs, \n         show_rownames = TRUE,\n         show_colnames = TRUE,\n         annotation_row = annRow, \n         annotation_colors = annColors, \n         cellwidth = 18, \n         cellheight = 12, \n         color = colorRampPalette(colPattern)(64), \n         name = \"log2FoldChange\") \n\n# 保存热图为PDF\n# Save heatmap as PDF\npdf(file = \"pancancer heatmap of log2fc for m6A between tumor and normal samples.pdf\", width = 8, height = 6)\n\n# 绘制热图\n# Draw heatmap\ndraw(hm)\n\n# 静默关闭图形设备\n# Silently close graphics device\ninvisible(dev.off())\n批量绘制箱型图(y轴的标签可以最后用AI补上)\nBatch Generation of Box Plots (Y-axis labels can be added later\nusing AI)\n以\nIGF2BP3\n基因为例\nUsing the IGF2BP3 gene as an example\n# 设置感兴趣的基因\n# Set gene of interest \ngeneInterest <- \"IGF2BP3\" \n\n# 定义颜色方案\n# Define color scheme\ndarkred <- \"#F2042C\"\ndarkblue <- \"#21498D\"\n\n# 创建多页PDF输出文件\n# Create multi-page PDF output\npdf(file = paste0(\"pancancer boxplot of \", geneInterest, \" expression between tumor and normal samples.pdf\"), width = 10,height = 10)\n\n# 设置4行5列的图形布局（适应20种癌症类型）\n# Set 4x5 graphical layout (for 20 cancer types)\npar(mfrow = c(4,5))\n\n# 跨癌种循环分析\n# Pan-Cancer Iterative Analysis\nfor (i in tumors) {\n  message(\"--\",i,\"...\")\n  \n  # 获取当前癌症类型的样本ID\n  # Get sample IDs for current cancer type\n  sam <- samAnno[which(samAnno$`cancer type` == i),\"simple_barcode\"]\n  \n  # 获取表达矩阵和样本注释的交集\n  # Get intersection between expression matrix and sample annotation\n  comsam <- intersect(colnames(expr_sub), sam)\n  \n  # 获得肿瘤样本\n  # Extract tumor samples\n  tumsam <- comsam[substr(comsam,14,14) == \"0\"] \n  \n  # 获得正常样本\n  # Extract normal samples\n  norsam <- comsam[substr(comsam,14,14) == \"1\"] \n  \n  # 读入子表达谱\n  # Load subset expression profile\n  expr_subset <- read.table(paste0(\"TCGA_\",i,\"_expr_subset.txt\"),sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\n  \n  # 取出肿瘤样本特定基因的表达并对数化\n  # Extract and log-transform tumor sample expression\n  exprTgene <- log2(as.numeric(expr_subset[geneInterest,tumsam]) + 1) \n  \n  # 取出正常样本特定基因的表达并对数化\n  # Extract and log-transform normal sample expression\n  exprNgene <- log2(as.numeric(expr_subset[geneInterest,norsam]) + 1) \n  \n  # 为了使得图形尽可能紧凑，因为四边的距离分别设置为0.1（底部空出一小段距离），1.5（左边因为要放y轴刻度），2（顶部因为肿瘤名写在顶部），0.1（右部空出一小段距离）\n  # Set plot parameters for compact display: 0.1 (bottom margin), 1.5 (left margin for y-axis), 2 (top margin for cancer type label), 0.1 (right margin) \n  par(bty=\"o\", mgp = c(1.5,.33,0), \n      mar=c(0.1,1.5,2,0.1), \n      las=1, tcl=-.25,las = 1, xpd = F)\n  \n  # 绘制肿瘤vs正常表达比较箱线图\n  # Draw tumor vs normal expression boxplot\n  boxplot(exprNgene,exprTgene,\n          col = c(darkblue,darkred), \n          outline = FALSE, \n          ylab = \"\", \n          xaxt='n') \n  \n  # 添加癌症类型标签（顶部）\n  # Add cancer type label (top)\n  mtext(side = 3, text = i,line = 0.5)\n}\n# 静默关闭图形设备\n# Silently close graphics device\ninvisible(dev.off())\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa266panHeatmap_FigureYa266panHeatmap",
      "title": "FigureYa266panHeatmap/FigureYa266panHeatmap.html",
      "html": "FigureYa266panHeatmap/FigureYa266panHeatmap.html",
      "text": "texts/main_FigureYa266panHeatmap_FigureYa266panHeatmap.txt",
      "folder": "FigureYa266panHeatmap",
      "thumb": "gallery_compress/FigureYa266panHeatmap.webp"
    },
    "word_count": 1393,
    "lines_count": 390,
    "title": "FigureYa266panHeatmap",
    "description": "Demand description 复现Figure1的EF，希望能用原始数据。 Replicate Figure 1E-F using raw data where possible.",
    "input_data_types": [
      "临床数据",
      "表达矩阵",
      "生存数据"
    ],
    "output_types": [
      "火山图",
      "热图",
      "统计表格",
      "箱线图",
      "生存曲线"
    ],
    "technical_methods": [
      "聚类分析",
      "质量控制",
      "差异表达分析"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "gene",
      "header",
      "width",
      "cluster_cols",
      "side",
      "nrow",
      "cellwidth",
      "prefix",
      "name"
    ]
  },
  {
    "id": "main_FigureYa260CNV_FigureYa260CNV",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa260CNV_FigureYa260CNV.txt",
    "content": "FigureYa260CNV\nFigureYa260CNV\nAuthor(s)\n: Shuwen Cheng; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nDemand description\n画出CNV的这个图。\nDraw this CNV plot.\n出自：\nhttps://molecular-cancer.biomedcentral.com/articles/10.1186/s12943-021-01322-w\n，跟FigureYa259circLink和FigureYa262GDC出自同一篇文章。\n图1. CRC中RNA修饰“书写器”的遗传及转录改变。 c,\n柱状图显示TCGA-COAD/READ队列中RNA修饰“书写器”的CNV增益（红色）、缺失（蓝色）和非CNV（绿色）的频率。每根柱子的高度代表改变频率。\nSource:\nhttps://molecular-cancer.biomedcentral.com/articles/10.1186/s12943-021-01322-w\n,\nit is from the same article as FigureYa259circLink and\nFigureYa262GDC.\nFig. 1 Genetic and transcriptional alterations of RNA modification\n“writers” in CRC. c, Bar graphs showing the frequency of CNV gain (red),\nloss (blue) and non_CNV (green) of RNA modification “writers” in the\nTCGA-COAD/READ cohort. The height of each bar represents the alteration\nfrequency.\n应用场景\nApplication scenarios\n外显子测序数据可以画这样的图。\nRNA-seq数据也可以借助这样的分析来深挖。例如RNA-seq筛出成百上千个差异基因，谁才是关键基因？它通过什么方式影响了下游基因的表达？或许是某些基因发生了高频copy\nnumber variation（gain/loss）。\nExome sequencing data can generate similar plots.\nRNA-seq data can also be leveraged for in-depth analysis using such\napproaches. For example, when RNA-seq identifies hundreds or thousands\nof differentially expressed genes, how can we pinpoint the key drivers?\nBy what mechanisms do they regulate downstream gene expression? One\npossible explanation could be high-frequency copy number variations\n(gain/loss) in certain genes.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(magrittr)\nlibrary(tidyverse)\nlibrary(org.Hs.eg.db)\nlibrary(TCGAbiolinks)\nlibrary(clusterProfiler)\nlibrary(SummarizedExperiment)\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character-to-factor conversion\noptions(stringsAsFactors = FALSE)\n输入数据\nInput Files\n从GDC下载hg38的CNV数据，以COAD/READ为例。\neasy_input_gene.txt，要看哪些基因的CNV，就写到这个文件里。甚至可以把所有差异基因或参与某个通路的基因都拿来计算，查看输出文件\noutput_cnv.csv\n。然后筛选gain或loss频率高的前十几个基因，进行画图展示。\nDownload hg38 CNV data from GDC, using COAD/READ as an example.\nThe file easy_input_gene.txt should contain the list of genes for CNV\nanalysis. You may include all differentially expressed genes or\npathway-related genes for calculation, then check the output file\noutput_cnv.csv\n. Subsequently, select the top ~10 genes with\nhigh-frequency gains or losses for visualization.\n# 查询并下载TCGA-COAD拷贝数变异数据\n# Query and download TCGA-COAD copy number variation data\ncnv_COAD <- GDCquery(\n  project = \"TCGA-COAD\",  \n  data.category = \"Copy Number Variation\",\n  data.type = \"Gene Level Copy Number\",\n  access = \"open\",\n  workflow.type = \"ASCAT3\",\n  experimental.strategy = \"Genotyping Array\"\n) %T>%\n  GDCdownload %>% GDCprepare\ndim(cnv_COAD)\n# 查询并下载TCGA-READ拷贝数变异数据\n# Query and download TCGA-READ copy number variation data\ncnv_READ <- GDCquery(project = \"TCGA-READ\",  \n  data.category = \"Copy Number Variation\",\n  data.type = \"Gene Level Copy Number\",\n  access = \"open\",\n  workflow.type = \"ASCAT3\",\n  experimental.strategy = \"Genotyping Array\"\n) %T>%\n  GDCdownload %>% GDCprepare\ndim(cnv_READ)\n# 提取拷贝数数据\n# Extract copy number data\ncnv_COAD_data <- assay(cnv_COAD, \"copy_number\")\ncnv_READ_data <- assay(cnv_READ, \"copy_number\")\n\n# 合并COAD和READ数据\n# Merge COAD and READ data\ncnv_data <- cbind(cnv_COAD_data, cnv_READ_data)\n\n# 统一colData\n# Harmonize colData\ncommon_cols <- intersect(colnames(colData(cnv_COAD)), colnames(colData(cnv_READ)))\ncolData_COAD <- colData(cnv_COAD)[, common_cols]\ncolData_READ <- colData(cnv_READ)[, common_cols]\ncombined_colData <- rbind(colData_COAD, colData_READ)\n\n# 重建 SummarizedExperiment\n# Reconstruct SummarizedExperiment\ncnv <- SummarizedExperiment(\n  assays = list(copy_number = cnv_data),\n  colData = combined_colData,\n  rowData = rowData(cnv_COAD)\n)\n\n# 检查合并结果\n# Check merging results\ndim(cnv)\n# 删除重复的sample\n# Remove duplicate samples\ncnv <- cnv[,!duplicated(colnames(cnv))]\ndim(cnv)\n# Define a gene set of interest\n# 定义感兴趣的基因集\n\n## 方法1：从文件读取\n## Option 1: Read from file\ngenes <- read.table(\"easy_input_gene.txt\", header = T)$SYMBOL\n\n## 方法2：直接指定基因\n## Option 2: Directly specify genes (commented out example)\n#genes <- c(\"METTL3\", \"METTL14\", \"FTO\", \"ALKBH5\",\"IGF2BP3\",\n#           \"YTHDF1\", \"YTHDF2\", \"YTHDF3\", \"IGF2BP1\", \"IGF2BP2\", )\n计算gain和loss频率\nCalculate gain and loss frequency\n# 将CNV数据转换为数据框并处理基因符号\n# Convert CNV data to dataframe and process gene symbols \ncnv_df <- as.data.frame(assay(cnv, \"copy_number\")) %>%\n  rownames_to_column(\"Gene_Symbol\")\n\n# CNV数据处理流程\n# Process CNV data    \ncnv2 <- cnv_df %>%\n  \n  # 提取ENSEMBL ID（取前15位字符）  \n  # Extract ENSEMBL IDs (first 15 characters)  \n  mutate(ENSEMBL = str_sub(Gene_Symbol, 1, 15)) %>%\n  \n  # 转换为基因名SYMBOL\n  # Convert to gene symbols\n  inner_join(bitr(.$ENSEMBL,\n                  fromType = \"ENSEMBL\",\n                  toType = \"SYMBOL\",\n                  OrgDb = org.Hs.eg.db)) %>% \n  \n  # 去除转换时可能产生的重复项\n  # Remove potential duplicates after conversion\n  distinct(SYMBOL, .keep_all = TRUE) %>% \n  \n  # 仅保留目的基因\n  # Filter for target genes\n  filter(SYMBOL %in% genes) %>% \n  \n  # 将SYMBOL作为行名\n  # SYMBOL is used as rownames\n  column_to_rownames(\"SYMBOL\") %>% \n  \n  # 移除注释信息列  \n  # Remove metadata columns  \n  dplyr::select(-ENSEMBL, -Gene_Symbol) %>% \n  \n  # 筛选肿瘤样本（TCGA编号第14-15位<10）  \n  # Filter tumor samples (TCGA barcode positions 14-15 < 10)  \n  select_if(str_sub(colnames(.), 14, 15) < 10) %>% \n  \n  # 计算CNV频率（基于ASCAT3的整数拷贝数）\n  # Calculate CNV frequencies (based on ASCAT3-derived integer copy number values)\n    mutate(\n    CNV_loss = rowMeans(.< 2, na.rm = TRUE),   \n    CNV_gain = rowMeans(.> 2, na.rm = TRUE),   \n    CNV_normal = rowMeans(. == 2, na.rm = TRUE)  \n  ) %>% \n \n  # 仅保留频率指标\n  # Keep only frequency metrics  \n  dplyr::select(CNV_loss, CNV_gain, CNV_normal) %>% \n  \n  # 恢复基因名列  \n  # Restore gene symbols column  \n  rownames_to_column(\"gene\") %>% \n  \n  # 将数据转变为长数据，便于绘图\n  # Convert to long format for plotting  \n  pivot_longer(!gene, names_to = \"Group\", values_to = \"pct\") %>% \n  \n  # 转换为百分比\n  # Convert to percentage\n  mutate(pct = pct * 100)\n# 保存处理结果  \n# Save processed data  \nwrite.csv(cnv2, \"output_cnv.csv\", row.names = F, quote = F)\n开始画图\nPlotting\n# 选项1：使用easy_input_gene.txt中预定义的顺序\n# Option 1: Use predefined order from easy_input_gene.txt\n#cnv2$gene <- factor(cnv2$gene, levels = genes)\n\n# 选项2：按CNV扩增频率降序排序\n# Option 2: Sort by CNV gain frequency (descending)\ncnv2_gain <- cnv2[cnv2$Group == \"CNV_gain\",]\ncnv2_gain_sorted <- cnv2_gain[order(cnv2_gain$pct, decreasing = T),] \ncnv2$gene <- factor(cnv2$gene, levels = cnv2_gain_sorted$gene)\n\n\n# 设置条形图堆叠顺序\n# Set bar plot order\ncnv2$Group <- factor(cnv2$Group, levels = c(\"CNV_loss\", \"CNV_gain\", \"CNV_normal\"))\n\n# 生成堆积条形图\n# Generate stacked bar plot\nggplot(cnv2, aes(x = gene, y = pct, fill = Group)) +\n  \n  # 绘制堆积条形图\n  # Draw stacked bars\n  geom_col(position = \"stack\") +\n  \n  # 添加标题\n  # Add title\n  ggtitle(paste0(\"TCGA-COAD/READ\\nn=\", ncol(cnv) - 3)) +\n  \n  # 手动添加颜色\n  # Custom color scheme\n  scale_fill_manual(values = c(\"steelblue3\", \"firebrick2\",  \"forestgreen\")) +\n  \n  # 坐标轴标签\n  # Axis labels\n  xlab(\"m6A genes\") +\n  ylab(\"Frequency of group(%)\") +\n  \n  theme_classic() +\n  theme(axis.line = element_line(size = 1, lineend = \"square\"),\n        axis.title = element_text(size = 15,face = \"bold\"),\n        axis.text.y = element_text(size = 12,face = \"bold\"),\n        axis.text.x = element_text(size = 12,face = \"bold\", angle = 90, hjust = 1),\n        axis.ticks.length = unit(0.25,\"cm\"),\n        axis.ticks = element_line(size = 1),\n        legend.text = element_text(size = 12,face = \"bold\"),\n        legend.title = element_text(size = 15,face = \"bold\"))\n# 保存为PDF\n# Save as PDF\nggsave(\"CNV.pdf\", width = 6, height = 4)\n我们算出的frequency跟原文差距较大，跟\ncBioPortal\n结果相近。跟原文作者联系，还没有回复。\nThe frequencies we calculated show significant discrepancies from\nthose reported in the original paper, but align closely with results\nfrom\ncBioPortal\n. We have reached out\nto the original authors for clarification but have not yet received a\nresponse.\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa260CNV_FigureYa260CNV",
      "title": "FigureYa260CNV/FigureYa260CNV.html",
      "html": "FigureYa260CNV/FigureYa260CNV.html",
      "text": "texts/main_FigureYa260CNV_FigureYa260CNV.txt",
      "folder": "FigureYa260CNV",
      "thumb": "gallery_compress/FigureYa260CNV.webp"
    },
    "word_count": 974,
    "lines_count": 270,
    "title": "FigureYa260CNV",
    "description": "Demand description 画出CNV的这个图。 Draw this CNV plot.",
    "input_data_types": [
      "临床数据"
    ],
    "output_types": [
      "统计表格"
    ],
    "technical_methods": [
      "通路分析"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "ticks",
      "values",
      "header",
      "width",
      "rowData",
      "colData",
      "pct",
      "hjust",
      "values_to"
    ]
  },
  {
    "id": "main_FigureYa153ccgraph_FigureYa153ccgraph",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa153ccgraph_FigureYa153ccgraph.txt",
    "content": "FigureYa153ccgraph\nFigureYa153ccgraph\nAuthor(s)\n: Chunhui Gao\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-10-16\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement Description\n用R从形式上复现原图。 Use R to reproduce the original figure in a\nformal manner.\n出自\nhttps://academic.oup.com/jnci/article-lookup/doi/10.1093/jnci/djy156\nFrom\nhttps://academic.oup.com/jnci/article-lookup/doi/10.1093/jnci/djy156\nFigure 1. Plot of all alterations detected by plasma next-generation\nsequencing (n=210). Size of circles represents number of patients\nidentified with an alteration.\n图的解析\nGraph Analysis\n例文用来展示基因上的 SNP/Indel/CNV 突变（多态性差异）。\n例如，在TP53基因中发现了最多的多态性，包括 CNV 差异 SPLICE 8\n个，单核苷酸位点差异 R273H\n5个等。用点的大小表示差异，所以很容易发现常见的多态性差异。 The example\ngraph is used to display SNP/Indel/CNV mutations (polymorphic\ndifferences) within a gene. For example, the TP53 gene has the most\npolymorphisms, including 8 CNV differences (SPLICE) and 5 single\nnucleotide variations (R273H). The size of the dots represents the\ndifference, making it easy to spot common polymorphic differences.\n稍作观察便可发现，本图是一个“圆环套圆环”的布局，中心处在中央，下一级的项目分别处在外环。图中只有二环，如果要扩展成五环，多显示几个层次应该也不错。\nA quick inspection reveals that this graph has a “ring within a circle”\nlayout, with the center at the center and the next-level items on the\nouter rings. The diagram only has two rings. If you want to expand it to\nfive, showing more layers would be helpful.\n原文用的是在线工具\nThe original article used\nan online tool\n推测原文是用这个工具画的：FuncTree\nhttps://bioviz.tokyo/functree/\n，能画出类似的图，用来展示基因组数据的关系。\nIt’s speculated that the original article used this tool: FuncTree\nhttps://bioviz.tokyo/functree/\n, which can create similar\ndiagrams for displaying relationships in genomic data.\n缺点：输入数据格式复杂非常复杂。需要针对每一个点做有针对性的设置。感兴趣的小伙伴去尝试一下吧～\nDisadvantages: The input data format is very complex. Targeted settings\nare required for each point. If you’re interested, give it a try!\n如何用R实现\nHow to Implement This in\nR\ntidytuesday\n2019-11-12的图跟原图很像，代码\nhttps://github.com/spren9er/tidytuesday/blob/master/tidytuesday_201946_cran_packages.r\n，输入数据\nhttps://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2019/2019-11-12/loc_cran_packages.csv\n。\nI found that the 2019-11-12 graph from\ntidytuesday\nis\nvery similar to the original. The code is\nhttps://github.com/spren9er/tidytuesday/blob/master/tidytuesday_201946_cran_packages.r\n,\nand the input data is\nhttps://raw.githubusercontent.com/rfordatascience/tidytuesday/master/data/2019/2019-11-12/loc_cran_packages.csv\n.\n参考这套代码，用\nggraph\n来画这个图。为此，花了几天时间仔细研究了\nggraph\n包，写下了一篇长文：\n一文读懂 ggraph\n的使用\nUsing this code as a reference, I used\nggraph\nto\ndraw this graph. To this end, I spent several days thoroughly studying\nthe\nggraph\npackage and wrote a lengthy article:\nUnderstanding\nggraph in One Article\n应用场景\nApplication Scenarios\n展示层级结构。例如： Displaying hierarchical structures. For\nexample:\n基因跟突变的关系，像例文那样；\n上游调控因子调控下游基因的层级和强度；\n宏基因组测序中发现的物种的丰度等信息。\nThe relationship between genes and mutations, as in the\nexample;\nThe level and strength of upstream regulatory factors regulating\ndownstream genes;\nInformation such as the abundance of species discovered in\nmetagenomic sequencing.\n注：\nNote:\n周围点的大小只能对应正值或绝对值，不能展示正负区别；\n不仅限于2层关系，还支持更多层级。\nThe size of surrounding points can only correspond to positive or\nabsolute values; it cannot display positive or negative\ndifferences;\nNot limited to two-level relationships; more levels are\nsupported.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")  # 确保依赖包已安装 # Ensure dependencies are installed\nsource(file = \"gather_graph_node.R\") # from ccgragh, https://github.com/gaospecial/ccgraph\nsource(file = \"gather_graph_edge.R\") # from ccgragh, https://github.com/gaospecial/ccgraph\nlibrary(clusterProfiler) # 用于功能富集分析 # For functional enrichment analysis\nlibrary(GOplot)          # 用于可视化基因本体分析结果 # For visualizing Gene Ontology analysis results\nlibrary(tidyverse)       # 用于数据操作和可视化的集合包 # A collection of packages for data manipulation and visualization\nlibrary(data.table)      # 用于高效的数据操作 # For efficient data manipulation\nlibrary(ggraph)          # 用于基于图形的可视化 # For graph-based visualizations\nlibrary(tidygraph)       # 用于处理图形数据 # For handling graph data\n\n# 设置环境变量\n# Set environment variables\nSys.setenv(LANGUAGE = \"en\")  # 显示英文报错信息 # Display error messages in English\noptions(stringsAsFactors = FALSE)  # 禁止字符型数据自动转换为因子型 # Prevent automatic conversion of character data to factors```\n输入文件的获得\nObtaining the input file\n如果你的数据已经整理成\nvery_easy_input.csv\n的格式，就可以跳过这步，直接进入“输入文件预处理”。\nIf your data is already formatted as\nvery_easy_input.csv\n,\nyou can skip this step and proceed directly to “Input File\nPreprocessing.”\n先用clusterProfiler做KEGG的GSEA，然后用例图的形式展示结果。 First,\nuse clusterProfiler to perform KEGG GSEA, then present the results using\na case diagram.\ngsym.fc <- read.table(\"easy_input_rnk.txt\", header = T)\ndim(gsym.fc)\nhead(gsym.fc)\n\n# 把gene symbol转换为ENTREZ ID\n# Convert gene symbols to ENTREZ IDs\n# 此处物种是人，其他物种的ID转换方法，请参考FigureYa52GOplot\n# The species here is human. For ID conversion methods for other species, please refer to FigureYa52GOplot\ngsym.id <- bitr(gsym.fc$SYMBOL, fromType = \"SYMBOL\", toType = \"ENTREZID\", OrgDb = \"org.Hs.eg.db\")\n\n#让基因名、ENTREZID、foldchange对应起来\n# Align gene name, ENTREZ ID, and foldchange\ngsym.fc.id <- merge(gsym.fc, gsym.id, by=\"SYMBOL\", all=F)\n\n#按照foldchange排序\n# Sort by foldchange\ngsym.fc.id.sorted <- gsym.fc.id[order(gsym.fc.id$logFC, decreasing = T),]\n\n#获得ENTREZID、foldchange列表，做为GSEA的输入\n# Obtain the ENTREZ ID and foldchange list as input for GSEA\nid.fc <- gsym.fc.id.sorted$logFC\nnames(id.fc) <- gsym.fc.id.sorted$ENTREZID\n\n#这一条语句就做完了KEGG的GSEA分析\n# This single statement completes the KEGG GSEA analysis\nkk <- gseKEGG(id.fc, organism = \"hsa\")\ndim(kk)\n\n# 把ENTREZ ID转为gene symbol，便于查看通路里的基因\n# Convert the ENTREZ ID to a gene symbol to facilitate viewing genes within the pathway\nkk.gsym <- setReadable(kk, 'org.Hs.eg.db', #物种\n                      'ENTREZID')\n\n# 可以用kk.gsym作为输入，用clusterProfiler画图\n# Use kk.gsym as input to plot with clusterProfiler\n# 用法看这里https://yulab-smu.github.io/clusterProfiler-book/chapter12.html\n# See here for usage: https://yulab-smu.github.io/clusterProfiler-book/chapter12.html\n# gsym.fc.l <- gsym.fc$logFC\n# Names(gsym.fc.l) <- gsym.fc$SYMBOL\n# Cnetplot(sortkk, foldChange = gsym.fc.l, circular = TRUE)\n\n# 按照enrichment score从高到低排序，取前5（up）和后5（down）\n# Sort by enrichment score, taking the top 5 (up) and bottom 5 (down)\n# Sortkk <- kk.gsym[order(kk.gsym@result$enrichmentScore, decreasing = T),][c(1:5, (nrow(kk.gsym)-5):nrow(kk.gsym)),]\n# 这里提取感兴趣的3个通路，数量太多拥挤的话不好看基因名\n# Extract the three pathways of interest here. Too many gene names will make the gene names look cluttered.\nsortkk <- kk.gsym[kk.gsym@result$Description %like% \"DNA\" | \n                    kk.gsym@result$Description %like% \"cycle\" | \n                    kk.gsym@result$Description %like% \"p53\",]\n\n# 把富集分析结果整理为GOplot所需的格式\n# Format the enrichment analysis results into the format required by GOplot\ngo <- data.frame(Category = \"KEGG\",\n                 ID = sortkk$ID,\n                 Term = sortkk$Description, \n                 Genes = gsub(\"/\", \", \", sortkk$core_enrichment), \n                 adj_pval = sortkk$p.adjust)\n\n# 基因变化倍数\n# Fold change of genes\ngenelist <- data.frame(ID = gsym.fc.id$SYMBOL, logFC = gsym.fc.id$logFC)\n\n# 把富集分析和倍数整合在一起\n# Integrate the enrichment analysis and fold change\ncirc <- circle_dat(go, genelist)\nhead(circ)\n# 可以用circ作为输入，用GOplot画图\n# Use circ as input to plot with GOplot\n# 用法看这里https://wencke.github.io/\n# See here for usage: https://wencke.github.io/\n# GOCircle(circ)\n\n# 保存到文件\n# Save to file\nwrite.csv(circ[,c(3,5,6)],\"very_easy_input.csv\", quote = F, row.names = F)\n输入文件预处理\nInput file preprocessing\nvery_easy_input.csv，这里以上面的富集分析结果为例，展示通路和通路里的基因变化倍数FC。三列依次是通路-基因-倍数，可以自由替换成“应用场景”里其他需要展示的信息。\nvery_easy_input.csv, using the above enrichment analysis results as an\nexample, displays pathways and gene fold-change FC within them. The\nthree columns are pathway-gene-fold-change, which can be freely replaced\nwith other information required for the “application scenario.”\ngene_special.txt，要突出显示的基因。第一列是基因名，第二列是类型（例如基因家族信息）。\ngene_special.txt, genes to be highlighted. The first column is the gene\nname, and the second column is the type (e.g., gene family\ninformation).\ndf <- read.csv(\"very_easy_input.csv\")\nhead(df)\ngeneSpecial <- read.table(\"gene_special.txt\", header = T)\ngeneCol <- geneSpecial$Type\nnames(geneCol) <- geneSpecial$Gene\ngeneCol\n图由两个部分组成，节点（node）和边（edge）。 A graph consists of two\ncomponents: nodes and edges.\n要从上面的数据框中采集节点和边的信息。 Node and edge information will\nbe collected from the above data frame.\n为此，我分别写了两个函数：\ngather_graph_node()\n和\ngather_graph_edge()\n来完成这一个任务（前面已加载）。 To\nthis end, I wrote two functions:\ngather_graph_node()\nand\ngather_graph_edge()\nto accomplish this task (previously\nloaded).\n这两个函数的参数设置借鉴了\ntreemap()\n的实现方式。\ndf\n：一个数据框\nindex\n：一个索引项（分组项）\nvalue\n：要采集的数值\nThe parameter settings for these two functions are inspired by the\nimplementation of\ntreemap()\n.\ndf\n: A data frame\nindex\n: An index item (grouping item)\nvalue\n: The value to be collected\n为了确保\nnode.name\n的唯一性，在图中使用了长名，而把原有的名字放在\nnode.short_name\n中去了。 To ensure the uniqueness of\nnode.name\n, the long name is used in the graph, and the\noriginal name is placed in\nnode.short_name\n.\nnode.level\n则用来指示节点应该处于第几个圆环。\nnode.level\nis used to indicate the ring level of the\nnode.\n节点的属性统一以\nnode\n作为前缀，而边的属性则以\nedge\n作为前缀。 Node attributes are prefixed with\nnode\n, while edge attributes are prefixed with\nedge\n.\nnodes <- gather_graph_node(df, index = c(\"term\", \"genes\"), value = \"logFC\", root=\"all\")\nedges <- gather_graph_edge(df, index = c(\"term\", \"genes\"), root = \"all\")\nnodes <- nodes %>% mutate_at(c(\"node.level\",\"node.branch\"),as.character)\nhead(nodes, 10)\nhead(edges, 10)\n# 把要突出显示的基因类型信息加到nodes里\n# Add the gene type information to be highlighted to nodes\nnodes$color <- \"normal\"\nnodes[nodes$node.short_name %in% geneSpecial$Gene,]$color <- geneCol[nodes[nodes$node.short_name %in% geneSpecial$Gene,]$node.short_name]\nnodes[nodes$node.short_name %in% geneSpecial$Gene,]\nnodes$color <- factor(nodes$color, levels = unique(nodes$color))\n\n# 有了节点和边的数据，使用 `tbl_graph()` 便可以得到一个图。\n# With the node and edge data, use `tbl_graph()` to create a graph.\ngraph <- tbl_graph(nodes, edges)\n开始画图\nStart drawing the graph\n自定义配色，直接出图\nCustomize the color scheme and plot directly\n# 用 `ggraph` 出图 # Plot the graph using `ggraph`\ngc <- ggraph(graph, layout = 'dendrogram', circular = TRUE) + \n  # 不画中心点，使用 filter 参数去掉 root（前面设置为\"all\"）节点及与其相连的边\n  # Do not show the center node. Use the filter parameter to remove the root node (previously set to \"all\") and its connected edges.\n  geom_edge_diagonal(aes(color = node1.node.branch,\n                         filter=node1.node.level!=\"all\"), \n                     alpha = 1/3,edge_width=1) + \n  geom_node_point(aes(size = node.size, \n                      color = node.branch,\n                      filter=node.level!=\"all\"), alpha = 1/3) + \n  scale_size(range = c(0.5,80)) + #做均一化处理，让点的大小介于range之间 # Normalize the points so that the size is between the range.\n  theme(legend.position = \"none\") + #不画图例 # Do not draw the legend.\n  \n  # 点和边的配色\n# Coloring of points and edges.\n  # 如果要改变边的配色，需要同时给边和点变色，否则会对应不上\n# If you want to change the edge color, you need to change both the edge and the points at the same time; otherwise, the colors will not match.\n  scale_edge_color_brewer(palette = \"Set1\") + #用?scale_color_brewer查看更多配色方案 # Use ?scale_color_brewer to view more color schemes\n  scale_color_brewer(palette = \"Set1\") +\n  \n  # 添加周围注释文字，此处是基因名gene\n# Add surrounding annotation text, here is the gene name\n  geom_node_text(\n    aes(\n      x = 1.048 * x, #控制字跟点的距离 # Control distance between the word and the dot\n      y = 1.048 * y, #控制字跟点的距离 # Control distance between the word and the dot\n      label = node.short_name,\n      angle = -((-node_angle(x, y) + 90) %% 180) + 90,\n      filter = leaf,\n      color = node.branch\n      ),\n    size = 6, hjust = 'outward') +\n  \n  # 添加内环文字，此处是通路名term\n# Add inner ring text, here is the pathway name\n  geom_node_text(\n    aes(label=node.short_name,\n        filter = !leaf & (node.level != \"all\"),\n        color = node.branch),\n    fontface=\"bold\",\n    size=6,\n    family=\"sans\"\n  ) + \n  theme(panel.background = element_rect(fill = NA)) +\n  coord_cartesian(xlim=c(-1.3,1.3),ylim = c(-1.3,1.3)) #扩大坐标系 # Expand the coordinate system\n\ngc\nggsave(\"ccgraph_color.pdf\", width = 14, height = 14)\n在上面的图形中，线条的颜色由\ngeom_edge_diagonal(aes(color = node1.node.branch))\n指定。\nIn the graph above, the line color is specified by\ngeom_edge_diagonal(aes(color = node1.node.branch))\n.\nnode1.node.branch\n指的是出发点（\nnode1\n）的\nnode.branch\n属性。如果要改变线条颜色，可以修改 nodes\n表，添加一个属性（如\ncolor\n） ，然后在\ngeom_edge_diagonal()\n中将其映射到\ncolor\n上即可。\nnode1.node.branch\nrefers to the\nnode.branch\nattribute of the starting point\n(\nnode1\n). To change the line color, modify the nodes table,\nadd an attribute (e.g.,\ncolor\n), and then map it to\ncolor\nin\ngeom_edge_diagonal()\n.\n按例文配色，然后后期加背景色\nFollow the example color scheme, then add a background color\nlater\n保留中心点和连向中心点的线 ｜ keep the center node and the links to\nit.\ngc1 <- ggraph(graph, layout = 'dendrogram', circular = TRUE) + \n  #画连线 # Draw the lines\n  geom_edge_diagonal(aes(color = node2.color), \n                     alpha = 0.5, #透明度 # Transparency\n                     edge_width=2.5) + #连线的粗细 # Line thickness\n  scale_edge_color_manual(values = c(\"#61C3ED\",\"red\",\"purple\",\"darkgreen\")) + #自定义颜色 # Custom color\n\n  #画点 # Draw the points\n  geom_node_point(aes(size = node.size), \n# Alpha = 1/3,\n                  color = \"#61C3ED\") + #统一为淡蓝色 # Unify the color to light blue\n  scale_size(range = c(0.5,80)) + #做均一化处理，让点的大小介于range之间 # Normalize the points so that the size is between the range\n  theme(legend.position = \"none\") + #不画图例 # Do not draw the legend\n  \n  # 添加周围注释文字，此处是基因名gene # Add surrounding annotation text, here is the gene name\n  geom_node_text(\n    aes(\n      x = 1.05 * x, #控制字跟点的距离 # Control the distance between the word and the point\n      y = 1.05 * y, #控制字跟点的距离 # Control the distance between the word and the point\n      label = node.short_name,\n      angle = -((-node_angle(x, y) + 90) %% 180) + 90,\n      filter = leaf\n      ),\n    color=\"black\", #统一为黑色字 # Uniformly use black text\n    size = 6, hjust = 'outward') +\n  \n  # 添加内环文字，此处是通路名term # Add inner ring text, here is the pathway name\n  geom_node_text(\n    aes(label=node.short_name,\n        filter = !leaf & (node.level != \"all\")\n        ),\n    color=\"black\", #统一为黑色字 # Uniformly use black text\n    fontface=\"bold\",\n    size=6,\n    family=\"sans\"\n  ) + \n  theme(panel.background = element_rect(fill = NA)) + #背景透明色 # Transparent background color\n  coord_cartesian(xlim=c(-1.3,1.3),ylim = c(-1.3,1.3)) #扩大坐标系 # Expand the coordinate system\n\ngc1\n后期处理\nPost-processing\n保存到pdf文件，是矢量图，可以用Illustrator等软件编辑图形、文字和背景\nSave to a PDF file, which is a vector image. You can edit the graphics,\ntext, and background using software such as Illustrator.\nggsave(\"ccgraph.pdf\",width = 14,height = 14)\n多层嵌套\nMulti-layer nesting\n这套代码不仅可以画两层的图，理论上支持更多层（要不然怎么叫“圆环套圆环”呢？）。\nThis code can not only draw two layers of graphs, but theoretically\nsupports more layers (otherwise, how can we say “rings within\ncircles”?).\n下面是一个例子，这里使用了常见的微生物组数据集（这是一个随机生成的\nOTU 表）。 Below is an example using a common microbiome dataset (a\nrandomly generated OTU table).\n#随机生成一套数据 # Generate a random data set\nn <- 1000\nmicrobiome <- data.frame(\n  otu = paste(\"OTU\",1:n,sep=\"_\"),\n  phylum = sample(paste(\"phylum\",1:5,sep=\"_\"),n,replace = T),\n  class = sample(paste(\"class\",6:30,sep=\"_\"),n,replace=T),\n  order = sample(paste(\"order\",31:80,sep=\"_\"),n,replace = T),\n  value = runif(n,min=1,max=1000)\n)\nhead(microbiome)\n\n#保存到文件，便于小白套用格式 # Save to a file for easy formatting\nwrite.csv(microbiome, \"microbiome.csv\", quote = F, row.names = F)\n加载输入数据 Load input data\nmicrobiome.csv，想画几层就给几+1列。这里前4列对应4层，最后一列是最底层节点对应的数值。\nmicrobiome.csv. Add as many layers as you want + 1 column. Here, the\nfirst four columns correspond to the four layers, and the last column is\nthe value corresponding to the bottom-level node.\nmicrobiome <- read.csv(\"microbiome.csv\", header = T)\nindex_micro <- c(\"phylum\",\"class\",\"order\") #除了最低层以外的列名 #Column names except the lowest level\nnodes_micro <- gather_graph_node(microbiome,index=index_micro,\n                                  root = \"bacteria\") #root名字自己随便取 #The root name can be chosen by yourself\nedges_micro <- gather_graph_edge(microbiome,index=index_micro,root = \"bacteria\")\n画图 Draw a picture\ngraph_micro <- tbl_graph(nodes_micro,edges_micro)\nggraph(graph_micro,layout = \"dendrogram\",circular=T) +\n  geom_edge_diagonal(aes(color = node1.node.branch,filter=node1.node.level!=\"bacteria\", alpha = node1.node.level),edge_width=1) + \n  geom_node_point(aes(size = node.size, color = node.branch,filter=node.level!=\"bacteria\"), alpha = 1/3) + \n  scale_size(range = c(0.5,80)) + #做均一化处理，让点的大小介于range之间 # Normalize the points so that they are within the range\n  theme(legend.position = \"none\")+ #不画图例 # Do not draw a legend\n  \n  scale_edge_color_brewer(palette = \"Set1\") + #用?scale_color_brewer查看更多配色方案 # Use ?scale_color_brewer to view more color schemes\n  scale_color_brewer(palette = \"Set1\") +\n\n  # 添加周围注释文字，此处是基因名gene\n# Add surrounding annotation text, here is the gene name\n  geom_node_text(\n    aes(\n      x = 1.058 * x, #控制字跟点的距离 # Distance between the control word and the point\n      y = 1.058 * y, #控制字跟点的距离 # Distance between the control word and the point\n      label = node.short_name,\n      angle = -((-node_angle(x, y) + 90) %% 180) + 90,\n      filter = leaf,\n      color = node.branch\n      ),\n    size = 1, hjust = 'outward') +\n  \n  # 添加内环文字，此处是通路名term\n# Add inner ring text, here is the pathway name\n  geom_node_text(\n    aes(label=node.short_name,\n        filter = !leaf & (node.level == \"phylum\"),\n        color = node.branch),\n    fontface=\"bold\",\n    size=6,\n    family=\"sans\"\n  ) + \n  theme(panel.background = element_rect(fill = NA)) +\n  coord_cartesian(xlim=c(-1.3,1.3),ylim = c(-1.3,1.3)) #扩大坐标系 # Expand the coordinate system\nggsave(\"ccgraph_microbiome.pdf\", width = 14, height = 14)\n参考资料\nReferences\nhttps://mp.weixin.qq.com/s/JNIncz3W-59yjGk2ibJWUw\nSession Information\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa153ccgraph_FigureYa153ccgraph",
      "title": "FigureYa153ccgraph/FigureYa153ccgraph.html",
      "html": "FigureYa153ccgraph/FigureYa153ccgraph.html",
      "text": "texts/main_FigureYa153ccgraph_FigureYa153ccgraph.txt",
      "folder": "FigureYa153ccgraph",
      "thumb": "gallery_compress/FigureYa153ccgraph.webp"
    },
    "word_count": 2228,
    "lines_count": 515,
    "title": "FigureYa153ccgraph",
    "description": "Requirement Description 用R从形式上复现原图。 Use R to reproduce the original figure in a formal manner.",
    "input_data_types": [
      "DNA-seq",
      "突变数据"
    ],
    "output_types": [
      "统计表格"
    ],
    "technical_methods": [
      "聚类分析",
      "通路分析"
    ],
    "biology_areas": [],
    "complexity_level": "高级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "values",
      "min",
      "header",
      "Alpha",
      "width",
      "circular",
      "ylim",
      "n"
    ]
  },
  {
    "id": "main_FigureYa60GSEA_clusterProfilerV3_FigureYa60GSEA_clusterProfilerV2",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa60GSEA_clusterProfilerV3_FigureYa60GSEA_clusterProfilerV2.txt",
    "content": "FigureYa60GSEA_clusterProfiler\nFigureYa60GSEA_clusterProfiler\nYing Ge ,Yijing Chen\n2025-5-20\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\nclusterProfiler的GSEA结果作为输入，画出像paper里这样美的GSEA结果图。\n关注“小丫画图”公众号（微信ID：FigureYa），回复“GSEA”，查看GSEA在paper里的高级用法。\nUse the GSEA results from clusterProfiler as input to draw a GSEA\nresult plot as beautiful as those in paper.\nFollow the “Xiaoya drawing” official account (WeChat ID: FigureYa),\nreply with “GSEA” to see advanced usage of GSEA in paper.\n出自\nhttps://www.nature.com/articles/s41467-018-06944-1\nfrom\nhttps://www.nature.com/articles/s41467-018-06944-1\n应用场景\nApplication scenario\n可用于在一张图上对比多个通路（上面的例图），以及同一通路多组间对比（下图）。\nIt can be used to compare multiple pathways on a single graph\n(example graph above), as well as to compare multiple groups of the same\npathway (graph below).\nclusterProfiler擅长做富集分析，可以用GO、KEGG、Diseaes、Reactome、DAVID、MSigDB、甚至自定义的注释库做富集分析。enrichplot丰富的画图函数几乎涵盖了所有富集分析结果的展示方式，\nhttp://bioconductor.org/packages/devel/bioc/vignettes/enrichplot/inst/doc/enrichplot.html\n。\n适用于：用clusterProfiler做了富集分析，想自己DIY结果图的小伙伴。\n如果想用Java版GSEA做富集分析，自己DIY结果图，请用FigureYa13GSEA_Java。\nclusterProfiler is good at enrichment analysis, you can use GO, KEGG,\nDiseaes, Reactome, DAVID, MSigDB, and even custom annotation libraries\nto do enrichment analysis. enrichplot’s rich drawing functions cover\nalmost all the ways of presenting enrichment analysis results,\nhttp://bioconductor.org/packages/devel/bioc/vignettes/enrichplot/inst/doc/enrichplot.html\n.\nSuitable for: those who have done enrichment analysis with\nclusterProfiler and want to DIY the result plot by themselves.\nIf you want to use Java version of GSEA to do enrichment analysis and\nDIY result plot by yourself, please use FigureYa13GSEA_Java.\n环境设置\nEnvironment setting\nsource(\"install_dependencies.R\")\n#use the domestic mirror installation package\n#BiocManager::install(\"clusterProfiler\", version = \"3.8\")\n\nlibrary(clusterProfiler)\nlibrary(enrichplot)\nlibrary(plyr)\nlibrary(ggrepel)\nlibrary(ggplot2)\nlibrary(RColorBrewer)\nlibrary(gridExtra)\n\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 display English error messages\noptions(stringsAsFactors = FALSE) #禁止chr转成factor prohibit the conversion of chr to factor\n参数设置\nParameter setting\n此处我们选择“hsa04110”这条通路，突出显示这两条通路里的几个基因。\nHere we select the pathway “hsa04110” to highlight a few genes in\nthese two pathways.\n# 要画的通路\n# pathway to be drawn\ngeneSetID <- c(\"hsa04110\")\n输入文件的准备\nInput file preparation\n下面这段代码仅仅为了获得clusterProfiler格式的GSEA结果。\n有关用clusterProfiler做GSEA的问题，建议加入Y叔知识星球biobabble提问。\nThe following code is just to get the GSEA results in clusterProfiler\nformat.\nFor questions about GSEA with clusterProfiler, it is recommended to\njoin Uncle Y’s Knowledge Planet biobabble to ask questions.\n把clusterProfiler的GSEA结果输出到文件\nOutput the GSEA results of clusterProfiler to file\neasy_input_rnk.txt：包含两列，基因名（SYMBOL）、变化倍数（logFC）\n参考《\n听说你有RNAseq数据却不知道怎么跑GSEA\n》\neasy_input_rnk.txt: contains two columns, gene name (SYMBOL), fold\nchange (logFC)\nRefer to 《\nI heard you have\nRNAseq data but don’t know how to run GSEA\n》\ngsym.fc <- read.table(\"easy_input_rnk.txt\", header = T)\ndim(gsym.fc)\nhead(gsym.fc)\n#把gene symbol转换为ENTREZ ID\n#此处物种是人，其他物种的ID转换方法，请参考FigureYa52GOplot\n#convert gene symbol to ENTREZ ID.\n#the species here is human, for ID conversion methods of other species, please refer to FigureYa52GOplot\ngsym.id <- bitr(gsym.fc$SYMBOL, fromType = \"SYMBOL\", toType = \"ENTREZID\", OrgDb = \"org.Hs.eg.db\")\n#head(gsym.id)\n#dim(gsym.id)\n\n#让基因名、ENTREZID、foldchange对应起来\n#make gene names, ENTREZID, foldchange correspond\ngsym.fc.id <- merge(gsym.fc, gsym.id, by=\"SYMBOL\", all=F)\n#head(gsym.fc.id)\n\n#按照foldchange排序\n#sort by foldchange\ngsym.fc.id.sorted <- gsym.fc.id[order(gsym.fc.id$logFC, decreasing = T),]\n#head(gsym.fc.id.sorted)\n\n#获得ENTREZID、foldchange列表，做为GSEA的输入\n#get ENTREZID, foldchange list as input to GSEA\nid.fc <- gsym.fc.id.sorted$logFC\nnames(id.fc) <- gsym.fc.id.sorted$ENTREZID\n#head(id.fc)\n\n#查看clusterProfiler用法\n#view clusterProfiler usage\n#browseVignettes(\"clusterProfiler\")\n\n#这一条语句就做完了KEGG的GSEA分析\n#this single statement does the GSEA analysis of KEGG\nkk <- gseKEGG(id.fc, organism = \"hsa\")\ndim(kk)\n#head(kk)\n\n#把ENTREZ ID转为gene symbol，便于查看通路里的基因\n#convert ENTREZ ID to gene symbol for easy viewing of genes in the pathway\nkk.gsym <- setReadable(kk, 'org.Hs.eg.db', #物种 species\n                    'ENTREZID')\n\n#按照enrichment score从高到低排序，便于查看富集的通路\n#sort by enrichment score from highest to lowest for easy viewing of enriched pathways\nsortkk <- kk.gsym[order(kk.gsym$enrichmentScore, decreasing = T),]\n#head(sortkk)\n#tail(sortkk)\n\n#把富集的通路列表输出到文件\n#output the list of enriched pathways to a file\nwrite.csv(sortkk,\"gsea_output.csv\", quote = F, row.names = F)\n“gsea_output.csv”文件可作为文章的Supplementary File。\n“gsea_output.csv” file can be used as the Supplementary File for the\narticle.\nDIY多条通路\nDIY multiple pathways\n提取包里的gseaplot2函数，压缩成小白能看懂的语句，加以注释，就可以按照自己的审美修改参数啦！\nExtract the gseaplot2 function from the package, compress it into a\nstatement understandable to a beginner, and comment it out so that you\ncan modify the parameters according to your own aesthetics!\nx <- kk\ngeneList <- position <- NULL ## 满足codetool to satisfy codetool\n\n#合并多条通路的数据\n#merge data from multiple pathways\ngsdata <- do.call(rbind, lapply(geneSetID, enrichplot:::gsInfo, object = x))\ntable(gsdata$geneList==gsym.fc.id.sorted$logFC) #geneList即logFC geneList is logFC\ngsdata$gsym <- rep(gsym.fc.id.sorted$SYMBOL,length(geneSetID))\n\n# 画running score\n# draw running score\ngsdata <- gsdata[gsdata$position==1,]\np.res <- ggplot(gsdata ,aes(x = x, y = runningScore, color = geneList)) + \n  geom_line(size = 0.75) +\n  geom_bar(stat = 'identity', position = 'identity', size = 0.25) + \n  geom_point(shape = 16, size = 1.5) + \n  geom_hline(yintercept = 0, colour = \"black\") + \n  scale_x_continuous(breaks = c(1,5000,10000,15000,nrow(gsym.fc.id.sorted)), \n                     limits = c(0, nrow(gsym.fc.id.sorted)),\n                     expand = c(0.02,0)) + \n  \n  scale_color_gradient2(low = \"#1874CD\", mid = \"gray80\", high = \"#EE2C2C\", midpoint = 0, name = \"log2FoldChange\")+\n  labs(y='Enrichment Score', x=\"Genes ranked by log2FoldChange\") +   \n  theme(  plot.title = element_text(size = 12), \n          plot.background = element_blank(), \n          panel.background=element_blank(),\n          panel.grid=element_blank(),\n          panel.border = element_rect(fill = NA, size = 1), \n          axis.title.y = element_text(size = 12), \n          axis.title.x=element_text(size = 12), \n          axis.text.y = element_text(size = 12, color = \"black\"), \n          axis.text.x = element_blank(), \n          axis.ticks.y = element_line(size = 1, color = \"black\"), \n          axis.ticks.x = element_blank()) + \n  theme(  legend.background = element_blank(), \n          legend.direction = \"horizontal\",\n          legend.key = element_blank(), \n          legend.position = c(1,1),\n          legend.justification = c(1,1))\np.res\n# 保存到PDF文件\n# save to PDF file\nggsave(\"GSEA_pathways.pdf\", width=6, height=3.8)",
    "chapter_info": {},
    "word_count": 785,
    "lines_count": 191,
    "title": "FigureYa60GSEA_clusterProfiler",
    "description": "Requirement description clusterProfiler的GSEA结果作为输入，画出像paper里这样美的GSEA结果图。 关注“小丫画图”公众号（微信ID：FigureYa），回复“GSEA”，查看GSEA在paper里的高级用法。",
    "input_data_types": [],
    "output_types": [
      "统计表格"
    ],
    "technical_methods": [
      "通路分析"
    ],
    "biology_areas": [],
    "complexity_level": "高级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "colour",
      "key",
      "header",
      "width",
      "grid",
      "object",
      "name",
      "direction",
      "limits"
    ]
  },
  {
    "id": "main_FigureYa168legoplot_FigureYa168legoplot",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa168legoplot_FigureYa168legoplot.txt",
    "content": "FigureYa168legoplot\nFigureYa168legoplot\nAuthor(s)\n: Bin Wei\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement\n从基因组中获取突变位点context序列，用乐高图展示突变模式。\n顺便画个pie。 Extract the context sequence of the mutation site from the\ngenome and use a Lego plot to display the mutation pattern. Draw a pie\nchart as well.\n出自\nhttps://onlinelibrary.wiley.com/doi/full/10.1111/cas.14113\nFrom\nhttps://onlinelibrary.wiley.com/doi/full/10.1111/cas.14113\nFigure 2 Mutational signatures extracted from the aggregated NSCLC\ndataset. A, Lego plot representation of mutation patterns in 113 NSCLC\nsamples. Single-nucleotide substitutions are divided into 6 categories\nwith 16 surrounding flanking bases. The pie chart in the upper left\nshows the proportion of 6 categories of mutation patterns.\n图的解读\nInterpretation\n每种颜色内部是4X4结构，刚好对应TCGA四种碱基。因此，比通常所用的柱形图（例文Figure\n2 B）更适合展示四种碱基的关系。 Each color contains a 4x4 structure,\ncorresponding to the four TCGA bases. Therefore, this chart is more\nsuitable for displaying the relationships between the four bases than\nthe commonly used bar chart (see Figure 2 B).\n至于6种颜色，你也可以画成1X6结构，作者画成2X3结构会更节省空间。 As\nfor the six colors, you could also plot them in a 1x6 structure, but the\nauthor’s 2x3 structure saves space.\n柱子的高度代表第3种特征（这里是计数），除了柱子的形式以外，你也可以尝试换成圆点，用圆点大小来代替柱子的高度。或者把柱子换成热图，用颜色深浅代替柱子的高度。\nThe height of the bar represents the third feature (here, the count).\nBesides using the bar format, you could also try using dots, with the\nsize of the dots representing the bar height. Alternatively, you could\nuse a heat map, with the depth of the color representing the bar\nheight.\n应用场景\nApplication Scenarios\n同时展示3种特征。尤其适合其中一种特征具有m X\nn的特性的情况，例如文中的4种碱基 X 4种碱基。 Simultaneously displaying\nthree features is particularly suitable when one of the features has an\nm x n structure, such as the 4 bases x 4 bases in the article.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nif (!requireNamespace(\"BiocManager\", quietly = TRUE))\n  install.packages(\"BiocManager\")\nif (!(\"BSgenome.Hsapiens.UCSC.hg19\" %in% rownames(installed.packages()))) {\n  BiocManager::install(\"BSgenome.Hsapiens.UCSC.hg19\")\n}\nif (!(\"VariantAnnotation\" %in% rownames(installed.packages()))) {\n  BiocManager::install(\"VariantAnnotation\")\n}\nif (!(\"rgl\" %in% rownames(installed.packages()))) {\n  install.packages(\"rgl\")\n}\n\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 #Display English error message\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # Disable conversion of chr to factor\n加载自定义函数 Load custom functions\nsource(\"functions.R\")\n输入文件\nInput file\neasy_input.txt，突变数据，来自文章附件cas14113-sup-0002-tables1.xlsx。\neasy_input.txt, mutation data, from the article attachment\ncas14113-sup-0002-tables1.xlsx.\n不仅限于突变数据，如果你的数据已经整理成very_easy_input.csv格式，就跳过这步，直接进入“开始画图”。\nThis is not limited to mutation data. If your data is already organized\nin the very_easy_input.csv format, skip this step and proceed directly\nto “Start Plotting.”\ndata <- read.delim(\"easy_input.txt\", \n                   header=T, \n                   sep=\"\\t\", \n                   as.is=T)\nhead(data)\n参数设置\nParameter settings\n# 输出的文件名前缀，即以什么开头\n# 这里输出的文件名以test开头\n# Output file name prefix, i.e., what it starts with\n# The output file name starts with test\noutprefix <- \"test\"\n从基因组中获取突变位点context\nGet mutation site context from the genome\ndata <- data[data$Variant_Type==\"SNP\", ]\ndata <- data[data$Chromosome %in% (c(1:22, \"X\", \"Y\", \"M\")), ]\n\n# 获取突变形式 # Get mutation type\nmut_type_list <- apply(data, \n                       1, \n                       get.mutationtype, ref=\"Reference_Allele\", alt=\"Tumor_Seq_Allele2\")\nmut_type <- as.character(sapply(mut_type_list, function(x) x[[1]]))\nmut_reverse <- as.character(sapply(mut_type_list, function(x) x[[2]]))\ndata$mut_type <- mut_type\ndata$mut_reverse <- mut_reverse\n\n# 获取突变context\n# Get mutation context\n# 注：由于该步运行较慢，因此直接使用保存好的data.RData文件中的对象即可\n# Note: Because this step runs slowly, you can directly use the object in the saved data.RData file.\n#mut_context <- apply(data, \n#                     1, \n#                     get.mutationcontext, genome=Hsapiens, chrom=\"Chromosome\", start=\"Start_position\", reverse=\"mut_reverse\")\n#data$mut_context <- mut_context\n\n# 保存到文件\n# Save to file\n#write.csv(data[,c(13,15)], \"very_easy_input.csv\", quote = F, row.names = F)\n开始画图\nStart drawing\n画lego图\nDrawing a Lego Chart\nlego图参考了barplot3d包的源码，在其基础上进行了修改，这个R包链接为\nhttps://cran.r-project.org/web/packages/barplot3d/vignettes/barplot3d.html\nThe Lego chart is based on the source code of the barplot3d package,\nwith some modifications. The link to this R package is\nhttps://cran.r-project.org/web/packages/barplot3d/vignettes/barplot3d.html\nvery_easy_input.csv，包含两列，第一列mut_type对应图中的6种颜色，第二列mut_context对应每种颜色中的16个柱子，柱子的高度代表数量。套用自己的数据即可。\nvery_easy_input.csv contains two columns: the first column, mut_type,\ncorresponds to the six colors in the chart, and the second column,\nmut_context, corresponds to the 16 bars in each color. The height of the\nbar represents the number of bars. Simply apply your own data.\ndata <- read.csv(\"very_easy_input.csv\")\nhead(data)\ntable(data$mut_type)\ntable(data$mut_context)\n# 注：复现图的配色以及顺序和原文不太一样。原文的饼图和lego图顺序不一致，看起来有点奇怪。\n# Note: The color scheme and order of the reproduced chart differ from the original. The order of the pie chart and the Lego chart in the original is inconsistent, which makes it look a bit strange.\npalettecolors <- c(\"#805D3F\", \"#72549A\", \"#5EAFB2\", \"#3F4F9D\", \"#F2EC3C\", \"#74B655\") #颜色必须是6个\nmut_types <- c(\"C>T\", \"C>A\", \"C>G\", \"T>G\", \"T>C\", \"T>A\")\ncontexts <- c(\"T_T\", \"C_T\", \"A_T\", \"G_T\", \"T_C\", \"C_C\", \"A_C\", \"G_C\",\n         \"T_A\", \"C_A\", \"A_A\", \"G_A\", \"T_G\", \"C_G\", \"A_G\", \"G_G\")\ntypeorder <- c()\nfor(type in mut_types){\n    typeorder <- c(typeorder, paste(type, contexts, sep=\".\"))\n}\n\n# 计数\n# count\nmut_data <- table(paste0(as.character(data$mut_type), \".\", as.character(data$mut_context)))\nmut_data <- mut_data[typeorder]\n\n# 运行下面这段，会跳出画图窗口，用鼠标拖拽到合适的角度、拉伸窗口到合适的大小后，保存图。\n# Run the following code to open a plot window. Drag the mouse to the desired angle and size, then save the plot.\nlegoplot.3d(mut_data, \n            scalez=0.015, \n            zlab=\"Mutations\", \n            palettecolors=palettecolors)\n# 可以在弹出窗口手动调整图形方向，然后运行以下命令保存为pdf文件\n# You can manually adjust the plot orientation in the pop-up window, then run the following command to save as a PDF file.\n#rgl.postscript(paste0(outprefix, \"_legoplot.pdf\"), \n#               fmt=\"pdf\")\n有时我们希望同一篇文章中的多个3D图形保持同一角度来展示，那就把角度保存下来，每次画图都加载这个角度。\nSometimes, we want to display multiple 3D plots in the same article at\nthe same angle. To do this, save the angle and use it each time you\ndraw.\n#把手动调好3D图形位置、角度保存到文件\n# Save the manually adjusted 3D graph position and angle to a file\nmyMatrix <- par3d()\nuserMatrix <- myMatrix$userMatrix\nwindowRect <- myMatrix$windowRect\n# 把角度保存到文件\n# Save the angle to a file\nsave(userMatrix, windowRect, file = \"par3d.RData\")\n载入之前调好的角度画图 Load the previously adjusted angle to draw the\ngraph\n(load(\"par3d.RData\"))\npar3d(userMatrix=userMatrix,\n      windowRect=windowRect)\n\n# 保存到pdf文件\n# Save to PDF file\n#rgl.postscript(paste0(outprefix, \"_legoplot.pdf\"), \n#               fmt=\"pdf\")\n画饼图\nDraw the pie chart\npie_data <- round(table(as.character(data$mut_type)) * 100 / length(data$mut_type), digits=2)\npie_data <- pie_data[mut_types]\nlabel <- paste(names(pie_data), paste0(pie_data,\"%\"))\n\npdf(paste0(outprefix, \"_pieplot.pdf\"))\npie(pie_data, \n    label, \n    col=palettecolors)\ndev.off()\n后期处理\nPost-processing\n输出的PDF文件可以使用AI打开，拼接 The output PDF file can be opened\nand spliced using AI.\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa168legoplot_FigureYa168legoplot",
      "title": "FigureYa168legoplot/FigureYa168legoplot.html",
      "html": "FigureYa168legoplot/FigureYa168legoplot.html",
      "text": "texts/main_FigureYa168legoplot_FigureYa168legoplot.txt",
      "folder": "FigureYa168legoplot",
      "thumb": "gallery_compress/FigureYa168legoplot.webp"
    },
    "word_count": 899,
    "lines_count": 201,
    "title": "FigureYa168legoplot",
    "description": "Requirement 从基因组中获取突变位点context序列，用乐高图展示突变模式。 顺便画个pie。 Extract the context sequence of the mutation site from the",
    "input_data_types": [
      "DNA-seq",
      "突变数据"
    ],
    "output_types": [
      "热图",
      "统计表格"
    ],
    "technical_methods": [],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "windowRect",
      "header",
      "chrom",
      "col",
      "ref",
      "scalez",
      "alt",
      "is",
      "LANGUAGE"
    ]
  },
  {
    "id": "main_FigureYa227boxdensity_FigureYa227boxdensity",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa227boxdensity_FigureYa227boxdensity.txt",
    "content": "FigureYa227boxdensity\nFigureYa227boxdensity\nAuthor(s)\n: Xiaofan Lu\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n用高逼格的方式展示两组之间对于索拉菲尼药物治疗敏感性的差异。。也是出自上次那个药物敏感的文章。。\nRequirement Description\nThe difference in susceptibility to sorafenib between the two groups\nis also from the previous article on drug sensitivities.\n出自\nhttps://academic.oup.com/bib/advance-article/doi/10.1093/bib/bbaa164/5891146\nfrom\nhttps://academic.oup.com/bib/advance-article/doi/10.1093/bib/bbaa164/5891146\nFigure 5. Identification of candidate agents with higher drug\nsensitivity in high-PPS score patients. (D) Comparison of estimated\nsorafenib’s sensitivity (logAUC) between PI3K-MTOR altered and unaltered\ngroups.\n另外，FigureYa212drugTargetV2复现了例文的Figure\n5FG，利用细胞系表达谱（CCLE）及药敏结果（PRISM和CTRP），预测癌症样本的药敏结果。\nFigureYa213customizeHeatmap复现了Figure 6，实现CMap\nanalysis及画图。\nIn addition, FigureYa212drugTargetV2 reproduces Figure 5FG in the\nexample to predict the antimicrobial susceptibility of cancer samples\nusing cell line expression profiling (CCLE) and drug susceptibility\nresults (PRISM and CTRP).\nFigureYa213customizeHeatmap reproduces Figure 6 to implement CMap\nanalysis and drawing.\n应用场景\n绘制箱线图时同时给出数据的密度分布图，叠加展示美美哒～\n类似的，FigureYa68friends曾画过一半小提琴、一半box plot和散点图。\nApplication Scenarios\nWhen drawing the box plot, the density distribution map of the data\nis given at the same time, and the beauty is displayed on a superimposed\nbasis~\nSimilarly, FigureYa68friends has drawn half violin, half box plot,\nand scatter plot.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nlibrary(ggplot2)\nlibrary(data.table)\nlibrary(aplot)\nlibrary(ggpubr)\nlibrary(dplyr)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # error messages are displayed in English\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # chr is not allowed to be converted to factor\n输入文件\neasy_input.csv，包含三列，后两列必需：分组信息Subtype和每个sample对应的AUC。\nInput the file\neasy_input.csv, it contains three columns, the last two columns are\nrequired: the grouping information Subtype and the AUC corresponding to\neach sample.\n# 加载模拟数据(因为是用ggplot做，所以多个组都可以)\n# Load simulation data (because it is done with ggplot, so multiple groups are OK)\ndf <- read.table(\"easy_input.txt\",sep = \"\\t\",row.names = NULL,check.names = F,stringsAsFactors = F,header = T)\nhead(df)\n# 计算p值\n# 这里是多组，用kruskal.test函数，还可以改为aov\n# 如果是两组，可以改为t.test，或wilcox.test\n# Calculate the p-value\n# Here are multiple groups, use the kruskal.test function, and you can change it to aov\n# If there are two groups, you can change it to t.test, or wilcox.test\np.val <- kruskal.test(AUC ~ Subtype,\n                      data = df)\np.lab <- paste0(\"P\",\n                ifelse(p.val$p.value < 0.001, \" < 0.001\",\n                       paste0(\" = \",round(p.val$p.value, 3)))) \np.lab\n开始画图\nStart drawing\n# 设置颜色\n# Set the color\ngreen <- \"#C7EAB2\"\ncyan <- \"#5FC1C2\"\nblue <- \"#1B90BE\"\n\n# 绘制上半部分密度图\n# Draw the density map of the upper half\np_top <- ggplot(df, aes(x = AUC, color = Subtype, fill = Subtype)) +\n  geom_density() +\n  # 让箱子的所有位置都颜色统一，如例文所示\n  # Make all positions of the box uniform in color, as shown in the example\n  scale_color_manual(values = c(alpha(green,0.7),alpha(cyan,0.7),alpha(blue,0.7))) + # 设置透明色 # Set the transparent color\n  scale_fill_manual(values = c(alpha(green,0.7),alpha(cyan,0.7),alpha(blue,0.7))) +\n  theme_classic() + # 如果显示采用这一行 # Use this line if you want to display\n   \n  # 这里提取输入文件的第一列药物名称，写入x轴标签\n  # Here extract the drug name in the first column of the input file and write it to the x-axis label\n  xlab(paste0(\"Estimated AUC of \", unique(df$Drug))) + \n  # 第一列非必需，可以像下面这样直接写xlab\n  # The first column is not required, you can write xlab directly like the following xlab(\"Estimated AUC of Cisplatin\") +\n  \n  ylab(NULL) + \n  theme(legend.position = \"none\", \n        legend.title = element_blank(),\n        axis.text.x = element_text(size = 12,color = \"black\"),\n        axis.text.y = element_blank(), # 原文不显示纵轴的密度 # The original text does not show the density of the vertical axis\n        #axis.text.y = element_text(size = 12,color = \"black\"), # 如果要显示采用这一行 # If you want to display ,youcan use this line\n        axis.ticks.y = element_blank(),\n        axis.line.y = element_blank(),\n        panel.background = element_blank(),\n        panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank()) +\n  geom_rug()\np_top\n# 画box plot\n# Draw a box plot\np_bot <- ggplot(df, aes(Subtype, AUC, fill = Subtype)) + \n  geom_boxplot(aes(col = Subtype)) + \n  scale_fill_manual(values = c(green, cyan, blue)) + \n  scale_color_manual(values = c(green, cyan, blue)) + \n  xlab(NULL) + ylab(\"Estimated AUC\") + \n  theme_void() +\n  theme(legend.position = \"right\",\n        legend.title = element_blank(),\n        axis.text.x = element_blank(), # 原文不显示箱线图的x轴 # The original text does not show the x-axis of the boxplot\n        #axis.text.x = element_text(size = 12,color = \"black\"), # 如要显示箱线图x轴采用这一行 # If you want to display the boxplot x-axis, use this row\n        axis.text.y = element_text(size = 11,color = \"black\"),\n        panel.background = element_blank(),\n        panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank()) + \n  annotate(geom=\"text\",\n           x = 1.5,\n           hjust = 1,\n           y = max(df$AUC),\n           size = 4, angle = 270, fontface = \"bold\",\n           label = p.lab) +\n  coord_flip() # 翻转图像 # Flip the image\n\n# 用白色标记箱子的基本统计量\n# Mark the basic stats of the box in white\ndat <- ggplot_build(p_bot)$data[[1]]\np_bot <- p_bot + geom_segment(data=dat, aes(x=xmin, xend=xmax, y=middle, yend=middle), color=\"white\", inherit.aes = F)\np_bot\n# 使用aplot拼图，底部箱型图稍微小一些 \n# Use the aplot puzzle and make the bottom box plot slightly smaller\np <- p_top %>% insert_bottom(p_bot, height = 0.4)\npdf(file = \"boxdensity.pdf\", width = 6,height = 3)\np\ninvisible(dev.off())\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa227boxdensity_FigureYa227boxdensity",
      "title": "FigureYa227boxdensity/FigureYa227boxdensity.html",
      "html": "FigureYa227boxdensity/FigureYa227boxdensity.html",
      "text": "texts/main_FigureYa227boxdensity_FigureYa227boxdensity.txt",
      "folder": "FigureYa227boxdensity",
      "thumb": "gallery_compress/FigureYa227boxdensity.webp"
    },
    "word_count": 753,
    "lines_count": 151,
    "title": "FigureYa227boxdensity",
    "description": "用高逼格的方式展示两组之间对于索拉菲尼药物治疗敏感性的差异。。也是出自上次那个药物敏感的文章。。 Requirement Description The difference in susceptibility to sorafenib between the two groups",
    "input_data_types": [
      "临床数据"
    ],
    "output_types": [
      "散点图",
      "热图",
      "统计表格",
      "箱线图"
    ],
    "technical_methods": [
      "生存分析"
    ],
    "biology_areas": [
      "癌症研究",
      "药物研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "label",
      "values",
      "header",
      "width",
      "xend",
      "col",
      "major",
      "minor",
      "angle"
    ]
  },
  {
    "id": "main_FigureYa287L2logV2_FigureYa287L2log",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa287L2logV2_FigureYa287L2log.txt",
    "content": "FigureYa287L2logV2\nFigureYa287L2logV2\nAuthor(s)\n: Xiaofan Lu; Yasi Zhang\nReviewer(s)\n: Ying Ge\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirements Description\n这篇文章Fig4的a，b，c；实现以下关键词：nested cross-validation；\nHolm–Bonferroni correction for multiple hypotheses； L2-regularized\nclassifiers\nThis study’s Figure 4 panels a, b, and c demonstrate the\nimplementation of the following key methodologies: Nested\ncross-validation, Holm-Bonferroni correction for multiple hypothesis\ntesting, L2-regularized classifiers\n出自\nhttps://www.nature.com/articles/s43018-021-00190-z\n图4 |\n在发现队列中，全角蛋白富集配对的治疗前和治疗中活检组织的数字空间分析(DSP)与病理完全缓解相关，且优于现有标志物。通过嵌套交叉验证(基于双侧t检验)和Holm-Bonferroni多重假设检验校正，比较了不同模型的AUROC性能(发现/训练队列，n=23例具有两个时间点配对数据的患者)。a-c，使用具有治疗前和治疗中DSP全角蛋白富集数据的病例(共23个生物学独立病例)生成ROC曲线。\na，使用治疗前、治疗中以及治疗前+治疗中(‘on-treatment +\npre-treatment’)DSP蛋白标志物平均值(跨感兴趣区域平均)训练的L2正则化分类器的ROC曲线及统计学比较。AUC表示曲线下面积。\nb，使用全部标志物、肿瘤标志物和免疫标志物平均值训练的治疗前+治疗中DSP蛋白L2正则化分类器的ROC曲线及统计学比较。本分析使用了两个时间点跨区域平均的标志物值。\nc，治疗前+治疗中DSP蛋白L2正则化分类器与基于雌激素受体和PAM50状态训练的模型的ROC曲线及统计学比较。这两个模型进一步与整合了治疗前+治疗中DSP蛋白数据、雌激素受体和PAM50状态的模型进行比较。\nSource:\nhttps://www.nature.com/articles/s43018-021-00190-z\nFig. 4 | DSP of pan-CK-enriched paired pre- and on-treatment biopsies\nis associated with pathological complete response in the discovery\ncohort and outperforms established markers. The AUrOC performance of\nvarious models was compared using nested cross-validation (based on a\ntwo-sided t-test) with Holm–Bonferroni correction for multiple\nhypotheses in the discovery (training) cohort (n = 23 patients with\npaired data for both time points). a–c, ROC curves were generated using\ncases with DSP pan-CK-enriched data from both the pre-treatment and\non-treatment time points (23 biologically independent cases were used in\nthese analyses).\na, ROC curves and statistical comparison of L2-regularized\nclassifiers trained using DSP protein marker mean values (averaged\nacross rOIs) pre-treatment, on-treatment and the combination of\npre-treatment and on-treatment (‘on-treatment + pre-treatment’). AUC,\narea under the curve.\nb, ROC curves and statistical comparison of DSP protein on-treatment\n+ pre-treatment L2-regularized classifiers trained using all marker,\ntumor marker and immune marker mean values. Cross-region mean marker\nvalues from both the pre-treatment and on-treatment time points were\nused in this analysis.\nc, ROC curves and statistical comparison of the on-treatment +\npre-treatment DSP protein L2-regularized classifier to a model trained\nusing estrogen receptor and PAM50 status. These two models were compared\nto a model that incorporates on-treatment + pre-treatment DSP protein\ndata, estrogen receptor and PAM50 status.\n应用场景\nApplication Scenario\n实现nested cross-validation, holm-bonferroni correction for multiple\nhypotheses, 以及L2-regularized classifiers\nImplements nested cross-validation, Holm-Bonferroni correction, and\nL2-regularized classifiers\n重要：请先阅读当前文件夹下的README.txt文件，了解各函数的用法，参数，注意事项。\nImportant: Please read README.txt first to understand function usage,\nparameters and notes.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(rms)\nlibrary(pROC)\nlibrary(ggplot2)\nlibrary(glmnet)\n# 显示英文报错信息\n# Show English error messages\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止chr转成factor\n# Prevent character to factor conversion\noptions(stringsAsFactors = FALSE)\n自定义函数\nCustom Functions\n# 构建一个函数Calculate01()，该函数可以计算一个向量中0，1的数目并返回一个计数向量\n# Build a function Calculate01() that can count the number of 0s and 1s in a vector and return a count vector\nCalculate01<-function(ob){\n  Negative=0\n  Positive=0\n  for (i in 1:length(ob)){\n    if (ob[i] == 0){Negative = Negative +1}\n    if (ob[i] == 1){Positive = Positive +1}\n  }\n  result<-c(Positive,Negative)\n  names(result)<-c(\"Positive\",\"Negative\")\n  return(result)\n}\n\n# 构建一个函数str_sample(),用于进行分层抽样\n# Build a function str_sample() for stratified sampling\nstr_sample<-function(data,strataname,size){\n  sample_vec<-data[,strataname]\n  select0_amount<-size[1]\n  select1_amount<-size[2]\n  select0_id<-sample(which(sample_vec==0),size=select0_amount,replace=F)\n  select1_id<-sample(which(sample_vec==1),size=select1_amount,replace=F)\n  result<-data.frame(select=c(select0_id,select1_id))\n  return(result)\n}\n\n\n# 构建一个函数strata_nfolds()，用于分层抽样来构建交叉验证中每一折的样本，保证每一折都包含至少两种不同类型的样本,每折所包含的样本的编号用列表形式进行返回\n# data为包含各建模特征，且二分类outcome列名为“outcome”并处于最后一列的数据框,注意：二分类outcome要以0，1表示\n# nfolds为分层折叠的折叠数\n# Create a strata_nfolds() function for stratified sampling to construct cross-validation folds, ensuring each fold contains at least two different sample types. Returns fold sample indices as a list.\n# data: Dataframe containing modeling features with binary \"outcome\" column (values 0/1) as last column\n# nfolds: Number of stratified folds\nstrata_nfolds<-function(data,nfolds){\n  lst<-list()\n  nsamples_everyfold<-round(nrow(data)/nfolds)\n  pandn_numbers<-Calculate01(data[,ncol(data)])\n  if (nfolds > min(pandn_numbers)) {stop(\"请合理设置折叠数（折叠数不能超过二分类变量中最少类别的样本数）\")}\n  if (pandn_numbers[1] >= pandn_numbers[2]){\n    # 计算出每一折中不同类别的样本个数，这样可以保证每一折中都会存在而分类中的小群体样本\n    # Calculate the number of samples for each class in every fold to ensure the minority class samples are represented in all folds\n    nnegative_everyfold <<- round(pandn_numbers[2]/nfolds)\n    npositive_everyfold <<- nsamples_everyfold - nnegative_everyfold\n  }\n  if(pandn_numbers[1] < pandn_numbers[2]){\n    npositive_everyfold <<- round(pandn_numbers[1]/nfolds)\n    nnegative_everyfold <<- nsamples_everyfold - npositive_everyfold\n  }\n  mydata<-data\n  mydata_backup<-data\n  \n  # 稍后用来构建已经抽选出来的所有样本的编号，从而得到最后一折的样本编号\n  # Later used to compile indices of all selected samples to obtain the indices for the final fold\n  id_vec_already<-c()\n\n  for (i in 1:nfolds){\n    if (i != nfolds){\n      mystrata<-str_sample(mydata,strataname=\"outcome\",size=c(nnegative_everyfold,npositive_everyfold))\n      \n      # 获取抽样的样本编号向量，但注意此处的id_vec为字符串形式的\n      # Get the sampled index vector (note: id_vec is in string format)\n      id_vec<-rownames(mydata)[mystrata[,1]]\n      id_vec<-as.numeric(id_vec)\n      \n      # 除去已经被抽选出来的样本\n      # Exclude samples that have already been selected\n      mydata<-mydata[-mystrata[,1],]\n      id_vec_already<-c(id_vec_already,id_vec)\n      lst[[i]]<-id_vec\n    }\n    if (i == nfolds){\n      id_vec<-rownames(mydata_backup[-id_vec_already,])\n      id_vec<-as.numeric(id_vec)\n      lst[[i]]<-id_vec}}\n  return(lst)\n}\n\n#构建一个函数logis_cal(),用于计算线性outcome的对应归一化outcome\n# Build a function logis_cal() to calculate normalized outcomes corresponding to linear outcomes\nlogis_cal<-function(x){\n  m<-1/(1+exp(-x))\n  return(m)\n}\n\n# 构建一个函数logis_straCV()，可进行分层交叉验证，得出最佳lambda\n# Build a function logis_straCV() to perform stratified cross-validation and determine the optimal lambda\nlogis_straCV<-function(li,data,nfolds,formula){\n  \n  #构建误判率向量\n  # Build a misclassification rate vector\n  miserror<-c()\n  \n  # 所有尝试的正则项系数lambda的向量，以0.03为步长，从0.03到9.99\n  # A vector of all attempted regularization coefficients lambda, ranging from 0.03 to 9.99 with a step size of 0.03\n  lambda_vec<-seq(from=0.03,to=9.99,by=0.03)\n  for (i in 1:nfolds){#开始内层交叉验证\n    validation<-data[li[[i]],]\n    train<-data[-li[[i]],]\n    for (mylambda in lambda_vec){\n      model<-lrm(formula = formula,\n                 train,\n                 x = T,\n                 y = T,\n                 penalty = mylambda)\n      \n      # 计算验证集得分\n      # Calculate validation set scores\n      coe<-model$coefficients\n      for (n in 1:length(coe)){\n        if (n == 1) {Score = rep(coe[n],nrow(validation))}\n        if (n != 1) {\n          \n          # name11是为了防止与数据中有名字为“name”的列撞名\n          # name11 is used to prevent naming conflicts with columns named \"name\" in the data\n          name11 = names(coe)[n]\n          Score = Score + coe[n]*validation[,name11]}\n      }\n      probs<-apply(matrix(Score,ncol = 1),MARGIN = 1,FUN = logis_cal)\n      pred_result<-ifelse(probs>0.5,1,0)\n      misclasserror <- mean(pred_result != data[,(\"outcome\")])\n      miserror<-c(miserror,misclasserror)\n    }\n  }\n  \n  # 找出对应误分类率最低的最大lambda\n  # Find the maximum lambda corresponding to the lowest misclassification rate\n  miserror_matrix<-matrix(miserror,nrow = nfolds,byrow = T)\n  mean_miserror<-apply(miserror_matrix,MARGIN=2,FUN=mean)\n  min_error<-min(mean_miserror)\n  perfect_lambda_address<-max(which(mean_miserror == min_error))\n  perfect_lambda<-lambda_vec[perfect_lambda_address]\n  return_list<-list()\n  return_list[[1]]<-perfect_lambda\n  return_list[[2]]<-miserror_matrix\n  return_list[[3]]<-mean_miserror\n  return(return_list)\n}\n\n# 构建一个函数add1000(),其可以把一个取值在01之间的升序向量sensity根据1-specificity的值扩展至1000个元素，拟合连续型变量,vect是roc曲线横轴从0至1变化时最高点的坐标\n# Create an add1000() function that expands an ascending vector 'sensity' (with values between 0-1) to 1000 elements based on 1-specificity values, fitting continuous variables. 'vect' represents the coordinates of the highest point when the ROC curve's horizontal axis changes from 0 to 1.\nadd1000<-function(vec_sen,vec_spe){\n  vect<-rep(0,1001)\n  vec<-round(vec_spe,3)\n  spe_min<-c()\n  spe_max<-c()\n  sen_min<-c()\n  sen_max<-c()\n  spe_min_ad<-c()\n  spe_max_ad<-c()\n  for (i in 2:length(vec_sen)){\n    \n    # 检测1-specificity和sensitivity同时变化的转折点\n    # Detect inflection points where both 1-specificity and sensitivity change\n    if (vec_sen[i] != vec_sen[i-1] & vec_spe[i] != vec_spe[i-1]){\n      \n      # spe_min存储变化点前的1-specificity值（较小值）\n      # spe_min stores the pre-change 1-specificity value (smaller value)\n      \n      spe_min<-c(spe_min,vec_spe[i-1])\n      # spe_max stores the post-change 1-specificity value (larger value)\n      # spe_max存储变化点后的1-specificity值（较大值）\n      spe_max<-c(spe_max,vec_spe[i])\n      sen_min<-c(sen_min,vec_sen[i-1])\n      sen_max<-c(sen_max,vec_sen[i])\n    }\n  }\n  vect[vec*1000+1]<-vec_sen\n  for (i in 1:1001){\n    if (vect[i] == 0) vect[i] = max(vect[1:i])\n  }\n  if (length(sen_min) != 0 ){\n    spe_min_ad<-round(spe_min,3)*1000+1\n    spe_max_ad<-round(spe_max,3)*1000+1\n    if (length(sen_min) != 1){\n      for (i in 1:length(spe_min)){\n        if (i == 1){\n          for (j in spe_min_ad[i]:spe_max_ad[i]){\n            vect[j] = vect[spe_min_ad[i]] +(sen_max[i]-sen_min[i])/(spe_max_ad[i]/1000-spe_min_ad[i]/1000)*(j-spe_min_ad[i])/1000\n          }\n        }\n        if (i != 1){\n          vect[spe_min_ad[i]] = sen_min[i]\n          for (j in spe_min_ad[i]:spe_max_ad[i]){\n            vect[j] = vect[spe_min_ad[i]] +(sen_max[i]-sen_min[i])/(spe_max_ad[i]/1000-spe_min_ad[i]/1000)*(j-spe_min_ad[i])/1000\n          }\n        }\n      }\n    }\n    if (length(sen_min) == 1){\n      for (i in 1:length(spe_min)){\n        for (j in spe_min_ad[i]:spe_max_ad[i]){\n          vect[j] = vect[spe_min_ad[i]] +(sen_max[i]-sen_min[i])/(spe_max_ad[i]/1000-spe_min_ad[i]/1000)*(j-spe_min_ad[i])/1000\n        }\n      }\n    }\n  }\n  return(vect)\n}\n\n# 构建一个函数Ncv，用于构建嵌套交叉验证模型并记录单次嵌套交叉验证的平均roc曲线\n# data为包含建模数据的数据框\n# outer_fold为外层折叠数\n# inter_fold为内层折叠数\n# biresult_col为二分类outcome所在列\n# model_col为模型纳入的变量所在的列\n# formula为模型公式，如：outcome~年龄+健康状况\n# Build a function Ncv to construct nested cross-validation models and record the average ROC curve from a single nested cross-validation\n# data: Dataframe containing modeling data\n# outer_fold: Number of outer folds\n# inner_fold: Number of inner folds  \n# biresult_col: Column name of binary outcome\n# model_col: Columns of variables included in model\n# formula: Model formula (e.g. outcome~age+health_status)\nNcv<-function(data,outer_fold,inter_fold,biresult_col,model_col,formula){\n  f<-formula\n  nsamples<-nrow(data)\n  auc_vec<-c()\n  sensity_vec<-c()\n  specificity_vec<-c()\n  roc_vec<-c()\n  \n  #对所有样本进行编号\n  # Assign unique numeric IDs to each sample in the dataset\n  rownames(data)<-c(1:nsamples)\n  data_for_model<-data[,c(model_col,biresult_col)]\n  \n  # 让data_for_model的最后一列的列名为\"outcome\"\n  # Set the last column name of data_for_model to \"outcome\"\n  colnames(data_for_model)[ncol(data_for_model)]<-\"outcome\"\n  \n  # Step 1:利用分层抽样将验证集和剩余（N-1）折的训练集抽取出来，保证验证集有两个来自不同二分类outcome的样本，并进行内层的分层交叉验证\n  # Step 1: Use stratified sampling to extract the validation set and remaining (N-1)-fold training set, ensuring the validation set contains samples from both binary outcome classes, and perform inner-layer stratified cross-validation\n  outerfolds_list<<-strata_nfolds(data_for_model,nfolds = outer_fold)\n  for (i in 1:outer_fold){#进行外层嵌套\n    data_test<<-data_for_model[outerfolds_list[[i]],]\n    data_train<-data_for_model[-outerfolds_list[[i]],]\n    \n    #为了方便strata_nfolds()根据行名的样本抽取，行名再次改为从1顺序排列到最后\n    # For strata_nfolds() to easily sample based on row names, reset row names to sequential numbering from 1 to the end\n    rownames(data_train)<-c(1:nrow(data_train))\n    \n    #构建包含内部分层交叉验证各折数据编号的列表\n    # Create list containing fold indices for inner stratified cross-validation\n    interfolds_list<-strata_nfolds(data_train,nfolds = inter_fold)\n    \n    #进行内层分层交叉验证，返回该组训练集筛选出的最佳lambda\n    # Perform inner stratified CV, returns optimal lambda for this training set\n    str_CV<-logis_straCV(interfolds_list,data_train,inter_fold,f)\n    \n    #提取最佳lambda\n    # Extract the optimal lambda value\n    best_lambda<-str_CV[[1]][1]\n    \n    #使用最佳lambda对测试集进行建模\n    # Build model on test set using optimal lambda\n    mod<-lrm(formula = f,\n             data_test,\n             x = T,\n             y = T,\n             penalty = best_lambda)\n    \n    # 提取模型中线性部分计算outcome\n    # Extract linear predictors from model to calculate outcome\n    linear_pred<<-mod[[\"linear.predictors\"]]\n    mod_prob<<- apply(matrix(linear_pred,nrow=1,byrow=T),MARGIN=2,FUN=logis_cal)\n    mod_pred<-ifelse(linear_pred>0,1,0)#生成模型的预测outcome（0 or 1）\n    datatestr<<-data_test$outcome\n    \n    # 绘制外层测试集中模型的roc曲线并得出auc面积以及\"sensities\"和“specificities”的各数值，用于之后的平均化处理\n    # Plot the ROC curve of the model on the outer test set and calculate the AUC area along with the values of \"sensitivities\" and \"specificities\" for subsequent averaging processing\n    if (i == 1){\n      LR_test <- plot.roc(data_test$outcome,mod_prob,ylim=c(0,1),xlim=c(1,0),\n                          smooth=F, \n                          ci=TRUE,\n                          main=\"\",\n                          col=1, \n                          lwd=2,\n                          legacy.axes=T,\n                          print.auc=F)\n      \n      # 得出auc面积\n      # Calculate AUC value\n      mod_auc<-LR_test[[\"auc\"]]\n      auc_vec<-c(auc_vec,mod_auc)\n      mod_specificity<-rev(1-LR_test[[\"specificities\"]])\n      mod_sensity<-rev(LR_test[[\"sensitivities\"]])\n      \n      # specificity和sensity的坐标个数容易受roc曲线中斜线部分影响，所以接下来要对坐标进行填充，保证长度一致\n      # The number of specificity and sensitivity coordinates can be affected by the diagonal portions of the ROC curve, so we will now fill in the coordinates to ensure consistent length\n      if (length(mod_specificity) < (nrow(data)/outer_fold+1)) mod_specificity<-c(mod_specificity,rep(1,((nrow(data)/outer_fold+1)-length(mod_specificity))))\n      if (length(mod_sensity) < (nrow(data)/outer_fold+1)) mod_sensity<-c(mod_sensity,rep(1,((nrow(data)/outer_fold+1)-length(mod_sensity))))\n      sensity_vec<-c(sensity_vec,mod_sensity)\n      specificity_vec<-c(specificity_vec,mod_specificity)\n      mod_roc<-add1000(vec_sen=mod_sensity,vec_spe=mod_specificity)\n      roc_vec<-c(roc_vec,mod_roc)\n    }else{\n      LR_test <- plot.roc(data_test$outcome,mod_prob,ylim=c(0,1),xlim=c(1,0),\n                          smooth=F, \n                          ci=TRUE,\n                          main=\"\",\n                          col=1, \n                          lwd=2, \n                          legacy.axes=T,\n                          print.auc=F,\n                          add=T)\n      \n      # 得出auc面积\n      # Calculate AUC value\n      mod_auc<-LR_test[[\"auc\"]]\n      auc_vec<-c(auc_vec,mod_auc)\n      mod_specificity<-rev(1-LR_test[[\"specificities\"]])\n      mod_sensity<-rev(LR_test[[\"sensitivities\"]])\n      if (length(mod_specificity) < (nrow(data)/outer_fold+1)) mod_specificity<-c(mod_specificity,rep(1,((nrow(data)/outer_fold+1)-length(mod_specificity))))\n      if (length(mod_sensity) < (nrow(data)/outer_fold+1)) mod_sensity<-c(mod_sensity,rep(1,((nrow(data)/outer_fold+1)-length(mod_sensity))))\n      sensity_vec<-c(sensity_vec,mod_sensity)\n      specificity_vec<-c(specificity_vec,mod_specificity)\n      mod_roc<-add1000(vec_sen=mod_sensity,vec_spe=mod_specificity)\n      roc_vec<-c(roc_vec,mod_roc)\n    }\n    \n    # Step2: 计算每次嵌套交叉验证的平均roc曲线的散点坐标\n    # Step 2: Calculate scatter plot coordinates for the average ROC curve across each nested cross-validation\n    sensity_matrix<-matrix(sensity_vec,nrow=outer_fold,byrow=T)\n    specificity_matrix<-matrix(specificity_vec,nrow=outer_fold,byrow=T)\n    roc_matrix<-matrix(roc_vec,nrow=outer_fold,byrow=T)\n    \n    # 计算出每次嵌套交叉验证的平均sensitity序列\n    # Compute mean sensitivity sequence across all nested CV folds\n    mean_sensity<-apply(sensity_matrix,MARGIN=2,FUN=mean)\n    \n    # 计算出每次嵌套交叉验证的平均specificity序列\n    # Compute mean specificity sequence across all nested CV folds\n    mean_specificity<-apply(specificity_matrix,MARGIN=2,FUN=mean)\n    \n    # 计算出每次嵌套交叉验证的平均ROC值\n    # Compute mean ROC values across all nested CV folds\n    mean_roc<-apply(roc_matrix,MARGIN=2,FUN=mean)\n  }\n  return_list<-list()\n  return_list[[\"mean_sensity\"]]<-mean_sensity\n  return_list[[\"mean_specificity\"]]<-mean_specificity\n  return_list[[\"mean_roc\"]]<-mean_roc\n  return_list[[\"mean_auc\"]]<-mean(auc_vec)\n  return_list[[\"roc_mat\"]]<-roc_matrix\n  return_list[[\"sensity_mat\"]]<-sensity_matrix\n  return_list[[\"specificity_mat\"]]<-specificity_matrix\n  return(return_list)\n}\n\n# 构建一个函数repeat_ncv(),用于将Ncv()函数重复n次，并获得平均roc曲线，默认n为100次（根据文献）\n# data为包含建模数据的数据框\n# outer_fold为外层折叠数\n# inter_fold为内层折叠数\n# biresult_col为二分类outcome所在列\n# model_col为模型纳入的变量所在的列\n# formula为模型公式，如：outcome~年龄+健康状况\n# n_repeat为嵌套交叉验证重复的次数，默认为100次\n# 返回列表中包含以下value\n# mean_sensity:roc曲线sensity向量在n_repeat次重复的平均值\n# mean_specificity:roc曲线1-specificity向量在n_repeat次重复的平均值\n# sensity_mat：roc曲线sensity向量在n_repeat次重复中每一次的取值，纵轴代表循环次数，横轴对应每一次的向量\n# specificity_mat：roc曲线1-specificity向量在n_repeat次重复中每一次的取值，纵轴代表循环次数，横轴对应每一次的向量\n# mean_roc:n_repeat次重复中roc曲线的平均值\n# mean_AUROC:每一次嵌套验证的平均auc面积的向量\n# mean_auc:mean_AUROC的平均值，即所有n_repeat次嵌套交叉验证中所有外层测试集的auc平均值\n# Build a function repeat_ncv() to execute the Ncv() function n times and obtain average ROC curves (default n=100 per literature)\n# data: Dataframe containing modeling data\n# outer_fold: Number of outer CV folds\n# inner_fold: Number of inner CV folds\n# biresult_col: Column containing binary outcome\n# model_col: Columns of predictor variables\n# formula: Model formula (e.g. outcome~age+health_status)\n# n_repeat: Times to repeat nested CV (default=100)\n# Returns list containing:\n# mean_sensity: Average sensitivity vector across n_repeat iterations\n# mean_specificity: Average 1-specificity vector across n_repeat iterations\n# sensity_mat: Matrix of sensitivity vectors (rows=iterations, columns=values)\n# specificity_mat: Matrix of 1-specificity vectors (rows=iterations, columns=values)\n# mean_roc: Average ROC curve across all iterations\n# mean_AUROC: Vector of average AUCs per CV iteration\n# mean_auc: Grand mean AUC across all test sets\nrepeat_ncv<-function(data,outer_fold,inter_fold,biresult_col,model_col,formula,n_repeat=100){\n  all_sensity_vec<-c()\n  all_specificity_vec<-c()\n  all_roc_vec<-c()\n  mean_AUROC<-c()\n  for (i in 1:n_repeat){\n    Ncv_result<-Ncv(data = data,\n                    outer_fold = outer_fold,\n                    inter_fold =inter_fold,\n                    biresult_col = biresult_col,\n                    model_col = model_col,\n                    formula = formula)\n    all_sensity_vec<-c(all_sensity_vec,Ncv_result[[\"mean_sensity\"]])\n    all_specificity_vec<-c(all_specificity_vec,Ncv_result[[\"mean_specificity\"]])\n    all_roc_vec<-c(all_roc_vec,Ncv_result[[\"mean_roc\"]])\n    mean_AUROC<-c(mean_AUROC,Ncv_result[[\"mean_auc\"]])\n    print(paste0(\"Completed \", i, \"th nested validation\"))\n  }\n  \n  # 将sensity向量折叠成按行排列的矩阵\n  # Reshape sensitivity vector into row-wise matrix\n  sensity_mat<-matrix(all_sensity_vec,nrow=n_repeat,byrow = T)\n  \n  # 将specificity向量折叠成按行排列的矩阵\n  # Reshape specificity vector into row-wise matrix\n  specificity_mat<-matrix(all_specificity_vec,nrow=n_repeat,byrow = T)\n  \n  # 将ROC值折叠成按行排列的矩阵\n  # Reshape ROC values into row-wise matrix\n  roc_mat<-matrix(all_roc_vec,nrow=n_repeat,byrow = T)\n  \n  # 利用sensity矩阵计算100次循环后sensity的均值向量\n  # Calculate mean sensitivity vector across 100 iterations\n  mean_sensity<-apply(sensity_mat,MARGIN=2,FUN=mean)\n  \n  # 利用specificity矩阵计算100次循环后specificity的均值向量\n  # Calculate mean specificity vector across 100 iterations\n  mean_specificity<-apply(specificity_mat,MARGIN=2,FUN=mean)\n  \n  mean_roc<-apply(roc_mat,MARGIN=2,FUN=mean)\n  mean_auc<-mean(mean_AUROC)\n  result_list<-list()\n  result_list[[\"mean_sensity\"]]<-mean_sensity\n  result_list[[\"mean_specificity\"]]<-mean_specificity\n  result_list[[\"sensity_mat\"]]<-sensity_mat\n  result_list[[\"specificity_mat\"]]<-specificity_mat\n  result_list[[\"mean_roc\"]]<-mean_roc\n  result_list[[\"mean_AUROC\"]]<-mean_AUROC\n  result_list[[\"mean_auc\"]]<-mean_auc\n  return(result_list)\n  print(\"Outcome has been generated, task completed\")\n}\n\n# 构建一个函数roc.plot(),用于绘制多个模型的ROC曲线\n# model_list为多个repeat_ncv的outcome构成的列表\n# roc_color为人为为模型选定的颜色向量\n# model_name为必填选项，为人为指定的模型名称\n# Build a function roc.plot() to plot ROC curves for multiple models\n# model_list: List containing outcomes from multiple repeat_ncv runs\n# roc_color: User-specified color vector for the models (optional)\n# model_name: Required parameter specifying model names\nroc.plot<-function(model_list,roc_color=NULL,model_name=NULL){\n  if (is.null(model_name)) stop(\"Please provide the model name vector\")\n  bb<-roc_color\n  n_model<-length(model_list)\n  x_vec<-c()\n  y_vec<-c()\n  mean_auc<-c()\n  group_vec<-c()\n  color_vec<-c()\n  if (is.null(bb)){\n    for (i in 1:n_model){\n      mean_auc<-c(mean_auc,model_list[[i]][[\"mean_auc\"]])\n    }\n    mean_auc<-round(mean_auc,3)\n    \n    # 将模型名称改变为“模型名称（mean_auc=xxx）”的形式\n    # Format model names to \"ModelName (mean_auc=xxx)\" style\n    model_name<-paste(model_name,\"(mean_auc=\")\n    model_name<-paste(model_name,mean_auc)\n    model_name<-paste(model_name,\")\")\n    for (i in 1:n_model){\n      x_vec<-c(x_vec,c(0,seq(from=0,to=1,by=0.001)))#\n      y_vec<-c(y_vec,c(0,model_list[[i]][[\"mean_roc\"]]))\n      n_rocpoint<-length(c(0,model_list[[i]][[\"mean_roc\"]]))\n      group_vec<-c(group_vec,rep(model_name[i],n_rocpoint))\n    }\n    rocs_data<-data.frame(x_vec,y_vec,group_vec)\n    graph<-ggplot(rocs_data, aes(x=x_vec, y=y_vec, colour=group_vec,group=group_vec)) + \n      geom_line(size=1)+\n      labs(title=\"ROC\", x=\"1-Specificity\", y=\"Sensity\")+\n      theme(plot.title = element_text(hjust = 0))+\n      guides(color=guide_legend(title = \"Model\"))+\n      theme_bw()\n  }\n  if (length(roc_color) == length(model_list)){\n    for (i in 1:n_model){\n      mean_auc<-c(mean_auc,model_list[[i]][[\"mean_auc\"]])\n    }\n    mean_auc<-round(mean_auc,3)   \n    model_name<-paste(model_name,\"(mean_auc=\")\n    model_name<-paste(model_name,mean_auc)\n    model_name<-paste(model_name,\")\")\n    for (i in 1:n_model){\n      x_vec<-c(x_vec,c(0,seq(from=0,to=1,by=0.001)))#\n      y_vec<-c(y_vec,c(0,model_list[[i]][[\"mean_roc\"]]))\n      n_rocpoint<-length(c(0,model_list[[i]][[\"mean_roc\"]]))\n      group_vec<-c(group_vec,rep(model_name[i],n_rocpoint))\n      color_vec<-c(color_vec,rep(roc_color[i],n_rocpoint))\n    }\n    rocs_data<-data.frame(x_vec,y_vec,group_vec,color_vec)\n    group_name<-c()\n    for (i in 1:length(group_vec)){\n      if (i == 1){\n        group_name<-c(group_name,group_vec[i])\n      }\n      if (i != 1){\n        if (group_vec[i] != group_name[length(group_name)]) group_name<-c(group_name,group_vec[i])\n      }\n    }\n    color_deal<-roc_color\n    names(color_deal)<-group_name\n    graph<-ggplot(rocs_data, aes(x=x_vec, y=y_vec, group = group_vec,color = group_vec)) + \n      geom_line(size=1)+\n      labs(title=\"ROC\", x=\"1-Specificity\", y=\"Sensity\")+\n      theme(plot.title = element_text(hjust = 0.5))+\n      guides(color=guide_legend(title = \"Model\"))+\n      scale_color_manual(values=color_deal)+\n      theme_bw()\n  }\n  if (length(roc_color) != length(model_list) & !is.null(bb)){\n    stop(\"The number of colors in the color vector does not match the number of models\")}\n  return(graph)\n}\n\n\n# 构建一个函数ttest_HB(),来对不同模型的mean_AUROC进行Holm–Bonferroni校正的非配对双尾t检验\n# model_list为数个repeat_ncv()函数outcome的列表(同roc.plot()函数中的model_list),model_name为列表中每个模型的名称向量，按model_list顺序一一对应\n# 函数ttest_HB()的返回值为一个数据框，model列为进行t检验的两个模型的名称；Pvalue列为检验P值，带\"*\"代表显著；order为Pvalue的降序排列的序号\n# Build a function ttest_HB() to perform Holm-Bonferroni corrected unpaired two-tailed t-tests on mean_AUROC between different models\n# model_list is a list of outcomes from multiple repeat_ncv() functions (same as model_list in roc.plot() function), model_name is a vector of model names corresponding to each element in model_list (in the same order)\n# The return value of function ttest_HB() is a dataframe, where model column contains names of the two models being compared; Pvalue column contains test p-values (\"*\" indicates significance); order column contains descending rank of Pvalues\nttest_HB<-function(model_list,model_name){\n  model_name<-as.character(model_name)\n  mean_AUROC_list<-list()\n  for (i in 1:length(model_list)){\n    mean_AUROC_list[[i]]<-model_list[[i]][[\"mean_AUROC\"]]\n  }\n  \n  # 模型个数\n  # Number of Models\n  model_number<-length(model_list)\n  name_vec<-c()\n  P_value<-c()\n  for (i in 1:(model_number-1)){\n    for (j in (i+1):model_number){\n      name_vec<-c(name_vec,paste0(model_name[i],\"and\",model_name[j]))\n      p_ttest<-t.test(x=model_list[[i]][[\"mean_AUROC\"]],\n                      y=model_list[[j]][[\"mean_AUROC\"]],\n                      paired =F,\n                      alternative=\"two.sided\")\n      \n      # 构建每次双尾t检验的P值向量\n      # Build vector of p-values from each two-tailed t-test\n      P_value<-c(P_value,p_ttest$p.value)\n    }\n  }\n  \n  # 获得P值的降序排列序数向量,ceiling()为向上取整\n  # Create descending order index vector of p-values (ceiling() rounds up)\n  order_vec<-rev(ceiling(rank(P_value)))\n  \n  #构建显著性\n  # Set significance level\n  alpha = 0.05\n  alpha_vec<-c()\n  star_vec<-c()\n  for (i in 1:length(P_value)){\n    \n    # 计算每个模型对应的Holm–Bonferroni显著性\n    # Calculate Holm-Bonferroni significance for each model\n    alpha_vec<-c(alpha_vec,alpha/order_vec[i])\n    if (P_value[i] <= alpha_vec[i]) star_vec<-c(star_vec,\"*\")\n    if (P_value[i] > alpha_vec[i]) star_vec<-c(star_vec,\"\")\n  }\n  \n  # 为P值小于显著性的P值添加*号\n  # Add asterisk (*) to P-values smaller than the significance level\n  P_value<-paste(P_value,star_vec)\n  data_return<-data.frame(model = name_vec,\n                          Pvalue = P_value,\n                          order = order_vec,\n                          alpha = alpha_vec)\n  return(data_return)\n}\n\n# 构建一个岭回归（L2逻辑回归）函数L2log()\n# x为数据框中自变量切片\n# y为数据框中因变量的切片\n# nfolds为交叉检验折叠数\n# 返回值：lambda取lambda.min和lambda.1se两个值时的模型系数,lambda取lambda.min模型准确率更高,lambda取lambda.1se模型更精简，但牺牲准确率\n# Build a ridge regression (L2 logistic regression) function L2log()\n# x: Dataframe slice containing independent variables\n# y: Dataframe slice containing dependent variable\n# nfolds: Number of cross-validation folds\n# Returns: Model coefficients at both lambda.min and lambda.1se values. lambda.min yields higher model accuracy. lambda.1se produces a more parsimonious model at the cost of reduced accuracy.\nL2log<-function(x,y,nfolds){\n  myx<-data.matrix(x)\n  myy<-y\n  model <- cv.glmnet(x = myx, y =myy,\n                     type.measure = \"mse\",\n                     ## K = 10 is the default.\n                     nfold = nfolds,\n                     ## ‘alpha = 1’ is the lasso penalty, and ‘alpha = 0’ the ridge penalty.\n                     alpha = 0)\n  \n  #使用最小预测误差的lambda值计算特征系数\n  # Calculate feature coefficients using lambda value with minimum prediction error\n  coef_lambda.min<- coef(model,s=\"lambda.min\") \n  \n  #使用距离最小预测误差一个标准差之内的最大lambda值计算特征系数\n  # Calculate feature coefficients using largest lambda value within one standard error of minimum prediction error\n  coef_lambda.1se<- coef(model,s=\"lambda.1se\") \n  \n  list_return<-list()\n  list_return[[\"coef_lambda.min\"]]<-coef_lambda.min\n  list_return[[\"coef_lambda.1se\"]]<-coef_lambda.1se\n  return(list_return)\n}\n输入文件\nInput Files\neasy_input.txt，保证最后一列的列名为outcome，且为二分类变量。\neasy_input.txt, ensure the last column is named “outcome” and is a\nbinary categorical variable.\n# 生成输入文件\n# Generate input file\nage <- c(10,20,30,40,50,60,70,80,90,100,110,120,130,140,150)\nhealth <- c(1,5,1,11,23,3,11,3,1,3,80,3,1,3,4)\nweight <- c(1,3,2,5,2,7,7,7,5,8,4,5,8,7,3)\noutcome <- c(1,0,1,1,0,1,0,0,0,0,0,0,0,1,1)\ndat <- data.frame(age, health, weight, outcome)\nwrite.table(dat, \"easy_input.txt\",sep = \"\\t\",row.names = F,col.names = T,quote = F)\n# 加载输入文件\n# Load input file\ndat <- read.table(file = \"easy_input.txt\", sep = \"\\t\", row.names = NULL, header = T, check.names = F, stringsAsFactors = F)\nhead(dat)\n模型验证模块\nModel Validation Module\n对目标数据进行n_reapeat次的嵌套交叉验证\nPerform nested cross-validation on target data for n_repeat times\nres1 <- repeat_ncv(data = dat,\n                  outer_fold = 3,\n                  inter_fold = 2,\n                  biresult_col = c(4),\n                  model_col = c(1,2),\n                  formula = outcome ~ age + health,\n                  n_repeat = 3)\nres2 <- repeat_ncv(data = dat,\n                   outer_fold = 3,\n                   inter_fold = 2,\n                   biresult_col = c(4),\n                   model_col = c(2,3),\n                   formula = outcome ~ health + weight,\n                   n_repeat = 3)\nres3 <- repeat_ncv(data = dat,\n                   outer_fold = 3,\n                   inter_fold = 2,\n                   biresult_col = c(4),\n                   model_col = c(1,2,3),\n                   formula = outcome ~ age + health + weight,\n                   n_repeat = 3)\n# 构建3个模型的列表\n# Create list containing all three models\nmodelList <- list(res1, res2, res3)\n绘图模块\nPlotting Module\n分别测试指定颜色和不指定颜色\n对多个模型经过repeat_ncv()函数返回值制成的列表进行多个模型平均roc曲线的绘制\nTest with and without specified colors respectively\nPlot average ROC curves across multiple models using the list\nreturned by repeat_ncv() function\nroc.plot(model_list = modelList, model_name = c(\"health + age\",\"health + weight\",\"age + health + weight\"), roc_color = c(\"#C51B7D\",\"#4D9221\",\"#CCFFFF\"))\nggsave(filename = \"roc with customized color.pdf\", width = 8,height = 5)\nroc.plot(model_list = modelList, model_name = c(\"health + age\",\"health + weight\",\"age + health + weight\"))\nggsave(filename = \"roc with default color.pdf\", width = 8,height = 5)\n多重检验模块\nMultiple Testing Module\n对model_list中包含的模型进行两两n_repeat个mean_AUROC的Holm–Bonferroni校正的非配对双尾t检验\nPerforms pairwise Holm-Bonferroni corrected unpaired two-tailed\nt-tests on mean_AUROC values (n_repeat times) for models contained in\nmodel_list\nhbres <- ttest_HB(model_list = modelList, model_name = c(\"health + age\",\"health + weight\",\"age + health + weight\")) \n\n# 输出制作表格的结果\n# Print formatted test results\nprint(hbres)\nwrite.table(hbres, file = \"Holm-Bonferroni test result.txt\",sep = \"\\t\", row.names = F, col.names = T, quote = F)\nL2逻辑回归建模模块\nL2 Logistic Regression Modeling Module\n#使用L2log()函数构建L2逻辑回归模型（岭回归）\n# Build L2 logistic regression model (ridge regression) using L2log() function\nmodel <- L2log(x = dat[,c(1,2)], y = dat[,4],nfolds = 3)\n\n# 输出制作表格的结果\n# Print model results in table format\nprint(model)\nwrite.table(as.matrix(model$coef_lambda.min), \n            file = \"L2-regularized classifiers using lambda.1se.txt\",sep = \"\\t\", row.names = T, col.names = NA, quote = F)\nwrite.table(as.matrix(model$coef_lambda.min), \n            file = \"L2-regularized classifiers using lambda.min.txt\",sep = \"\\t\", row.names = T, col.names = NA, quote = F)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa287L2logV2_FigureYa287L2log",
      "title": "FigureYa287L2logV2/FigureYa287L2log.html",
      "html": "FigureYa287L2logV2/FigureYa287L2log.html",
      "text": "texts/main_FigureYa287L2logV2_FigureYa287L2log.txt",
      "folder": "FigureYa287L2logV2",
      "thumb": "gallery_compress/FigureYa287L2logV2.webp"
    },
    "word_count": 2733,
    "lines_count": 777,
    "title": "FigureYa287L2logV2",
    "description": "Requirements Description 这篇文章Fig4的a，b，c；实现以下关键词：nested cross-validation； Holm–Bonferroni correction for multiple hypotheses； L2-regularized",
    "input_data_types": [
      "临床数据"
    ],
    "output_types": [
      "散点图",
      "统计表格"
    ],
    "technical_methods": [
      "通路分析"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学",
      "药物研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "to",
      "add",
      "colour",
      "paired",
      "strataname",
      "values",
      "measure",
      "header",
      "lwd"
    ]
  },
  {
    "id": "main_FigureYa9heatmap_FigureYa9heatmap",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa9heatmap_FigureYa9heatmap.txt",
    "content": "FigureYa9 heatmap\nFigureYa9 heatmap\nAuthor(s)\n: Ying Ge; Yijing Chen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n用R代码画出paper里的热图heatmap\nDraw heatmap in paper with R code\n使用场景\nUsage scenario\n场景一：sample间的相关性，用来评价生物学重复之间的重复性，或者体现不同组的差异\n场景二：基因的表达变化聚类、sample聚类\nScenario 1: Correlation between samples, used to assess the\nreproducibility among biological replicates or to reflect differences\nbetween various groups.\nScenario 2: Clustering of Gene Expression Changes, Clustering of\nSamples\n输入数据\nInput data\nsource(\"install_dependencies.R\")\ndf<-read.table(\"mRNA.txt\",row.names = 1,header = T,as.is = T)\ndf[1:3,1:3]\n#查看一共有多少个基因，多少个sample\n#check the number of genes and samples in total\ndim(df)\n开始画图\nStart drawing\n场景一：sample间的相关性，用来评价生物学重复之间的重复性，或者不同组的差异\nScenario 1: Correlation between samples, used to assess the\nreproducibility among biological replicates or to reflect differences\nbetween various groups\n#计算每两个sample之间的相关系数，method可选\"pearson\" (default), \"kendall\", or \"spearman\"\n#calculate the correlation coefficient between each pair of samples, method can be \"pearson\" (default), \"kendall\", or \"spearman\"\ncormat<-round(cor(df,method = \"spearman\"),2)\n\n#install.packages(\"pheatmap\")\nlibrary(pheatmap)\npheatmap(cormat,cellwidth = 8, cellheight = 8,fontsize = 8,\n         color = colorRampPalette(c(\"#3C7DAF\", \"#EAF4F1\",\"#FFFCBA\", \"#E83140\"))(20),\n         show_colnames=T,show_rownames =T,#显示sample的名字 display the name of the sample\n         #border_color = \"NA\",#默认有边框，不要边框的话就加这行 the default is to have a border, add this line if you don't want a border\n         treeheight_row = \"0\",treeheight_col = \"0\")#不画树 no tree drawing\n输出pdf文件，只需加一行：filename=“文件名”\noutput pdf file, just add a line: filename=“filename”\npheatmap(cormat,cellwidth = 8, cellheight = 8,fontsize = 8,\n         #可以用下面这行自定义颜色\n         #You can use the following line to define a custom color\n         #color = colorRampPalette(c(\"#3C7DAF\", \"#EAF4F1\",\"#FFFCBA\", \"#E83140\"))(20),\n         show_colnames=T,show_rownames =T,\n         #border_color = \"NA\",#默认有边框，不要边框的话就加这行 the default is to have a border, add this line if you don't want a border\n         treeheight_row = \"0\",treeheight_col = \"0\",\n         filename=\"Correlation.pdf\")\n如果sample数量少，还可以在热图里显示数字\n只需加一行：display_numbers = TRUE\n此处用20个sample展示效果\nIf the sample size is small, you can also show the number in the\nheatmap\nJust add one line: display_numbers = TRUE\nHere 20 samples are used to show the effect\npheatmap(cormat[4:24,4:24],cellwidth = 15, cellheight = 15,fontsize = 8,\n         #color = colorRampPalette(c(\"#3C7DAF\", \"#EAF4F1\",\"#FFFCBA\", \"#E83140\"))(20),\n         show_colnames=T,show_rownames =T,\n         display_numbers = TRUE,#显示数字 display number\n         treeheight_row = \"0\",treeheight_col = \"0\")#不画树 no tree drawing\n有些热图，同组sample用同一个颜色表示，那些色块也是同时画出来的\n要为每组设置颜色\nFor some heatmaps, the same group of samples is represented by the\nsame color, and those color blocks are also drawn at the same time\nset the color for each group\n#先查看有哪些sample，顺序是怎样的\n#First check what samples are available and in what order\ncolnames(df)\n#按照sample的顺序，告诉R，它是属于哪个组的\n#Tell R, in order of sample, which group it belongs to\nannotation_col = data.frame(\n  type = factor(rep(c(\"DG\",\"PFC\",\"PCC\",\"CA1\",\"CB\",\"OC\",\"TC\",\"PC\"),c(8,8,8,8,8,8,8,8))))\nrownames(annotation_col) = colnames(df)\n\nannotation_row = data.frame(\n  type = factor(rep(c(\"DG\",\"PFC\",\"PCC\",\"CA1\",\"CB\",\"OC\",\"TC\",\"PC\"),c(8,8,8,8,8,8,8,8))))\nrownames(annotation_row) = colnames(df)\n\n#然后给每个组设置颜色\n#then set the color for each group\nann_colors = list(\n  type = c(DG = \"blue\", PFC = \"green\", PCC = \"red\", CA1 = \"black\",\n  CB = \"pink\", OC = \"grey\", TC = \"yellow\", PC = \"purple\")\n)\n\npheatmap(cormat,cellwidth = 8, cellheight = 8,\n         fontsize = 8,\n         #display_numbers = TRUE,\n         color = colorRampPalette(c(\"navy\", \"white\", \"firebrick3\"))(20),\n         show_colnames=F,show_rownames =F,#不显示sample的名字 do not show the name of the sample\n         annotation_col = annotation_col, annotation_row = annotation_row,\n         annotation_colors = ann_colors,\n         treeheight_row = \"0\",treeheight_col = \"0\",#不画树 no tree drawing\n         border_color = \"NA\")#不显示边框 do not show border\n场景二：基因的表达变化聚类、sample聚类\nScenario 2: Clustering of Gene Expression Changes, Clustering of\nSamples\nlibrary(pheatmap)\n#有时会有多种分组方式，那就分别告诉R，此处增加一个性别组\n#sometimes there are multiple groupings, so tell R separately and add a gender group here\nannotation_col <- data.frame(\n  Gender = factor(rep(c(\"F\",\"M\"),32)),#按性别分组 group by gender\n  type = factor(rep(c(\"DG\",\"PFC\",\"PCC\",\"CA1\",\"CB\",\"OC\",\"TC\",\"PC\"),c(8,8,8,8,8,8,8,8))))\nrownames(annotation_col) = colnames(df)\n\nann_colors = list(\n  Gender = c(F = \"#FFA42D\", M = \"#A9D9DF\"),#给性别分组设置颜色 set colors for gender grouping\n  type = c(DG = \"blue\", PFC = \"green\", PCC = \"red\", CA1 = \"black\",\n  CB = \"pink\", OC = \"grey\", TC = \"yellow\", PC = \"purple\")\n)\n\n#此处用前1000行基因画图\n#实际作图时，先筛差异基因，再用差异基因画图；或者用变化大的Top几千个基因画图\n#here the first 1000 rows of genes are used to draw the graph\n#When creating the plot, first filter the differential genes and then use them for plotting; alternatively, use the top few thousand genes with the most significant changes for plotting.\ndeg <- df[1:1000,]\npheatmap(deg, cellwidth = 8, cellheight = 1, fontsize = 8,\n         method=\"spearman\", #计算gene或sample之间的相关性的方法，可选\"pearson\" method to calculate correlation between genes or samples, optionally “pearson”. (default), \"kendall\", or \"spearman\"\n         scale=\"row\", #为基因做scale scale for genes\n         cluster_rows=T, #为基因做聚类 cluster for genes\n         cluster_cols=T, #为sample做聚类 cluster for sample\n         color = colorRampPalette(c(\"navy\", \"white\", \"firebrick3\"))(20), #自定义颜色 custom color\n         show_colnames=F, #显示样品名称就改为T display sample name and change it to T\n         show_rownames =F, #显示基因名就改为T display the gene name and change it to T\n         annotation_col = annotation_col,\n         annotation_colors = ann_colors,\n         #如果想显示树状结构，就删掉下面这行前面的#\n         #If you want to show the tree structure, just delete the line below#\n         #treeheight_row = \"0\",treeheight_col = \"0\",#不画树 no tree drawing\n         filename = \"pheatmap.pdf\", #直接保存到pdf文件 save directly to pdf file\n         border_color = \"NA\") #不给每个小格子画边框，如果画边框，可以把NA改为你想要的颜色\n#Do not draw borders for each cubby, if you do, you can change the NA to the color you want\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa9heatmap_FigureYa9heatmap",
      "title": "FigureYa9heatmap/FigureYa9heatmap.html",
      "html": "FigureYa9heatmap/FigureYa9heatmap.html",
      "text": "texts/main_FigureYa9heatmap_FigureYa9heatmap.txt",
      "folder": "FigureYa9heatmap",
      "thumb": "gallery_compress/FigureYa9heatmap.webp"
    },
    "word_count": 778,
    "lines_count": 147,
    "title": "FigureYa9 heatmap",
    "description": "Requirement description 用R代码画出paper里的热图heatmap Draw heatmap in paper with R code",
    "input_data_types": [],
    "output_types": [
      "散点图",
      "热图",
      "统计表格"
    ],
    "technical_methods": [
      "聚类分析"
    ],
    "biology_areas": [],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "PC",
      "OC",
      "annotation_col",
      "header",
      "cluster_cols",
      "cellwidth",
      "TC",
      "CB",
      "method",
      "DG"
    ]
  },
  {
    "id": "main_FigureYa251NPHSurv_FigureYa251NPHSurv",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa251NPHSurv_FigureYa251NPHSurv.txt",
    "content": "FigureYa251NPHSurv\nFigureYa251NPHSurv\nAuthor(s)\n: Xiaofan Lu\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n看起来Xiaofan Lu\n用了两种非比例风险的预后模型来计算接受了免疫治疗的队列的生存差异，包括RMS限制性生存均值以及long-term\nsurvival分析。这个在临床中很有意义，因为免疫治疗患者确实存在他说的“delayed\neffect”延迟效应。\nRequirement Description\nIt appears that the Xiaofan Lu used two non-proportional risk\nprognostic models to calculate the difference in survival in the cohort\nthat received immunotherapy, including RMS-limiting mean survival and\nlong-term survival analysis. This is very meaningful in clinical\npractice, because immunotherapy patients do have the “delayed\neffect”.\n出自\nhttps://www.biorxiv.org/content/10.1101/2021.05.30.446369v1.full\n的补充材料Supplementary\nFigure S4a from\nhttps://www.biorxiv.org/content/10.1101/2021.05.30.446369v1.full\nSupplementary Figure S4a\n应用场景\n采用非比例风险的生存模型（non-proportional-hazard survival model,\nNPHSurv）评价接受免疫治疗患者的预后情况\nApplication Scenarios\nThe non-proportional-hazard survival model (NPHSurv) was used to\nevaluate the prognosis of patients receiving immunotherapy\noriginal text：\nTo evaluate the treatment effect of immune\ncheckpoint inhibitors on different iCSs in the IMvigor210\ncohort\n, we compared the RMS time difference at six months and\none year after treatment. We found that the iBS4 subtype showed a\nsignificantly poorer outcome than immune-hot iCSs (i.e., iBS1 and iLS2;\nboth P < 0.05 at 6 months, both P < 0.1 at 12 months) and had a\nsegregated survival curve compared to the immune-cold iLS3 subtype\n(Supplementary Figure S4a). Due to the *\ndelayed clinical effect\nof immunotherapy\n, we also compared the long-term survival rates\nafter three months of treatment. Consistently, the iBS4 subtype was\nassociated with significantly poorer long-term survival than the\nimmune-hot iBS1 (P = 0.046) and iLS2 (P = 0.027) subtypes and the\nimmune-cold iLS3 subtype (P = 0.095), suggesting its high malignancy and\npotential resistance to immune checkpoint blockade (Supplementary Figure\nS4b).\n例文中很多图我们都实现过，例如：\nFigure 1b的画法可参考FigureYa196PanPie\nFigure\n2a的算法可参考FigureYa249Regulon，b的画法可参考FigureYa248MutLandscape\nFigure 3de可产考FigureYa25sankey和FigureYa125Fishertest\nFigure 4f可参考FigureYa106immunotherapy\nFigure 5b可参考FigureYa12box，f可参考FigureYa162boxViolin\nFigure\n6可参考FigureYa35batch_bestSeparation，FigureYa144DiagHeatmap或\nhttps://mp.weixin.qq.com/s/34WRZRBVPHUNRLlzNH2nzw\nWe have many of the images in the examples, such as:\nFor more information about Figure 1b, see FigureYa196PanPie\nFor Figure 2a, see FigureYa249Regulon, and for b, see\nFigureYa248MutLandscape\nFor Figure 3de, see FigureYa25sankey and FigureYa125Fishertest\nFigure 4f can refer to Figure Ya106 immunotherapy\nFigure 5b can refer to FigureYa12box, and f can refer to\nFigureYa162boxViolin\nFor Figure 6, see FigureYa35batch_bestSeparation,\nFigureYa144DiagHeatmap, or\nhttps://mp.weixin.qq.com/s/34WRZRBVPHUNRLlzNH2nzw\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\nlibrary(survRM2)\nlibrary(ComparisonSurv)\nlibrary(ggplot2)\nlibrary(ggpubr)\nlibrary(survminer)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # error messages are displayed in English\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # chr is not allowed to be converted to factor\n输入文件\neasy_input_annCol.txt，亚型信息。\neasy_input_surv.txt，预后信息。\nInput the file\neasy_input_annCol.txt, subtype information.\neasy_input_surv.txt. Prognostic information.\n# 读取经过NTP预测的IMvigor210队列的CMOIC亚型\n# Read the CMOIC isoform of the IMvigor210 cohort predicted by NTP\nannCol.imvigor210 <- read.table(\"easy_input_annCol.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\n\n# 读取IMvigor210队列的预后信息\n# Read the prognosis information of the IMvigor210 queue\nimvigor210.surv <- read.table(\"easy_input_surv.txt\",sep = \"\\t\",row.names = 1,check.names = F,stringsAsFactors = F,header = T)\n采用非比例风险的生存模型（non-proportional-hazard survival model,\nNPHSurv）评价接受免疫治疗患者的预后情况\nThe non-proportional-hazard survival model (NPHSurv) was used to\nevaluate the prognosis of patients receiving immunotherapy\n# 构建完整的预后和亚型信息\n# Construct complete prognosis and subtype information\nsurv <- cbind.data.frame(annCol.imvigor210,imvigor210.surv[rownames(annCol.imvigor210),])\nsurv$os <- surv$os * 30 # 生存时间由月换算成日 # Time to live is converted from months to days\n\n# 循环计算非比例风险生存模型的统计显著性\n# Statistical significance of non-proportional risk survival models is calculated in a circular manner\nsubt <- c(\"CS1\",\"CS2\",\"CS3\",\"CS4\") # 目前定义的亚型名 # The name of the subtype as currently defined\ntau1 <- 180 # 第一次计算RMS的时间截点（半年） # Cut-off point for the first RMS calculation (half a year)\ntau2 <- 365 # 第二次计算RMS的时间截点（1年） # Time cut-off point for calculating RMS for the second time (1 year)\nt0 <- 90 # 认为免疫治疗延迟效应的时间（3个月） # Time to consider the delayed effect of immunotherapy (3 months)\nrms.mat1 <- as.data.frame(matrix(0, ncol = length(subt), nrow = (length(subt)),dimnames = list(subt,subt))) # 初始化半年的RMS模型的p值矩阵 # Initialize the p-value matrix of the half-year RMS model\nrms.mat2 <- as.data.frame(matrix(0, ncol = length(subt), nrow = (length(subt)),dimnames = list(subt,subt))) # 初始化一年的RMS模型的p值矩阵 # Initialize the p-value matrix of the RMS model for one year\nlts.mat <- as.data.frame(matrix(0, ncol = length(subt), nrow = (length(subt)),dimnames = list(subt,subt))) # 初始化延迟效应的长期生存模型的p值矩阵 # Initialize the p-value matrix of the long-term survival model of the delay effect\n\nfor(i in subt) {\n  for (j in subt) {\n    if(i == j) {\n      next\n    } else {\n        tmp <- surv[which(surv$CMOIC %in% c(i,j)),] # 若亚型相同时则跳过 # Skip if the subtype is the same\n        \n        # 计算6个月时的RMS\n        # Calculate RMS at 6 months\n        rmst1 <- rmst2(time = tmp$os,\n                      status = tmp$censOS,\n                      arm = ifelse(tmp$CMOIC == i,1,0), # 谁为参考不重要，p值不发生变化，但是RMS diff以及RMS ratio会改变，可根据需要自己查看rmst1中的结果 # It doesn't matter who is the reference, the p-value does not change, but the RMS diff and RMS ratio will change, you can check the results in rmst1 by yourself as needed\n                      tau = tau1)\n        rms.mat1[i,j] <- rmst1$unadjusted.result[1,4]\n        \n        # 计算12个月时的RMS\n        # RMS at 12 months is calculated\n        rmst2 <- rmst2(time = tmp$os,\n                       status = tmp$censOS,\n                       arm = ifelse(tmp$CMOIC == i,1,0),\n                       tau = tau2)\n        rms.mat2[i,j] <- rmst2$unadjusted.result[1,4]\n        \n        # 计算3个月延迟以后的长期生存率\n        # Long-term survival after a 3-month delay was calculated\n        lts <- Long.test(time = tmp$os,\n                         status = tmp$censOS,\n                         group = ifelse(tmp$CMOIC == i,1,0), # 谁为参考不重要，p值不发生变化，统计量符号会改变 # It doesn't matter who the reference is, the p-value doesn't change, the statistic symbol changes\n                         t0 = t0) # t0为延迟起效的时间 # t0 is the time for the delay to take effect\n        lts.mat[i,j] <- lts$pvalue[4] # 这里我取的是第四个统计量Chi-square(Qua) # Here I take the fourth statistic, Chi-square(Qua)\n      }\n  }\n}\n\n# 输出p值矩阵\n# Output p-value matrix\nwrite.table(rms.mat1,file = paste0(\"output_restricted mean survival p value matrix at \", tau1,\" cutoff.txt\"),sep = \"\\t\",row.names = T,col.names = NA,quote = F)\nwrite.table(rms.mat2,file = paste0(\"output_restricted mean survival p value matrix at \", tau2,\" cutoff.txt\"),sep = \"\\t\",row.names = T,col.names = NA,quote = F)\nwrite.table(lts.mat,file = paste0(\"output_long term survival p value matrix after \", t0,\" delayed effect.txt\"),sep = \"\\t\",row.names = T,col.names = NA,quote = F)\n开始画图\n这里只绘制基本图形，细节均需要AI补充。\nStart drawing\nOnly basic graphics are drawn here, and the details need to be\nsupplemented by AI.\n# 设置颜色\n# Set the color\nclust.col <- c(\"#DD492E\",\"#40548A\",\"#32A087\",\"#EC7D21\")\n\ntmp <- surv\ntmp$os <- tmp$os/30 # 生存时间改为月 # Survival time changed to months\nfit <- survfit(Surv(os, censOS) ~ CMOIC,\n               data      = tmp,\n               type      = \"kaplan-meier\",\n               error     = \"greenwood\",\n               conf.type = \"plain\",\n               na.action = na.exclude)\nnames(fit$strata) <- gsub(\"CMOIC=\", \"\", names(fit$strata)) # 去掉亚组名中的CMOIC字样 # Removed the word CMOIC from the subgroup name\np <- suppressWarnings(ggsurvplot(fit               = fit,\n                                 conf.int          = FALSE,\n                                 risk.table        = FALSE,\n                                 risk.table.col    = \"strata\",\n                                 palette           = clust.col,\n                                 data              = tmp,\n                                 censor            = TRUE,\n                                 size              = 1,\n                                 xlim              = c(0,12), # 第一张KM曲线是用来做RMS，所以只显示到12个月时间，AI补充两个p值矩阵 # The first KM curve is used for RMS, so it is only displayed up to 12 months, and the AI supplements two p-value matrices\n                                 break.time.by     = 2,\n                                 legend.title      = \"\",\n                                 pval              = FALSE, # 不使用log-rank检验总体预后情况 # Do not use log-rank to test for overall prognosis\n                                 surv.median.line  = \"none\",\n                                 xlab              = \"Time (Months)\",\n                                 ylab              = \"Overall survival\",\n                                 risk.table.y.text = FALSE)) \np$plot <- p$plot + \n  theme_bw() +\n  theme(axis.text.x = element_text(size = 10,colour = \"black\"),\n        axis.text.y = element_text(colour = \"black\",size = 10),\n        panel.background = element_blank(),\n        panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank(),\n        legend.position = \"top\") +\n  geom_vline(xintercept = 6, color=\"black\", linetype=\"longdash\", size=0.3) + # 在第6个月处加虚线 # Add a dotted line at the 6th month\n  geom_vline(xintercept = 12, color=\"black\", linetype=\"longdash\", size=0.3) # 在第12个月处加虚线 # Add a dotted line at the 12th month\nggsave(\"kaplan meier curve1.pdf\",width = 5,height = 5)\n\np <- suppressWarnings(ggsurvplot(fit               = fit,\n                                 conf.int          = FALSE,\n                                 risk.table        = FALSE,\n                                 risk.table.col    = \"strata\",\n                                 palette           = clust.col,\n                                 data              = tmp,\n                                 censor            = TRUE,\n                                 size              = 1,\n                                 xlim              = c(0,24), # 第二张KM曲线是长期生存，显示到2年时间，前3个月的延迟效应需要AI修饰 # The second KM curve is long-term survival, showing that up to 2 years, the delay effect of the first 3 months needs to be modified by AI\n                                 break.time.by     = 3,\n                                 legend.title      = \"\",\n                                 pval              = FALSE,\n                                 surv.median.line  = \"none\",\n                                 xlab              = \"Time (Months)\",\n                                 ylab              = \"Overall survival\",\n                                 risk.table.y.text = FALSE)) \np$plot <- p$plot + \n  theme_bw() +\n  theme(axis.text.x = element_text(size = 10,colour = \"black\"),\n        axis.text.y = element_text(colour = \"black\",size = 10),\n        panel.background = element_blank(),\n        panel.grid.major = element_blank(),\n        panel.grid.minor = element_blank(),\n        legend.position = \"top\") +\n  geom_vline(xintercept = 3, color=\"black\", linetype=\"longdash\", size=0.3) # 在第3个月处加虚线 # Add a dotted line at the 3rd month\nggsave(\"kaplan meier curve2.pdf\",width = 5,height = 5)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa251NPHSurv_FigureYa251NPHSurv",
      "title": "FigureYa251NPHSurv/FigureYa251NPHSurv.html",
      "html": "FigureYa251NPHSurv/FigureYa251NPHSurv.html",
      "text": "texts/main_FigureYa251NPHSurv_FigureYa251NPHSurv.txt",
      "folder": "FigureYa251NPHSurv",
      "thumb": "gallery_compress/FigureYa251NPHSurv.webp"
    },
    "word_count": 1314,
    "lines_count": 232,
    "title": "FigureYa251NPHSurv",
    "description": "看起来Xiaofan Lu 用了两种非比例风险的预后模型来计算接受了免疫治疗的队列的生存差异，包括RMS限制性生存均值以及long-term survival分析。这个在临床中很有意义，因为免疫治疗患者确实存在他说的“delayed",
    "input_data_types": [
      "临床数据",
      "生存数据"
    ],
    "output_types": [
      "热图",
      "统计表格",
      "箱线图",
      "生存曲线"
    ],
    "technical_methods": [
      "生存分析"
    ],
    "biology_areas": [
      "免疫学",
      "药物研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "colour",
      "header",
      "width",
      "status",
      "xlim",
      "xintercept",
      "pvalue",
      "fit",
      "group"
    ]
  },
  {
    "id": "main_FigureYa129TCGAbox_FigureYa129TCGAbox",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa129TCGAbox_FigureYa129TCGAbox.txt",
    "content": "FigureYa129TCGAbox\nFigureYa129TCGAbox\nYin Li, Taojun Ye\n2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n用TCGA数据画这种图，在不同分期对比不同分型里某个基因的表达量。从数据下载到出图。\nRequirement description\nDraw this graph using TCGA data to compare the expression level of a\ncertain gene in different stages and subtypes. Download data to generate\nimages.\n出自\nhttps://www.tandfonline.com/doi/full/10.1080/2162402X.2016.1196310\nFrom\nhttps://www.tandfonline.com/doi/full/10.1080/2162402X.2016.1196310\nFigure 2. PD-L1 expression in molecular subtypes (A, B)\nTo investigate the molecular relevance between PD-L1 and glioma, we\nasked the distribution of PD-L1 expression in different molecular\nsubtypes defined by TCGA network. As shown in Figs. 2A and B PD-L1 was\nsignificantly upregulated in mesenchymal subtype than other subtypes in\nboth CGGA and TCGA dataset, except for classical subtype in CGGA data\nset, which also showed apparent trend although not significant. This\nresult enlightened us that PD-L1 may serve as a biomarker for\nmesenchymal subtype.\n应用场景\n基因在哪个分期能区分不同亚型？画这个图一目了然。\n然后还可以像例文那样接着画ROC曲线，画法可参考FigureYa24ROC。\n甚至你可以写成循环，批量画出多个基因，看看哪几个基因的分型效果更好。\nApplication scenarios\nAt which stage can genes distinguish different subtypes? Draw this\npicture at a glance.\nThen you can continue to draw the ROC curve like in the example text,\nand the drawing method can refer to FigureYa24ROC.\nYou can even write it as a loop and draw multiple genes in batches to\nsee which genes have better typing results.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\n# 加载tidyverse包：用于数据处理和可视化（Load tidyverse package: for data processing and visualization）\nlibrary(tidyverse)\n# 加载ggplot2包：用于创建优雅的图形（Load ggplot2 package: for creating elegant graphics）\nlibrary(ggplot2)\n# 加载ggpubr包：用于增强ggplot2的功能（Load ggpubr package: for enhancing ggplot2 functionality）\nlibrary(ggpubr)\n# 加载data.table包：用于高效处理大数据集（Load data.table package: for efficient handling of large datasets）\nlibrary(data.table)\n# 加载gtools包：提供各种辅助函数（Load gtools package: provides various utility functions）\nlibrary(gtools)\n# 加载ggsignif包：用于添加显著性标记（Load ggsignif package: for adding significance markers）\nlibrary(ggsignif)\n\n# 设置环境语言为英文，以便显示英文报错信息（Set environment language to English for English error messages）\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止将字符型变量自动转换为因子类型（Disable automatic conversion of character variables to factors）\noptions(stringsAsFactors = FALSE)\n输入文件的下载：\n从xena\nhttps://xenabrowser.net/datapages/\n下载感兴趣的癌症的表达数据和临床信息。此处以例文数据为例：\n先进入LGG + GBM的基因表达和临床资料所在页面，TCGA lower grade glioma\nand glioblastoma (GBMLGG) (14 datasets)：\nhttps://xenabrowser.net/datapages/?cohort=TCGA%20lower%20grade%20glioma%20and%20glioblastoma%20(GBMLGG)&removeHub=https%3A%2F%2Fxena.treehouse.gi.ucsc.edu%3A443\n：\ngene expression RNAseq，IlluminaHiSeq (n=702) TCGA\nhub，下载地址：\nhttps://tcga.xenahubs.net/download/TCGA.GBMLGG.sampleMap/HiSeqV2.gz\nsomatic non-silent mutation (gene-level)，PANCAN AWG (n=461) TCGA\nhub，下载地址：\nhttps://tcga.xenahubs.net/download/TCGA.GBMLGG.sampleMap/mutation.gz\nphenotype，Phenotypes (n=1,148) TCGA hub，下载地址：\nhttps://tcga.xenahubs.net/download/TCGA.GBMLGG.sampleMap/GBMLGG_clinicalMatrix.gz\n再进入LGG的WHO grade资料所在页面，TCGA Lower Grade Glioma (LGG) (27\ndatasets)：\nhttps://xenabrowser.net/datapages/?dataset=TCGA.LGG.sampleMap%2FLGG_clinicalMatrix&host=https%3A%2F%2Ftcga.xenahubs.net&removeHub=https%3A%2F%2Fxena.treehouse.gi.ucsc.edu%3A443\n：\nphenotype，Phenotypes (n=530) TCGA hub，下载地址：\nhttps://tcga.xenahubs.net/download/TCGA.LGG.sampleMap/LGG_clinicalMatrix.gz\nDownload the input file:\nFrom Xena<\nhttps://xenabrowser.net/datapages/\n>Download the\nexpression data and clinical information of the cancer of interest. Here\nis an example of sample data:\nFirst, enter the page where the gene expression and clinical data of\nLGG+GBM are located, TCGA lower grade glioma and glioblastoma (GBMLGG)\n(14 datasets)：<\nhttps://xenabrowser.net/datapages/?cohort=TCGA%20lower%20grade%20glioma%20and%20glioblastoma%20\n(GBMLGG)&removeHub=https%3A%2F%2Fxena.treehouse.gi.ucsc.edu%3A443>：\ngene expression RNAseq，IlluminaHiSeq (n=702) TCGA hub， Download\nlink:<\nhttps://tcga.xenahubs.net/download/TCGA.GBMLGG.sampleMap/HiSeqV2.gz\n>\nsomatic non-silent mutation (gene-level)，PANCAN AWG (n=461) TCGA\nhub， Download link:<\nhttps://tcga.xenahubs.net/download/TCGA.GBMLGG.sampleMap/mutation.gz\n>\nphenotype，Phenotypes (n=1,148) TCGA hub， Download link:<\nhttps://tcga.xenahubs.net/download/TCGA.GBMLGG.sampleMap/GBMLGG_clinicalMatrix.gz\n>\nGo back to the page where LGG’s WHO grade information is located,\nTCGA Lower Grade Glioma (LGG) (27 datasets)：<\nhttps://xenabrowser.net/datapages/?dataset=TCGA.LGG.sampleMap%2FLGG_clinicalMatrix&host=https%3A%2F%2Ftcga.xenahubs.net&removeHub=https%3A%2F%2Fxena.treehouse.gi.ucsc.edu%3A443\n>：\nphenotype，Phenotypes (n=530) TCGA hub， Download link:<\nhttps://tcga.xenahubs.net/download/TCGA.LGG.sampleMap/LGG_clinicalMatrix.gz\n>\n输入文件预处理\nInput file preprocessing\n# 将多形性胶质母细胞瘤直接列为IV级（Classify glioblastoma as Grade IV）\nclniical_all$grade <- na.replace(clniical_all$neoplasm_histologic_grade,'G4')\nclniical_all$sample <- clniical_all$sampleID\nclniical_all <- clniical_all[,c(5,4)]\n\n### 合并所有数据（表达、突变、临床）（Merge all data (expression, mutation, clinical)）\nalldata <- left_join(clniical_all,exp_mut)\n# 删除缺失值（Remove missing values）\nalldata <- na.omit(alldata)\nalldata <- filter(alldata,alldata$grade!='[Discrepancy]')\n\n# 把G替换为Grade（Replace 'G' with 'Grade'）\nalldata$grade <- str_replace_all(alldata$grade,'G','Grade ')\nalldata$grade <- str_replace_all(alldata$grade,'4','IV')\nalldata$grade <- str_replace_all(alldata$grade,'3','III')\nalldata$grade <- str_replace_all(alldata$grade,'2','II')\n\n# 突变状态也修改一下（Modify mutation status notation）\nalldata$mut <- ifelse(alldata$IDH1=='0','WT','Mut')\nalldata$CD274 <- as.numeric(alldata$CD274)\n开始画图\nStart plot\n# 创建基于IDH突变状态分组的PD-L1表达箱线图，按肿瘤分级分面展示（Create boxplot of PD-L1 expression grouped by IDH mutation status, faceted by tumor grade）\nggplot(alldata, aes(x=mut, y=CD274)) + \n  # 添加箱线图，按突变状态着色，设置透明度为0（无填充），宽度为0.6（Add boxplot colored by mutation status, transparency 0, width 0.6）\n  geom_boxplot(aes(color=mut), alpha=0, width=0.6) +\n  # 按肿瘤分级水平分面（Facet by tumor grade horizontally）\n  facet_grid(.~grade) +\n  # 添加抖动散点图，展示每个样本的数据点，按突变状态着色，设置抖动宽度为0.2（Add jittered scatter plot to show individual data points, colored by mutation status, jitter width 0.2）\n  geom_jitter(aes(color=mut), width = 0.2) +\n  # 使用黑白主题（Use black and white theme）\n  theme_bw() +\n  # 添加显著性标记，比较突变组和野生型组，使用Wilcoxon检验，映射显著性水平（Add significance markers for comparison between mutant and wild-type groups using Wilcoxon test）\n  geom_signif(comparisons = list(c('Mut','WT')), map_signif_level = T, test = 'wilcox.test') +\n  # 设置Y轴标签为\"PD-L1 Expression\"（Set Y-axis label）\n  ylab('PD-L1 Expression') +\n  # 隐藏图例（Hide legend）\n  guides(color = FALSE) +\n  # 设置X轴标签为\"IDH Mutation Status\"（Set X-axis label）\n  xlab('IDH Mutation Status') +\n  # 设置图标题为\"PD-L1 Expression in TCGA dataset\"（Set plot title）\n  labs(title = 'PD-L1 Expression in TCGA dataset') +\n  # 自定义主题设置：标题大小20，居中；坐标轴标签和刻度文字大小和颜色设置（Customize theme: title size 20, centered; axis text and title size and color）\n  theme(title = element_text(size = 20, colour = 'black'),\n        plot.title = element_text(hjust = 0.5),\n        axis.text.y = element_text(size = 11, colour = 'black'),\n        axis.text.x = element_text(size = 11, colour = 'black'),\n        axis.title.x = element_text(size = 15, colour = 'black'),\n        axis.title.y = element_text(size = 15, colour = 'black'),\n        strip.text.x = element_text(size = 15, colour = 'black'))\n# 将图形保存为PDF文件（Save plot as PDF file）\nggsave('PD-L1.pdf')\n第一组不显著的那个“NS”就拿AI抹去了吧～\nLet’s use AI to erase the insignificant ‘NS’ in the first group\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa129TCGAbox_FigureYa129TCGAbox",
      "title": "FigureYa129TCGAbox/FigureYa129TCGAbox.html",
      "html": "FigureYa129TCGAbox/FigureYa129TCGAbox.html",
      "text": "texts/main_FigureYa129TCGAbox_FigureYa129TCGAbox.txt",
      "folder": "FigureYa129TCGAbox",
      "thumb": "gallery_compress/FigureYa129TCGAbox.webp"
    },
    "word_count": 776,
    "lines_count": 170,
    "title": "FigureYa129TCGAbox",
    "description": "用TCGA数据画这种图，在不同分期对比不同分型里某个基因的表达量。从数据下载到出图。 Requirement description Draw this graph using TCGA data to compare the expression level of a",
    "input_data_types": [
      "临床数据",
      "突变数据"
    ],
    "output_types": [
      "散点图",
      "箱线图",
      "统计表格",
      "网络图"
    ],
    "technical_methods": [
      "网络分析",
      "生存分析"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "colour",
      "width",
      "n",
      "map_signif_level",
      "cohort",
      "LANGUAGE",
      "x",
      "test",
      "color"
    ]
  },
  {
    "id": "main_FigureYa107ChIPheatmap_FigureYa107ChIPheatmap",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa107ChIPheatmap_FigureYa107ChIPheatmap.txt",
    "content": "FigureYa107ChIPheatmap\nFigureYa107ChIPheatmap\n¶\ntitle: \"FigureYa107ChIPheatmap\"\nauthor: \"Long Zhao, Taojun Ye\"\nreviewer: \"Ying Ge\"\ndate: \"2025-5-20\"\noutput: html_document\n需求描述\n¶\n复现这个图，左侧按ChIP-seq聚类，右侧ATAC-seq行的排序跟左侧对应一致。\n出自：\nhttp://genesdev.cshlp.org/content/32/2/96.long\n对这篇文章的解读：\nhttps://mp.weixin.qq.com/s/zmf0GMdGZqNxseFZKHooOw\nRequirement description\n¶\nReproduce this image, cluster the left side according to ChIP seq, and the sorting of the ATAC seq rows on the right side corresponds to the left side.\n! [] (example. png)\nfrom:<\nhttp://genesdev.cshlp.org/content/32/2/96.long\n>\nInterpretation of this article:<\nhttps://mp.weixin.qq.com/s/zmf0GMdGZqNxseFZKHooOw\n>\n应用场景\n¶\n不仅限于按ChIP-seq的顺序排ATAC-seq，还可以自己组合各种factor的ChIP-seq，进而发现规律。\n例如：在转录因子结合位点，染色质开放程度是怎样的？组蛋白修饰的分布是怎样的？\n场景一：手上有多组ChIP-seq/ATAC-seq数据，按一种数据的聚类来排序，从其他数据的分布中发现规律。\n场景二：自己只测了一两个样品的ChIP-seq/ATAC-seq，只画一条多难看，可以再找些公共数据，按这个画法，能深挖出更多规律。\nApplication scenarios\n¶\nNot limited to arranging ATAC seq in the order of ChIP seq, one can also combine ChIP seq of various factors to discover patterns.\nFor example, what is the degree of chromatin opening at transcription factor binding sites? What is the distribution of histone modifications?\nScenario 1: There are multiple sets of ChIP seq/ATAC seq data in hand, sorted by clustering one type of data, and patterns are discovered from the distribution of other data.\nScenario 2: I only tested the ChIP seq/ATAC seq of one or two samples, and drawing only one line is not very good. You can find some public data and use this drawing method to dig out more patterns.\n环境设置\n¶\n下载并安装Anaconda发行版，\nhttps://www.anaconda.com/distribution/#download-section\n用Jupyter notebook打开FigureYa107ChIPheatmap.ipynb文档\n用法参考这篇：\nhttps://mp.weixin.qq.com/s/G-CQhNEJBmMRuDe2kxND_w\n通过conda安装deeptools：\nEnvironment settings\n¶\nDownload and install the Anaconda distribution,\nhttps://www.anaconda.com/distribution/#download\n-section\nOpen the FigureYa107ChIPheatmap.ipynb document with Jupyter notebook\nRefer to this article for usage:\n<\nhttps://mp.weixin.qq.com/s/G-CQhNEJBmMRuDe2kxND_w\n>\nInstall Deeptools through conda:\nIn [ ]:\nimport\nsys\nprint\n(\nsys\n.\nexecutable\n)\nIn [ ]:\n!\nconda\ninstall\n-c\nbioconda\ndeeptools\n输入数据的准备\n¶\n如果你的ChIP-seq/ATAC-seq数据已经保存为bw文件，并且有相应的peak.bed文件，就可以跳过这步，直接进入“开始画图”。\nPreparation of input data\n¶\nIf your ChIP seq/ATAC seq data has already been saved as a bw file and there is a corresponding peak.bed file, you can skip this step and directly enter \"Start Drawing\".\n数据下载\n¶\n测序数据在发表文章时，作者会把数据上传到GEO/SRA数据库，GEO里除了原始的fastq文件外，往往还会提供bigwig（bw）文件、或bedGraph文件，以及peak.bed文件等等。\n哪些数据更靠谱？\n推荐首选高影响因子的文章里的数据，快速查询高分数据的方式，可参考FigureYa104GEOmining。\n例文的数据链接：\nhttps://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE107242\n，点击Download中的(custom)，选择以下文件下载：\nData Download\n¶\nWhen publishing sequencing data, authors will upload the data to the GEO/SRA database. In addition to the original fastq file, GEO often provides bigwig (bw) files, bedGraph files, peak.bed files, and so on.\n**Which data is more reliable? **Recommend selecting data from articles with high impact factors, and refer to Figure Ya104 GEOmining for a quick way to query high scoring data.\nData link for example text:<\nhttps://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE107242\n>Click on (custom) in Download and select the following file to download:\nGSM2863128_N06_0.RPKM_nor.bw\nGSM2863129_NO6_24.RPKM_nor.bw\nGSM2863130_NO6_72.RPKM_nor.bw\nGSM2863131_NO6_cd19pos.RPKM_nor.bw\nGSM2863142_Input_NO14_24_mm9.bedGraph.gz\nGSM2863147_EBF1_NO14_24_mm9.bedGraph.gz\nGSM2863148_EBF1_NO14_72_mm9.bedGraph.gz\nGSM2863149_EBF1_NO14_cd19pos_mm9.bedGraph.gz\n转换bedgraph到bigwig文件\n¶\n例文给出的ChIP-seq数据是bedgraph格式，需要转换成bigwig文件。用的是UCSC的bedGraphToBigWig，用法参考这里的Example 3：\nhttp://genome.ucsc.edu/goldenPath/help/bigWig.html\n下载工具：bedGraphToBigWig，根据自己的系统选择合适的版本\nConvert bedgraph to bigwig file\n¶\nThe ChIP seq data provided in the example text is in bedgraph format and needs to be converted into a bigwig file. I am using UCSC's bedGraphToBigWig, refer to Example 3 for usage here:<\nhttp://genome.ucsc.edu/goldenPath/help/bigWig.html\n>\nDownload tool: bedGraphToBigWig, choose the appropriate version according to your own system\nIn [ ]:\n#我用wget下载，你也可以复制粘贴地址，直接从浏览器下载\n#I downloaded it using wget, but you can also copy and paste the address and download it directly from the browser\n!\nwget\nhttp://hgdownload.soe.ucsc.edu/admin/exe/linux.x86_64/bedGraphToBigWig\n!\nwget\nhttp://hgdownload.soe.ucsc.edu/admin/exe/macOSX.x86_64/bedGraphToBigWig\n!\nchmod\n775\nbedGraphToBigWig\n有可能需要添加环境变量\n下载mm9的染色体长度的文件\nIt may be necessary to add environment variables\nDownload the file of chromosome length for mm9\nIn [ ]:\n!\n/opt/homebrew/bin/wget\nhttp://hgdownload.cse.ucsc.edu/goldenPath/mm9/bigZips/mm9.chrom.sizes\n现在就可以把ChIP-seq的bedGraph文件转成bw了：\nNow you can convert the ChIP seq bedGraph file to bw:\nIn [ ]:\n!\nfor\nfile\nin\n*.bedGraph.peak.bed\n;\ndo\nsort\n-k1,1\n-k2,2n\n$file\n>\n$file\n.sorted.bedGraph\n;\n./bedGraphToBigWig\n$file\n.sorted.bedGraph\nmm9.chrom.sizes\n$file\n.bw\n;\nrm\n$file\n.sorted.bedGraph\n;\ndone\n获得peak.bed\n¶\n可以跳过这步，直接用我跑好的allpeak.bed文件\n文章没有提供每个样品的peak文件，找peak不是这里的重点，就不从mapping开始跑了。仅从文章提供的EBF1 ChIP-seq的bedgraph文件开始做，定义较高的位置为peak，作为示例文件。有点粗糙，但足够用于展示需求描述所需解决的问题。\nGet peak.bed\n¶\nYou can skip this step and directly use the allpeak.bed file that I have run\nThe article did not provide a peak file for each sample, so finding the peak is not the focus here, so we won't start with mapping. Starting from the bedgraph file of EBF1 ChIP seq provided in the article, define the higher position as peak as an example file. A bit rough, but sufficient to demonstrate the problem that needs to be solved in the requirement description.\nIn [ ]:\n# 筛选所有GSM编号的EBF1相关bedGraph文件中信号值大于80的区域，输出为peak.bed格式\n# 语法说明：$4表示第四列数据(通常是信号值)，$file.peak.bed是输出文件名\n# Filter regions with signal value >80 from all GSM EBF1-related bedGraph files, output as peak.bed format\n# Syntax explanation: $4 refers to the fourth column (usually signal value), $file.peak.bed is the output filename\n!\nfor\nfile\nin\nGSM*_EBF1_*.bedGraph\n;\ndo\nawk\n'$4> 80 {print}'\n$file\n>\n$file\n.peak.bed\n;\ndone\n# 通过bioconda渠道安装bedtools工具集(用于基因组区间操作)\n# 注意：需要提前配置好conda环境和bioconda渠道\n# Install bedtools toolkit via bioconda channel (for genomic interval operations)\n# Note: Conda environment and bioconda channel need to be configured in advance\n!\nconda\ninstall\n-c\nbioconda\nbedtools\n# 合并所有peak.bed文件并进行坐标排序，然后使用bedtools合并重叠区间\n# 排序参数说明：-k1.1V按染色体名称排序，-k2,2n和-k3,3n按起始和终止坐标数值排序\n# Merge all peak.bed files, sort by genomic coordinates, and merge overlapping intervals using bedtools\n# Sorting parameters: -k1.1V sorts by chromosome name, -k2,2n and -k3,3n sort by start and end coordinates numerically\n!\ncat\n*.peak.bed\n|\nsort\n-k1.1V\n-k2,2n\n-k3,3n\n|\nbedtools\nmerge\n-i\n-\n>\nallpeak.bed\n附：\n正常的做法是用MACS2从每个样本的bam文件里call出peak.bed，例如：\n**Attachment: * * The normal practice is to use MACS2 to call peak.bed from the BAM file of each sample, for example:\nmacs2\ncallpeak\n-c\nInput.bam\n-t\ntreatment.bam\n-q\n0\n.05\n-f\nBAM\n-g\nmm\n-n\ntreatment\n2\n>\ntreatment.macs2.log\n开始画图-左侧ChIP-seq\n¶\n每次运行computeMatrix大概需要10分钟，具体用法参见\nhttps://deeptools.readthedocs.io/en/develop/content/tools/computeMatrix.html?highlight=computeMatrix\n，下面是computeMatrix的主要参数说明：\n--referencePoint center：中间对齐\n-b 3000 -a 3000：前后距离\n-R xx.bed：bed文件\n-S Input.bw 24_EBF1.bw 72_EBF1.bw prob_EBF1.bw：准备的bigwig文件\nplotHeatmap的具体用法参见\nhttps://deeptools.readthedocs.io/en/develop/content/tools/plotHeatmap.html?highlight=plotHeatmap\n，主要参数说明：\n--zMax 150 ： colorbar的最大值，对应的还有最小值--zMin\n这里有一个关键是--outFileSortedRegions这个参数。\n这里输出的bed文件就是我们heatmap对应的文件。主要用于绘制后面ATAC的heatmap与之对应。\nStart drawing - ChIP seq on the left\n¶\nIt takes about 10 minutes to run computeMatrix each time. For specific usage, please refer to<\nhttps://deeptools.readthedocs.io/en/develop/content/tools/computeMatrix.html?highlight=computeMatrix\n>Here are the main parameter descriptions of computeMatrix:\n--ReferencePoint center: center alignment\n-B 3000- a 3000: Front to back distance\n-R xx.bed: bed file\n-S Input.bw 24_SBF1.bw 72_SBF1.bw prob_SBF1.bw: prepared bigwig file\nFor the specific usage of plotHeatmap, please refer to<\nhttps://deeptools.readthedocs.io/en/develop/content/tools/plotHeatmap.html?highlight=plotHeatmap\n>Main parameter description:\n--ZMax 150: The maximum value of colorbar corresponds to the minimum value - zMin\nThere is a key parameter here - outFileSortedRegions.\nThe bed file output here is the file corresponding to our heatmap. Mainly used to draw the heatmap corresponding to ATAC in the future.\nIn [ ]:\n# 使用deepTools的computeMatrix工具计算峰区域(center点)上下游3kb范围内的信号矩阵\n# 参数说明：\n# --referencePoint center：以峰中心为参考点\n# -b 3000 -a 3000：参考点上下游各扩展3000bp\n# --missingDataAsZero：将缺失数据视为0\n# --skipZeros：跳过全零区域提高计算效率\n# -p 40：使用40个线程并行计算\n# -R：输入的参考区域文件(allpeak.bed)\n# -S：输入的信号值文件(多个bigWig格式)\n# -o：输出的矩阵文件名(nom.gz)\n# Calculate signal matrix for 3kb regions around peak centers using deepTools' computeMatrix\n# Parameter explanation:\n# --referencePoint center: Use peak center as reference point\n# -b 3000 -a 3000: Extend 3000bp upstream and downstream from reference point\n# --missingDataAsZero: Treat missing data as 0\n# --skipZeros: Skip regions with all zeros to improve efficiency\n# -p 40: Use 40 threads for parallel computation\n# -R: Input reference regions file (allpeak.bed)\n# -S: Input signal files (multiple bigWig format)\n# -o: Output matrix file (nom.gz)\n!\ncomputeMatrix\nreference-point\n--referencePoint\ncenter\n-b\n3000\n-a\n3000\n--missingDataAsZero\n--skipZeros\n-p\n40\n-R\nallpeak.bed\n-S\nGSM2863142_Input_NO14_24_mm9.bedGraph.bw\nGSM2863147_EBF1_NO14_24_mm9.bedGraph.bw\nGSM2863148_EBF1_NO14_72_mm9.bedGraph.bw\nGSM2863149_EBF1_NO14_cd19pos_mm9.bedGraph.bw\n-o\nnom.gz\n# 使用plotHeatmap工具基于计算的矩阵绘制热图，并输出聚类后的区域文件\n# 参数说明：\n# -m：输入的矩阵文件(nom.gz)\n# -out：输出的热图文件名(ChIP-pre.pdf)\n# --zMax 150：颜色映射的最大值设为150\n# --kmeans 5：使用k-means算法将区域聚为5类\n# --outFileSortedRegions：输出聚类排序后的区域文件\n# --samplesLabel：为每个样本指定标签\n# Generate heatmap from computed matrix using plotHeatmap, and output clustered regions\n# Parameter explanation:\n# -m: Input matrix file (nom.gz)\n# -out: Output heatmap file (ChIP-pre.pdf)\n# --zMax 150: Set maximum value for color scale to 150\n# --kmeans 5: Cluster regions into 5 groups using k-means algorithm\n# --outFileSortedRegions: Output file for sorted/clustered regions\n# --samplesLabel: Assign labels to each sample\n!\nplotHeatmap\n-m\nnom.gz\n-out\nChIP-pre.pdf\n--zMax\n150\n--kmeans\n5\n--outFileSortedRegions\nHeatmap1sortedRegions.bed\n--samplesLabel\n0hrs\n24hrs\n72hrs\npro-B\n生成的图在ChIP-pre.pdf里，位于当前文件夹。可以看出最上面两个cluster里的信号不像peak，这是上面找peak的方式粗糙导致的，正常自己的peak文件中应该不会存在这种情况。我们把这些异常的peak删掉就好了：\nThe generated image is in ChIP pre. pdf, located in the current folder. It can be seen that the signals in the top two clusters are not like peaks, which is caused by the rough way of finding peaks above. Normally, this situation should not exist in one's own peak file. We just need to delete these abnormal peaks:\nIn [ ]:\n# 从热图聚类结果中筛选出不属于cluster_1和cluster_2的peak区域\n# 语法说明：\n# grep -v：反向筛选，排除匹配的行\n# 首先排除cluster_1，然后在剩余结果中排除cluster_2\n# 最终结果输出到allpeak2.bed，用于后续分析\n# Filter out peaks belonging to cluster_1 and cluster_2 from the heatmap clustering results\n# Syntax explanation:\n# grep -v: Inverse filtering, exclude lines that match the pattern\n# First exclude cluster_1, then exclude cluster_2 from the remaining results\n# The final result is output to allpeak2.bed for subsequent analysis\n!\ngrep\n-v\ncluster_1\nHeatmap1sortedRegions.bed\n|\ngrep\n-v\ncluster_2\n>\nallpeak2.bed\n然后再运行一次\nThen run it again\nIn [ ]:\n#计算矩阵\n!\ncomputeMatrix\nreference-point\n--referencePoint\ncenter\n-b\n3000\n-a\n3000\n--missingDataAsZero\n--skipZeros\n-p\n40\n-R\nallpeak2.bed\n-S\nGSM2863142_Input_NO14_24_mm9.bedGraph.bw\nGSM2863147_EBF1_NO14_24_mm9.bedGraph.bw\nGSM2863148_EBF1_NO14_72_mm9.bedGraph.bw\nGSM2863149_EBF1_NO14_cd19pos_mm9.bedGraph.bw\n-o\nnom.gz\n#画图，并输出bed文件，用于画右侧ATAC-seq\n!\nplotHeatmap\n-m\nnom.gz\n-out\nChIP.pdf\n--zMax\n150\n--kmeans\n5\n--outFileSortedRegions\nHeatmap1sortedRegions.bed\n--samplesLabel\n0hrs\n24hrs\n72hrs\npro-B\n#如果不想画average profile，就加上参数：--whatToShow \"heatmap and colorbar\"\n生成的图在ChIP.pdf里，位于当前文件夹。\nChIP.pdf蓝色最大值已经超过100，原文只有16，这与生成bigwig文件时bamCoverage --normalizeUsing RPKM或其他标准化方法（CPM, BPM, RPGC）有很大关系。同时还跟这一步用bin的大小有关。\n这里我觉得主要是bin的大小的原因。--binSize 越大，这个值就越大。所以我估计原文画图的时候用的bin是比较小的。\n原文没有提供bw文件，我们通过bedgraph转过来，这个bin就有点大，所以数值就偏大。\n看后面ATAC-seq的大小跟文章就很一致，因为用的是文章提供的bigwig文件。\n具体分析自己的数据时，左右两侧数据从头开始用同样的标准和参数处理就可以了。\nThe generated image is located in ChIP.pdf, in the current folder.\nThe maximum blue value of ChIP.pdf has exceeded 100, while the original text only has 16, which is closely related to the normalization using RPKM or other standardization methods (CPM, BPM, RPGC) when generating bigwig files. It is also related to the size of the bin used in this step.\nI think the main reason here is the size of the bin. --The larger the binSize, the greater this value. So I estimate that the bin used in the original drawing was relatively small.\nThe original text did not provide a BW file. We converted it through the bedgraph, and this bin is a bit large, so the value is biased towards a larger value.\nThe size of ATAC seq is consistent with the article, as it uses the bigwig file provided in the article. When analyzing one's own data specifically, the data on both sides can be processed from scratch using the same standards and parameters.\n开始画图-右侧ATAC-seq\n¶\ncomputeMatrix里用到的-R为上面画ChIP-seq的图时输出的bed文件，里面是有顺序的。\nplotHeatmap的主要参数：\n--sortRegions keep ： 这个参数是一个关键，要保证和ChIP-seq的顺序是一致的。\n--colorMap 'Greens'：颜色，deeptools还有很多颜色可以选，具体参考help。\n--whatToShow ：这个是展示heatmap还是带有profile的heatmap还是其他。可以参考help。\n--samplesLabel： 标签的label\nStart drawing - ATAC seq on the right\n¶\nThe - R used in computeMatrix is the bed file output when drawing the ChIP seq graph above, which is in order.\nThe main parameters of plotHeatmap are:\n--SortRegions keep: This parameter is crucial to ensure consistency with the order of ChIP seq.\n--ColorMap 'Greens': There are many colors to choose from in deeptools, please refer to help for details.\n--WhatsApp Show: Is this showing a heatmap or a heatmap with a profile, or something else. You can refer to help.\n--SamplesLabel: label of the label\nIn [ ]:\n# 使用deepTools的computeMatrix工具计算热图聚类区域(center点)上下游3kb范围内的信号矩阵\n# 参数说明：\n# --referencePoint center：以区域中心为参考点\n# -b 3000 -a 3000：参考点上下游各扩展3000bp\n# --missingDataAsZero：将缺失数据视为0\n# --skipZeros：跳过全零区域提高计算效率\n# -p 40：使用40个线程并行计算\n# -R：输入的参考区域文件(Heatmap1sortedRegions.bed)\n# -S：输入的信号值文件(多个bigWig格式)\n# -o：输出的矩阵文件名(nom2.gz)\n# Calculate signal matrix for 3kb regions around centers of clustered regions using deepTools' computeMatrix\n# Parameter explanation:\n# --referencePoint center: Use region center as reference point\n# -b 3000 -a 3000: Extend 3000bp upstream and downstream from reference point\n# --missingDataAsZero: Treat missing data as 0\n# --skipZeros: Skip regions with all zeros to improve efficiency\n# -p 40: Use 40 threads for parallel computation\n# -R: Input reference regions file (Heatmap1sortedRegions.bed)\n# -S: Input signal files (multiple bigWig format)\n# -o: Output matrix file (nom2.gz)\n!\ncomputeMatrix\nreference-point\n--referencePoint\ncenter\n-b\n3000\n-a\n3000\n--missingDataAsZero\n--skipZeros\n-p\n40\n-R\nHeatmap1sortedRegions.bed\n-S\nGSM2863128_N06_0.RPKM_nor.bw\nGSM2863129_NO6_24.RPKM_nor.bw\nGSM2863130_NO6_72.RPKM_nor.bw\nGSM2863131_NO6_cd19pos.RPKM_nor.bw\n-o\nnom2.gz\n# 使用plotHeatmap工具基于计算的矩阵绘制热图\n# 参数说明：\n# -m：输入的矩阵文件(nom2.gz)\n# -out：输出的热图文件名(ATAC.pdf)\n# --sortRegions keep：保持输入文件的区域顺序(不重新排序)\n# --zMax 15：颜色映射的最大值设为15\n# --colorMap 'Greens'：使用绿色系的颜色映射\n# --samplesLabel：为每个样本指定标签\n# --whatToShow \"heatmap and colorbar\"：只显示热图和颜色条(不显示平均曲线)\n# Generate heatmap from computed matrix using plotHeatmap\n# Parameter explanation:\n# -m: Input matrix file (nom2.gz)\n# -out: Output heatmap file (ATAC.pdf)\n# --sortRegions keep: Maintain input region order (do not re-sort)\n# --zMax 15: Set maximum value for color scale to 15\n# --colorMap 'Greens': Use green color palette\n# --samplesLabel: Assign labels to each sample\n# --whatToShow \"heatmap and colorbar\": Show only heatmap and colorbar (no average profile)\n!\nplotHeatmap\n-m\nnom2.gz\n-out\nATAC.pdf\n--sortRegions\nkeep\n--zMax\n15\n--colorMap\n'Greens'\n--samplesLabel\n0hrs\n24hrs\n72hrs\npro-B\n# If you don't want to show the average profile, add the parameter: --whatToShow \"heatmap and colorbar\"\n生成的图在ATAC.pdf里，位于当前文件夹\nThe generated image is located in the current folder of ATAC.gdf\n后期处理\n¶\n输出的pdf文件都是矢量图，可以在Illustrator等编辑器里打开，编辑图形、文字、组图。\nPost processing\n¶\nThe output PDF files are all vector graphics that can be opened in editors such as Illustrator to edit graphics, text, and group images.\nIn [ ]:\nimport\nIPython\nprint\n(\nIPython\n.\nsys_info\n())\n!\njupyter\nnbconvert\n--to\nhtml\nFigureYa107ChIPheatmap.ipynb\nIn [ ]:",
    "chapter_info": {
      "id": "main_FigureYa107ChIPheatmap_FigureYa107ChIPheatmap",
      "title": "FigureYa107ChIPheatmap/FigureYa107ChIPheatmap.html",
      "html": "FigureYa107ChIPheatmap/FigureYa107ChIPheatmap.html",
      "text": "texts/main_FigureYa107ChIPheatmap_FigureYa107ChIPheatmap.txt",
      "folder": "FigureYa107ChIPheatmap",
      "thumb": "gallery_compress/FigureYa107ChIPheatmap.webp"
    },
    "word_count": 2008,
    "lines_count": 546,
    "title": "FigureYa107ChIPheatmap",
    "description": "¶ 复现这个图，左侧按ChIP-seq聚类，右侧ATAC-seq行的排序跟左侧对应一致。 出自：",
    "input_data_types": [
      "临床数据",
      "DNA-seq"
    ],
    "output_types": [
      "热图",
      "统计表格"
    ],
    "technical_methods": [
      "聚类分析",
      "标准化",
      "motif分析"
    ],
    "biology_areas": [
      "药物研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "acc",
      "highlight"
    ]
  },
  {
    "id": "main_FigureYa34count2FPKMv2_FigureYa34count2FPKMv2",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa34count2FPKMv2_FigureYa34count2FPKMv2.txt",
    "content": "FigureYa34 count2FPKMv2\nFigureYa34 count2FPKMv2\nAuthor(s)\n: Ying Ge, Yuan Tang; Yijing Chen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\nRNA-seq read count转换成FPKM。\nRNA-seq read count converted to FPKM.\n应用场景\nApplication scenario\n只能拿到RNA-seq数据的read count，想转换成FPKM。\n注：FPKM的计算方式最好是直接从原始的FASTQ文件开始计算\nYou can only get the read count of the RNA-seq data and want to\nconvert to FPKM.\nNote: The best calculation method of FPKM is to start directly from\nthe original FASTQ file.\n计算基因长度\nCalculate gene length\n这步比较耗时。建议：\n使用TCGA数据的小伙伴可以直接使用压缩包里的\ngene_length.csv\n文件，就可以跳过这步，直接从“输入数据”开始运行。\n每个物种每个基因组注释版本的基因长度是相同的，下面这部分代码你只需要运行一次，保存好生成的\neff_length.csv\n文件，标注好基因组版本。当你需要做count到FPKM或TPM的转换时，就可以跳过“计算基因长度”这步，直接从“read\ncount转FPKM”开始运行。\n此处以TCGA的read\ncount作为输入，因此，用跟TCGA一致的注释文件提取外显子长度。\n去\nhttps://api.gdc.cancer.gov/data/fe1750e4-fc2d-4a2c-ba21-5fc969a24f27\n下载gtf文件，解压缩到当前文件夹。\n计算基因长度的代码作者：biotrainee tang\nThis step is more time consuming. Suggestion:\nIf you are using TCGA data, you can directly use the\ngene_length.csv\nfile in the zip package, you can skip this\nstep, and run directly from “Input data”.\nEach species has the same gene length for each annotated version\nof the genome, so you only need to run this part of the code once, save\nthe generated\neff_length.csv\nfile, and annotate the genome\nversion. When you need to do the conversion from count to FPKM or TPM,\nyou can skip the step of “Calculate gene length”, and start running\ndirectly from “read count to FPKM”.\nHere, the read count of TCGA is used as input, so the exon lengths\nare extracted from the same annotation file as TCGA.\nGo to\nhttps://api.gdc.cancer.gov/data/fe1750e4-fc2d-4a2c-ba21-5fc969a24f27\nto download the gtf file and extract it to the current folder.\nCode to calculate gene length by biotrainee tang\n数据的准备\nData preparation\n如果你自己的RNA-seq数据已经保存成\neasy_input.csv\n的格式，就跳过这步，直接进入“输入数据”\n此处下载TCGA RNA-seq的read\ncount和FPKM，前者用于演示代码，后者用于对比结果。\nsample跟\nFigureYa22 FPKM2TPM\n、\nFigureYa23 count2TPM\n一致\nIf your own RNA-seq data has been saved as\neasy_input.csv\n, skip this step and go directly to “Input\ndata”.\nDownload TCGA RNA-seq read count and FPKM here, the former is used to\ndemonstrate the code, the latter is used to compare the results.\nThe sample is the same as\nFigureYa22 FPKM2TPM\nand\nFigureYa23 count2TPM\n.\n先下载read count，用于转换成FPKM\nDownload read count first, and use it to convert to FPKM\nlibrary(TCGAbiolinks)\nexpquery <- GDCquery(project = \"TCGA-LIHC\", \n                data.category = \"Transcriptome Profiling\",\n                data.type = \"Gene Expression Quantification\",\n                workflow.type = \"HTSeq - Counts\",\n                barcode = c(\"TCGA-DD-A11D-01A-11R-A131-07\",\"TCGA-DD-AACT-01A-11R-A41C-07\",\"TCGA-G3-AAUZ-01A-11R-A38B-07\",\"TCGA-EP-A26S-11A-12R-A16W-07\")#去掉这行，就能提取所有sample的数据 remove this line and you can extract all the sample data\n                )\nGDCdownload(expquery)\nexpquery2 <- GDCprepare(expquery)\nexpMatrix <- TCGAanalyze_Preprocessing(expquery2)\n\nwrite.csv(expMatrix, \"easy_input.csv\", quote=F, row.names=T)\n再下载同样4个Sample的FPKM，用于对比从TCGA下载的FPKM跟用read\ncount转成的FPKM\nDownload the FPKM of the same 4 samples, to compare the FPKM\ndownloaded from TCGA with the FPKM converted by read count\nTCGA GDC提供多种表达值类型：read count、HTSeq - FPKM、HTSeq -\nFPKM-UQ。后两者有什么区别？\n“上四分位点 FPKM（FPKM-UQ）是一种改进的 FPKM\n计算方法，其中蛋白质编码总读数被样本的第 75 百分位读数值所取代”。\n出自\nhttps://docs.gdc.cancer.gov/Data/Bioinformatics_Pipelines/Expression_mRNA_Pipeline/\n此处下载HTSeq - FPKM\nTCGA GDC provides several types of expression values: read count,\nHTSeq - FPKM, HTSeq - FPKM-UQ. what is the difference between the latter\ntwo?\n“The upper quartile FPKM (FPKM-UQ) is a modified FPKM calculation in\nwhich the total protein-coding read count is replaced by the 75th\npercentile read count value for the sample.”\nfrom\nhttps://docs.gdc.cancer.gov/Data/Bioinformatics_Pipelines/Expression_mRNA_Pipeline/\nDownload HTSeq - FPKM here\nexpquery <- GDCquery(project = \"TCGA-LIHC\", \n                data.category = \"Transcriptome Profiling\",\n                data.type = \"Gene Expression Quantification\",\n                workflow.type = \"HTSeq - FPKM\",\n                barcode = c(\"TCGA-DD-A11D-01A-11R-A131-07\",\"TCGA-DD-AACT-01A-11R-A41C-07\",\"TCGA-G3-AAUZ-01A-11R-A38B-07\",\"TCGA-EP-A26S-11A-12R-A16W-07\")#去掉这行，就能提取所有sample的数据 remove this line and you can extract all the sample data\n                )\nGDCdownload(expquery)\nexpquery2 <- GDCprepare(expquery)\nexpMatrix <- TCGAanalyze_Preprocessing(expquery2)\n\nwrite.csv(expMatrix, \"TCGA_FPKM.csv\", quote=F, row.names=T)\n输入数据\nInput data\n每行一个基因，每列一个sample\nOne gene per row, one sample per column\nsource(\"install_dependencies.R\")\nexpMatrix <- read.csv(\"easy_input.csv\",\n                        row.names = 1, header = TRUE, as.is = T)\n#查看前三个基因的read count\n#view the read count of the first three genes\nexpMatrix[1:3,]\nread count转FPKM\nRead count to FPKM\n首先要保证表达矩阵的行名和存放基因长度向量的名字一致,\n这一步非常重要。\nIt is very important to make sure that the names of the rows of the\nexpression matrix are the same as the names of the gene length\nvectors.\neff_length2 <-read.csv(\"gene_length.csv\", row.names = 1, header = T)\nrownames(eff_length2)<-eff_length2$gene_id \ncolnames(eff_length2)<-c(\"gene_id\",\"eff_length\")\nrownames(eff_length2) <- do.call(rbind,strsplit(as.character(eff_length2$gene_id),'\\\\.'))[,1]\n\n# 从输入数据里提取基因名\n# extract gene names from input data\nfeature_ids <- rownames(expMatrix)\n\n# 检查gtf文件和表达量输入文件里基因名的一致性\n# check the consistency of gene names in the gtf file and expression input file\nif (! all(feature_ids %in% rownames(eff_length2))){\n  tbl <- table(feature_ids %in% rownames(eff_length2))\n  msg1 <- sprintf(\"%i gene is shared, %i gene is specified\", tbl[[2]],tbl[[1]])\n  warning(msg1)\n} \n\nif (! identical(feature_ids, rownames(eff_length2))){\n  msg2 <- sprintf(\"Given GTF file only contain %i gene, but experssion matrix has %i gene\", nrow(eff_length2), nrow(expMatrix))\n  warning(msg2)\n}\n# 修剪表达矩阵和有效基因长度\n# trim the expression matrix and effetive gene length\nexpMatrix <- expMatrix[feature_ids %in% rownames(eff_length2),]\nmm <- match(rownames(expMatrix), rownames(eff_length2))\neff_length2 <- eff_length2[mm, ]\n\nif (identical(rownames(eff_length2), rownames(expMatrix))){\n  print(\"GTF and expression matix now have the same gene and gene in same order\")\n}\n如果上面代码运行时有警告，主要是因为GTF里面的基因数少于表达矩阵，请换一个更新版本的GTF文件。为了让二者基因数量一致，会删减表达矩阵的行数（基因数）。\n写个count转FPKM的函数，来源 ：\nhttps://haroldpimentel.wordpress.com/2014/05/08/what-the-fpkm-a-review-rna-seq-expression-units/\nIf the above code runs with a warning, mainly because the number of\ngenes inside the GTF is less than the expression matrix, please change\nto a newer version of the GTF file. The number of rows (genes) in the\nexpression matrix will be trimmed down in order to make the number of\ngenes in both the same.\nWrite a count to FPKM function, source:\nhttps://haroldpimentel.wordpress.com/2014/05/08/what-the-fpkm-a-review-rna-seq-expression-units/\ncountToFpkm <- function(counts, effLen){\n  N <- sum(counts)\n  exp( log(counts) + log(1e9) - log(effLen) - log(N) )\n}\n最后执行下面的代码，从read count转成FPKM：\nFinally execute the following code to switch from read count to\nFPKM:\nfpkms <- apply(expMatrix, 2, countToFpkm, effLen = eff_length2$eff_length)\nfpkms.m<-data.frame(fpkms)\ncolnames(fpkms.m)<-colnames(expMatrix)\ndim(fpkms.m)\n#查看前三个基因的TPM值\n#view TPM values for the first three genes\nfpkms.m[1:3,]\n#把算好的FPKM保存到本地\n#save the calculated FPKM locally\nwrite.table(fpkms.m, \"output_count2fpkm.txt\", sep=\"\\t\", quote=F, row.names=T)\n结果对比\nComparison of results\n直接比较count转成的FPKM 和\n从TCGA下载的FPKM，你或许会发现两者的结果有一些差异。这和你选择的GTF版本以及FPKM的生成方式有关，下面比较相关性。\nDirectly comparing the FPKM converted by count and the FPKM\ndownloaded from TCGA, you may find some differences between the two\nresults. This is related to the version of GTF you chose and the way\nFPKM is generated, compare the correlation below.\n#导入从TCGA下载的FPKM\n#import FPKM downloaded from TCGA\nTCGAfpkm <- read.csv(\"TCGA_FPKM.csv\", row.names = 1)\nhead(TCGAfpkm[1:3,])\n# 将原始计数与计数的FPKM进行比较\n# compare raw count with FPKM from count\ncor(x=expMatrix[,1], y=fpkms.m[,1])\n# 将原始计数与TCGA的FPKM进行比较\n# compare raw count with FPKM from TCGA\ncor(x=expMatrix[,1],\n    y=TCGAfpkm$TCGA.DD.A11D.01A.11R.A131.07)\n# 将TCGA的FPKM与计数的FPKM进行比较\n# compare FPKM from TCGA with FPKM from count\ncor(x=fpkms.m[,1],\n    y=TCGAfpkm$TCGA.DD.A11D.01A.11R.A131.07)\n以第一个sample为例，raw count 和\ncount转成的FPKM的相关系数是0.898；\nraw count 和 从TCGA直接下载的FPKM的相关系数是 0.898。\n而count转成的FPKM和从TCGA下载的FPKM的相关系数是1,\n证明了count2FPKM的代码是有效的。\nTaking the first sample as an example, the correlation coefficient\nbetween the raw count and the FPKM converted from the count is\n0.898;\nThe correlation coefficient between raw count and FPKM downloaded\ndirectly from TCGA is 0.898.\nThe correlation coefficient between the FPKM converted from count and\nthe FPKM downloaded from TCGA is 1, which proves that the code of\ncount2FPKM is valid.\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa34count2FPKMv2_FigureYa34count2FPKMv2",
      "title": "FigureYa34count2FPKMv2/FigureYa34count2FPKMv2.html",
      "html": "FigureYa34count2FPKMv2/FigureYa34count2FPKMv2.html",
      "text": "texts/main_FigureYa34count2FPKMv2_FigureYa34count2FPKMv2.txt",
      "folder": "FigureYa34count2FPKMv2",
      "thumb": "gallery_compress/FigureYa34count2FPKMv2.webp"
    },
    "word_count": 1061,
    "lines_count": 239,
    "title": "FigureYa34 count2FPKMv2",
    "description": "Requirement description RNA-seq read count转换成FPKM。 RNA-seq read count converted to FPKM.",
    "input_data_types": [
      "表达矩阵",
      "临床数据",
      "DNA-seq"
    ],
    "output_types": [
      "散点图",
      "统计表格"
    ],
    "technical_methods": [],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "quote",
      "x",
      "project",
      "effLen",
      "header",
      "y",
      "type",
      "names",
      "category",
      "is"
    ]
  },
  {
    "id": "main_FigureYa3genomeView_FigureYa3genomeView",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa3genomeView_FigureYa3genomeView.txt",
    "content": "FigureYa3genomeView\nFigureYa3genomeView\nDekang Lv; Ying Ge, Yijing Chen\n2025-9-15\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement description\n想展示我感兴趣的基因附近的ChIP-seq、DNase/ATAC-seq或RNA-seq的bigwig信号图，不想用IGV或UCSC\ngenome browser那种截图，我想要矢量图。\nI want to display bigwig signal plots of ChIP-seq, DNase/ATAC-seq, or\nRNA-seq near the gene I am interested in, without using screenshots from\nIGV or UCSC genome browser. I want vector plots.\n使用场景\nUsage scenario\n场景一：用DNase/ATAC-seq或H3K4me3、H3K4me1、H3K27ac等组蛋白修饰的ChIP-seq数据证实基因启动子、增强子的位置。\n场景二：展示ChIP-seq数据，证实哪些转录因子调控我的基因。\n场景三：展示RNA-seq和ChIP-seq的信号，证实转录因子结合对基因转录的影响。\nScenario 1: Use DNase/ATAC-seq or ChIP-seq data of histone\nmodifications such as H3K4me3, H3K4me1, and H3K27ac to confirm the\nlocations of gene promoters and enhancers.\nScenario 2: Show ChIP-seq data to confirm which transcription factors\nregulate my genes.\nScenario 3: Show RNA-seq and ChIP-seq signals to confirm the effect\nof transcription factor binding on gene transcription.\n环境设置\nsource(\"install_dependencies.R\")\nlibrary(data.table)\nlibrary(Gviz)\nlibrary(RColorBrewer)\nlibrary(TxDb.Hsapiens.UCSC.hg38.knownGene)\n输入数据\nInput data\n需要展示的区域loci.bed\nbigwig文件TAL1.bw，POLR2A.bw\nbigwig文件描述easy_input.txt\nRegions to be displayed loci.bed\nbigwig files TAL1.bw, POLR2A.bw\nbigwig file description easy_input.txt\n开始画图\nStart drawing\ntxdb_hg38 <- TxDb.Hsapiens.UCSC.hg38.knownGene\ngrt <- GeneRegionTrack(txdb_hg38, genome=\"hg38\",showId=TRUE, geneSymbol=TRUE, name=\"UCSC\")\nlibrary(org.Hs.eg.db)\nz <- mapIds(org.Hs.eg.db, gene(grt), \"SYMBOL\", \"ENTREZID\", multiVals = \"first\")\nzz <- sapply(z, is.null)\nz[zz] <- gene(grt)[zz]\ngr <- ranges(grt)\nmcols(gr)$symbol <- z\ngrt@range <- gr\n\n# 输入数据\n# input data\nbwInfo<-read.table(\"easy_input.txt\",header=F,row.names=1,as.is=T)\nhead(bwInfo)\ngloci<-read.table(\"loci.bed\",header=F,as.is=T)\nhead(gloci)\n#可调整的参数\n#adjustable parameters\ngenefold<-as.numeric(\"1.5\")#放大、缩小展示的范围 zoom in and out of the display range\n\n# 展示的基因组范围\n# range of genomes displayed\ncolnames(gloci)<-c(\"chr\",\"start\",\"end\",\"strand\")\nchr<-gloci[rownames(gloci),]$chr\ngloci$width<-with(gloci,end-start)\nstartpoint<-gloci[rownames(gloci),]$start-genefold*gloci[rownames(gloci),]$width\nendpoint<-gloci[rownames(gloci),]$end+genefold*gloci[rownames(gloci),]$width\n\n#下面将scale等track写入tracklist\n#Write scale and other tracks into tracklist below\ntracklist<-list()\n#写入chromosome\n#write to chromosome\nitrack <- IdeogramTrack(genome = \"hg38\", chromosome = chr,outline=T)\ntracklist[[\"itrack\"]]<-itrack\n\n#写入比例尺\n#write to scale\nscalebar <- GenomeAxisTrack(scale=0.25,col=\"black\",fontcolor=\"black\",name=\"Scale\",labelPos=\"above\",showTitle=TRUE)\ntracklist[[\"scalebar\"]]<-scalebar\n\n#写入基因组位置\n#write to genomic location\naxisTrack <- GenomeAxisTrack(labelPos=\"above\",col=\"black\",fontcolor=\"black\",name=paste(chr,\":\",sep=\"\"),exponent=0,showTitle=TRUE)\ntracklist[[\"axisTrack\"]]<-axisTrack\n\n#写入bigwig\n#配色\n#Write to bigwig\n#color matching\ncolpal<-rep(brewer.pal(12,\"Paired\"),20)\ncoldf<-data.frame(col=colpal[1:nrow(bwInfo)],row.names = rownames(bwInfo),stringsAsFactors = F)\n\nfor(index in rownames(bwInfo)){\n  bgFile<-file.path(paste(index,\".bw\",sep=\"\"))\n  tracklist[[index]]<-DataTrack(range = bgFile,genome=\"hg38\",type=\"histogram\",\n                                name=chartr(\"_\",\"\\n\",bwInfo[index,]),\n                                col.histogram=coldf[index,])#每个track颜色不同才好看 each track looks better with a different color\n}\n\n#写入基因结构\n#write to gene structure\ntracklist[[\"grt\"]]<-grt\n\n#画图\n#draw the plot\nplotTracks(tracklist, from = startpoint, to = endpoint,\n           chromosome=chr,background.panel = \"white\", background.title = \"white\",\n           col.title=\"black\",col.axis=\"black\",\n           rot.title=0,cex.title=0.9,margin=38,title.width=1.5,\n           collapseTranscripts = \"longest\")#同一个基因的多个transcript压缩成最长的一个 multiple transcripts of the same gene compress into the longest one\n#输出pdf文件\n#output pdf file\npdf(\"loci.pdf\",height=5,width=8)\nplotTracks(tracklist, from = startpoint, to = endpoint,\n           chromosome=chr,background.panel = \"white\", background.title = \"white\",\n           col.title=\"black\",col.axis=\"black\",\n           rot.title=0,cex.title=0.9,margin=38,title.width=1.5,\n           collapseTranscripts = \"longest\")#同一个基因的多个transcript压缩成最长的一个 multiple transcripts of the same gene compress into the longest one\ndev.off()\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa3genomeView_FigureYa3genomeView",
      "title": "FigureYa3genomeView/FigureYa3genomeView.html",
      "html": "FigureYa3genomeView/FigureYa3genomeView.html",
      "text": "texts/main_FigureYa3genomeView_FigureYa3genomeView.txt",
      "folder": "FigureYa3genomeView",
      "thumb": "gallery_compress/FigureYa3genomeView.webp"
    },
    "word_count": 393,
    "lines_count": 128,
    "title": "FigureYa3genomeView",
    "description": "Requirement description 想展示我感兴趣的基因附近的ChIP-seq、DNase/ATAC-seq或RNA-seq的bigwig信号图，不想用IGV或UCSC genome browser那种截图，我想要矢量图。",
    "input_data_types": [
      "DNA-seq"
    ],
    "output_types": [
      "基因组浏览器",
      "统计表格"
    ],
    "technical_methods": [
      "motif分析"
    ],
    "biology_areas": [],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "to",
      "header",
      "labelPos",
      "width",
      "name",
      "showId",
      "col",
      "panel",
      "exponent",
      "type"
    ]
  },
  {
    "id": "main_FigureYa199crosslink_FigureYa199crosslink",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa199crosslink_FigureYa199crosslink.txt",
    "content": "FigureYa199crosslink\nFigureYa199crosslink\nAuthor(s)\n: Zongcheng Li\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n这幅连线图很有趣，比FigureYa174squareCross多了两层信息：点的大小和颜色。\nRequirement Description\nThis line diagram is interesting because it has two more layers of\ninformation than FigureYa174squareCross: the size and color of the\ndots.\n出自\nhttps://www.biorxiv.org/content/10.1101/2020.07.21.214387v1\nfrom\nhttps://www.biorxiv.org/content/10.1101/2020.07.21.214387v1\nFigure 2: CellChat analysis of the communications between skin cells\nduring wound repair. (a)\nHierarchical plot\nshows the\ninferred intercellular communication network for TGFb signaling.\nLeft and right panels\nhighlight the autocrine and\nparacrine signaling to fibroblast states and other non-fibroblast skin\ncell states, respectively.\nSolid and open circles\nrepresent source and target, respectively.\nCircle sizes\nare proportional to the number of cells in each cell group.\nEdge\ncolors\nare consistent with the signaling source.\n类似的图： similar plot:\n出自\nhttps://molecular-cancer.biomedcentral.com/articles/10.1186/s12943-019-1066-3\nfrom\nhttps://molecular-cancer.biomedcentral.com/articles/10.1186/s12943-019-1066-3\nFig. 2 m6A regulators are correlated with the activation and\ninhibition of cancer pathways. a Network diagram demonstrating the\ncorrelation between m6A regulators and cancer pathways. Red represents a\npositive correlation, and blue represents a negative correlation. The\nsize of the nodes corresponds to the number of links.\n应用场景\n任意两组、多组连线，同时用颜色大小展示节点的更多信息，用连线的颜色粗细展示关系的类别强弱等信息。\n根据自己数据的生物学意义，来排列各个节点的顺序。或许能够出现特殊的模式，从而展示出有意义的生物学规律。\n上下左右连线的方法可参考FigureYa174squareCross。\nApplication Scenario\nConnect any two or multiple groups with lines, while using color and\nsize to display additional node information, and the color/thickness of\nthe connecting lines to represent relationship categories and\nstrengths.\nArrange the order of nodes based on the biological significance of\nyour data. This may reveal unique patterns, thereby demonstrating\nmeaningful biological insights.\nFor methods of connecting nodes (top, bottom, left, right), refer to\nFigureYa174squareCross\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nsource(\"crosslink.R\") # From R package crosslink\nsource(\"layout.R\") # From R package crosslink\nsource(\"transfromation.R\") # From R package crosslink\nsource(\"utils.R\") # From R package crosslink\nsource(\"crossplot.R\") # From R package crosslink\n\nlibrary(dplyr)\nlibrary(ggplot2)\nlibrary(scales)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息 # error messages are displayed in English\noptions(stringsAsFactors = FALSE) #禁止chr转成factor # It is forbidden to convert chr into factor\n输入文件\nInput files\n图中每个点、每条线的外观设置有两种方式供你选择。理解之后就可以灵活运用了，例如有些外观用代码写，有些外观填写在输入文件里。\n方式一：在输入文件中填写外观，个性化地写成不同的值。\n优点：所见即所得，写什么样就画出什么样\n缺点：麻烦\n方式二：在输入文件中最少可以只写id和type两列，其余外观都可以在画图时通过设置参数来实现。\n优点：方便修改，能用代码就不去一个一个写，便于跟上游分析衔接。\n缺点：外观种类太多时，其实不如“方式一”方便\neasy_input_nodes.csv，每个节点为一行。第一列是节点id，之后是其类别type、颜色color、大小size、透明度alpha和形状shape。例如一个节点代表一个基因；type列就写gene；颜色、大小、透明度和形状都可以代表基因的某一特征值，例如表达量等。\neasy_input_edges.csv，每两个被连起来的节点为一行，前两列是两个节点的id，之后是颜色color、类型type、透明度alpha和粗细size，这些外观信息可以代表每两个节点之间关系的强度、类型等。\nThere are two ways to customize the appearance of each point and line\nin the figure. Once understood, you can apply them flexibly—for example,\nsetting some appearances via code while specifying others in the input\nfile.\n-Option 1: Define appearances in the input file with custom values\nPros: WYSIWYG (What You See Is What You Get)—the output will match\nexactly what you write. Cons: More tedious to set up.\n-Option 2: Keep the input file minimal (only id and type columns\nrequired) and control appearances via plotting parameters Pros: Easier\nto modify; avoids manual editing for each element and integrates\nsmoothly with upstream analysis. Cons: Less convenient than Option 1\nwhen dealing with too many appearance variations.\n-Input File Formats:easy_input_nodes.csv.Each row represents a node.\nThe first column is the node id, followed by its type, color, size,\nalpha (transparency), and shape.\nExample: If a node represents a gene, set type as “gene.”Other\ncolumns (color, size, alpha, shape) can encode additional features\n(e.g., expression levels).\n-easy_input_edges.csvEach row connects two nodes. The first two\ncolumns are the linked node ids, followed by color, type, alpha, and\nsize (thickness).These attributes can reflect relationship strength,\ntype, etc.\n# 载入节点信息\n# Load node information\nnodes <- read.csv(\"easy_input_nodes.csv\", header = T)\nhead(nodes)\n# 载入连线信息\n# Load the connection information\nedges <- read.csv(\"easy_input_edges.csv\", header = T)\nhead(edges)\n开始画图\n方式一：所有外观都由输入文件决定\nStart drawing\nMethod 1: All appearances are determined by the input file\n# 写入想画的type\n# Write the type you want to draw\ncolumns <- list(# 如果你只有两个type（或者只想画两列），就在list里写两行。# If you only have two types (or just want to draw two columns), write two lines in the list\n  Gene = nodes$id[nodes$type == \"Gene\"],\n  Drug = nodes$id[nodes$type == \"Drug\"],\n  Target = nodes$id[nodes$type == \"Tar\"], \n  Pathway = nodes$id[nodes$type == \"Path\"]\n)\n\ncolumnCross2(edges, nodes, columns,\n             height = 1, flank_mult = rep(0.1, length(columns)), segment_shrink = 0.1,\n             linetype = \"type\", line_alpha = \"alpha\", line_color = \"color\", line_size = \"size\",\n             pt_shape = \"shape\", pt_alpha = \"alpha\", \n             pt_color = \"color\", # 外圈颜色 # Outer ring color\n             pt_fill = \"color\", # 填充颜色 # Fill color\n             pt_size = \"size\", pt_stroke = 1)\nggsave(filename = \"crosslink_file.pdf\", width = 8, height = 5)\n方式二：画图时设置外观参数\nMethod 2: Set the appearance parameters when drawing\n# 写入想画的type\n# 如果你只有两个type（或者只想画两列），就在list里写两行。\n# Write the type you want to draw\n# If you only have two types (or just want to draw two columns), write two lines in the list.\ncolumns <- list(\n  Gene = nodes$id[nodes$type == \"Gene\"],\n  Drug = nodes$id[nodes$type == \"Drug\"],\n  Target = nodes$id[nodes$type == \"Tar\"], \n  Pathway = nodes$id[nodes$type == \"Path\"]\n)\n\n# 以连线类型和节点形状为例，说明定义外观的两种方式，定义其他外观的方法类似\n# Take the line type and node shape as an example to illustrate the two ways to define appearances, and the methods for defining other appearances are similar\ncolumnCross2(edges, nodes, columns,\n             height = 1, flank_mult = rep(0.1, length(columns)), segment_shrink = 0.1,\n             \n             linetype = 1, # 默认值，所有连线都画成直线 # By default, all lines are drawn as straight lines\n             line_alpha = \"alpha\", line_color = \"color\", line_size = \"size\" ,\n             \n             #pt_shape = 21, # 统一画成实心圆 # Draw a solid circle in unison\n             # 或者Drug画成空心圆，其余画成实心圆 # Or the Drug is drawn as a hollow circle, and the rest is drawn as a solid circle\n             pt_shape = c(rep(16, length(columns$Gene)), rep(1, length(columns$Drug)), rep(16, (length(columns$Target) + length(columns$Pathway)))), \n             \n             pt_alpha = .8, # 统一设置透明度 # Set transparency uniformly\n             pt_color = \"color\", pt_fill = \"color\", pt_size = \"size\", \n             pt_stroke = 3) # 让空心圆的边粗一些 # Make the edges of the hollow circle thicker\nggsave(filename = \"crosslink_par.pdf\", width = 8, height = 5)\n再来一个例子\n如果某类节点太多，可以排成多列，就像需求描述的第二个例子那样。\nOne more example\nIf there are too many nodes of a certain type, you can arrange them\ninto multiple columns, as in the second example of the requirements\ndescription.\n输入文件\nInput file\n# 载入节点信息\n# Load node information\nnodes <- read.csv(\"easy_input2_nodes.csv\", header = T)\nhead(nodes)\n# 载入连线信息\n# Load connection information\nedges <- read.csv(\"easy_input2_edges.csv\", header = T)\nhead(edges)\n开始画图\nStart plot\n# 这里把P和N都拆成两列，当然你也可以拆成更多列\n# Split both P and N into two columns, but you can also split them into more columns\ncolumns <- list(\n  P1 = nodes$id[nodes$type == \"P\"][1:15],\n  P2 = nodes$id[nodes$type == \"P\"][16:30],\n  RBP = nodes$id[nodes$type == \"RBP\"],\n  N1 = nodes$id[nodes$type == \"N\"][1:15], \n  N2 = nodes$id[nodes$type == \"N\"][16:30]\n)\nseq_len(length(columns))\n# 以连线类型和节点形状为例，说明定义外观的两种方式，定义其他外观的方法类似\n# Take the line type and node shape as an example to illustrate the two ways to define appearances, and the methods for defining other appearances are similar\ncolumnCross2(edges, nodes, columns,\n             height = 1, \n             \n             # 默认值是1,2,3,4,5，每列之间是等距的\n             # 我们想让两边的两列距离近些，就这样改\n             # The default values are 1, 2, 3, 4, 5, and each column is equidistant\n             # We want to make the two columns on both sides closer, so change it like this\n             column_x = c(1, 1.5, 3, 4.5, 5), \n             \n             # 默认值都是0.1\n             # 我们想让中间RBP那列短一些，就这样改\n             # The default value is 0.1\n             # We want to make the middle RBP column shorter, so change it like this\n             flank_mult = c(0.1, 0.1, 0.15, 0.1, 0.1), \n             \n             segment_shrink = 0,\n             line_alpha = .2, line_size = 1, line_color = \"color\",\n             pt_shape = \"shape\",  pt_alpha = \"alpha\", pt_color = \"color\", pt_fill = \"color\", pt_size = \"size\", pt_stroke = 1)\nggsave(filename = \"crosslink_multiCol.pdf\", width = 6, height = 8)\n后期处理\n输出的pdf文件是矢量图，可以用矢量图编辑器打开（例如Illustrator）调整图形、文字。\n附\npt_shape的可选参数及其对应的形状\nPost-processing\nThe output pdf file is a vector image, which can be opened with a\nvector editor (e.g. Illustrator) to adjust graphics, text.\nAttached\nOptional parameters for pt_shape and their corresponding shapes\n示例一的输入数据生成过程\nExample 1 of the input data generation process\n# 节点的颜色\n# The color of the node\nnode_colors <- RColorBrewer::brewer.pal(11, \"Spectral\")\n# 连线的颜色\n# The color of the wire\nedge_colors <- RColorBrewer::brewer.pal(12, \"Paired\")\n\n# nodes\nnodes <- data.frame(\n  id = c(paste0(\"Gene\", 1:10), paste0(\"Meth\", 1:10),\n         paste0(\"Mir\", 1:6), paste0(\"Drug\", 1:8),\n         paste0(\"Tar\", 1:8), paste0(\"Path\", 1:6)),\n  type = c(rep(\"Gene\", 10), rep(\"Meth\", 10),\n           rep(\"Mir\", 6), rep(\"Drug\", 8),\n           rep(\"Tar\", 8), rep(\"Path\", 6)),\n  color = sample(node_colors, 48, replace = T),\n  size = sample(3:10, 48, replace = T),\n  alpha = sample((5:10)/10, 48, replace = T),\n  shape = sample(1:20, 48, replace = T)\n)\nwrite.csv(nodes, \"easy_input_nodes.csv\", quote = F, row.names = F)\n\n# edges\nedges <- data.frame(rbind(\n  # gene vs mir\n  data.frame(\n    source = sample(nodes$id[nodes$type == \"Gene\"],\n                    replace = T, 30),\n    target = sample(nodes$id[nodes$type == \"Mir\"],\n                    replace = T, 30)),\n  # gene vs drug\n  data.frame(\n    source = sample(nodes$id[nodes$type == \"Gene\"],\n                    replace = T, 100),\n    target = sample(nodes$id[nodes$type == \"Drug\"],\n                    replace = T, 100)),\n  # meth vs drug\n  data.frame(\n    source = sample(nodes$id[nodes$type == \"Meth\"],\n                    replace = T, 100),\n    target = sample(nodes$id[nodes$type == \"Drug\"],\n                    replace = T, 100)),\n  # mir vs drug\n  data.frame(\n    source = sample(nodes$id[nodes$type == \"Mir\"],\n                    replace = T, 20),\n    target = sample(nodes$id[nodes$type == \"Drug\"],\n                    replace = T, 20)),\n  \n  # drug vs target\n  data.frame(\n    source = nodes$id[nodes$type == \"Drug\"],\n    target = nodes$id[nodes$type == \"Tar\"]),\n  # target vs path\n  data.frame(\n    source = sample(nodes$id[nodes$type == \"Tar\"],\n                    replace = T, 15),\n    target = sample(nodes$id[nodes$type == \"Path\"],\n                    replace = T, 15))\n),\ncolor = sample(edge_colors, 273, replace = T),\ntype = sample(1:5, 273, replace = T),\nalpha = sample((5:10)/10, 273, replace = T),\nsize = sample(1:3, 273, replace = T))\nwrite.csv(edges, \"easy_input_edges.csv\", quote = F, row.names = F)\n示例二的输入数据的生成过程\nExample 2: The process of generating input data\n# 节点的颜色\n# The color of the node\nnode_colors <- RColorBrewer::brewer.pal(11, \"Spectral\")\n# 连线的颜色\n# The color of the wire\nedge_colors <- RColorBrewer::brewer.pal(12, \"Paired\")\n\n# nodes\nnodes <- data.frame(\n  id = c(paste0(\"P\", 1:30),\n         paste0(\"RBP\", 1:20),\n         paste0(\"N\", 1:30)),\n  type = c(rep(\"P\", 30),\n           rep(\"RBP\", 20),\n           rep(\"N\", 30)),\n  color = c(rep(\"firebrick\",30), sample(node_colors, 20,replace = T), rep(\"dodgerblue\", 30)),\n  size = sample(3:10, 80, replace = T),\n  alpha = sample((5:10)/10, 80, replace = T),\n  shape = c(rep(15,30), rep(16, 20), rep(15, 30))\n)\nwrite.csv(nodes, \"easy_input2_nodes.csv\", quote = F, row.names = F)\n\n# edges\nedges <- data.frame(rbind(\n  # Positive pathway vs RBP\n  data.frame(\n    source = sample(nodes$id[nodes$type == \"P\"],\n                    replace = T, 100),\n    target = sample(nodes$id[nodes$type == \"RBP\"],\n                    replace = T, 100)),\n  # Negative pathway vs RBP\n  data.frame(\n    source = sample(nodes$id[nodes$type == \"N\"],\n                    replace = T, 100),\n    target = sample(nodes$id[nodes$type == \"RBP\"],\n                    replace = T, 100))\n),\ncolor = c(rep(\"red\", 100), rep(\"cornflowerblue\", 100)))\nwrite.csv(edges, \"easy_input2_edges.csv\", quote = F, row.names = F)\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa199crosslink_FigureYa199crosslink",
      "title": "FigureYa199crosslink/FigureYa199crosslink.html",
      "html": "FigureYa199crosslink/FigureYa199crosslink.html",
      "text": "texts/main_FigureYa199crosslink_FigureYa199crosslink.txt",
      "folder": "FigureYa199crosslink",
      "thumb": "gallery_compress/FigureYa199crosslink.webp"
    },
    "word_count": 1660,
    "lines_count": 336,
    "title": "FigureYa199crosslink",
    "description": "这幅连线图很有趣，比FigureYa174squareCross多了两层信息：点的大小和颜色。 Requirement Description This line diagram is interesting because it has two more layers of",
    "input_data_types": [],
    "output_types": [
      "散点图",
      "网络图"
    ],
    "technical_methods": [
      "聚类分析",
      "网络分析",
      "通路分析"
    ],
    "biology_areas": [
      "癌症研究",
      "药物研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "Target",
      "N2",
      "Pathway",
      "line_color",
      "id",
      "header",
      "width",
      "N1",
      "P1"
    ]
  },
  {
    "id": "main_FigureYa119Multiclasslimma_FigureYa119Multiclasslimma",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa119Multiclasslimma_FigureYa119Multiclasslimma.txt",
    "content": "FigureYa119Multiclasslimma\nFigureYa119Multiclasslimma\nAuthor(s)\n: Xiaofan Lu, Taojun Ye\nReviewer(s)\n: Ying Ge\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\n用limma实现多组差异分析。能用来替换FigureYa109SubtypeGSEA中的配对差异表达过程（亚型数目>=3），并跟它无缝对接。\nRequirement description\nImplement multi group difference analysis using limma. Can be used to\nreplace the paired differential expression process (subtype\nnumber>=3) in FigureYa109SubtypeGSEA and seamlessly integrate with\nit.\n应用场景\n结合FigureYa109subtypeGSEA，分析每一组与其他样品的差异基因，进而找出亚型特异富集的通路；\n结合FigureYa116supervisedCluster，分析每一组与其他样品的差异基因，进而找出亚型特异的marker基因。\n注意：\n本次不涉及批次效应消除，若样本间含有批次效应，请阅读limma相关document并修改该脚本，在设计矩阵中纳入batch\neffect。\n这里针对FPKM/RPKM或芯片数据作为输入的情况，如果你的数据是read\ncount，请参考FigureYa118MulticlassDESeq2\nApplication scenarios\nBased on Figure Ya109 subtype GSEA, analyze the differentially\nexpressed genes between each group and other samples, and identify\nsubtype specific enriched pathways;\nUsing FigureYa116supervisedCluster, analyze the differentially\nexpressed genes between each group and other samples, and identify\nsubtype specific marker genes.\n**Note: * * This time does not involve batch effect elimination. If\nthere are batch effects between samples, please read the relevant\ndocuments of limma and modify the script to include batch effects in the\ndesign matrix.\nFor the case where FPKM/RPKM or chip data is used as input,\nif your data is read count, please refer to\nFigureYa118MulticlassDESeq2\n环境设置\nEnvironment settings\nUse domestic image installation package\nBiocManager::install(\"affy\")\nBiocManager::install(\"affyPLM\")\nsource(\"install_dependencies.R\")\n# 加载limma包 - 用于基因表达数据分析和差异表达分析\n# Load the limma package - for gene expression data analysis and differential expression analysis\nlibrary(limma)\n\n# 加载affy包 - 用于Affymetrix基因芯片数据的预处理和分析\n# Load the affy package - for preprocessing and analysis of Affymetrix gene chip data\nlibrary(affy)\n# 加载affyPLM包 - 提供基于探针水平模型的Affymetrix芯片数据分析方法\n# Load the affyPLM package - provides probe-level model-based methods for Affymetrix chip data analysis\nlibrary(affyPLM)\n# 设置环境变量使R显示英文错误信息，便于问题排查和社区求助\n# Set environment variable to display English error messages for easier troubleshooting and community support\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁止字符串自动转换为因子类型，避免数据处理中的意外行为\n# Prevent automatic conversion of strings to factors to avoid unexpected behavior in data processing\noptions(stringsAsFactors = FALSE)\n自定义函数，分别比较每一组跟其他样品之间的差异，如果有更多组，按规律补充进去即可\nCustomize functions to compare the differences between each group and\nother samples separately. If there are more groups, simply add them\naccording to the pattern\n# 创建需要配对比较的列表\n# Create a list of paired comparisons for differential analysis\ncreateList <- function(group=NULL) {\n  \n  tumorsam <- names(group)\n  sampleList = list()\n  treatsamList =list()\n  treatnameList <- c()\n  ctrlnameList <- c()\n  \n  #A-1: 类1 vs 其他\n  # Class 1 vs Others\n  sampleList[[1]] = tumorsam\n  treatsamList[[1]] = intersect(tumorsam, names(group[group==\"immune\"])) # 需要根据实际亚型修改 / Modify according to actual subtypes\n  treatnameList[1] <- \"immune\" # 处理组亚型名称 / Name of the treatment subtype\n  ctrlnameList[1] <- \"Others\" # 对照组名称 / Name of the control group\n  \n  #A-2: 类2 vs 其他\n  # Class 2 vs Others\n  sampleList[[2]] = tumorsam\n  treatsamList[[2]] = intersect(tumorsam, names(group[group==\"keratin\"]))\n  treatnameList[2] <- \"keratin\"\n  ctrlnameList[2] <- \"Others\"\n  \n  #A-3: 类3 vs 其他\n  # Class 3 vs Others\n  sampleList[[3]] = tumorsam\n  treatsamList[[3]] = intersect(tumorsam, names(group[group==\"MITF-low\"]))\n  treatnameList[3] <- \"MITF-low\"\n  ctrlnameList[3] <- \"Others\"\n  \n  #如果有更多类，按以上规律继续写\n  # Add more comparisons following the same pattern if needed\n\n  return(list(sampleList, treatsamList, treatnameList, ctrlnameList))\n  \n}\n\n# 配对limma差异表达分析\n# Paired differential expression analysis using limma\ntwoclasslimma <- function(res.path=NULL, expr=NULL, prefix=NULL, complist=NULL, overwt=FALSE) {\n  # 参数说明 / Parameter Description:\n  # res.path: 结果文件保存路径 / Path to save result files\n  # expr: 表达矩阵，行名为基因，列名为样本 / Expression matrix with genes as rows and samples as columns\n  # prefix: 结果文件前缀 / Prefix for result files\n  # complist: 比较组列表，由createList函数生成 / Comparison list generated by createList function\n  # overwt: 是否覆盖已存在的结果文件 / Whether to overwrite existing result files\n  \n  sampleList <- complist[[1]]\n  treatsamList <- complist[[2]]\n  treatnameList <- complist[[3]]\n  ctrlnameList <- complist[[4]]\n  allsamples <- colnames(expr)\n  \n  options(warn=1)\n  for (k in 1:length(sampleList)) { # 循环处理每一组比较 / Process each comparison group\n    samples <- sampleList[[k]]\n    treatsam <- treatsamList[[k]] \n    treatname <- treatnameList[k]\n    ctrlname <- ctrlnameList[k]\n    \n    compname <- paste(treatname, \"_vs_\", ctrlname, sep=\"\") # 生成比较组名称 / Generate comparison name\n    tmp = rep(\"others\", times=length(allsamples))\n    names(tmp) <- allsamples\n    tmp[samples]=\"control\"\n    tmp[treatsam]=\"treatment\"\n    outfile <- file.path( res.path, paste(prefix, \"_limma_test_result.\", compname, \".txt\", sep=\"\") )\n    if (file.exists(outfile) & (overwt==FALSE)) { # 避免重复计算已存在的结果 / Skip existing results\n      cat(k, \":\", compname, \"exists and skipped;\\n\")\n      next\n    }\n    \n    pd <- data.frame(Samples=names(tmp),Group=as.character(tmp),stringsAsFactors = F)\n    \n    design <-model.matrix(~ -1 + factor(pd$Group, levels=c(\"treatment\",\"control\"))) # 设计矩阵，可根据需要添加批次效应 / Design matrix, can add batch effects if needed\n    colnames(design) <- c(\"treatment\",\"control\")\n    \n    # 对数转换\n    # Log transformation to stabilize variance\n    gset <- log2(expr + 1) # 避免信号值为0导致计算错误 / Avoid log(0) errors\n    \n    # 差异表达分析流程，参数细节请参考limma文档\n    # Differential expression analysis workflow, see limma documentation for parameter details\n    fit <- lmFit(gset, design=design);\n    contrastsMatrix <- makeContrasts(treatment - control, levels=c(\"treatment\", \"control\"))\n    fit2 <- contrasts.fit(fit, contrasts=contrastsMatrix)\n    fit2 <- eBayes(fit2, 0.01)\n    tT <- topTable(fit2, adjust=\"fdr\", sort.by=\"B\", number=100000)\n    tT <- subset(tT, select=c(\"logFC\",\"t\",\"B\",\"P.Value\",\"adj.P.Val\"))\n    colnames(tT) <- c(\"log2FC\",\"t\",\"B\",\"PValue\",\"FDR\")\n    tT <- tT[order(tT$FDR),]\n    \n    write.table(tT, file=outfile, row.names=T, col.names=NA, sep=\"\\t\", quote=F)\n    cat(k, \",\")\n  }\n  options(warn=0)\n  \n}\n输入文件\nInput file\n# 读取表达矩阵 - 输入文件为制表符分隔的FPKM表达量矩阵\n# Read expression matrix - input file is a tab-separated FPKM expression matrix\nexpr <- read.table(\"easy_input_FPKM.txt\",sep = \"\\t\",header = T,check.names = F,stringsAsFactors = F,row.names = 1)\n\nexpr[1:3, 1:3] # 查看表达矩阵前3行3列的内容 / View first 3 rows and 3 columns of expression matrix\n# 读取样本亚型信息 - 包含样本ID及其对应的分子亚型分类\n# Read sample subtype information - contains sample IDs and their corresponding molecular subtype classifications\nsubt <- read.table(\"easy_input_subtype.txt\", sep = \"\\t\", check.names = F, stringsAsFactors = F, header = T, row.names = 1)\n\nhead(subt) # 查看亚型信息数据前几行 / View first few rows of subtype information\nn.sub.label <- unique(subt$TCGA_Subtype) # 获取所有唯一的亚型名称 / Get all unique subtype names\n# Unique subtype names\nn.sub.label\nn.sub <- length(table(subt$TCGA_Subtype)) # 计算亚型的数量 / Calculate number of subtypes\n# Number of distinct subtypes\nn.sub\n开始分析\nStart analyzing\n在当前文件夹会生成3个文件，可以作为FigureYa116supervisedCluster的输入：\nSKCM_limma_test_result.immune_vs_Others.txt\nSKCM_limma_test_result.keratin_vs_Others.txt\nSKCM_limma_test_result.MITF-low_vs_Others.txt\n如果想跟FigureYa109SubtypeGSEA无缝对接，就继续运行下面这段，生成degs.list，然后从FigureYa109SubtypeGSEA里的“自定义分析函数”开始运行，手动把“自定义分析函数”里第160行的\ngeneList <- degs$log2FoldChange\n改为\ngeneList <- degs$log2FC\n：\nThree files will be generated in the current folder, which can be\nused as input for FigureYa116supervisedCluster:\nSKCM_limma_test_result.immune_vs_Others.txt\nSKCM_limma_test_result.keratin_vs_Others.txt\nSKCM_limma_test_result.MITF-low_vs_Others.txt\nIf you want to seamlessly integrate with FigureYa109SubtypeGSEA,\ncontinue running the following paragraph to generate degs.list, and then\nstart running from “Custom Analysis Functions” in\nFigureYa109SubtypeGSEA. Manually change the “geneList<- degs\n$log2FoldChange” in line 160 of “Custom Analysis Functions” to\n“geneList<- degs $log2FC”:\n# 定义差异表达分析结果文件路径列表\n# Define paths to differential expression analysis result files\nDEfiles <- c(\"SKCM_limma_test_result.immune_vs_Others.txt\",\n             \"SKCM_limma_test_result.keratin_vs_Others.txt\",\n             \"SKCM_limma_test_result.MITF-low_vs_Others.txt\")\n\n# 初始化空列表用于存储各亚型差异表达基因结果\n# Initialize empty list to store differential expression results for each subtype\ndegs.list <- list()\n\n# 循环读取各亚型差异表达分析结果\n# Loop through each subtype's differential expression results\nfor (i in 1:n.sub) {\n  # 读取差异表达分析结果文件\n  # Read differential expression analysis results\n  degs <- read.table(DEfiles[i],sep = \"\\t\",header = T,check.names = F,stringsAsFactors = F,row.names = 1)\n  \n  # 查看结果文件前几行\n  # Preview the first few rows of the results\n  head(degs)\n  \n  # 去除含有缺失值的行并将结果存入列表，以亚型名称作为列表元素名\n  # Remove rows with missing values and store results in list with subtype name as key\n  degs.list[[n.sub.label[i]]] <- as.data.frame(na.omit(degs))\n}\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa119Multiclasslimma_FigureYa119Multiclasslimma",
      "title": "FigureYa119Multiclasslimma/FigureYa119Multiclasslimma.html",
      "html": "FigureYa119Multiclasslimma/FigureYa119Multiclasslimma.html",
      "text": "texts/main_FigureYa119Multiclasslimma_FigureYa119Multiclasslimma.txt",
      "folder": "FigureYa119Multiclasslimma",
      "thumb": "gallery_compress/FigureYa119Multiclasslimma.webp"
    },
    "word_count": 1046,
    "lines_count": 235,
    "title": "FigureYa119Multiclasslimma",
    "description": "用limma实现多组差异分析。能用来替换FigureYa109SubtypeGSEA中的配对差异表达过程（亚型数目>=3），并跟它无缝对接。 Requirement description Implement multi group difference analysis using limma. Can be used to",
    "input_data_types": [
      "临床数据",
      "表达矩阵"
    ],
    "output_types": [
      "火山图",
      "统计表格"
    ],
    "technical_methods": [
      "通路分析",
      "差异表达分析"
    ],
    "biology_areas": [
      "癌症研究",
      "免疫学",
      "药物研究"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "times",
      "header",
      "complist",
      "pvalue",
      "prefix",
      "group",
      "Samples",
      "expr",
      "warn"
    ]
  },
  {
    "id": "main_FigureYa102multipanelROC_FigureYa102multipanelROC",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa102multipanelROC_FigureYa102multipanelROC.txt",
    "content": "FigureYa102multipanelROC\nFigureYa102multipanelROC\nAuthor(s)\n: Xiaofan Lu, Taojun Ye\nReviewer(s)\n: Ying Ge\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nFigureYa24ROC能拿到4个miRNA的ROC，每个miRNA一条线。这里的Figure5E是把上述4条miRNA都一起进行预测，Figure6根据4个miRNA建立logistic\nregression model，然后对不同病理分期的肿瘤阶段进行预测。\nRequirement description\nFigure Ya24ROC can obtain ROC for 4 miRNAs, with one line for each\nmiRNA. Figure 5E predicts all four miRNAs together, while Figure 6\nestablishes a logistic regression model based on the four miRNAs and\npredicts tumor stages at different pathological stages.\n出自\nhttps://www.nature.com/articles/bjc2014489\nfrom\nhttps://www.nature.com/articles/bjc2014489\nFigure 5. Receiver operating characteristic (ROC) curves for the\nability of the four individual miRNAs (A–D) and\nthe 4-miRNA\npanel (E)\nto differentiate the CAC patients from the control\ngroup in the training phase. Comparison of ROC curves for the ability of\nthe 4-miRNA panel and carcinoembryonic antigen (CEA) (F) to\ndifferentiate the CAC patients from the control group in the validation\nphase.\n对图的解读：\n其中Figure\n5E是多变量panel下逻辑回归的ROC，Figure\n5F是该模型在验证集中的应用。Figure\n5和6没有本质区别，只是响应变量改变了，模型没有变化。这里将提供构建multiple-biomarker的predictive\nmodel的方法，用ROC评价，及其在验证集中的performance，画出对比的ROC图。\n**Interpretation of the figures: * * Among them, Figure 5E is the ROC\nof logistic regression under multivariate panel, and Figure 5F is the\napplication of the model in the validation set. There is no essential\ndifference between Figures 5 and 6, only that the response variables\nhave changed, while the model has not changed. Here we will provide a\nmethod for constructing a predictive model of multiple biomarkers, using\nROC evaluation and its performance in the validation set, and draw a\ncomparative ROC graph.\n应用场景\n利用训练集构建多变量二分类逻辑回归模型，将模型应用于测试集计算预测概率，比较二者的ROC，画图。\n如果需要计算并绘制单个biomarker的ROC，请参考FigureYa24ROC。\nApplication scenarios\nBuild a multivariate binary logistic regression model using the\ntraining set, apply the model to the test set to calculate the\nprediction probability, compare the ROC of the two, and draw a\ngraph.\nIf you need to calculate and plot the ROC of a single biomarker,\nplease refer to FigureYa24ROC.\n环境设置\nEnvironment settings\nsource(\"install_dependencies.R\")\n# 加载pROC包，用于ROC曲线分析和计算\n# Load the pROC package for ROC curve analysis and calculation\nlibrary(pROC)\n# 设置环境语言为英文，确保错误信息以英文显示\n# Set the environment language to English to display error messages in English\nSys.setenv(LANGUAGE = \"en\") \n\n# 禁用字符串自动转换为因子的功能\n# Disable the automatic conversion of strings to factors\noptions(stringsAsFactors = FALSE)\n输入文件\neasy_input_train.txt，easy_input_test.txt，训练集和测试集，格式一致。第一列是样本ID，第二列为分组（二分类），之后各列是基因表达量。不仅限于基因表达量，还可以是其他量化指标。\nInput file\neasy_input_train.txt，easy_input_test.txt， The training set and test\nset have the same format. The first column is sample ID, the second\ncolumn is grouping (binary classification), and the following columns\nare gene expression levels. Not limited to gene expression levels, it\ncan also be other quantitative indicators.\n# 读取训练集数据，该数据集存储在制表符分隔的文本文件中\n# 读取时不检查列名有效性，禁止自动转换字符串为因子，使用首行为列名，首列为行名\n# Read the training dataset stored in a tab-separated text file\n# During reading, column names are not checked for validity, automatic conversion of strings to factors is disabled, \n# the first row is used as column names, and the first column as row names\ntrain_df <- read.table(\"easy_input_train.txt\",sep = \"\\t\",check.names = F,stringsAsFactors = F,header = T,row.names = 1)\n\n# 显示训练集数据的前3行和前3列，用于快速查看数据结构\n# Display the first 3 rows and 3 columns of the training dataset for a quick data structure overview\ntrain_df[1:3,1:3]\n# 读取测试集数据，该数据集存储在制表符分隔的文本文件中\n# 读取时不检查列名有效性，禁止自动转换字符串为因子，使用首行为列名，首列为行名\n# Read the test dataset stored in a tab-separated text file\n# During reading, column names are not checked for validity, automatic conversion of strings to factors is disabled, \n# the first row is used as column names, and the first column as row names\ntest_df <- read.table(\"easy_input_test.txt\",sep = \"\\t\",check.names = F,stringsAsFactors = F,header = T,row.names = 1)\n\n# 显示测试集数据的前3行和前3列，用于快速查看数据结构\n# Display the first 3 rows and 3 columns of the test dataset for a quick data structure overview\ntest_df[1:3,1:3]\n利用训练集构建多变量二分类逻辑回归模型\nConstructing a Multivariate Binary Logistic Regression Model Using a\nTraining Set\n# 获取训练集的所有列名（变量名）\n# Get all column names (variable names) of the training dataset\nn <- colnames(train_df) \n\n# 动态生成逻辑回归模型的公式，排除目标变量Group\n# Dynamically generate the formula for the logistic regression model, excluding the target variable Group\nf <- as.formula(paste('Group ~', paste(n[!n %in% 'Group'], collapse = ' + '))) \n\n# 构建二分类逻辑回归模型\n# 参数说明：\n# f: 使用前面生成的全变量公式\n# data: 指定训练数据集\n# family = binomial: 二分类问题使用二项式分布\n# Build a binary classification logistic regression model\n# Parameter description:\n# f: Use the full variable formula generated earlier\n# data: Specify the training dataset\n# family = binomial: Use binomial distribution for binary classification problems\nlogit_model <- glm(f,data=train_df, family = binomial) \n\n# 若不需要全变量模型，可手动选择纳入逻辑回归的变量，例如选择CD86和FOS\n# If you don't need a full variable model, you can manually select variables to include in the logistic regression, such as CD86 and FOS\n#logit_model <- glm(Group ~ CD86 + FOS, data=train_df,family = binomial)   \n\n# 使用逐步回归法筛选变量（向后消除法）\n# 参数说明：\n# logit_model: 初始的全变量模型\n# direction = 'backward': 指定向后逐步回归\n# 也可以选择'both'（双向）或'forward'（向前）方法\n# 也可以使用LASSO等其他变量筛选方法\n# Use stepwise regression for variable selection (backward elimination)\n# Parameter description:\n# logit_model: The initial full variable model\n# direction = 'backward': Specify backward stepwise regression\n# You can also choose 'both' (bidirectional) or 'forward' methods\n# Other variable selection methods such as LASSO can also be used\nlogit_step <- step(logit_model, direction = 'backward')\n# 查看逐步回归后的模型摘要\n# View the summary of the model after stepwise regression\nsummary(logit_step)\n# 在训练集上进行预测并评估模型效能\n# 创建包含预测概率、真实标签的数据框\n# 参数说明：\n# Prob: 预测概率，保留四位小数\n# GoldStandard: 真实标签（训练集中的Group列）\n# Predict on the training set and evaluate model performance\n# Create a data frame containing predicted probabilities and true labels\n# Parameter description:\n# Prob: Predicted probabilities, rounded to four decimal places\n# GoldStandard: True labels (Group column in the training set)\npred_train <- data.frame(Prob = round(predict(logit_step, newdata = train_df,type=\"response\"),4), GoldStandard = train_df$Group, stringsAsFactors = F)\n\n# 计算训练集上的ROC曲线并绘制\n# 参数说明：\n# pred_train[,2]: 真实标签列\n# pred_train[,1]: 预测概率列\n# ylim=c(0,1): 设置Y轴范围为0到1\n# xlim=c(1,0): 设置X轴范围为1到0（传统ROC曲线方向）\n# smooth=F: 不绘制平滑曲线\n# ci=TRUE: 计算并显示置信区间\n# legacy.axes=T: 使用传统的ROC曲线坐标轴（1-specificity从0到1）\n# Calculate and plot the ROC curve on the training set\n# Parameter description:\n# pred_train[,2]: True label column\n# pred_train[,1]: Predicted probability column\n# ylim=c(0,1): Set the Y-axis range from 0 to 1\n# xlim=c(1,0): Set the X-axis range from 1 to 0 (traditional ROC curve direction)\n# smooth=F: Do not draw a smoothed curve\n# ci=TRUE: Calculate and display confidence intervals\n# legacy.axes=T: Use traditional ROC curve axes (1-specificity from 0 to 1)\nroc.train <- plot.roc(pred_train[,2], pred_train[,1], ylim=c(0,1),xlim=c(1,0), \n              smooth=F, \n              ci=TRUE, \n              legacy.axes=T)\n将模型应用于测试集计算预测概率\nApply the model to the test set to calculate the prediction\nprobability\n# 在测试集上进行预测并准备评估数据\n# 创建包含预测概率和真实标签的数据框\n# Prob列存储预测概率（保留四位小数）\n# GoldStandard列存储真实标签（来自测试集的Group列）\n# Predict on the test set and prepare data for evaluation\n# Create a data frame containing predicted probabilities and true labels\n# The Prob column stores predicted probabilities (rounded to four decimal places)\n# The GoldStandard column stores true labels (from the Group column of the test set)\npred_test <- data.frame(Prob = round(predict(logit_step, newdata = test_df,type=\"response\"),4), GoldStandard = test_df$Group, stringsAsFactors = F)\n\n# 计算并绘制测试集的ROC曲线\n# 参数说明：\n# pred_test[,2]: 真实标签列\n# pred_test[,1]: 预测概率列\n# ylim=c(0,1): 设置Y轴范围为0到1\n# xlim=c(1,0): 设置X轴范围为1到0（传统ROC曲线方向）\n# smooth=F: 不使用平滑处理\n# ci=TRUE: 计算并显示置信区间\n# legacy.axes=T: 使用传统坐标轴（横轴为1-Specificity，从0到1）\n# Calculate and plot the ROC curve for the test set\n# Parameter description:\n# pred_test[,2]: True label column\n# pred_test[,1]: Predicted probability column\n# ylim=c(0,1): Set Y-axis limits from 0 to 1\n# xlim=c(1,0): Set X-axis limits from 1 to 0 (traditional ROC curve direction)\n# smooth=F: Do not use smoothing\n# ci=TRUE: Calculate and display confidence intervals\n# legacy.axes=T: Use traditional axes (X-axis is 1-Specificity, ranging from 0 to 1)\nroc.test <- plot.roc(pred_test[,2], pred_test[,1], ylim=c(0,1),xlim=c(1,0),\n                      smooth=F, # Draw a smooth curve\n                      ci=TRUE, \n                      legacy.axes=T)# Use the plotting style of most papers, where the x-axis is \"1-specificity\" from 0 to 1\nROC比较\nROC comparison\n# 比较训练集和测试集ROC曲线的差异\n# 使用bootstrap方法进行统计检验\n# 参数说明：\n# roc.train: 训练集ROC对象\n# roc.test: 测试集ROC对象\n# method=\"bootstrap\": 使用自助法计算p值\n# Compare the ROC curves between training and test sets\n# Use bootstrap method for statistical testing\n# Parameter description:\n# roc.train: ROC object of the training set\n# roc.test: ROC object of the test set\n# method=\"bootstrap\": Use bootstrap method to calculate p-value\ncompare.roc <- roc.test(roc.train, roc.test, method=\"bootstrap\")\n\n# 根据比较结果输出结论\n# 若p值大于0.05，说明训练集和测试集上的模型性能无显著差异\n# 若p值小于等于0.05，说明存在显著差异\n# Output the conclusion based on the comparison result\n# If p-value > 0.05, there is no significant difference in model performance between training and test sets\n# If p-value ≤ 0.05, there is a significant difference\nif(compare.roc$p.value > 0.05) {\n  cat(paste0(\"p = \",compare.roc$p.value,\"\\nNo statiscal difference in evaluating model performence on train dataset or test dataset!\\n\"))\n} else {\n  cat(paste0(\"p = \",compare.roc$p.value,\"\\nStatistical difference exsits in evaluating model performence on train dataset or test dataset!\\n\"))\n}\n开始画图\n个人比较喜欢baseplot绘制ROC，这样更灵活。因为有时可能需要在图片上点出一个特定的灵敏度特异度组合（比如某专家的判断与金标准的比较）。\nStart drawing\nI personally prefer baseplot to plot ROC, as it is more flexible.\nBecause sometimes it may be necessary to highlight a specific\ncombination of sensitivity and specificity on the image (such as\ncomparing an expert’s judgment with the gold standard).\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa102multipanelROC_FigureYa102multipanelROC",
      "title": "FigureYa102multipanelROC/FigureYa102multipanelROC.html",
      "html": "FigureYa102multipanelROC/FigureYa102multipanelROC.html",
      "text": "texts/main_FigureYa102multipanelROC_FigureYa102multipanelROC.txt",
      "folder": "FigureYa102multipanelROC",
      "thumb": "gallery_compress/FigureYa102multipanelROC.webp"
    },
    "word_count": 1399,
    "lines_count": 248,
    "title": "FigureYa102multipanelROC",
    "description": "FigureYa24ROC能拿到4个miRNA的ROC，每个miRNA一条线。这里的Figure5E是把上述4条miRNA都一起进行预测，Figure6根据4个miRNA建立logistic regression model，然后对不同病理分期的肿瘤阶段进行预测。 Requirement description",
    "input_data_types": [
      "临床数据"
    ],
    "output_types": [
      "统计表格"
    ],
    "technical_methods": [],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "LANGUAGE",
      "stringsAsFactors",
      "data",
      "direction",
      "method",
      "ci",
      "GoldStandard",
      "header",
      "Prob"
    ]
  },
  {
    "id": "main_FigureYa79CNV_FigureYa79CNV",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa79CNV_FigureYa79CNV.txt",
    "content": "FigureYa79CNV\nFigureYa79CNV\nAuthor(s)\n: Haitao Wang, Taojun Ye\nReviewer(s)\n: Ying Ge\nDate\n: 2025-09-22\n需求描述\n我要DIY出paper里的这种对比多个subtype的composite copy number\nprofiles：\nRequirement description\nI want to DIY composite copy number profiles for comparing multiple\nsubtypes in the paper:\n出自\nhttps://www.nature.com/articles/nature20805\nfrom\nhttps://www.nature.com/articles/nature20805\nGISTIC自带画图功能（见结尾“附二”），能画出类似于C这种图。从firehose能下载到TCGA各癌症的Segmented\ncopy number profiles（类似于B）和Genomic positions of amplified\nregions（类似于C），但只有全部sample的图，我要对比不同subtype：\nGISTIC comes with its own drawing function (see Appendix 2 at the\nend), which can draw images similar to C. I can download Segmented copy\nnumber profiles (similar to B) and Genomic positions of amplified\nregions (similar to C) for various cancers in TCGA from firehose, but\nonly the images of all samples are available. I want to compare\ndifferent subtypes:\n出自\nhttps://www.sciencedirect.com/science/article/pii/S2352396418302986?via%3Dihub\nFrom\nhttps://www.sciencedirect.com/science/article/pii/S2352396418302986?via%3Dihub\n应用场景\n此处提供的DIY画图方法更灵活，可以画gistic\nscore，还可以画percentage/frequency。\n可单独画一个sample，也可以对比多组subtypes。\nApplication scenarios\nThe DIY drawing method provided here is more flexible, allowing you\nto draw Gistic scores and percentage/frequency.\nYou can draw a single sample or compare multiple subtypes.\n环境设置\n使用国内镜像安装包\nEnvironment settings\nsource(\"install_dependencies.R\")\n# 加载人类基因组数据（hg19版本）\n# Load the human genome data (hg19 version)\nlibrary(BSgenome.Hsapiens.UCSC.hg19)\n# 设置环境变量，使R显示英文错误信息（便于查阅官方文档）\n# Set environment variable to display English error messages for easier documentation lookup\nSys.setenv(LANGUAGE = \"en\") \n\n# 全局设置：禁止字符型数据自动转换为因子类型\n# Global option: Prevent automatic conversion of character data to factors\noptions(stringsAsFactors = FALSE)\n输入文件的获得\n画copy number profile需要gistic score和染色体信息，其中gistic\nscore可以用GISTIC 2.0计算（输入segment file）。\n如果你已经算出gistic\nscores，保存为“easy_input_*scores.gistic.txt”，就可以跳过这步，直接进入“准备染色体信息”。\nObtaining input files\nDrawing a copy number profile requires a Gistic score and chromosome\ninformation, where Gistic score can be calculated using GISTIC 2.0\n(input segment file).\nIf you have already calculated the Gistic scores and saved them as’\neasy_input_ * scores. gitistic. txt ‘, you can skip this step and\ndirectly enter’ Prepare Chromosome Information ’.\n获得subtype的gistic scores\n下载全部样本的segment file，然后按subtype分开，用GISTIC 2.0计算gistic\nscores，然后用算出的gistic scores来画图。\nObtain Gistic Scores for Subtypes\nDownload the segment files for all samples, then separate them by\nsubtype, calculate the Gistic scores using GISTIC 2.0, and use the\ncalculated Gistic scores to draw a graph.\n第一步，下载全部样本的segment file\nfocal_input.seg.txt：segment file。从\nfirehose\n下载hg19版本的TCGA\n数据，例文用 ESCA，压缩包链接：\nhttp://gdac.broadinstitute.org/runs/analyses__2016_01_28/data/ESCA/20160128/gdac.broadinstitute.org_ESCA-TP.CopyNumber_Gistic2.Level_4.2016012800.0.0.tar.gz\n。解压缩，点击nozzle.html，查看其他结果图表和Methods。需要里面的focal_input.seg.txt和scores.gistic（后面直接用它画全部样本的图）两个文件。\nhg38版本（TCGA数据）segment的获取方法见“附一”。\nStep one, download the segment files for all samples\nfocal_input.seg.txt：segment file。 From [firehose]（\nhttps://gdac.broadinstitute.org/\n）Download the TCGA\ndata of hg19 version, using ESCA as an example. The compressed file link\nis:<\nhttp://gdac.broadinstitute.org/runs/analyses__2016_01_28/data/ESCA/20160128/gdac.broadinstitute.org_ESCA-TP.CopyNumber_Gistic2.Level_4.2016012800.0.0.tar.gz\n>Extract the file, click on nozzle.exe to view other result charts\nand methods. We need two files inside, focal_input.seg.txt and\nscores.gitic (which can be used to draw the entire sample image\nlater).\nThe method for obtaining segments in the hg38 version (TCGA data) is\nshown in Appendix 1.\n第二步，拆分出subtype的segment file\n从TCGA获得亚型的sample\nID，然后把focal_input.seg.txt拆分成亚型的segment file\n此处模仿例文，根据Histological.Type…Oesophagus和Gastric.classification分为四种subtype。实际操作时可根据每种癌症的具体情况选择合适的列来分亚型做对比。\nStep 2, split the segment file of the subtype\nObtain the sample ID of the subtype from TCGA, and then split\nfocal_input.seg.txt into segment files for the subtype\nHere, imitating the example text, it is divided into four subtypes\nbased on Histologically. Type… Oesophagus and Gastroc.classification. In\npractical operation, appropriate columns can be selected based on the\nspecific situation of each cancer to classify subtypes for\ncomparison.\n# 获取食管癌(ESCA)的分子亚型信息\n# Retrieve molecular subtype information for esophageal cancer (ESCA)\nlibrary(TCGAbiolinks)  # 加载TCGAbiolinks包用于获取TCGA数据\n# Load TCGAbiolinks package for accessing TCGA data\ndataSub <- data.frame(TCGAquery_subtype(tumor = \"ESCA\"))  # 获取ESCA的亚型数据\n# Fetch ESCA subtype data\n\n# dataSub与补充表1内容一致，包含组织学类型和位置信息\n# dataSub is identical to Supplementary Table 1, containing histological type and location information\ntable(dataSub$Histological.Type...Oesophagus)  # 统计不同组织学类型的样本数\n# Count samples by histological type\ntable(dataSub$Tissue.level.Location)  # 统计不同组织位置的样本数\n# Count samples by tissue location\n\n# 提取不同分子亚型的患者ID\n# Extract patient IDs for different molecular subtypes\nEAC_id <- dataSub[dataSub$Histological.Type...Oesophagus==\"EAC\", \"patient\"]  # 食管腺癌患者ID\n# Patient IDs for esophageal adenocarcinoma (EAC)\nESCC_id <- dataSub[dataSub$Histological.Type...Oesophagus==\"ESCC\", \"patient\"]  # 食管鳞癌患者ID\n# Patient IDs for esophageal squamous cell carcinoma (ESCC)\nGA <- dataSub[dataSub$Tissue.level.Location==\"Gastric\", ]  # 胃组织来源样本\n# Samples from gastric tissue origin\ntable(GA$Gastric.classification)  # 统计胃组织样本的分类\n# Count gastric tissue samples by classification\nGA_CIN_id <- dataSub[dataSub$Gastric.classification==\"CIN\", \"patient\"]  # 胃CIN亚型患者ID\n# Patient IDs for gastric CIN subtype\nGA_nonCIN_id <- dataSub[dataSub$Gastric.classification!=\"CIN\", \"patient\"]  # 胃非CIN亚型患者ID\n# Patient IDs for gastric non-CIN subtype\n\n# 获取不同分子亚型的CNV片段数据\n# Retrieve CNV segment data for different molecular subtypes\nEAC.seg.cnv <- tumor.seg.cnv[tumor.seg.cnv$Sample %in% EAC_id,]  # EAC患者的CNV片段\n# CNV segments for EAC patients\nESCC.seg.cnv <- tumor.seg.cnv[tumor.seg.cnv$Sample %in% ESCC_id,]  # ESCC患者的CNV片段\n# CNV segments for ESCC patients\nGA_CIN.seg.cnv <- tumor.seg.cnv[tumor.seg.cnv$Sample %in% GA_CIN_id,]  # 胃CIN亚型患者的CNV片段\n# CNV segments for gastric CIN subtype patients\nGA_nonCIN.seg.cnv <- tumor.seg.cnv[tumor.seg.cnv$Sample %in% GA_nonCIN_id,]  # 胃非CIN亚型患者的CNV片段\n# CNV segments for gastric non-CIN subtype patients\n\n# 将不同亚型的CNV片段数据写入文本文件\n# Write CNV segment data for different subtypes to text files\nwrite.table(\n  EAC.seg.cnv,                  # 要写入的数据 Data to write\n  file=\"tumor.EAC.seg.txt\",     # 输出文件名 Output file name\n  sep=\"\\t\",                     # 分隔符 Tab separator\n  row.names=F,                  # 不保留行名 Exclude row names\n  quote = F                     # 不使用引号 Exclude quotes\n)\nwrite.table(ESCC.seg.cnv, file=\"tumor.ESCC.seg.txt\", sep=\"\\t\", row.names=F, quote = F)  # ESCC亚型CNV数据\n# ESCC subtype CNV data\nwrite.table(GA_CIN.seg.cnv, file=\"tumor.GACIN.seg.txt\", sep=\"\\t\", row.names=F, quote = F)  # 胃CIN亚型CNV数据\n# Gastric CIN subtype CNV data\nwrite.table(GA_nonCIN.seg.cnv, file=\"tumor.GAnonCIN.seg.txt\", sep=\"\\t\", row.names=F, quote = F)  # 胃非CIN亚型CNV数据\n# Gastric non-CIN subtype CNV data\n第三步，计算gistic score\n注：\nsegment file作为GISTIC 2.0的输入，用GISTIC\n2.0计算gistic score的方法见“附二”。\n计算将获得easy_input_*.scores.gistic.txt文件：\neasy_input_scores.gistic.txt：所有样品的gistic\nscore，跟focal_input.seg.txt位于同一压缩包，原文件名为scores.gistic。\neasy_input_*.scores.gistic.txt：四种亚型的gistic score。\nStep three, calculate the Gistic score\n**Note: The segment file is used as input for GISTIC 2.0, and the\nmethod for calculating the GISTIC score using GISTIC 2.0 is shown in\nAppendix 2.\nThe calculation will obtain the easy_input_ *. scores.gistic.txt\nfile:\n-EasyInput_Scores.gistic.txt: The gistic scores of all samples are\nlocated in the same compressed file as focal_input.seg.txt, with the\noriginal file name being scores.gistic. -Easy_input_ *.\nscores.gistic.txt: Gistic scores for four subtypes.\n准备染色体信息\nPrepare chromosome information\n# 创建染色体参考对象的函数\n# Function to create chromosome reference objects\nchrom_extract <- function(BSgenome.hg  = NULL) {\n  # 检查输入的基因组对象是否为空\n  # Check if the input genome object is NULL\n  if (is.null(BSgenome.hg )) stop(\"NULL object !\", call. = FALSE)\n  \n  # 创建包含物种和基因组构建版本的列表\n  # Create a list containing species and genome build information\n  obj <- list(\n    species = GenomeInfoDb::organism(BSgenome.hg),  # 物种信息\n    # Species information\n    genomebuild = BSgenome::providerVersion(BSgenome.hg)  # 基因组版本\n    # Genome build version\n  )\n  \n  # 创建染色体信息数据框\n  # Create a dataframe with chromosome information\n  df <- data.frame(\n    chrom = BSgenome::seqnames(BSgenome.hg),  # 染色体名称\n    # Chromosome names\n    chrN = seq_along(BSgenome::seqnames(BSgenome.hg)),  # 染色体编号\n    # Chromosome numbers\n    chr.length = GenomeInfoDb::seqlengths(BSgenome.hg),  # 染色体长度\n    # Chromosome lengths\n    stringsAsFactors = FALSE\n  )\n  \n  # 仅保留前24条染色体（1-22, X, Y）\n  # Keep only the first 24 chromosomes (1-22, X, Y)\n  df <- df[1:24,]\n  \n  # 计算染色体累积长度信息\n  # Calculate cumulative chromosome lengths\n  df$chr.length.sum <- cumsum(as.numeric(df$chr.length))  # 累积长度\n  # Cumulative length\n  df$chr.length.cumsum <- c(0, df$chr.length.sum[-nrow(df)])  # 前一个累积长度\n  # Previous cumulative length\n  \n  # 计算染色体中点位置\n  # Calculate midpoints of each chromosome\n  df$middle.chr <- round(diff(c(0, df$chr.length.sum)) /2)  # 染色体内部中点\n  # Midpoint within chromosome\n  df$middle.chr.genome <- df$middle.chr + df$chr.length.cumsum  # 基因组中的中点位置\n  # Midpoint position in the genome\n  \n  # 将染色体信息添加到对象中\n  # Add chromosome information to the object\n  obj$chromosomes <- df\n  \n  # 创建染色体名称与编号的映射关系\n  # Create mappings between chromosome names and numbers\n  obj$chrom2chr <- sapply(obj$chromosomes$chrom, function(k) { \n    obj$chromosomes$chrN[obj$chromosomes$chrom == k]\n  }, simplify = FALSE)  # 染色体名称到编号的映射\n  # Mapping from chromosome name to number\n  \n  obj$chr2chrom <- sapply(obj$chromosomes$chrN, function(k) { \n    obj$chromosomes$chrom[obj$chromosomes$chrN == k]\n  }, simplify = FALSE)  # 染色体编号到名称的映射\n  # Mapping from chromosome number to name\n  \n  # 设置映射的名称\n  # Set names for the mappings\n  names(obj$chr2chrom) <- obj$chromosomes$chrN\n  \n  # 计算基因组总长度\n  # Calculate total genome length\n  obj$genome.length <- sum(as.numeric(obj$chromosomes$chr.length), na.rm = TRUE)\n  \n  # 返回包含所有染色体信息的对象\n  # Return the object containing all chromosome information\n  return(obj)\n}\n\n# 提取染色体参考位点信息\n# Extract chromosome reference loci information\nBSgenome.hg = \"BSgenome.Hsapiens.UCSC.hg19\"  # 指定人类基因组hg19版本\n# Specify human genome hg19 version\nBSg.obj <- getExportedValue(BSgenome.hg, BSgenome.hg)  # 获取基因组对象\n# Get the genome object\ngenome.version <- BSgenome::providerVersion(BSg.obj)  # 获取基因组版本信息\n# Get genome version information\nchrom <- chrom_extract(BSg.obj)  # 提取染色体信息\n# Extract chromosome information\n#str(chrom)  # 查看染色体信息结构（已注释掉）\n# View the structure of chromosome information (commented out)\n开始画图\n分别画全部样本的gistic\nscore和percentage/frequency，再画四个subtye对比的gistic\nscore和percentage/frequency。\nStart drawing\nDraw the Gistic score and percentage/frequency of all samples\nseparately, and then draw the Gistic score and percentage/frequency of\nfour subties for comparison.\n画全部sample的gistic score\nDraw the Gistic Score for all samples\n#pdf(\"ESCA_copy_number_gistic_score.pdf\",12,5)\n# Import gistic2 results read gistic output file\nscores <- read.table(\"easy_input_scores.gistic.txt\", sep=\"\\t\",header=T,stringsAsFactors = F)\nhead(scores)\nunique(scores$Chromosome)\n#把染色体名从阿拉伯数字改为“chr1”、“chrX”的形式\nscores[scores$Chromosome==23, \"Chromosome\"] <- \"X\"\nscores[scores$Chromosome==24, \"Chromosome\"] <- \"Y\"\nchrID <- unname(unlist(chrom$chrom2chr[as.character(paste0(\"chr\",scores$Chromosome))]))\n\n# Important step for accurate length to match back to continual chrom loci\nscores$Start.geno <- scores$Start + chrom$chromosomes$chr.length.cumsum[chrID]\nscores$End.geno <- scores$End + chrom$chromosomes$chr.length.cumsum[chrID]\n\n# Prepare input data for ploting\nscores.amp <- scores[scores$Type==\"Amp\",]\nscores.amp$G.score <- scores.amp$G.score * 1\nscores.del <- scores[scores$Type==\"Del\",]\nscores.del$G.score <- scores.del$G.score * -1\nscores <- rbind.data.frame(scores.amp,scores.del)\n\n# seg.col = list(gain = \"red\", outscale.gain = \"darkred\", loss = \"blue\", outscale.red = \"midnightblue\")\nylim <- c(min(scores$G.score) - 0.1, max(scores$G.score) + 0.1)\ntitle <- paste0(\"TCGA ESCA overall copy number gistic score\", \" \", \"n=\", length(dataSub$patient))\n\nplot(scores.amp$Start.geno, scores.amp$G.score,\n     pch = \".\", type='h',cex = 2, xaxs = \"i\", yaxs = \"i\", \n     xlim = c(0,chrom$genome.length), ylim = ylim,\n     main = title, cex.main = 2, ylab = \"gistic score\", xlab = NA,\n     cex.lab = 2, col = adjustcolor(\"darkred\", alpha.f = .8), xaxt = \"n\", lwd = 2, las=1) # las=1 rotating axis labels in R\nlines(scores.del$Start.geno, scores.del$G.score, type='h', lwd = 2, col = adjustcolor(\"midnightblue\", alpha.f = .8))\nink <- chrom$chromosomes$chrN %in% chrID\nyrange = abs(diff(ylim))\nm.pos <- c(ylim[1]+0.15,ylim[2]-0.15)\nm.mod <- -(chrom$chromosomes$chrN[ink] %% 2) +2\ntry(text(x = chrom$chromosomes$middle.chr.geno[ink], y = m.pos[m.mod], labels = chrom$chromosomes$chrom[ink], cex = 1))\nabline(h = 0.0, col = 1, lwd = 1, lty = 3)\nabline(v = c(0,chrom$chromosomes$chr.length.sum), col = 1, lty = 3, lwd = 1)\n\ncol1 <- adjustcolor(\"darkred\", alpha.f = .8)\ncol2 <- adjustcolor(\"midnightblue\", alpha.f = .8)\n# The position of the legend can be specified also using the following keywords : \"bottomright\", \"bottom\", \"bottomleft\", \"left\", \"topleft\", \"top\", \"topright\", \"right\" and \"center\".\nlegend(\"topleft\", c(\"gain\",\"loss\"), cex=0.6, bty=\"n\", fill=c(col1,col2))\n#dev.off()\n画全部样本的percentage/frequency\nDraw the percentage/frequency of all samples\n#pdf(\"ESCA_copy_number_gistic_score.pdf\",12,5)  # 输出PDF（已注释）\n# Output PDF (commented out)\n\n# 导入GISTIC2结果数据\n# Import GISTIC2 results data\nscores <- read.table(\n  \"easy_input_scores.gistic.txt\",  # GISTIC评分输入文件\n  # Input file for GISTIC scores\n  sep=\"\\t\",                        # 制表符分隔\n  # Tab-separated\n  header=T,                        # 包含表头\n  # Include header\n  stringsAsFactors = F             # 不将字符串转换为因子\n  # Do not convert strings to factors\n)\nhead(scores)  # 查看数据前几行\n# View first few rows of data\nunique(scores$Chromosome)  # 查看唯一的染色体值\n# Check unique chromosome values\n\n# 将染色体编号从阿拉伯数字转换为\"chr1\"、\"chrX\"格式\n# Convert chromosome numbers to \"chr1\", \"chrX\" format\nscores[scores$Chromosome==23, \"Chromosome\"] <- \"X\"  # 将23号染色体重命名为X\n# Rename chromosome 23 to X\nscores[scores$Chromosome==24, \"Chromosome\"] <- \"Y\"  # 将24号染色体重命名为Y\n# Rename chromosome 24 to Y\n\n# 将染色体名称映射为内部编号\n# Map chromosome names to internal IDs\nchrID <- unname(unlist(chrom$chrom2chr[as.character(paste0(\"chr\", scores$Chromosome))]))\n\n# 关键步骤：将坐标转换为基因组连续位置\n# Important step: Convert coordinates to continuous genomic positions\nscores$Start.geno <- scores$Start + chrom$chromosomes$chr.length.cumsum[chrID]  # 起始位置转换\n# Convert start positions\nscores$End.geno <- scores$End + chrom$chromosomes$chr.length.cumsum[chrID]      # 终止位置转换\n# Convert end positions\n\n# 准备绘图数据\n# Prepare data for plotting\nscores.amp <- scores[scores$Type==\"Amp\",]  # 提取扩增数据\n# Extract amplification data\nscores.amp$G.score <- scores.amp$G.score * 1  # 正向评分（保持正值）\n# Positive scores (maintain positive values)\nscores.del <- scores[scores$Type==\"Del\",]  # 提取缺失数据\n# Extract deletion data\nscores.del$G.score <- scores.del$G.score * -1  # 负向评分（转换为负值）\n# Negative scores (convert to negative values)\nscores <- rbind.data.frame(scores.amp, scores.del)  # 合并数据\n# Combine data\n\n# 设置颜色方案\n# Set color scheme\n# seg.col = list(gain = \"red\", outscale.gain = \"darkred\", loss = \"blue\", outscale.red = \"midnightblue\")\n\n# 设置Y轴范围\n# Set Y-axis range\nylim <- c(min(scores$G.score) - 0.1, max(scores$G.score) + 0.1)\n\n# 设置标题\n# Set plot title\ntitle <- paste0(\"TCGA ESCA overall copy number gistic score\", \" \", \"n=\", length(dataSub$patient))\n\n# 绘制扩增数据（红色垂线）\n# Plot amplifications (red vertical lines)\nplot(\n  scores.amp$Start.geno,  # X轴：基因组起始位置\n  # X-axis: Genomic start positions\n  scores.amp$G.score,     # Y轴：GISTIC评分\n  # Y-axis: GISTIC scores\n  pch = \".\",              # 点形状（像素点）\n  # Point shape (pixel dot)\n  type='h',               # 绘制垂线\n  # Plot vertical lines\n  cex = 2,                # 点大小\n  # Point size\n  xaxs = \"i\",             # X轴范围严格按照数据\n  # X-axis range exactly matches data\n  yaxs = \"i\",             # Y轴范围严格按照数据\n  # Y-axis range exactly matches data\n  xlim = c(0, chrom$genome.length),  # X轴范围：基因组全长\n  # X-axis range: Full genome length\n  ylim = ylim,            # Y轴范围\n  # Y-axis range\n  main = title,           # 标题\n  # Plot title\n  cex.main = 2,           # 标题大小\n  # Title size\n  ylab = \"gistic score\",  # Y轴标签\n  # Y-axis label\n  xlab = NA,              # 不显示X轴标签\n  # No X-axis label\n  cex.lab = 2,            # 标签大小\n  # Label size\n  col = adjustcolor(\"darkred\", alpha.f = .8),  # 颜色（半透明深红色）\n  # Color (semi-transparent dark red)\n  xaxt = \"n\",             # 不显示X轴刻度\n  # No X-axis tick marks\n  lwd = 2,                # 线宽\n  # Line width\n  las=1                   # Y轴标签水平显示\n  # Y-axis labels horizontal\n)\n\n# 添加缺失数据（蓝色垂线）\n# Add deletions (blue vertical lines)\nlines(\n  scores.del$Start.geno,  # X轴：基因组起始位置\n  # X-axis: Genomic start positions\n  scores.del$G.score,     # Y轴：GISTIC评分（负值）\n  # Y-axis: GISTIC scores (negative values)\n  type='h',               # 绘制垂线\n  # Plot vertical lines\n  lwd = 2,                # 线宽\n  # Line width\n  col = adjustcolor(\"midnightblue\", alpha.f = .8)  # 颜色（半透明深蓝色）\n  # Color (semi-transparent midnight blue)\n)\n\n# 标记染色体位置\n# Mark chromosome positions\nink <- chrom$chromosomes$chrN %in% chrID  # 检查染色体是否存在\n# Check if chromosome exists\nyrange = abs(diff(ylim))  # Y轴范围\n# Y-axis range\nm.pos <- c(ylim[1]+0.15, ylim[2]-0.15)  # 标记位置\n# Label positions\nm.mod <- -(chrom$chromosomes$chrN[ink] %% 2) +2  # 交替位置\n# Alternating positions\ntry(text(\n  x = chrom$chromosomes$middle.chr.geno[ink],  # X坐标：染色体中点\n  # X-coordinates: Chromosome midpoints\n  y = m.pos[m.mod],                             # Y坐标：交替位置\n  # Y-coordinates: Alternating positions\n  labels = chrom$chromosomes$chrom[ink],        # 标签：染色体名称\n  # Labels: Chromosome names\n  cex = 1                                       # 字体大小\n  # Font size\n))\n\n# 添加参考线\n# Add reference lines\nabline(h = 0.0, col = 1, lwd = 1, lty = 3)  # 水平参考线（y=0）\n# Horizontal reference line (y=0)\nabline(v = c(0, chrom$chromosomes$chr.length.sum), col = 1, lty = 3, lwd = 1)  # 染色体边界垂直线\n# Vertical lines at chromosome boundaries\n\n# 设置颜色\n# Set colors\ncol1 <- adjustcolor(\"darkred\", alpha.f = .8)  # 扩增颜色\n# Amplification color\ncol2 <- adjustcolor(\"midnightblue\", alpha.f = .8)  # 缺失颜色\n# Deletion color\n\n# 添加图例\n# Add legend\n# 图例位置可以使用以下关键字指定：\"bottomright\", \"bottom\", \"bottomleft\", \"left\", \"topleft\", \"top\", \"topright\", \"right\" and \"center\"\n# Legend position can be specified using keywords: \"bottomright\", \"bottom\", \"bottomleft\", \"left\", \"topleft\", \"top\", \"topright\", \"right\", \"center\"\nlegend(\n  \"topleft\",              # 图例位置：左上角\n  # Legend position: Top-left\n  c(\"gain\", \"loss\"),      # 图例标签\n  # Legend labels\n  cex=0.6,                # 字体大小\n  # Font size\n  bty=\"n\",                # 无边框\n  # No border\n  fill=c(col1, col2)      # 填充颜色\n  # Fill colors\n)\n#dev.off()  # 关闭PDF设备（已注释）\n# Close PDF device (commented out)\n画四个subtype对比的gistic score\nDraw a Gistic Score Comparing Four Subtypes\n# 创建PDF文件，设置宽度15英寸、高度12英寸\n# Create PDF file with specified width and height\npdf(\"cnv.scores.gistic.pdf\", 15, 12)\n\n# 设置绘图布局为4行1列，调整边距（上、右、下、左各增加3个单位）\n# Set plot layout to 4 rows and 1 column, adjust margins (add 3 units to top, right, bottom, left)\npar(mfrow=c(4,1), mar = par()$mar + c(3,0,0,3))\n\n\n### ESCC亚型分析 ###\n### ESCC subtype analysis ###\n\n# 读取ESCC的GISTIC评分数据（制表符分隔，含表头）\n# Read GISTIC score data for ESCC (tab-separated, with header)\nscores <- read.table(\n  \"easy_input_ESCC.scores.gistic.txt\",  # 输入文件路径\n  # Input file path\n  sep=\"\\t\",                             # 分隔符：制表符\n  # Separator: tab\n  header=T,                             # 包含表头\n  # Include header row\n  stringsAsFactors = F                  # 不将字符串转换为因子\n  # Do not convert strings to factors\n)\n\n# 关键步骤：标准化染色体编号并映射到基因组坐标\n# Important step: Standardize chromosome numbers and map to genomic coordinates\nscores[scores$Chromosome==23, \"Chromosome\"] <- \"X\"  # 将23号染色体重命名为X\n# Rename chromosome 23 to X\nscores[scores$Chromosome==24, \"Chromosome\"] <- \"Y\"  # 将24号染色体重命名为Y\n# Rename chromosome 24 to Y\nchrID <- unname(unlist(chrom$chrom2chr[as.character(paste0(\"chr\", scores$Chromosome))]))  # 获取染色体内部索引\n# Get internal chromosome indices\nscores$Start.geno <- scores$Start + chrom$chromosomes$chr.length.cumsum[chrID]  # 转换起始位置为全基因组坐标\n# Convert start positions to genome-wide coordinates\nscores$End.geno <- scores$End + chrom$chromosomes$chr.length.cumsum[chrID]      # 转换终止位置为全基因组坐标\n# Convert end positions to genome-wide coordinates\n\n# 准备绘图数据：分离扩增和缺失数据，设置正负评分方向\n# Prepare plotting data: Separate amplifications and deletions, set positive/negative directions\nscores.amp <- scores[scores$Type==\"Amp\", ]  # 提取扩增数据\n# Extract amplification data\nscores.amp$G.score <- scores.amp$G.score * 1  # 保持正向评分\n# Maintain positive scores\nscores.del <- scores[scores$Type==\"Del\", ]  # 提取缺失数据\n# Extract deletion data\nscores.del$G.score <- scores.del$G.score * -1  # 转换为负向评分\n# Convert to negative scores\nscores <- rbind.data.frame(scores.amp, scores.del)  # 合并数据\n# Combine data\n\n# 设置Y轴范围（扩展上下限0.1以避免数据贴近边界）\n# Set Y-axis range (extend 0.1 from min/max to avoid data clipping)\nylim <- c(min(scores$G.score) - 0.1, max(scores$G.score) + 0.1)\n# 生成标题（包含样本数）\n# Generate title (including sample count)\ntitle <- paste0(\"ESCC copy number gistic score\", \" \", \"n=\", length(ESCC_id))\n\n# 绘制ESCC拷贝数变异图（红色为扩增，蓝色为缺失）\n# Plot ESCC copy number variations (red for amplification, blue for deletion)\nplot(\n  scores.amp$Start.geno,       # X轴：基因组起始位置\n  # X-axis: Genomic start positions\n  scores.amp$G.score,          # Y轴：GISTIC评分（正值）\n  # Y-axis: GISTIC scores (positive values)\n  pch = \".\",                   # 点形状：像素点\n  # Point shape: pixel\n  type='h',                    # 绘图类型：垂直线\n  # Plot type: vertical lines\n  cex = 2,                     # 点大小\n  # Point size\n  xaxs = \"i\",                  # X轴范围：严格匹配数据\n  # X-axis range: strictly match data\n  yaxs = \"i\",                  # Y轴范围：严格匹配数据\n  # Y-axis range: strictly match data\n  xlim = c(0, chrom$genome.length),  # X轴范围：全基因组长度\n  # X-axis range: full genome length\n  ylim = ylim,                 # Y轴范围\n  # Y-axis range\n  main = title,                # 主标题\n  # Main title\n  cex.main = 2,                # 标题字体大小\n  # Title font size\n  ylab = \"gistic score\",       # Y轴标签\n  # Y-axis label\n  xlab = NA,                   # 不显示X轴标签\n  # No X-axis label\n  cex.lab = 2,                 # 标签字体大小\n  # Label font size\n  col = adjustcolor(\"darkred\", alpha.f = .8),  # 颜色：半透明深红色\n  # Color: semi-transparent dark red\n  xaxt = \"n\",                  # 不显示X轴刻度\n  # No X-axis ticks\n  lwd = 2,                     # 线宽\n  # Line width\n  las=1                        # Y轴标签水平显示\n  # Y-axis labels horizontal\n)\n# 添加缺失数据（蓝色垂线）\n# Add deletions (blue vertical lines)\nlines(\n  scores.del$Start.geno,       # X轴：缺失起始位置\n  # X-axis: deletion start positions\n  scores.del$G.score,          # Y轴：GISTIC评分（负值）\n  # Y-axis: GISTIC scores (negative values)\n  type='h',                    # 绘图类型：垂直线\n  # Plot type: vertical lines\n  lwd = 2,                     # 线宽\n  # Line width\n  col = adjustcolor(\"midnightblue\", alpha.f = .8)  # 颜色：半透明深蓝色\n  # Color: semi-transparent midnight blue\n)\n\n# 标记染色体位置（在染色体中点显示名称）\n# Mark chromosome positions (display names at chromosome midpoints)\nink <- chrom$chromosomes$chrN %in% chrID  # 筛选存在的染色体\n# Filter existing chromosomes\nyrange <- abs(diff(ylim))  # Y轴范围差值\n# Y-axis range difference\nm.pos <- c(ylim[1] + 0.05, ylim[2] - 0.05)  # 标签Y坐标（上下交替）\n# Label Y-coordinates (alternating top and bottom)\nm.mod <- -(chrom$chromosomes$chrN[ink] %% 2) + 2  # 计算交替位置索引\n# Calculate alternating position index\ntry(text(\n  x = chrom$chromosomes$middle.chr.geno[ink],  # X坐标：染色体中点基因组位置\n  # X-coordinates: chromosome midpoint genomic positions\n  y = m.pos[m.mod],                            # Y坐标：交替位置\n  # Y-coordinates: alternating positions\n  labels = chrom$chromosomes$chrom[ink],       # 标签：染色体名称\n  # Labels: chromosome names\n  cex = 1                                      # 字体大小\n  # Font size\n))\n\n# 添加参考线（水平中线和染色体边界）\n# Add reference lines (horizontal midline and chromosome boundaries)\nabline(h = 0.0, col = 1, lwd = 1, lty = 3)  # 水平参考线（y=0）\n# Horizontal reference line (y=0)\nabline(v = c(0, chrom$chromosomes$chr.length.sum), col = 1, lty = 3, lwd = 1)  # 染色体边界垂直线\n# Vertical lines at chromosome boundaries\n\n# 添加图例（左上角，无背景框）\n# Add legend (top-left corner, no background box)\ncol1 <- adjustcolor(\"darkred\", alpha.f = .8)  # 扩增颜色\n# Amplification color\ncol2 <- adjustcolor(\"midnightblue\", alpha.f = .8)  # 缺失颜色\n# Deletion color\nlegend(\n  \"topleft\",              # 图例位置：左上角\n  # Legend position: top-left\n  c(\"gain\", \"loss\"),      # 图例标签\n  # Legend labels\n  cex=0.6,                # 字体大小\n  # Font size\n  bty=\"n\",                # 无边框\n  # No border\n  fill=c(col1, col2)      # 填充颜色\n  # Fill colors\n)\n\n\n### EAC亚型分析（与ESCC类似，注意评分缩放100倍）###\n### EAC subtype analysis (similar to ESCC, note score scaling by 100) ###\n\nscores <- read.table(\"easy_input_EAC.scores.gistic.txt\", sep=\"\\t\", header=T, stringsAsFactors = F)\n# 读取EAC的GISTIC评分数据\n# Read GISTIC score data for EAC\n\n# 染色体编号转换和基因组坐标映射（同上）\n# Chromosome number conversion and genomic coordinate mapping (same as above)\nscores[scores$Chromosome==23, \"Chromosome\"] <- \"X\"\nscores[scores$Chromosome==24, \"Chromosome\"] <- \"Y\"\nchrID <- unname(unlist(chrom$chrom2chr[as.character(paste0(\"chr\", scores$Chromosome))]))\nscores$Start.geno <- scores$Start + chrom$chromosomes$chr.length.cumsum[chrID]\nscores$End.geno <- scores$End + chrom$chromosomes$chr.length.cumsum[chrID]\n\n# 数据准备（评分缩放100倍，Y轴标签改为\"Frequency\"）\n# Data preparation (scores scaled by 100, Y-axis label changed to \"Frequency\")\nscores.amp <- scores[scores$Type==\"Amp\", ]\nscores.amp$G.score <- scores.amp$G.score * 100  # 扩增评分×100\n# Amplification scores ×100\nscores.del <- scores[scores$Type==\"Del\", ]\nscores.del$G.score <- scores.del$G.score * -100  # 缺失评分×-100\n# Deletion scores ×-100\nscores <- rbind.data.frame(scores.amp, scores.del)\n\nylim <- c(min(scores$G.score) - 0.1, max(scores$G.score) + 0.1)\ntitle <- paste0(\"EAC copy number gistic score\", \" \", \"n=\", length(EAC_id))\n\nplot(\n  scores.amp$Start.geno, \n  scores.amp$G.score,\n  pch = \".\", type='h', cex = 2, xaxs = \"i\", yaxs = \"i\", \n  xlim = c(0, chrom$genome.length), ylim = ylim,\n  main = title, cex.main = 2, ylab = \"Frequency\", xlab = NA,  # Y轴标签改为\"频率\"\n  # Y-axis label changed to \"Frequency\"\n  cex.lab = 2, col = adjustcolor(\"darkred\", alpha.f = .8), xaxt = \"n\", lwd = 2, las=1\n)\nlines(scores.del$Start.geno, scores.del$G.score, type='h', lwd = 2, col = adjustcolor(\"midnightblue\", alpha.f = .8))\n\n# 染色体标记和参考线（同上）\n# Chromosome marking and reference lines (same as above)\nink <- chrom$chromosomes$chrN %in% chrID\nyrange = abs(diff(ylim))\nm.pos <- c(ylim[1] + 10, ylim[2] - 10)  # 调整标签位置适应缩放后的评分\n# Adjust label positions for scaled scores\nm.mod <- -(chrom$chromosomes$chrN[ink] %% 2) + 2\ntry(text(x = chrom$chromosomes$middle.chr.geno[ink], y = m.pos[m.mod], labels = chrom$chromosomes$chrom[ink], cex = 1))\nabline(h = 0.0, col = 1, lwd = 1, lty = 3)\nabline(v = c(0, chrom$chromosomes$chr.length.sum), col = 1, lty = 3, lwd = 1)\n\n# 图例（同上）\n# Legend (same as above)\ncol1 <- adjustcolor(\"darkred\", alpha.f = .8)\ncol2 <- adjustcolor(\"midnightblue\", alpha.f = .8)\nlegend(\"topleft\", c(\"gain\", \"loss\"), cex=0.6, bty=\"n\", fill=c(col1, col2))\n\n\n### GA_CIN亚型分析 ###\n### GA_CIN subtype analysis ###\n\nscores <- read.table(\"easy_input_GA_CIN.scores.gistic.txt\", sep=\"\\t\", header=T, stringsAsFactors = F)\n# 读取GA_CIN的GISTIC评分数据\n# Read GISTIC score data for GA_CIN\n\n# 染色体编号转换和基因组坐标映射（同上）\n# Chromosome number conversion and genomic coordinate mapping (same as above)\nscores[scores$Chromosome==23, \"Chromosome\"] <- \"X\"\nscores[scores$Chromosome==24, \"Chromosome\"] <- \"Y\"\nchrID <- unname(unlist(chrom$chrom2chr[as.character(paste0(\"chr\", scores$Chromosome))]))\nscores$Start.geno <- scores$Start + chrom$chromosomes$chr.length.cumsum[chrID]\nscores$End.geno <- scores$End + chrom$chromosomes$chr.length.cumsum[chrID]\n\n# 数据准备（同ESCC）\n# Data preparation (same as ESCC)\nscores.amp <- scores[scores$Type==\"Amp\", ]\nscores.amp$G.score <- scores.amp$G.score * 1\nscores.del <- scores[scores$Type==\"Del\", ]\nscores.del$G.score <- scores.del$G.score * -1\nscores <- rbind.data.frame(scores.amp, scores.del)\n\nylim <- c(min(scores$G.score) - 0.1, max(scores$G.score) + 0.1)\ntitle <- paste0(\"GA_CIN copy number gistic score\", \" \", \"n=\", length(GA_CIN_id))\n\nplot(\n  scores.amp$Start.geno, \n  scores.amp$G.score,\n  pch = \".\", type='h', cex = 2, xaxs = \"i\", yaxs = \"i\", \n  xlim = c(0, chrom$genome.length), ylim = ylim,\n  main = title, cex.main = 2, ylab = \"gistic score\", xlab = NA,\n  cex.lab = 2, col = adjustcolor(\"darkred\", alpha.f = .8), xaxt = \"n\", lwd = 2, las=1\n)\nlines(scores.del$Start.geno, scores.del$G.score, type='h', lwd = 2, col = adjustcolor(\"midnightblue\", alpha.f = .8))\n\n# 染色体标记和参考线（同上）\n# Chromosome marking and reference lines (same as above)\nink <- chrom$chromosomes$chrN %in% chrID\nyrange = abs(diff(ylim))\nm.pos <- c(ylim[1] + 0.05, ylim[2] - 0.05)\nm.mod <- -(chrom$chromosomes$chrN[ink] %% 2) + 2\ntry(text(x = chrom$chromosomes$middle.chr.geno[ink], y = m.pos[m.mod], labels = chrom$chromosomes$chrom[ink], cex = 1))\nabline(h = 0.0, col = 1, lwd = 1, lty = 3)\nabline(v = c(0, chrom$chromosomes$chr.length.sum), col = 1, lty = 3, lwd = 1)\n\n# 图例（同上）\n# Legend (same as above)\ncol1 <- adjustcolor(\"darkred\", alpha.f = .8)\ncol2 <- adjustcolor(\"midnightblue\", alpha.f = .8)\nlegend(\"topleft\", c(\"gain\", \"loss\"), cex=0.6, bty=\"n\", fill=c(col1, col2))\n\n\n### GA_nonCIN亚型分析 ###\n### GA_nonCIN subtype analysis ###\n\nscores <- read.table(\"easy_input_GA_nonCIN.scores.gistic.txt\", sep=\"\\t\", header=T, stringsAsFactors = F)\n# 读取GA_nonCIN的GISTIC评分数据\n# Read GISTIC score data for GA_nonCIN\n\n# 染色体编号转换和基因组坐标映射（同上）\n# Chromosome number conversion and genomic coordinate mapping (same as above)\nscores[scores$Chromosome==23, \"Chromosome\"] <- \"X\"\nscores[scores$Chromosome==24, \"Chromosome\"] <- \"Y\"\nchrID <- unname(unlist(chrom$chrom2chr[as.character(paste0(\"chr\", scores$Chromosome))]))\nscores$Start.geno <- scores$Start + chrom$chromosomes$chr.length.cumsum[chrID]\nscores$End.geno <- scores$End + chrom$chromosomes$chr.length.cumsum[chrID]\n\n# 准备绘图数据\n# Prepare data for plotting\nscores.amp <- scores[scores$Type==\"Amp\",]  # 筛选扩增区域数据\n# Filter amplification regions\nscores.amp$G.score <- scores.amp$G.score * 1  # 扩增评分保持正值（乘以1）\n# Keep amplification scores positive\nscores.del <- scores[scores$Type==\"Del\",]  # 筛选缺失区域数据\n# Filter deletion regions\nscores.del$G.score <- scores.del$G.score * -1  # 缺失评分转为负值\n# Convert deletion scores to negative values\nscores <- rbind.data.frame(scores.amp,scores.del)  # 合并扩增和缺失数据\n# Combine amplification and deletion data\n\n# 设置颜色方案（未使用的代码，但定义了颜色映射）\n# Color scheme definition (commented out, not used in current code)\n# seg.col = list(gain = \"red\", outscale.gain = \"darkred\", loss = \"blue\", outscale.red = \"midnightblue\")\n\n# 设置Y轴范围（在最小值和最大值基础上各扩展0.1）\n# Set Y-axis limits with a small buffer\nylim <- c(min(scores$G.score)-0.1,max(scores$G.score)+0.1)\n# 生成图表标题，包含样本类型和数量\n# Generate plot title with sample type and count\ntitle=paste0(\"GA_nonCIN copy number gistic score\",\" \",\"n=\",length(GA_nonCIN_id))\n\n# 绘制扩增区域的GISTIC评分\n# Plot GISTIC scores for amplifications\nplot(scores.amp$Start.geno, scores.amp$G.score,\n     pch = \".\", type='h', cex = 2, xaxs = \"i\", yaxs = \"i\",  # 设置点形状、绘图类型和坐标轴范围\n     # Set point character, plot type, and axis ranges\n     xlim = c(0,chrom$genome.length), ylim = ylim,  # X轴为全基因组范围，Y轴为评分范围\n     # X-axis spans the entire genome, Y-axis based on score range\n     main = title, cex.main = 2,  # 设置主标题及字体大小\n     # Set main title and font size\n     ylab = \"gistic score\", xlab = NA,  # Y轴标签为GISTIC评分，不显示X轴标签\n     # Y-axis label is GISTIC score, hide X-axis label\n     cex.lab = 2,  # 设置标签字体大小\n     # Set label font size\n     col = adjustcolor(\"darkred\", alpha.f = .8),  # 扩增区域用半透明深红色表示\n     # Use semi-transparent dark red for amplifications\n     xaxt = \"n\",  # 不显示默认X轴刻度\n     # Suppress default X-axis ticks\n     lwd = 2,  # 设置线宽\n     # Set line width\n     las=1  # Y轴标签水平显示\n     # Make Y-axis labels horizontal\n)\n# 添加缺失区域的GISTIC评分（负值）\n# Add GISTIC scores for deletions (negative values)\nlines(scores.del$Start.geno, scores.del$G.score, \n      type='h', lwd = 2, col = adjustcolor(\"midnightblue\", alpha.f = .8))  # 缺失区域用半透明深蓝色表示\n      # Use semi-transparent midnight blue for deletions\n\n# 在染色体中部添加染色体标签\n# Add chromosome labels at the midpoint of each chromosome\nink <- chrom$chromosomes$chrN %in% chrID  # 筛选存在数据的染色体\n# Filter chromosomes with data\nyrange = abs(diff(ylim))  # 计算Y轴范围\n# Calculate Y-axis range\nm.pos <- c(ylim[1]+0.05,ylim[2]-0.05)  # 设置标签Y坐标位置（上下交替）\n# Set label positions (alternating top and bottom)\nm.mod <- -(chrom$chromosomes$chrN[ink] %% 2) +2  # 计算染色体标签位置的索引\n# Calculate indices for alternating label positions\ntry(text(x = chrom$chromosomes$middle.chr.geno[ink],  # X坐标为染色体中部位置\n         # X-coordinates at chromosome midpoints\n         y = m.pos[m.mod],  # Y坐标为上方或下方（交替）\n         # Y-coordinates alternating between top and bottom\n         labels = chrom$chromosomes$chrom[ink],  # 标签为染色体名称\n         # Labels are chromosome names\n         cex = 1))  # 设置字体大小\n\n# 添加参考线\n# Add reference lines\nabline(h = 0.0, col = 1, lwd = 1, lty = 3)  # 添加y=0的水平参考线（虚线）\n# Add horizontal reference line at y=0 (dashed line)\nabline(v = c(0,chrom$chromosomes$chr.length.sum), col = 1, lty = 3, lwd = 1)  # 添加染色体边界垂直线\n# Add vertical lines at chromosome boundaries\n\n# 设置图例颜色\n# Set legend colors\ncol1 <- adjustcolor(\"darkred\", alpha.f = .8)  # 扩增颜色\n# Color for amplifications\ncol2 <- adjustcolor(\"midnightblue\", alpha.f = .8)  # 缺失颜色\n# Color for deletions\n\n# 图例位置可以使用以下关键字指定：\"bottomright\", \"bottom\", \"bottomleft\", \"left\", \"topleft\", \"top\", \"topright\", \"right\" and \"center\"\n# Legend position can be specified using keywords: \"bottomright\", \"bottom\", \"bottomleft\", \"left\", \"topleft\", \"top\", \"topright\", \"right\", \"center\"\n\n# 添加图例（左上角，无边框，显示扩增和缺失的颜色）\n# Add legend (top-left corner, no border, showing colors for gains and losses)\nlegend(\"topleft\", c(\"gain\",\"loss\"), cex=0.6, bty=\"n\", fill=c(col1,col2))\n\n# 关闭图形设备，完成PDF绘制\n# Close the graphics device to finalize the PDF\ndev.off()\n四种subtype的percentage/frequence\nPercentage/frequency of four subtypes\n# 创建PDF文件，设置宽度15英寸、高度12英寸\n# Create PDF file with specified width and height\npdf(\"cnv.frequence.pdf\", 15, 12)\n\n# 设置绘图布局为4行1列，调整边距\n# Set plot layout to 4 rows and 1 column, adjust margins\npar(mfrow=c(4,1), mar = par()$mar + c(3,0,0,3))\n\n\n### ESCC亚型分析 ###\n### ESCC subtype analysis ###\n\n# 读取ESCC的GISTIC评分数据\n# Read GISTIC score data for ESCC\nscores <- read.table(\n  \"easy_input_ESCC.scores.gistic.txt\",  # 输入文件路径\n  # Input file path\n  sep=\"\\t\",                             # 分隔符为制表符\n  # Tab separator\n  header=T,                             # 包含表头\n  # Include header row\n  stringsAsFactors = F                  # 不将字符串转换为因子\n  # Do not convert strings to factors\n)\n\n# 关键步骤：转换染色体编号为标准格式并映射到基因组坐标\n# Important step: Convert chromosome numbers to standard format and map to genomic coordinates\nscores[scores$Chromosome==23, \"Chromosome\"] <- \"X\"  # 将23号染色体重命名为X\n# Rename chromosome 23 to X\nscores[scores$Chromosome==24, \"Chromosome\"] <- \"Y\"  # 将24号染色体重命名为Y\n# Rename chromosome 24 to Y\nchrID <- unname(unlist(chrom$chrom2chr[as.character(paste0(\"chr\", scores$Chromosome))]))  # 获取染色体内部编号\n# Get internal chromosome IDs\nscores$Start.geno <- scores$Start + chrom$chromosomes$chr.length.cumsum[chrID]  # 转换起始位置为基因组坐标\n# Convert start positions to genomic coordinates\nscores$End.geno <- scores$End + chrom$chromosomes$chr.length.cumsum[chrID]      # 转换终止位置为基因组坐标\n# Convert end positions to genomic coordinates\n\n# 准备绘图数据：分离扩增和缺失数据，并将频率转换为百分比\n# Prepare plotting data: Separate amplification and deletion data, convert frequency to percentage\nscores.amp <- scores[scores$Type==\"Amp\", ]  # 提取扩增数据\n# Extract amplification data\nscores.amp$frequency <- scores.amp$frequency * 100  # 扩增频率转换为百分比（正值）\n# Convert amplification frequency to percentage (positive values)\nscores.del <- scores[scores$Type==\"Del\", ]  # 提取缺失数据\n# Extract deletion data\nscores.del$frequency <- scores.del$frequency * -100  # 缺失频率转换为负百分比\n# Convert deletion frequency to negative percentage\nscores <- rbind.data.frame(scores.amp, scores.del)  # 合并数据\n# Combine data\n\n# 设置Y轴范围和标题\n# Set Y-axis range and plot title\nylim <- c(min(scores$frequency) - 0.1, max(scores$frequency) + 0.1)  # 扩展Y轴范围\n# Expand Y-axis range\ntitle <- paste0(\"ESCC, n=\", length(ESCC_id))  # 标题包含样本数\n# Title including sample count\n\n# 绘制ESCC拷贝数变异频率图\n# Plot ESCC copy number variation frequency\nplot(\n  scores.amp$Start.geno,       # X轴：基因组起始位置\n  # X-axis: Genomic start positions\n  scores.amp$frequency,        # Y轴：扩增频率百分比\n  # Y-axis: Amplification frequency percentage\n  pch = \".\",                   # 点形状为像素点\n  # Point shape as pixel\n  type='h',                    # 绘制垂直线\n  # Plot vertical lines\n  cex = 2,                     # 点大小\n  # Point size\n  xaxs = \"i\",                  # X轴范围严格匹配数据\n  # X-axis range strictly match data\n  yaxs = \"i\",                  # Y轴范围严格匹配数据\n  # Y-axis range strictly match data\n  xlim = c(0, chrom$genome.length),  # X轴范围：整个基因组长度\n  # X-axis range: Full genome length\n  ylim = ylim,                 # Y轴范围\n  # Y-axis range\n  main = title,                # 主标题\n  # Main title\n  cex.main = 2,                # 标题字体大小\n  # Title font size\n  ylab = \"Frequency\",          # Y轴标签：频率\n  # Y-axis label: Frequency\n  xlab = NA,                   # 不显示X轴标签\n  # No X-axis label\n  cex.lab = 2,                 # 标签字体大小\n  # Label font size\n  col = adjustcolor(\"darkred\", alpha.f = .8),  # 颜色：半透明深红色（扩增）\n  # Color: Semi-transparent dark red (amplification)\n  xaxt = \"n\",                  # 不显示X轴刻度\n  # No X-axis ticks\n  lwd = 2,                     # 线宽\n  # Line width\n  las=1                        # Y轴标签水平显示\n  # Y-axis labels horizontal\n)\nlines(\n  scores.del$Start.geno,       # X轴：缺失数据起始位置\n  # X-axis: Deletion start positions\n  scores.del$frequency,        # Y轴：缺失频率百分比（负值）\n  # Y-axis: Deletion frequency percentage (negative values)\n  type='h',                    # 绘制垂直线\n  # Plot vertical lines\n  lwd = 2,                     # 线宽\n  # Line width\n  col = adjustcolor(\"midnightblue\", alpha.f = .8)  # 颜色：半透明深蓝色（缺失）\n  # Color: Semi-transparent midnight blue (deletion)\n)\n\n# 标记染色体位置\n# Mark chromosome positions\nink <- chrom$chromosomes$chrN %in% chrID  # 筛选存在的染色体\n# Filter existing chromosomes\nyrange <- abs(diff(ylim))  # Y轴范围差值\n# Y-axis range difference\nm.pos <- c(ylim[1] + 10, ylim[2] - 10)  # 标签Y坐标（上下交替）\n# Label Y-coordinates (alternating top and bottom)\nm.mod <- -(chrom$chromosomes$chrN[ink] %% 2) + 2  # 计算交替位置索引\n# Calculate alternating position index\ntry(text(\n  x = chrom$chromosomes$middle.chr.geno[ink],  # X坐标：染色体中点基因组位置\n  # X-coordinates: Chromosome midpoint genomic positions\n  y = m.pos[m.mod],                            # Y坐标：交替位置\n  # Y-coordinates: Alternating positions\n  labels = chrom$chromosomes$chrom[ink],       # 标签：染色体名称\n  # Labels: Chromosome names\n  cex = 1                                      # 字体大小\n  # Font size\n))\n\n# 添加参考线\n# Add reference lines\nabline(h = 0.0, col = 1, lwd = 1, lty = 3)  # 水平参考线（y=0）\n# Horizontal reference line (y=0)\nabline(v = c(0, chrom$chromosomes$chr.length.sum), col = 1, lty = 3, lwd = 1)  # 染色体边界垂直线\n# Vertical lines at chromosome boundaries\n\n# 添加图例\n# Add legend\ncol1 <- adjustcolor(\"darkred\", alpha.f = .8)  # 扩增颜色\n# Amplification color\ncol2 <- adjustcolor(\"midnightblue\", alpha.f = .8)  # 缺失颜色\n# Deletion color\nlegend(\n  \"topleft\",              # 图例位置：左上角\n  # Legend position: Top-left\n  c(\"gain\", \"loss\"),      # 图例标签\n  # Legend labels\n  cex=0.6,                # 字体大小\n  # Font size\n  bty=\"n\",                # 无边框\n  # No border\n  fill=c(col1, col2)      # 填充颜色\n  # Fill colors\n)\n\n\n### EAC亚型分析 ###\n### EAC subtype analysis ###\n\n# 读取EAC的GISTIC评分数据（后续步骤与ESCC类似）\n# Read GISTIC score data for EAC (subsequent steps similar to ESCC)\nscores <- read.table(\"easy_input_EAC.scores.gistic.txt\", sep=\"\\t\", header=T, stringsAsFactors = F)\n\n# 染色体编号转换和基因组坐标映射\n# Chromosome number conversion and genomic coordinate mapping\nscores[scores$Chromosome==23, \"Chromosome\"] <- \"X\"\nscores[scores$Chromosome==24, \"Chromosome\"] <- \"Y\"\nchrID <- unname(unlist(chrom$chrom2chr[as.character(paste0(\"chr\", scores$Chromosome))]))\nscores$Start.geno <- scores$Start + chrom$chromosomes$chr.length.cumsum[chrID]\nscores$End.geno <- scores$End + chrom$chromosomes$chr.length.cumsum[chrID]\n\n# 数据准备：频率转换为百分比\n# Data preparation: Convert frequency to percentage\nscores.amp <- scores[scores$Type==\"Amp\", ]\nscores.amp$frequency <- scores.amp$frequency * 100\nscores.del <- scores[scores$Type==\"Del\", ]\nscores.del$frequency <- scores.del$frequency * -100\nscores <- rbind.data.frame(scores.amp, scores.del)\n\n# 设置Y轴范围和标题\n# Set Y-axis range and title\nylim <- c(min(scores$frequency) - 0.1, max(scores$frequency) + 0.1)\ntitle <- paste0(\"EAC, n=\", length(EAC_id))\n\n# 绘制EAC拷贝数变异频率图\n# Plot EAC copy number variation frequency\nplot(\n  scores.amp$Start.geno, \n  scores.amp$frequency,\n  pch = \".\", type='h', cex = 2, xaxs = \"i\", yaxs = \"i\", \n  xlim = c(0, chrom$genome.length), ylim = ylim,\n  main = title, cex.main = 2, ylab = \"Frequency\", xlab = NA,\n  cex.lab = 2, col = adjustcolor(\"darkred\", alpha.f = .8), xaxt = \"n\", lwd = 2, las=1\n)\nlines(scores.del$Start.geno, scores.del$frequency, type='h', lwd = 2, col = adjustcolor(\"midnightblue\", alpha.f = .8))\n\n# 标记染色体位置和添加参考线\n# Mark chromosome positions and add reference lines\nink <- chrom$chromosomes$chrN %in% chrID\nyrange = abs(diff(ylim))\nm.pos <- c(ylim[1] + 10, ylim[2] - 10)\nm.mod <- -(chrom$chromosomes$chrN[ink] %% 2) + 2\ntry(text(x = chrom$chromosomes$middle.chr.geno[ink], y = m.pos[m.mod], labels = chrom$chromosomes$chrom[ink], cex = 1))\nabline(h = 0.0, col = 1, lwd = 1, lty = 3)\nabline(v = c(0, chrom$chromosomes$chr.length.sum), col = 1, lty = 3, lwd = 1)\n\n# 添加图例\n# Add legend\ncol1 <- adjustcolor(\"darkred\", alpha.f = .8)\ncol2 <- adjustcolor(\"midnightblue\", alpha.f = .8)\nlegend(\"topleft\", c(\"gain\", \"loss\"), cex=0.6, bty=\"n\", fill=c(col1, col2))\n\n\n### GA_CIN亚型分析 ###\n### GA_CIN subtype analysis ###\n\n# 读取GA_CIN的GISTIC评分数据（后续步骤与ESCC类似）\n# Read GISTIC score data for GA_CIN (subsequent steps similar to ESCC)\nscores <- read.table(\"easy_input_GA_CIN.scores.gistic.txt\", sep=\"\\t\", header=T, stringsAsFactors = F)\n\n# 染色体编号转换和基因组坐标映射\n# Chromosome number conversion and genomic coordinate mapping\nscores[scores$Chromosome==23, \"Chromosome\"] <- \"X\"\nscores[scores$Chromosome==24, \"Chromosome\"] <- \"Y\"\nchrID <- unname(unlist(chrom$chrom2chr[as.character(paste0(\"chr\", scores$Chromosome))]))\nscores$Start.geno <- scores$Start + chrom$chromosomes$chr.length.cumsum[chrID]\nscores$End.geno <- scores$End + chrom$chromosomes$chr.length.cumsum[chrID]\n\n# 数据准备：频率转换为百分比\n# Data preparation: Convert frequency to percentage\nscores.amp <- scores[scores$Type==\"Amp\", ]\nscores.amp$frequency <- scores.amp$frequency * 100\nscores.del <- scores[scores$Type==\"Del\", ]\nscores.del$frequency <- scores.del$frequency * -100\nscores <- rbind.data.frame(scores.amp, scores.del)\n\n# 设置Y轴范围和标题\n# Set Y-axis range and title\nylim <- c(min(scores$frequency) - 0.1, max(scores$frequency) + 0.1)\ntitle <- paste0(\"GA_CIN, n=\", length(GA_CIN_id))\n\n# 绘制GA_CIN拷贝数变异频率图\n# Plot GA_CIN copy number variation frequency\nplot(\n  scores.amp$Start.geno, \n  scores.amp$frequency,\n  pch = \".\", type='h', cex = 2, xaxs = \"i\", yaxs = \"i\", \n  xlim = c(0, chrom$genome.length), ylim = ylim,\n  main = title, cex.main = 2, ylab = \"Frequency\", xlab = NA,\n  cex.lab = 2, col = adjustcolor(\"darkred\", alpha.f = .8), xaxt = \"n\", lwd = 2, las=1\n)\nlines(scores.del$Start.geno, scores.del$frequency, type='h', lwd = 2, col = adjustcolor(\"midnightblue\", alpha.f = .8))\n\n# 标记染色体位置和添加参考线\n# Mark chromosome positions and add reference lines\nink <- chrom$chromosomes$chrN %in% chrID\nyrange = abs(diff(ylim))\nm.pos <- c(ylim[1] + 10, ylim[2] - 10)\nm.mod <- -(chrom$chromosomes$chrN[ink] %% 2) + 2\ntry(text(x = chrom$chromosomes$middle.chr.geno[ink], y = m.pos[m.mod], labels = chrom$chromosomes$chrom[ink], cex = 1))\nabline(h = 0.0, col = 1, lwd = 1, lty = 3)\nabline(v = c(0, chrom$chromosomes$chr.length.sum), col = 1, lty = 3, lwd = 1)\n\n# 添加图例\n# Add legend\ncol1 <- adjustcolor(\"darkred\", alpha.f = .8)\ncol2 <- adjustcolor(\"midnightblue\", alpha.f = .8)\nlegend(\"topleft\", c(\"gain\", \"loss\"), cex=0.6, bty=\"n\", fill=c(col1, col2))\n\n\n### GA_nonCIN亚型分析 ###\n### GA_nonCIN subtype analysis ###\n\n# 读取GA_nonCIN的GISTIC评分数据（后续步骤与ESCC类似）\n# Read GISTIC score data for GA_nonCIN (subsequent steps similar to ESCC)\nscores <- read.table(\"easy_input_GA_nonCIN.scores.gistic.txt\", sep=\"\\t\", header=T, stringsAsFactors = F)\n\n# 染色体编号转换和基因组坐标映射\n# Chromosome number conversion and genomic coordinate mapping\nscores[scores$Chromosome==23, \"Chromosome\"] <- \"X\"\nscores[scores$Chromosome==24, \"Chromosome\"] <- \"Y\"\nchrID <- unname(unlist(chrom$chrom2chr[as.character(paste0(\"chr\", scores$Chromosome))]))\nscores$Start.geno <- scores$Start + chrom$chromosomes$chr.length.cumsum[chrID]\nscores$End.geno <- scores$End + chrom$chromosomes$chr.length.cumsum[chrID]\n\n# 数据准备：频率转换为百分比\n# Data preparation: Convert frequency to percentage\nscores.amp <- scores[scores$Type==\"Amp\", ]\nscores.amp$frequency <- scores.amp$frequency * 100\nscores.del <- scores[scores$Type==\"Del\", ]\nscores.del$frequency <- scores.del$frequency * -100\nscores <- rbind.data.frame(scores.amp, scores.del)\n\n# 设置Y轴范围和标题\n# Set Y-axis range and title\nylim <- c(min(scores$frequency) - 0.1, max(scores$frequency) + 0.1)\ntitle <- paste0(\"GA_nonCIN, n=\", length(GA_nonCIN_id))\n\n# 绘制GA_nonCIN拷贝数变异频率图\n# Plot GA_nonCIN copy number variation frequency\nplot(\n  scores.amp$Start.geno, \n  scores.amp$frequency,\n  pch = \".\", type='h', cex = 2, xaxs = \"i\", yaxs = \"i\", \n  xlim = c(0, chrom$genome.length), ylim = ylim,\n  main = title, cex.main = 2, ylab = \"Frequency\", xlab = NA,\n  cex.lab = 2, col = adjustcolor(\"darkred\", alpha.f = .8), xaxt = \"n\", lwd = 2, las=1\n)\nlines(scores.del$Start.geno, scores.del$frequency, type='h', lwd = 2, col = adjustcolor(\"midnightblue\", alpha.f = .8))\n\n# 标记染色体位置和添加参考线\n# Mark chromosome positions and add reference lines\nink <- chrom$chromosomes$chrN %in% chrID\nyrange = abs(diff(ylim))\nm.pos <- c(ylim[1] + 10, ylim[2] - 10)\nm.mod <- -(chrom$chromosomes$chrN[ink] %% 2) + 2\ntry(text(x = chrom$chromosomes$middle.chr.geno[ink], y = m.pos[m.mod], labels = chrom$chromosomes$chrom[ink], cex = 1))\nabline(h = 0.0, col = 1, lwd = 1, lty = 3)\nabline(v = c(0, chrom$chromosomes$chr.length.sum), col = 1, lty = 3, lwd = 1)\n\n# 添加图例\n# Add legend\ncol1 <- adjustcolor(\"darkred\", alpha.f = .8)\ncol2 <- adjustcolor(\"midnightblue\", alpha.f = .8)\nlegend(\"topleft\", c(\"gain\", \"loss\"), cex=0.6, bty=\"n\", fill=c(col1, col2))\n\n# 关闭PDF设备，完成绘图\n# Close PDF device to finalize plotting\ndev.off()\n附一：hg38版本的CNV segment，可通过TCGAbiolinks下载\n##Attachment 1: The CNV segment of hg38 version can be downloaded\nthrough TCGAbiolinks\nlibrary(TCGAbiolinks)\nquery <- GDCquery(project = \"TCGA-ESCA\", \n                  data.category = \"Copy Number Variation\",\n                  data.type = \"Copy Number Segment\",\n                  sample.type = c(\"Primary solid Tumor\",\"Solid Tissue Normal\"))\nGDCdownload(query,method = \"api\")\ntumor.cnv <- GDCprepare(query = query, save = TRUE, save.filename = \"tumorCNV.rda\")\n附二：GISTIC 2.0用法\n##Attachment 2: Usage of GISTIC 2.0\nTo generate discrete copy number data file you may need to run GISTIC\n2.0. GISTIC 2.0 can be [installed]\nhttp://www.broadinstitute.org/cgi-bin/cancer/publications/pub_paper.cgi?mode=view&paper_id=216&p=t\nor run online using the GISTIC 2.0 module on [GenePattern]\nhttps://cloud.genepattern.org/\n. Running GISTIC 2.0\nrequires two input files:\nA segmentation file, which contains the segmented data\nA marker file, which identifies the marker names and positions of\nthe markers in the original dataset (before segmentation).\n出自：\nhttps://cbioportal.readthedocs.io/en/latest/Data-Loading-Tips-and-Best-Practices.html\nGISTIC2.0在线版根据说明点鼠标即可\n###GISTIC2.0 online version can be clicked with the mouse according\nto the instructions\nIn linux system run GISTIC2\nsource /etc/profile\nsource /etc/profile.d/modules.sh\n\nmodule add impi/5.1.3\nmodule add intel/16.0.3\nmodule add java/1.8.0_91\n\n#mpirun -np 48 /share/apps/vasp/5.4.1/intel/16.0.2/bin/vasp_std\n\necho --- creating output directory --- \nbasedir=`pwd`/esca.basal.seg #esca.luma.seg \nmkdir -p $basedir\necho --- running GISTIC ---\n\n## input file definitions\n\nsegfile=`pwd`/esca.basal.seg.cnv.txt #esca.luma.seg.cnv.txt\nrefgenefile=`pwd`/refgenefiles/hg19.UCSC.add_miR.140312.refgene.mat\n\n## call script that sets MCR environment and calls GISTIC executable\n\n./gistic2 -b $basedir -seg $segfile -refgene $refgenefile -genegistic 1 -smallmem 1 -broad 1 -brlen 0.5 -conf 0.95 -armpeel 1 -savegene 1 -gcm extreme\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa79CNV_FigureYa79CNV",
      "title": "FigureYa79CNV/FigureYa79CNV.html",
      "html": "FigureYa79CNV/FigureYa79CNV.html",
      "text": "texts/main_FigureYa79CNV_FigureYa79CNV.txt",
      "folder": "FigureYa79CNV",
      "thumb": "gallery_compress/FigureYa79CNV.webp"
    },
    "word_count": 5959,
    "lines_count": 1263,
    "title": "FigureYa79CNV",
    "description": "我要DIY出paper里的这种对比多个subtype的composite copy number profiles： Requirement description",
    "input_data_types": [
      "临床数据",
      "DNA-seq"
    ],
    "output_types": [
      "统计表格"
    ],
    "technical_methods": [
      "标准化"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "chrN",
      "header",
      "gain",
      "lwd",
      "chrom",
      "ylim",
      "xlim",
      "genomebuild",
      "yaxs"
    ]
  },
  {
    "id": "main_FigureYa189timeCindex_FigureYa189timeCindex",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa189timeCindex_FigureYa189timeCindex.txt",
    "content": "FigureYa189timeCindex\nFigureYa189timeCindex\nAuthor(s)\n: Xiaofan Lu\nReviewer(s)\n: Ying Ge, Junyi Shen\nDate\n: 2025-09-22\nAcademic Citation\nIf you use this code in your work or research, we kindly request that\nyou cite our publication:\nXiaofan Lu, et al. (2025). FigureYa: A Standardized Visualization\nFramework for Enhancing Biomedical Data Interpretation and Research\nEfficiency. iMetaMed.\nhttps://doi.org/10.1002/imm3.70005\n需求描述\nRequirement\nFigureYa85timeAUC是时间依赖的auc曲线，我想要时间依赖的c-index，没法用之前的包画。\nFigureYa85timeAUC is a time-dependent auc curve. I want a time-dependent\nc-index, which cannot be drawn using the previous package.\n出自\nhttps://doi.org/10.1007/s12035-018-1416-y\nfromhttps://doi.org/10.1007/s12035-018-1416-y\nFig. 5 Performance evaluation of the 8 lncRNA-based risk score. d\nConcordance index showing measure of concordance of predictor with\nsurvival of patients in TCGA\nUVA8 outperforms all existing lncRNA-based survival models at\ndifferent times after diagnosis (Fig. 5d). As expected, prognostic\nsignatures that were specific to GBMs (Zhang6_2013 and Zhou6_2017) show\npoor concordance index when used to predict survival of lower grade\nglioma patients.\n应用场景\nApplication Scenarios\n时间依赖性C-index，评价不同模型的一致性指数。 Time-dependent C-index,\nevaluating the consistency index of different models.\n环境设置\nEnvironment Setup\nsource(\"install_dependencies.R\")\nlibrary(survival)\nlibrary(pec)\nSys.setenv(LANGUAGE = \"en\") #显示英文报错信息  # Display an English error message\noptions(stringsAsFactors = FALSE) #禁止chr转成factor  # prohibit chr from being converted to factor\n输入文件\nInput File\neasy_input.csv，包括由多变量Cox +\nLASSO惩罚得到的riskscore，以及两个临床变量（age、stage），还有time-to-event数据。跟FigureYa187RMS的easy_input.csv是同一个文件。\neasy_input.csv includes riskscore obtained from multivariate Cox + LASSO\npenalties, as well as two clinical variables (age, stage), and\ntime-to-event data. It is the same file as easy_input.csv of\nFigureYa187RMS.\ndat <- read.csv(\"easy_input.csv\", row.names = 1,header = T,check.names = F,stringsAsFactors = F)\ndat <- as.data.frame(na.omit(dat)) # 移除数据空值  # Remove data null values\ndat$OS.time <- dat$OS.time/365 # 将时间转化为以年为单位   # converts time to years\nhead(dat)\n构建模型用于time-dependent c-index的比较\nBuild a model for the comparison of time-dependent c-index\n这里利用cox比例风险构建几种预后模型。可以替换成其他模型。 Here,\nseveral prognostic models are constructed using cox proportional\nhazards. It can be replaced with other models.\ncox1 <- coxph(Surv(OS.time,OS)~Riskscore,data = dat,x=TRUE,y=TRUE) # 第一个模型仅考虑风险得分  # The first model only considers the risk score\ncox2 <- coxph(Surv(OS.time,OS)~Age,data = dat,x=TRUE,y=TRUE) # 第二个模型仅考虑年龄  # The second model only considers age\ncox3 <- coxph(Surv(OS.time,OS)~Stage,data = dat,x=TRUE,y=TRUE) # 第三个模型仅考虑分期  # The third model only considers staging\ncox4 <- coxph(Surv(OS.time,OS)~Age + Stage,data = dat,x=TRUE,y=TRUE) # 第四个模型综合考虑年龄和分期   # The fourth model takes age and stage into comprehensive consideration\ncox5 <- coxph(Surv(OS.time,OS)~Riskscore + Age,data = dat,x=TRUE,y=TRUE) # 第五个模型综合考虑得分和年龄   # The fifth model takes into account both score and age\ncox6 <- coxph(Surv(OS.time,OS)~Riskscore + Age + Stage,data = dat,x=TRUE,y=TRUE) # 第六个模型综合考虑所有变量  # The sixth model takes all variables into comprehensive consideration\n\n# 创建公式（也可直接在算法里使用\".\"代表全部变量）\n# Create Formulas (You can also directly use \".\" to represent all variables in the algorithm)\n# lhs = \"Surv(OS.time, OS)\"\n# rhs = paste(setdiff(colnames(dat),c(\"OS\",\"OS.time\")),collapse = \"+\")\n# form = as.formula(paste(lhs, \"~\", rhs))\n\n# 设置种子以便结果可重复\n# Set seeds to make the results repeatable\nset.seed(123456) \n\n# 每一次cindex评估的时间点，越密集曲线越平滑，这里按每0.5年为一步长\n# For each C-Index assessment, the denser the time point, the smoother the curve. Here, the step size is set at every 0.5 years\neval.time <- seq(1,floor(max(dat$OS.time)),0.5) \n\n# 创建算法需要的对象，命名可以按照自己习惯的方式，或者后期AI调整也很方便\n# When creating the objects required by the algorithm, you can name them in the way you are accustomed to, or it is also very convenient for the AI to make adjustments later\nobj <- list(\"cox1\"=cox1,\n            \"cox2\"=cox2,\n            \"cox3\"=cox3,\n            \"cox4\"=cox4,\n            \"cox5\"=cox5,\n            \"cox6\"=cox6)\n\ntimeC <- pec::cindex(object = obj,\n                      #formula=form,\n                      formula=Surv(OS.time,OS)~.,\n                      data=dat,\n                      eval.times=eval.time, \n                      splitMethod = \"BootCv\") # 使用bootstrap cross validation法计算（注意设置种子）  # Calculate using the bootstrap cross validation method (Note to set the seed)\n# 提出time-dependent Cindex结果\n# Present the time-dependent Cindex results\ntimeC.mat <- do.call(cbind,timeC$BootCvCindex) \n# 输出每个变量的Cindex的值\n# Output the value of the Cindex for each variable\nwrite.csv(timeC.mat, \"output_cindex.csv\", quote = F, row.names = eval.time)\n开始画图\nStart drawing\n# 获取cindex的最小值作为y轴的下界\n# Obtain the minimum value of the c-index as the lower bound of the Y-axis\nymin <- min(timeC.mat) \n\n# 如果想用调色板，下面这行代码比较方便\n# If you want to use a color palette, the following line of code is quite convenient\nmycol <- RColorBrewer::brewer.pal(n = ncol(timeC.mat), name = 'Set2')\n# 如果想自定义颜色，要自己设置足够多的颜色，如例文颜色\n# If you want to customize colors, you need to set enough colors yourself, such as the colors in the example text\nmycol <- c(\"#DFDFDF\", \"#999999\", \"#FDD7C2\", \"#ED7F54\", \"#C04658\", \"#050505\")\n\npdf(\"time-dependent Cindex.pdf\",width = 6,height = 5.5)\npar(bty=\"l\", #如果想要例文那样坐标轴分开的，就把l改为n  #If you want the coordinate axes to be separated like in the example, change l to n\n    mgp = c(1.9,.33,0), mar=c(4.1,4.1,2.1,2.1)+.1, las=1, tcl=-.25) # 基础画板设置  #based panel Settings\n\n# 循环绘制折线\n# Loop to draw broken lines\nfor (i in 1:ncol(timeC.mat)) { \n  if(i == 1){ # 当绘制第一根cindex折线时plot完整画布  # plot the entire canvas when the first C-index line is drawn\n    plot(eval.time,timeC.mat[,i],\n         type=\"l\",\n         col = mycol[i],\n         lwd = 2,\n         ylim = c(ymin,1),xlim = range(dat$OS.time),\n         xaxt = \"n\",\n         xlab=\"Time (Years)\",ylab = \"Concordance index\")\n    axis(side = 1,\n         at = seq(0,max(eval.time),1),\n         labels = seq(0,max(eval.time),1))\n  } else { # 随后添加折线  # Then add a broken line\n    lines(eval.time,timeC.mat[,i],\n          col = mycol[i],\n          lwd = 2)\n  }\n}\n# 例文在0.5处画了阈值线，因为0.5为“猜测”线\n# The example text draws a threshold line at 0.5 because 0.5 is a \"guess\" line\n# if(ymin < 0.5) {abline(h = 0.5,lty = 4,col = \"grey50\",lwd = 2)} # 如果cindex矩阵中最小值小于0.5，则绘制y=0.5处的虚线为阈值  # If the minimum value in the C-index matrix is less than 0.5, draw the dotted line at y=0.5 as the threshold\n\n# 个人建议以0.6为阈值，因为cindex认为有效的最低阈值为0.6\n# My personal suggestion is to set the threshold at 0.6, as the minimum threshold that the cindex considers effective is 0.6\nif(ymin < 0.6) {abline(h = 0.6,lty = 4,col = \"grey50\",lwd = 2)} # 如果cindex矩阵中最小值小于0.5，则绘制y=0.5处的虚线为阈值  # If the minimum value in the C-index matrix is less than 0.5, draw the dotted line at y=0.5 as the threshold\n\n# 绘制图例\n# Draw Legends\nlegend(\"topright\", # 图例位于右上角  #The legend is located in the upper right corner\n       legend = colnames(timeC.mat),\n       col = mycol,\n       lty = 1,\n       lwd = 2,\n       y.intersp = 1, x.intersp = 0.5, # 各行图例的间距细节  # spacing details of each row legend\n       bty = \"o\") # 图例保留边框  # The legend retains the border\ninvisible(dev.off()) # 关闭图像句柄  # Closes the image handle\nSession Info\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa189timeCindex_FigureYa189timeCindex",
      "title": "FigureYa189timeCindex/FigureYa189timeCindex.html",
      "html": "FigureYa189timeCindex/FigureYa189timeCindex.html",
      "text": "texts/main_FigureYa189timeCindex_FigureYa189timeCindex.txt",
      "folder": "FigureYa189timeCindex",
      "thumb": "gallery_compress/FigureYa189timeCindex.webp"
    },
    "word_count": 947,
    "lines_count": 158,
    "title": "FigureYa189timeCindex",
    "description": "Requirement FigureYa85timeAUC是时间依赖的auc曲线，我想要时间依赖的c-index，没法用之前的包画。 FigureYa85timeAUC is a time-dependent auc curve. I want a time-dependent",
    "input_data_types": [
      "临床数据",
      "生存数据"
    ],
    "output_types": [
      "统计表格",
      "生存曲线"
    ],
    "technical_methods": [
      "生存分析"
    ],
    "biology_areas": [],
    "complexity_level": "高级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "intersp",
      "times",
      "header",
      "lwd",
      "则绘制y",
      "width",
      "ylim",
      "n",
      "xlim"
    ]
  },
  {
    "id": "main_FigureYa110mutationSignature_FigureYa110mutationSignature",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa110mutationSignature_FigureYa110mutationSignature.txt",
    "content": "FigureYa110mutationSignature\nFigureYa110mutationSignature\nXiaofan Lu, Taojun Ye\n2025-5-20\n需求描述\n画出文章里的3个热图：\n##Requirement description\nDraw three heat maps from the article:\n出自\nhttps://academic.oup.com/annonc/article/28/7/1597/3611460\nfrom\nhttps://academic.oup.com/annonc/article/28/7/1597/3611460\n应用场景\n利用deconstructsigs计算突变签名模式，NMF做聚类分析，寻找亚型驱动签名，并绘制热图。\n注意：若使用本众筹分析流程，请引用：\nAlexandrov LB, Nik-Zainal S, Wedge DC, Aparicio SA, Behjati S,\nBiankin AV, et al. Signatures of mutational processes in human cancer.\nNature 2013;500(7463):415.\nRosenthal R, McGranahan N, Herrero J, Taylor BS, Swanton C.\nDeconstructSigs: delineating mutational processes in single tumors\ndistinguishes DNA repair deficiencies and patterns of carcinoma\nevolution. Genome biology 2016;17(1):31.\nGaujoux R , Seoighe C . A flexible R package for nonnegative matrix\nfactorization[J]. BMC Bioinformatics, 2010, 11(1):367.\n##Application scenarios\nUsing decortructsigs to calculate mutation signature patterns, NMF\nperforms clustering analysis to find subtype driven signatures, and\ndraws a heatmap.\nAttention: If using this crowdfunding analysis process,\nplease cite:\nAlexandrov LB, Nik-Zainal S, Wedge DC, Aparicio SA, Behjati S,\nBiankin AV, et al. Signatures of mutational processes in human cancer.\nNature 2013; 500(7463):415.\nRosenthal R, McGranahan N, Herrero J, Taylor BS, Swanton C.\nDeconstructSigs: delineating mutational processes in single tumors\ndistinguishes DNA repair deficiencies and patterns of carcinoma\nevolution. Genome biology 2016; 17(1):31.\nGaujoux R , Seoighe C . A flexible R package for nonnegative matrix\nfactorization[J]. BMC Bioinformatics, 2010, 11(1):367.\n环境设置\n使用国内镜像安装包\n##Environment settings\nUse domestic image installation package\noptions(\"repos\"= c(CRAN=\"https://mirrors.tuna.tsinghua.edu.cn/CRAN/\"))\noptions(BioC_mirror=\"http://mirrors.ustc.edu.cn/bioc/\")\nBiocManager::install(\"BSgenome\")\nBiocManager::install(\"BSgenome.Hsapiens.UCSC.hg19\")\nBiocManager::install(\"GenomeInfoDb\")\ndeconstructsigs的安装：从github下载\nhttps://github.com/raerose01/deconstructSigs\n，解压缩，然后压缩为.tar.gz格式，本地安装。\nInstallation of decorstructsigs: Download from GitHub<\nhttps://github.com/raerose01/deconstructSigs\n>Extract\nand compress to. tar.gz format for local installation.\ntar -czvf deconstructSigs.tar.gz deconstructSigs-master\n加载包\nlibrary packages\n# 加载数据分析常用工具包\n# Load commonly used data analysis toolkits\nlibrary(tidyverse)\n# 管道操作符包\n# Pipe operator package\nlibrary(magrittr)\n# Excel文件读取包\n# Excel file reading package\nlibrary(readxl)\n# 字符串处理包\n# String processing package\nlibrary(stringr)\n# 因子处理包\n# Factor processing package\nlibrary(forcats)\n# 突变特征分析包\n# Mutation signature analysis package\nlibrary(deconstructSigs)\n# 人类基因组参考包（hg19）\n# Human genome reference package (hg19)\nlibrary(BSgenome.Hsapiens.UCSC.hg19)\n# 非负矩阵分解包\n# Non-negative matrix factorization package\nlibrary(NMF)\n# 设置环境变量使R显示英文错误信息\n# Set environment variable to display R error messages in English\nSys.setenv(LANGUAGE = \"en\") \n# 禁止将字符串自动转换为因子类型\n# Disable automatic conversion of strings to factors\noptions(stringsAsFactors = FALSE)\n输入文件\nblca.mut.maf.txt，基因突变数据。\n##Input file\nblca.mut.maf.txt， Genetic mutation data.\n# 将tibble格式转换为传统data.frame格式\n# Convert tibble format to traditional data.frame format\nmaf <- as.data.frame(maf)\n开始画图\nstart plot\n# 定义保存突变特征细节图的文件夹路径\n# Define folder path to save mutation signature detail plots\nfig.path <- \"Figures\" \n# 若指定文件夹不存在则创建\n# Create the directory if it does not exist\nif (!file.exists(fig.path)) { dir.create(fig.path) }\n\n# 设置绘图配色方案（JCO期刊风格）\n# Set color palette (Journal of Clinical Oncology style)\n# 蓝色、金色、红色、灰色\n# Blue, Gold, Red, Gray\njco <- c(\"#2874C5\",\"#EABF00\",\"#C6524A\",\"#868686\")\n计算96种三核苷酸变化\n###Calculate 96 types of trinucleotide changes###\n# 是否移除沉默突变（可根据实际需求移除其他SNP类型）\n# Whether to remove silent mutations (other SNP types can also be removed based on requirements)\n# 移除则改为T（默认保留）\n# Set to T to remove silent mutations (default: retain)\nrmSilence = F \n\n# 根据rmSilence参数过滤突变数据\n# Filter mutation data based on rmSilence parameter\nif (rmSilence) {\n  # 仅保留SNP且移除沉默突变\n  # Keep only SNPs and remove silent mutations\n  maf <- as.data.frame(maf[which(maf$Variant_Type == \"SNP\" & maf$Variant_Classification != \"Silent\"),]) \n} else {\n  # 仅保留SNP类型突变（突变特征分析通常只考虑SNP）\n  # Keep only SNPs (mutation signature analysis typically focuses on SNPs)\n  maf <- as.data.frame(maf[which(maf$Variant_Type == \"SNP\"),]) \n}\n\n# 确保染色体名称格式符合deconstructSigs包要求（添加\"chr\"前缀）\n# Ensure chromosome names match deconstructSigs input format (add \"chr\" prefix)\nmaf$Chromosome <- paste0(\"chr\",maf$Chromosome) \n\n# 转换突变数据为突变特征分析所需的输入格式\n# Convert mutation data to input format required by deconstructSigs\nsnp.count <- mut.to.sigs.input(\n  mut.ref = maf,                      # 输入的MAF格式突变数据框\n                                      # Input MAF format mutation dataframe\n  sample.id = \"Tumor_Sample_Barcode\", # 样本ID列名\n                                      # Column name for sample IDs\n  chr = \"Chromosome\",                 # 染色体列名\n                                      # Column name for chromosomes\n  pos = \"Start_Position\",             # 突变起始位置列名\n                                      # Column name for mutation start positions\n  ref = \"Reference_Allele\",           # 参考碱基列名（野生型）\n                                      # Column name for reference alleles (wild-type)\n  alt = \"Tumor_Seq_Allele2\",          # 突变碱基列名（突变型）\n                                      # Column name for alternate alleles (mutated)\n  bsg = BSgenome.Hsapiens.UCSC.hg19  # 指定hg19人类参考基因组\n                                      # Human reference genome (hg19)\n)\n# 将转换后的突变计数矩阵保存为制表符分隔文件\n# Save the converted mutation count matrix as a tab-separated file\nwrite.table(snp.count, \"snp.count.txt\", sep = \"\\t\", row.names = T, col.names = NA)\n计算单样本突变签名的权重\n###Calculate the weight of a single sample mutation signature###\n# 设置突变特征贡献度阈值（默认6%，与参考论文一致）\n# Set threshold for signature contribution (default 6%, consistent with reference paper)\ncut.off <- 0.06 \n\n# 初始化数据结构存储结果\n# Initialize data structures to store results\nmut.wt <- data.frame()           # 存储各样本的突变特征权重矩阵\n                                 # Store signature weight matrix for each sample\nsigs.out.list <- list()          # 存储每个样本的突变特征分析结果\n                                 # Store signature analysis results for each sample\nindex <- 1                       # 计数器，记录当前处理的样本序号\n                                 # Counter for tracking processed samples\n\n# 遍历每个样本进行突变特征分析\n# Iterate through each sample for mutation signature analysis\nfor (sample in rownames(snp.count)) {\n  # 打印进度信息\n  # Print progress information\n  cat(paste0(sample,\" starts and \",length(rownames(snp.count))-index,\" samples remain to be analyzed!\\n\"))\n  \n  # 使用deconstructSigs包的whichSignatures函数进行突变特征分解\n  # Decompose mutation signatures using whichSignatures function from deconstructSigs\n  tmp <- whichSignatures(\n    tumor.ref = snp.count,                   # 输入的突变计数矩阵\n                                             # Input mutation count matrix\n    signatures.ref = signatures.cosmic,      # 参考的突变特征库（COSMIC特征）\n                                             # Reference signature library (COSMIC signatures)\n    sample.id = sample,                      # 当前分析的样本ID\n                                             # ID of the current sample\n    contexts.needed = TRUE,                  # 是否需要计算三核苷酸上下文\n                                             # Whether to calculate trinucleotide context\n    tri.counts.method = 'exome2genome',      # 外显子组数据标准化为全基因组的方法\n                                             # Method to normalize exome data to genome-wide\n    signature.cutoff = cut.off               # 特征贡献度阈值，低于此值的特征将被忽略\n                                             # Threshold for signature contribution\n  )\n  \n  index <- index + 1  # 更新计数器\n  \n  # 输出每个样本的突变特征细节图\n  # Generate and save detailed signature plots for each sample\n  pdf(file.path(fig.path,paste0(sample,\"_plotSignatures.pdf\")))\n  plotSignatures(tmp)                # 绘制特征贡献度柱状图\n                                     # Plot signature contribution bar chart\n  invisible(dev.off())\n  \n  # 输出每个样本的特征权重饼图\n  # Generate and save signature weight pie chart for each sample\n  pdf(file.path(fig.path,paste0(sample,\"_weightPie.pdf\")))\n  makePie(tmp)                       # 绘制特征权重饼图\n                                     # Plot signature weight pie chart\n  invisible(dev.off())\n  \n  # 生成并存储突变特征权重矩阵\n  # Generate and store mutation signature weight matrix\n  sigs.out.list[[sample]] <- tmp     # 保存完整分析结果\n                                     # Save full analysis results\n  tmp <- data.frame(c(tmp$weights,unknown=tmp$unknown),row.names = sample)\n                                     # 提取特征权重和未知成分\n                                     # Extract signature weights and unknown component\n  mut.wt <- rbind.data.frame(mut.wt,tmp)  # 合并到总权重矩阵\n                                          # Merge into overall weight matrix\n}\n# 将突变特征权重矩阵保存到文件\n# Save mutation signature weight matrix to file\nwrite.table(mut.wt, \"mutsig.weightMatrix.txt\", sep = \"\\t\", row.names = T, col.names = NA)\n非负矩阵分解识别驱动性signature并绘图\n###Non negative matrix factorization for identifying driving\nsignatures and plotting them###\n# 搜索最优NMF分解秩（聚类数量不宜过大）\n# Search for optimal NMF rank (number of clusters should not be too large)\nnmf.input <- t(mut.wt)  # 转置突变特征权重矩阵作为NMF输入\n                        # Transpose signature weight matrix as NMF input\nnmf.input <- nmf.input[setdiff(rownames(nmf.input),\"unknown\"),]  # 去除未知成分\n                                                                     # Remove unknown component\nranks <- 2:5  # 测试不同的秩（聚类数量）范围\n              # Range of ranks (number of clusters) to test\n\n# 对每个秩进行NMF拟合并评估\n# Perform NMF fitting and evaluation for each rank\nestim <- lapply(ranks, function(r){\n  fit <- nmf(nmf.input, r, nrun = 5, seed = 4, method = \"lee\")  # 执行NMF分解（nrun设为5避免运行时间过长）\n                                                                     # Perform NMF decomposition (nrun=5 to limit runtime)\n  list(fit = fit, consensus = consensus(fit), .opt = \"vp\", coph = cophcor(fit))  # 保存拟合结果及评估指标\n                                                                                       # Save fitting results and evaluation metrics\n})\nnames(estim) <- paste('rank', ranks)  # 命名结果列表\n                                       # Name result list entries\n\n# 绘制cophenetic系数随秩变化的曲线图，选择最优聚类数量\n# Plot cophenetic coefficient vs. rank to select optimal cluster number\npdf(\"Cophenetic coefficient for seleting optimal nmf rank.pdf\")\npar(cex.axis=1.5)  # 设置坐标轴字体大小\n                   # Set axis label font size\nplot(ranks, sapply(estim, '[[', 'coph'), xlab=\"\", ylab=\"\", type=\"b\", col=\"red\", lwd=4, xaxt=\"n\")  # 绘制cophenetic系数曲线\n                                                                                                              # Plot cophenetic coefficient curve\naxis(side = 1, at=1:5)  # 设置x轴刻度\n                        # Set x-axis tick marks\ntitle(xlab=\"number of clusters\", ylab=\"Cophenetic coefficient\", cex.lab=1.5)  # 添加坐标轴标题\n                                                                                   # Add axis labels\ninvisible(dev.off())\n\n# 根据cophenetic得分选择最优秩（聚类数量）\n# Select optimal rank (number of clusters) based on cophenetic score\nrank <- 4\nseed <- 2019620  # 设置随机种子确保结果可重复\n                 # Set random seed for reproducibility\nrownames(nmf.input) <- gsub(\"Signature\",\"Sig\",rownames(nmf.input))  # 简化行名（Signature→Sig）\n                                                                         # Simplify row names\n\n# 执行NMF分解，将样本分为4个亚型\n# Perform NMF decomposition to classify samples into 4 subtypes\nmut.nmf <- nmf(nmf.input, \n               rank = rank, \n               seed = seed, \n               method = \"lee\")  # 使用Lee和Seung的乘性迭代算法\n                                # Use Lee and Seung multiplicative update algorithm\n\n# 提取每个聚类的驱动突变特征（原文使用特征占比筛选，此处使用NMF自身方法）\n# Extract driving signatures for each cluster (original paper used proportion threshold, here use NMF method)\nindex <- extractFeatures(mut.nmf, \"max\")  # 提取每个聚类中贡献最大的特征\n                                           # Extract features with maximum contribution for each cluster\n                                           # 注：理论上每个亚型应有特征，但可能存在无显著特征的情况（输出NA）\n                                           # Note: Each subtype should have features, but may be NA if none significant\n                                           # 若更改提取方法请参考??extractFeatures\n                                           # Refer to ??extractFeatures for alternative methods\nsig.order <- unlist(index)  # 将特征列表展平为向量\n                            # Flatten feature list into vector\n\n# 使用筛选出的特征再次进行NMF分解\n# Perform NMF decomposition again using selected signatures\nnmf.input2 <- nmf.input[sig.order,]  # 仅保留筛选出的特征\n                                      # Keep only selected signatures\nmut.nmf2 <- nmf(nmf.input2, \n                rank = rank, \n                seed = seed, \n                method = \"lee\")  # 再次执行NMF\n                                # Repeat NMF decomposition\ngroup <- predict(mut.nmf2)  # 预测样本所属聚类（亚型）\n                            # Predict sample clusters (subtypes)\n\n# 按聚类排序样本，用于后续热图展示\n# Sort samples by cluster for heatmap visualization\nsample.order <- names(group[order(group)])  # 按聚类编号升序排列样本\n                                            # Sort samples by cluster number\n\n# 绘制一致性矩阵热图，展示聚类稳定性\n# Plot consensus matrix heatmap to show clustering stability\npdf(file = \"consensusmap.pdf\", width = 4, height = 4)\nconsensusmap(mut.nmf2,\n             labRow = NA,  # 不显示行标签\n                           # Omit row labels\n             labCol = NA,  # 不显示列标签\n                           # Omit column labels\n             annCol = data.frame(\"cluster\"=group[colnames(nmf.input)]),  # 添加列注释（聚类信息）\n                                                                          # Add column annotations (cluster information)\n             annColors = list(cluster=c(\"1\"=jco[1],\"2\"=jco[2],\"3\"=jco[3],\"4\"=jco[4])))  # 设置聚类颜色\n                                                                                              # Set cluster colors\ninvisible(dev.off())\n\n# 绘制基矩阵热图，展示特征-聚类关系\n# Plot basis matrix heatmap to show signature-cluster relationships\npdf(file = \"basismap.pdf\", width = 4.5, height = 4)\n# 从此图可清晰看到各亚型的驱动特征（颜色越深表示贡献越大），对应下方的NMF热图\n# This plot shows driving signatures for each subtype (darker colors indicate higher contribution), corresponding to NMF heatmap below\nbasismap(mut.nmf2,\n         cexCol = 1,  # 设置列标签字体大小\n                      # Set column label font size\n         cexRow = 0.3,  # 设置行标签字体大小\n                        # Set row label font size\n         annColors=list(c(\"1\"=jco[1],\"2\"=jco[2],\"3\"=jco[3],\"4\"=jco[4])))  # 设置聚类颜色\n                                                                                # Set cluster colors\ninvisible(dev.off())\n\n# 绘制NMF热图，展示样本-特征关系\n# Plot NMF heatmap to show sample-signature relationships\naheatmap(as.matrix(nmf.input2[,sample.order]),  # 使用筛选的特征和排序后的样本\n         Rowv=NA,  # 不进行行聚类\n                   # Disable row clustering\n         Colv=NA,  # 不进行列聚类（已按聚类排序）\n                   # Disable column clustering (already sorted by cluster)\n         annCol = data.frame(\"cluster\"=group[sample.order]),  # 添加列注释（聚类信息）\n                                                                 # Add column annotations (cluster information)\n         annColors = list(cluster=c(\"1\"=jco[1],\"2\"=jco[2],\"3\"=jco[3],\"4\"=jco[4])),  # 设置聚类颜色\n                                                                                             # Set cluster colors\n         color=c(\"#EAF0FA\",\"#6081C3\",\"#3454A7\"),  # 使用例文的蓝色渐变\n                                                     # Use blue gradient from example\n         revC=TRUE,  # 反转颜色映射\n                     # Reverse color mapping\n         cexCol = 0.3,  # 设置列标签字体大小\n                        # Set column label font size\n         cexRow = 0.3,  # 设置行标签字体大小\n                        # Set row label font size\n         filename = \"NMF_heatmap.pdf\")  # 保存为PDF文件\n                                        # Save as PDF file\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa110mutationSignature_FigureYa110mutationSignature",
      "title": "FigureYa110mutationSignature/FigureYa110mutationSignature.html",
      "html": "FigureYa110mutationSignature/FigureYa110mutationSignature.html",
      "text": "texts/main_FigureYa110mutationSignature_FigureYa110mutationSignature.txt",
      "folder": "FigureYa110mutationSignature",
      "thumb": "gallery_compress/FigureYa110mutationSignature.webp"
    },
    "word_count": 1587,
    "lines_count": 352,
    "title": "FigureYa110mutationSignature",
    "description": "画出文章里的3个热图： Draw three heat maps from the article: 出自",
    "input_data_types": [
      "临床数据",
      "DNA-seq",
      "突变数据"
    ],
    "output_types": [
      "热图",
      "统计表格"
    ],
    "technical_methods": [
      "聚类分析",
      "标准化"
    ],
    "biology_areas": [
      "癌症研究"
    ],
    "complexity_level": "中级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "pos",
      "needed",
      "id",
      "seed",
      "lwd",
      "width",
      "side",
      "cutoff",
      "fit"
    ]
  },
  {
    "id": "main_FigureYa92immune_gene_update_FigureYa92immune_gene_update",
    "file_path": "/Users/mypro/Downloads/FigureYa/texts/main_FigureYa92immune_gene_update_FigureYa92immune_gene_update.txt",
    "content": "FigureYa92immune_gene_update\nFigureYa92immune_gene_update\nShipeng Guo, Taojun Ye\n2025-5-20\n需求描述\n计算免疫浸润跟基因的相关性，画图。\n#Requirement description\nCalculate the correlation between immune infiltration and genes and\ndraw a graph.\n出自\nhttps://mp.weixin.qq.com/s/tWJkLVDt1mx5COduw7H35w\n当初众筹是因为果子的idea，用这种方式展示两个转录本和免疫浸润的关系，发布在果子学生信公众号上\nhttps://mp.weixin.qq.com/s/tWJkLVDt1mx5COduw7H35w\n。小伙伴看到了也想画，我们就众筹了。后来有小伙伴用这个图发表了文章，供参考：\nFrom<\nhttps://mp.weixin.qq.com/s/tWJkLVDt1mx5COduw7H35w\n>\nThe original crowdfunding was due to the idea of Guozi, which showed\nthe relationship between the two transcripts and immune infiltration in\nthis way, and was published on the official account of Guozi Student\nLetter<\nhttps://mp.weixin.qq.com/s/tWJkLVDt1mx5COduw7H35w\n>The friends also wanted to draw when they saw it, so we crowdfunded.\nLater, a friend published an article using this image for reference:\n出自\nhttps://s3-us-west-1.amazonaws.com/paperchase-aging/pdf/GpDPdC6dMaFhzrxao.pdf\nfrom\nhttps://s3-us-west-1.amazonaws.com/paperchase-aging/pdf/GpDPdC6dMaFhzrxao.pdf\nFigure 5. Validation of hub genes and PPI map construction. (A)\nRelationship between 10 hub genes expression and CD8+ T cell\ninfiltration level; P < 0.05 is considered statistically significant.\n(B) Scatter plot of CCL5 expression and CD8+ T cell infiltration\nlevel.\n出自\nhttps://link.springer.com/article/10.1007/s00109-020-01908-9\nfrom\nhttps://link.springer.com/article/10.1007/s00109-020-01908-9\nFig. 3 Construction of a prognostic immune-related gene signature. g\nssGSEA revealed the most significant hallmarks correlated with the\nimmune-related signature.\n应用场景\n评价基因对免疫浸润的影响，甚至可以写成循环，批量筛选出影响免疫浸润的候选基因。\n不仅限于基因跟免疫浸润之间的关系，还可以把免疫细胞矩阵替换为基因表达矩阵，计算基因跟基因之间的关系，找出并可视化共表达基因；或者把基因表达矩阵替换为转录本或临床信息，用于分析不同转录本、甚至临床指标跟免疫浸润的关系。\n在“小丫画图”公众号回复“R2”查看类似的图在文章里的用法。\n#Application scenarios\nEvaluate the impact of genes on immune infiltration, and even write\nit as a cycle to batch screen candidate genes that affect immune\ninfiltration.\nNot limited to the relationship between genes and immune\ninfiltration, the immune cell matrix can also be replaced with a gene\nexpression matrix to calculate the relationship between genes and\nidentify and visualize co expressed genes; Alternatively, the gene\nexpression matrix can be replaced with transcripts or clinical\ninformation to analyze the relationship between different transcripts,\neven clinical indicators, and immune infiltration.\nReply “R2” on the “Xiaoya Painting” official account to check the\nusage of similar pictures in the article.\n环境设置\n使用国内镜像安装包\n#Environment settings\nUse domestic image installation package\n# 设置CRAN镜像为清华大学镜像源，提高包下载速度（Set CRAN mirror to Tsinghua University source for faster package downloads）\noptions(\"repos\"= c(CRAN=\"https://mirrors.tuna.tsinghua.edu.cn/CRAN/\"))\n\n# 设置Bioconductor镜像为清华大学镜像源，用于生物信息学相关包的下载（Set Bioconductor mirror to Tsinghua University source for bioinformatics package downloads）\noptions(BioC_mirror=\"http://mirrors.tuna.tsinghua.edu.cn/bioconductor/\")\n\n# 安装ggstatsplot包，该包集成了ggplot2和统计测试功能（Install the ggstatsplot package, which integrates ggplot2 and statistical testing functions）\ninstall.packages(\"ggstatsplot\")\n加载包\nlibrary packages\n# 加载数据可视化和统计分析相关的包  \n# Load packages for data visualization and statistical analysis  \nlibrary(ggstatsplot)  # 用于ggplot2扩展的统计可视化\n# Package for extended statistical visualization based on ggplot2  \nlibrary(data.table)   # 高性能数据处理  \n# Package for high-performance data processing  \nlibrary(dplyr)        # 数据操作工具\n# Package for data manipulation operations  \nlibrary(tidyr)        # 数据整理工具  \n# Package for data tidying and reshaping  \nlibrary(ggplot2)      # 强大的绘图系统  \n# Powerful plotting system  \n\n\n# 环境设置  \n# Environment settings  \nSys.setenv(LANGUAGE = \"en\")  # 设置英文报错信息，便于问题排查  \n# Set error messages to English for easier troubleshooting  \noptions(stringsAsFactors = FALSE)  # 禁止字符串自动转换为因子，避免意外的数据类型转换  \n# Disable automatic conversion of strings to factors to avoid unexpected data type conversion\n输入文件\n要求两个文件的样本名一致\nssGSEA_output.csv，免疫细胞矩阵，列是免疫细胞，行是样本，由FigureYa71ssGSEA产生。在FigureYa71ssGSEA读取文件的命令行里添加\ncheck.names = F\n，避免行名TCGA\nid的“-”变成“.”。列也可以是基因，即基因表达矩阵。\neasy_input_expr.txt，基因表达矩阵，列是样本，行是基因。行也可以是转录本，甚至是临床信息。另外，作者还提供了从TCGA表达矩阵（例如not_easy_input_expr.txt）提取某一基因表达谱的代码，见pick1gene.R文件。\n#Input file\nRequest that the sample names of the two files be consistent\nssGSEA_output.csv， Immune cell matrix, with columns representing\nimmune cells and rows representing samples, generated by\nFigureYa71ssGSEA. Add ‘check. games=F’ to the command line for reading\nfiles in FigureYa71ssGSEA, to avoid the TCGA id line name changing from\n‘-’ to ‘.’. Columns can also be genes, i.e. gene expression\nmatrices.\neasy_input_expr.txt， Gene expression matrix, with columns\nrepresenting samples and rows representing genes. It can also be a\ntranscript or even clinical information. In addition, the author also\nprovided the code to extract the expression profile of a certain gene\nfrom the TCGA expression matrix (such as not_ easy_input-expr. txt), as\nshown in the pick1gene. R file.\n# 清除环境中所有对象（释放内存并避免变量干扰）\n# Clear all objects in the environment (free memory and avoid variable interference)\nrm(list = ls())\n\n# ---------------------- 免疫细胞矩阵处理 ---------------------- #\n# ---------------------- Immune cell matrix processing ---------------------- #\n# 读取免疫细胞ssGSEA分析结果矩阵（行名为样本ID，列为免疫细胞类型）\n# Read the ssGSEA analysis results matrix of immune cells (rows are sample IDs, columns are immune cell types)\ntcga_gsva <- read.csv(\"ssGSEA_output.csv\", row.names = 1)\n# 查看矩阵前3行3列数据（检查数据结构和读取是否正确）\n# View the first 3 rows and 3 columns of the matrix (check data structure and reading correctness)\ntcga_gsva[1:3, 1:3]\n# 行名处理：将样本ID中的点号（.）批量替换为短横线（-）\n# 说明：若免疫矩阵行名与基因表达矩阵不一致，需统一格式以确保后续关联\n# Row name processing: batch-replace dots (.) with hyphens (-) in sample IDs\n# Note: If the row names of the immune matrix are inconsistent with the gene expression matrix, unify the format for subsequent association\nrownames(tcga_gsva) <- gsub(\"\\\\.\", \"-\", rownames(tcga_gsva))\n# 再次查看前3行3列数据（验证替换结果）\n# View the first 3 rows and 3 columns again (verify the replacement result)\ntcga_gsva[1:3, 1:3]\n# ---------------------- 基因表达矩阵处理 ---------------------- #\n# ---------------------- Gene expression matrix processing ---------------------- #\n# 读取基因表达矩阵（行名为基因ID，列名为样本ID，保留原始列名）\n# Read the gene expression matrix (rows are gene IDs, columns are sample IDs, preserve original column names)\ntcga_expr <- read.table(\"easy_input_expr.txt\", row.names = 1, header = T, check.names = F)\n# 查看矩阵前3列数据（检查样本ID格式是否与免疫矩阵兼容）\n# View the first 3 columns of the matrix (check if sample ID format is compatible with the immune matrix)\ntcga_expr[, 1:3]\n# ---------------------- 样本顺序对齐 ---------------------- #\n# ---------------------- Sample order alignment ---------------------- #\n# 用基因表达矩阵的样本名称调整免疫矩阵的样本顺序\n# 目的：确保后续相关性计算时样本一一对应（非必需步骤，视数据情况而定）\n# Adjust the sample order of the immune matrix using the sample names from the gene expression matrix\n# Purpose: Ensure one-to-one correspondence of samples in subsequent correlation calculations (non-essential step, subject to data conditions)\ntcga_gsva <- tcga_gsva[colnames(tcga_expr), ]\n\n# ---------------------- 数据预处理 ---------------------- #\n# ---------------------- Data preprocessing ---------------------- #\n# 提取基因表达矩阵的行名（基因ID）\n# Extract row names (gene IDs) from the gene expression matrix\nindex <- rownames(tcga_expr) \n# 将基因表达量转换为数值型向量（若存在非数值数据会触发警告）\n# Convert gene expression values to a numeric vector (warnings will be triggered if non-numeric data exists)\ny <- as.numeric(tcga_expr)\n# 查看前6个元素（检查数据类型转换是否成功）\n# View the first 6 elements (check if data type conversion is successful)\nhead(y)\n基因跟免疫细胞的相关性\n进行spearman相关性分析，返回相关性系数和p值\n#The correlation between genes and immune cells\nPerform Spearman correlation analysis, return correlation coefficient\nand p-value\n# 提取免疫细胞矩阵的列名（即免疫细胞类型或通路名称）\n# Extract column names from the immune cell matrix (i.e., immune cell types or pathway names)\ncolnames <- colnames(tcga_gsva)\n\n# 创建空数据框，用于存储相关性分析结果\n# Create an empty dataframe to store correlation analysis results\ndata <- data.frame(colnames)\n\n# 循环计算每个免疫细胞与所有基因的 Spearman 相关性\n# Loop to calculate Spearman correlation between each immune cell and all genes\nfor (i in 1:length(colnames)) {\n  # 对第i个免疫细胞的富集度向量与基因表达向量进行相关性检验\n  # Perform correlation test between the enrichment vector of the i-th immune cell and the gene expression vector\n  test <- cor.test(as.numeric(tcga_gsva[, i]), y, method = \"spearman\")\n  \n  # 提取相关系数（存储至数据框第2列）\n  # Extract correlation coefficient (stored in the 2nd column of the dataframe)\n  data[i, 2] <- test$estimate                                            \n  \n  # 提取P值（存储至数据框第3列）\n  # Extract p-value (stored in the 3rd column of the dataframe)\n  data[i, 3] <- test$p.value\n}\n# 重命名数据框列名（便于后续分析和识别）\n# Rename dataframe columns (for easier downstream analysis and identification)\nnames(data) <- c(\"symbol\", \"correlation\", \"pvalue\")\n\n# 查看结果前6行（检查输出格式和数据完整性）\n# View the first 6 rows of the results (check output format and data integrity)\nhead(data)\n# ---------------------- 结果输出 ---------------------- #\n# ---------------------- Result output ---------------------- #\n# 将相关性结果写入文本文件（制表符分隔，无行名，不转义字符）\n# Write correlation results to a text file (tab-separated, no row names, no escaped characters)\nwrite.table(data, \"output_cor.txt\", sep = \"\\t\", quote = F, row.names = F)\n开始画图\n##Start drawing\n# 读取预先计算好的相关性结果文件（需确保文件格式与output_cor.txt一致）\n# Read the precomputed correlation results file (ensure the format matches output_cor.txt)\ndata <- read.table(\"output_cor.txt\", sep = \"\\t\", header = T)\n# 查看数据前6行（检查数据读取是否正确）\n# View the first 6 rows of the data (check if the data is read correctly)\nhead(data)\n# 使用ggplot2绘制棒棒糖图（展示基因与免疫细胞的相关性）\n# Use ggplot2 to create a lollipop plot (show the correlation between genes and immune cells)\ndata %>% \n  # 筛选显著性结果（如需隐藏非显著数据，取消此行注释）\n  # Filter significant results (uncomment this line to hide non-significant data)\n  #filter(pvalue < 0.05) %>% \n  ggplot(aes(correlation, forcats::fct_reorder(symbol, correlation))) +  # 设定x轴为相关性值，y轴按相关性排序免疫细胞名称\n  geom_segment(aes(xend = 0, yend = symbol)) +  # 绘制从x=0到相关性值的水平线段（棒棒糖的\"杆\"）\n  geom_point(aes(col = pvalue, size = abs(correlation))) +  # 绘制点，颜色映射p值，大小映射相关性绝对值\n  scale_colour_gradientn(colours = c(\"#7fc97f\", \"#984ea3\")) +  # 自定义颜色渐变（绿色到紫色）\n  #scale_color_viridis_c(begin = 0.5, end = 1) +  # 可选：使用viridis颜色渐变（需安装viridis包）\n  scale_size_continuous(range = c(2, 8)) +  # 设置点的大小范围\n  theme_minimal() +  # 使用极简主题\n  ylab(NULL)  # 隐藏y轴标签\n# 保存图形为PDF格式（分辨率默认300dpi，可通过dpi参数调整）\n# Save the plot as a PDF file (default resolution is 300dpi, which can be adjusted via the dpi parameter)\nggsave(\"gene_Xcell.pdf\")\n基因跟1种免疫细胞的相关性\n从上面的图可以看出基因跟不同免疫细胞的相关性有差异，可以进一步挑一个相关性最强的免疫细胞，例如TReg，画出基因表达跟免疫细胞浸润在每个样本里的分布。\n#The correlation between genes and one type of immune cell\nFrom the above graph, it can be seen that there are differences in\nthe correlation between genes and different immune cells. Therefore, we\ncan further select the immune cell with the strongest correlation, such\nas TReg, and draw the distribution of gene expression and immune cell\ninfiltration in each sample.\n# 指定要分析的免疫细胞类型（此处为调节性T细胞，可替换为其他免疫细胞名称）\n# Specify the immune cell type to analyze (here: Regulatory T cells, can be replaced with other immune cell names)\nimucell <- \"TReg\"\n\n# ---------------------- 数据合并 ---------------------- #\n# ---------------------- Data merging ---------------------- #\n# 创建绘图数据框：将基因表达量向量(y)与指定免疫细胞的富集度数据合并\n# Create a dataframe for plotting: combine gene expression vector (y) with enrichment data of the specified immune cell\nplot_df <- data.frame(gene = y, imucell = tcga_gsva[, imucell])\n\n# 查看数据框前6行（验证数据结构和合并结果）\n# View the first 6 rows of the dataframe (verify data structure and merging results)\nhead(plot_df)\n用ggscatterstats包画图\n图好看，但是速度很慢。\n##Drawing with ggscatterstats package\nThe picture looks good, but the speed is very slow.\n# 取消注释此行可将图形保存为PDF文件（需确保有写入权限）\n# Uncomment this line to save the plot as a PDF file (ensure write permissions)\n#pdf(\"gene_1cell_ggscatterstats.pdf\")\n\n# 使用ggscatterstats绘制基因表达与免疫细胞相关性散点图（含统计信息）\n# Plot a scatter plot with statistical information between gene expression and immune cell enrichment\nggscatterstats(\n  data = plot_df,                # 指定数据源为之前创建的绘图数据框\n                               # Specify the data source as the previously created plotting data frame\n  x = gene,                      # x轴：基因表达量\n                               # x-axis: Gene expression level\n  y = imucell,                   # y轴：免疫细胞富集度\n                               # y-axis: Immune cell enrichment score\n  centrality.para = \"mean\",      # 显示均值作为中心趋势统计量\n                               # Display mean as the central tendency statistic\n  margins = \"both\",              # 在x轴和y轴边缘添加分布统计图表\n                               # Add distribution plots to both x and y axes margins\n  xfill = \"#CC79A7\",             # x轴边缘图表填充色（紫色系）\n                               # Fill color for x-axis marginal plot (purple)\n  yfill = \"#009E73\",             # y轴边缘图表填充色（绿色系）\n                               # Fill color for y-axis marginal plot (green)\n  marginal.type = \"histogram\"    # 边缘分布图表类型：直方图\n                               # Type of marginal distribution plot: histogram\n)\n#dev.off\n用ggplot2画图\n先定义一个函数，返回计算的结果，最终会作为标题放在图上方，他接受两个参数，就是作图文件的两列，分别是免疫数据和表达量数据。\n##Draw with ggplot2\nFirst, define a function that returns the calculated result, which\nwill be placed as a title above the graph. It takes two parameters,\nnamely the two columns of the graph file, which are immune data and\nexpression level data.\n# ---------------------- 定义相关性方程生成函数 ---------------------- #\n# ---------------------- Define correlation equation generation function ---------------------- #\n# Function: Calculate Spearman correlation and generate a text string \n# containing sample size, correlation coefficient, and p-value\n# 功能：计算Spearman相关性并生成包含样本量、相关系数和P值的文本字符串\n# Parameters:\n#   x, y - Numeric vectors to be analyzed\n#   digits - Number of decimal places for results (default: 2)\n# 参数：\n#   x, y - 待分析的数值型向量\n#   digits - 结果保留的小数位数（默认2位）\n# Returns: Formatted descriptive string of correlation results\n# Returns: 格式化后的相关性描述字符串\ncorr_eqn <- function(x, y, digits = 2) {\n  test <- cor.test(x, y, method = \"spearman\")  # Perform Spearman correlation test\n  # 执行Spearman相关性检验\n  paste(\n    paste0(\"n = \", length(x)),  # Sample size\n    # 样本量\n    paste0(\"r = \", round(test$estimate, digits), \"(Spearman)\"),  # Rounded correlation coefficient\n    # 四舍五入后的相关系数\n    paste0(\"p.value = \", round(test$p.value, digits)),  # Rounded p-value\n    # 四舍五入后的P值\n    sep = \", \"  # Separate parts with comma and space\n    # 各部分用逗号+空格分隔\n  )\n}\n\n# ---------------------- 测试函数功能 ---------------------- #\n# ---------------------- Test function functionality ---------------------- #\n# Call the function to calculate correlation for current data and print results\n# 调用函数计算当前数据的相关性并打印结果\n# Test the function with the current dataset\ncorr_eqn(plot_df$gene, plot_df$imucell)\n# ---------------------- 绘制定制化散点图 ---------------------- #\n# ---------------------- Draw customized scatter plot ---------------------- #\nplot_df %>%  # Operate based on the plotting data frame\n  # 基于绘图数据框进行操作\n  ggplot(aes(gene, imucell)) +  # Set x-axis as gene expression, y-axis as immune cell enrichment\n  # 设定x轴为基因表达量，y轴为免疫细胞富集度\n  geom_point(col = \"#984ea3\") +  # Plot scatter points with purple color\n  # 绘制散点，颜色设为紫色\n  geom_smooth(\n    method = lm,           # Add linear regression line (least squares method)\n    # 添加线性回归拟合线（最小二乘法）\n    se = T,                # Show confidence interval\n    # 显示置信区间\n    na.rm = T,             # Remove missing values\n    # 移除缺失值\n    fullrange = T,         # Extend fitting line to full data range\n    # 将拟合线延伸至数据范围全距\n    size = 2,              # Line thickness\n    # 线条粗细\n    col = \"#fdc086\"        # Line color: light orange\n    # 线条颜色设为浅橙色\n  ) +\n  geom_rug(col = \"#7fc97f\") +  # Add data distribution markers (rug plot) on axis edges, green color\n  # 在坐标轴边缘添加数据分布标记（地毯图），颜色设为绿色\n  theme_minimal() +  # Use minimal theme\n  # 使用极简主题\n  xlab(paste0(index, \" (TPM)\")) +  # Set x-axis label (gene name + expression unit)\n  # 设置x轴标签（基因名+表达量单位）\n  ylab(paste0(imucell, \" (immune infiltration)\")) +  # Set y-axis label (immune cell type + infiltration description)\n  # 设置y轴标签（免疫细胞类型+浸润程度说明）\n  labs(title = paste0(corr_eqn(plot_df$gene, plot_df$imucell))) +  # Display correlation results in title\n  # 在标题中显示相关性统计结果\n  theme(plot.title = element_text(hjust = 0.5))  # Center-align the title\n# 居中对齐标题\n\n# Save the plot as a PDF file (default resolution: 300 dpi)\n# 保存图形为PDF文件（默认分辨率300dpi）\nggsave(\"gene_1cell_ggplot2.pdf\")\nsessionInfo()",
    "chapter_info": {
      "id": "main_FigureYa92immune_gene_update_FigureYa92immune_gene_update",
      "title": "FigureYa92immune_gene_update/FigureYa92immune_gene_update.html",
      "html": "FigureYa92immune_gene_update/FigureYa92immune_gene_update.html",
      "text": "texts/main_FigureYa92immune_gene_update_FigureYa92immune_gene_update.txt",
      "folder": "FigureYa92immune_gene_update",
      "thumb": "gallery_compress/FigureYa92immune_gene_update.webp"
    },
    "word_count": 2002,
    "lines_count": 354,
    "title": "FigureYa92immune_gene_update",
    "description": "计算免疫浸润跟基因的相关性，画图。 Calculate the correlation between immune infiltration and genes and draw a graph.",
    "input_data_types": [
      "临床数据",
      "表达矩阵"
    ],
    "output_types": [
      "散点图",
      "统计表格"
    ],
    "technical_methods": [
      "通路分析"
    ],
    "biology_areas": [
      "免疫学"
    ],
    "complexity_level": "初级",
    "code_snippets": [],
    "key_parameters": [
      "",
      "gene",
      "begin",
      "header",
      "fullrange",
      "xend",
      "pvalue",
      "colours",
      "col",
      "method"
    ]
  }
]